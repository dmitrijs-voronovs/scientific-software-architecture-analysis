id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.6/apidoc/functions.html:114193,Integrability,depend,dependent,114193,"s, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist,",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:114615,Integrability,depend,dependent,114615,"Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0Qobj",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:115559,Integrability,depend,dependent,115559,"nt 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options cla",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:116238,Integrability,depend,dependent,116238,"se=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculat",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:117484,Integrability,depend,dependent,117484,"nte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:117906,Integrability,depend,dependent,117906," index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using th",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:119041,Integrability,depend,dependent,119041,"t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver opt",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:119714,Integrability,depend,dependent,119714," reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; C",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:121080,Integrability,depend,dependent,121080,"ement list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quan",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:121500,Integrability,depend,dependent,121500,"s; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calc",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:122619,Integrability,depend,dependent,122619," solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursive",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:123290,Integrability,depend,dependent,123290," correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\r",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:124569,Integrability,depend,dependent,124569,"ecause; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:124989,Integrability,depend,dependent,124989," instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression the",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:126207,Integrability,depend,dependent,126207,"ries). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:126878,Integrability,depend,dependent,126878,"ion function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \lef",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:140160,Integrability,depend,dependent,140160,"ints when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, default ‘smilu_2’ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns. dmqobjSteady state density matrix. infodict, optionalDictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters. Hqobj or listHamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). tfloat or array-likeTime or list of times for which to evaluate the propagator. c_op_listlistList of qobj collapse operators. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive appl",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:140412,Integrability,depend,dependent,140412,"objSteady state density matrix. infodict, optionalDictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters. Hqobj or listHamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). tfloat or array-likeTime or list of times for which to evaluate the propagator. c_op_listlistList of qobj collapse operators. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing,",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:141278,Integrability,depend,dependent,141278,"e propagator. c_op_listlistList of qobj collapse operators. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:141351,Integrability,depend,dependent,141351,"rs. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:141787,Integrability,depend,dependent,141787,"e of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accep",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:142707,Integrability,integrat,integrated,142707," a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (into any combination of; waveguides). c_opslistList of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlistarray_likeList of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced. system_zero_state:class: qutip.QobjState representing zero excitations in the syst",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:154052,Integrability,depend,depending,154052,"s to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe GHZ state density matrix in the requested basis. ground(N, basis='dicke')[source]¶; Generate the density matrix of the ground state.; This state is given by (N/2, -N/2) in the Dicke basis. If the argument; basis is “uncoupled” then it generates the state in a; \(2^N\)-dimensional Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe ground state density matrix in the requested basis. identity_uncoupled(N)[source]¶; Generate the identity in a \(2^N\)-dimensional Hilbert space.; The identity matrix is formed from the tensor product of N TLSs. Parameters. N: intThe number of two-level systems. Returns. identity: :class: qutip.QobjThe identity matrix. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. jspin(N, op=None, basis='dicke')[source]¶; Calculate the list of collective operators of the total algebra.; The Dicke basis \(\lvert j,m\rangle\langle j,m'\rvert\) is used by; default. Otherwise with “uncoupled” the operators are in a; \(2^N\) space. Parameters. N: intNumber of two-level systems. op: strThe operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no operator given, then output is the list of operators; for [‘x’,’y’,’z’]. basis: strThe basis of the operators - “dicke” or “uncoupled”; default: “dicke”. Returns. j_alg: list or :class: qutip.QobjA list of qutip.Qobj representing all the operators in; the “dicke” or “uncoupled” basis or a single operator requested. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(\lvert j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. num",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:161593,Integrability,integrat,integrated,161593,"ions as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:162325,Integrability,integrat,integrated,162325,".dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the W function. phiarray_likeAzimuthal angle at which to calculate the W function. Returns. W, THETA, PHI2d-arrayValues representing the spin Wigner function at the values specified; by THETA and PHI. References; [1] Agarwal, G. S. (1981). Phys. Rev. A, 24(6), 2889–2896.; https://doi.org/10.1103/PhysRevA.24.2889; [2] Dowling, J. P., Agarwal, G. S., & Schleich, W. P. (1994).; Phys. Rev. A, 49(5), 4101–4109. https://doi.org/10.1103/PhysRevA.49.4101; [3] Conversion between Wigner 3-j symbol and Clebsch-Gordan coefficients; taken from Wikipedia (https://en.wikipedia.org/wiki/3-j_symbol). wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:201140,Integrability,depend,dependent,201140,"', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar val",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:201360,Integrability,depend,dependent,201360,"_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:203612,Integrability,depend,dependent,203612,"ng local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each t",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:209572,Integrability,depend,dependent,209572," guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar val",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:209791,Integrability,depend,dependent,209791,"urce]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:217120,Integrability,wrap,wrapper,217120,"which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:218042,Integrability,depend,dependent,218042,"to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; appli",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:218253,Integrability,depend,dependent,218253," format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pul",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:225780,Integrability,depend,dependent,225780,"s=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar valu",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:226000,Integrability,depend,dependent,226000,"file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:228252,Integrability,depend,dependent,228252,"g local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each times",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:233595,Integrability,wrap,wrapper,233595,"error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent contro",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:234483,Integrability,depend,dependent,234483,"ource]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; appli",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:234694,Integrability,depend,dependent,234694,"and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pul",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:236946,Integrability,depend,dependent,236946," local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:242160,Integrability,rout,routines,242160,"¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. Utility Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)[source]¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure. Use A+trans(A); if original matrix is not symmetric or not sure. Parameters. Acsc_matrix, csr_matrixInput graph in CSC or CSR matrix format. startintStaring node for BFS traversal. Returns. orderarrayOrder in which nodes are traversed from starting node. levelsarrayLevel of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric graph in sparse CSR; or CSC format, or a qobj. Parameters. Aqobj, csr_matrix, csc_matrixInput quantum object or csr_matrix. Returns. degreearrayArray of integers giving the degree for each node (row). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an ar",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:244169,Integrability,rout,routine,244169,"mutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only.; The input matrix will be converted to CSC matrix format if necessary. Parameters. Asparse matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function relies on a maximum cardinality bipartite matching algorithm; based on a breadth-first search (BFS) of the underlying graph[1]_.; References; I. S. Duff, K. Kaya, and B. Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters. Acsc_matrix, csr_matrixInput sparse CSC or CSR sparse matrix format. symbool {False, True}Flag to set whether input matrix is symmetric. Returns. permarrayArray of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the prod",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:244780,Integrability,rout,routine,244780," Kaya, and B. Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters. Acsc_matrix, csr_matrixInput sparse CSC or CSR sparse matrix format. symbool {False, True}Flag to set whether input matrix is symmetric. Returns. permarrayArray of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular.; This function looks at both the structure and ABS values of the underlying; matrix. Parameters. Acsc_matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:244886,Integrability,rout,routines,244886," Kaya, and B. Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters. Acsc_matrix, csr_matrixInput sparse CSC or CSR sparse matrix format. symbool {False, True}Flag to set whether input matrix is symmetric. Returns. permarrayArray of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular.; This function looks at both the structure and ABS values of the underlying; matrix. Parameters. Acsc_matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:255494,Integrability,depend,dependencies,255494," to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:255812,Integrability,depend,dependencies,255812,"iew, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyri",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:43267,Modifiability,config,configuration,43267,"xp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters. NintShape of output quantum operator. densityfloatDensity between [0,1] of output Unitary operator. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:43356,Modifiability,config,configurations,43356," object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:47187,Modifiability,extend,extend,47187,"tum operator for pre-multiplication. BQobj or QobjEvoQuantum operator for post-multiplication. Returns. superQobj or QobjEvoSuperoperator formed from input quantum objects. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in vector form.; The passed object should have a Qobj.type of ‘operator-ket’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in column-stacked-vector form. This must have a type; of ‘operator-ket’. Returns. Qobj or QobjEvoThe same object, but re-cast into “standard” operator form. The output; is the same type as the passed object. Superoperator Representations¶; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms. chi_to_choi(q_oper)[source]¶; Converts a Chi matrix to a Choi matrix.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_list)[source]¶; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in kraus_list. kraus_to_super(kraus_list)[source]¶; Converts a list of Kraus operators and returns a super operator. super_to_choi(q_oper)[source]¶; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type==’super’. to_chi(q_",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:47395,Modifiability,extend,extend,47395,"eate a matrix representation given a quantum operator in vector form.; The passed object should have a Qobj.type of ‘operator-ket’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in column-stacked-vector form. This must have a type; of ‘operator-ket’. Returns. Qobj or QobjEvoThe same object, but re-cast into “standard” operator form. The output; is the same type as the passed object. Superoperator Representations¶; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms. chi_to_choi(q_oper)[source]¶; Converts a Chi matrix to a Choi matrix.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_list)[source]¶; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in kraus_list. kraus_to_super(kraus_list)[source]¶; Converts a list of Kraus operators and returns a super operator. super_to_choi(q_oper)[source]¶; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type==’super’. to_chi(q_oper)[source]¶; Converts a Qobj representing a quantum map to a representation as a chi; (process) matrix in the Pauli basis, such that the trace of the returned; operator is equal to the dimension of the sys",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:64980,Modifiability,variab,variable,64980,"ctor. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with operators is returned. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. rhoQobjDensity matrix for which to calculate the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:74915,Modifiability,evolve,evolve,74915,"p.gates.expand_operator to expand op; into full dimension. Returns. eigenvalues: list of floatThe list of eigenvalues of the measurement operator. eigenstates_or_projectors: list of QobjIf the state was a ket, return the eigenstates of the measurement; operator. Otherwise return the projectors onto the eigenstates. probabilities: list of floatThe probability of measuring the state as being in the corresponding; eigenstate (and the measurement result being the corresponding; eigenvalue). Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of operators for which to evaluate expectation; values. For operator evolution, the overlap is computed:; (e_ops[i].dag",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:77221,Modifiability,evolve,evolved,77221," simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding oper",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:86946,Modifiability,coupling,couplingto,86946,"rix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation¶. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfield tensor. eketsarray of qutip.qobjArray of kets that make up a basis tranformation for the eigenbasis. rho0qutip.qobjInitial density matrix. tlistlist / arrayList of times for \(t\). e_opslist of qutip.qobj / callback functionList of operators for which to evaluate expectation values. optionsqutip.QdeoptionsOptions for the ODE solver. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. bloch_redfield_tensor()¶. Calculates the time-independent Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters. Hqutip.qobj; System Hamiltonian. a_opslistNested list of system operators that couple to the environment,; and the corresponding bath spectra represented as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an i",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:87913,Modifiability,coupling,coupling,87913,"em given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters. Hqutip.qobj; System Hamiltonian. a_opslistNested list of system operators that couple to the environment,; and the corresponding bath spectra represented as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88109,Modifiability,coupling,coupling,88109,"d as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88249,Modifiability,variab,variable,88249,"d as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88510,Modifiability,variab,variable,88510,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88571,Modifiability,variab,variables,88571,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88654,Modifiability,variab,variable,88654,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:89974,Modifiability,coupling,coupling,89974,"line objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when evaluating bath-coupling terms. sec_cutofffloat {0.1}Cutoff for secular approximation. tolfloat {qutip.setttings.atol}Tolerance used for removing small values after; basis transformation. spectra_cblistDEPRECIATED. Do not use. optionsqutip.solver.OptionsOptions for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system u",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:91524,Modifiability,variab,variables,91524," in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of cor",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:92822,Modifiability,variab,variables,92822," f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:93730,Modifiability,variab,variables,93730,"Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Paramet",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:95045,Modifiability,variab,variables,95045,"d of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energie",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:96493,Modifiability,variab,variables,96493,"The wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputlistA list of Floquet states for the time \(t\). floquet_wavefunction(f_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:97731,Modifiability,variab,variables,97731,"n, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ s",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:100157,Modifiability,variab,variables,100157," temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:141434,Modifiability,config,config,141434,"t Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:142327,Modifiability,config,configuration,142327,"enting the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (i",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:179373,Modifiability,enhance,enhance,179373,"oatAngle with respect to z-axis. phifloatAngle in x-y plane. valuesarrayData set to be plotted. figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. savebool {False , True}Whether to save the figure or not. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. orbital(theta, phi, *args)[source]¶; Calculates an angular wave function on a sphere.; psi = orbital(theta,phi,ket1,ket2,...) calculates; the angular wave function on a sphere at the mesh of points; defined by theta and phi which is; \(\sum_{lm} c_{lm} Y_{lm}(theta,phi)\) where \(C_{lm}\) are the; coefficients specified by the list of kets. Each ket has 2l+1 components; for some integer l. Parameters. thetalist/arrayPolar angles. philist/arrayAzimuthal angles. argslist/arraylist of ket vectors. Returns. array for angular wave function. This module contains utility functions that enhance Matplotlib; in one way or another. complex_phase_cmap()[source]¶; Create a cyclic colormap for representing the phase of complex variables. Returns. cmap :A matplotlib linear segmented colormap. wigner_cmap(W, levels=1024, shift=0, max_color='#09224F', mid_color='#FFFFFF', min_color='#530017', neg_color='#FF97D4', invert=False)[source]¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters. WarrayWigner function array, or any array. levelsintNumber of color levels to create. shiftfloatShifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -1e-5). max_colorstrString for color corresponding to maximum value of data. Accepts; any string format compatible with the Matplotlib.colors.ColorConverter. mid_colorstrColor corresponding to zero values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter. min_colorstrColor corresponding to minimum data value",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:179510,Modifiability,variab,variables,179510,"figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. savebool {False , True}Whether to save the figure or not. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. orbital(theta, phi, *args)[source]¶; Calculates an angular wave function on a sphere.; psi = orbital(theta,phi,ket1,ket2,...) calculates; the angular wave function on a sphere at the mesh of points; defined by theta and phi which is; \(\sum_{lm} c_{lm} Y_{lm}(theta,phi)\) where \(C_{lm}\) are the; coefficients specified by the list of kets. Each ket has 2l+1 components; for some integer l. Parameters. thetalist/arrayPolar angles. philist/arrayAzimuthal angles. argslist/arraylist of ket vectors. Returns. array for angular wave function. This module contains utility functions that enhance Matplotlib; in one way or another. complex_phase_cmap()[source]¶; Create a cyclic colormap for representing the phase of complex variables. Returns. cmap :A matplotlib linear segmented colormap. wigner_cmap(W, levels=1024, shift=0, max_color='#09224F', mid_color='#FFFFFF', min_color='#530017', neg_color='#FF97D4', invert=False)[source]¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters. WarrayWigner function array, or any array. levelsintNumber of color levels to create. shiftfloatShifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -1e-5). max_colorstrString for color corresponding to maximum value of data. Accepts; any string format compatible with the Matplotlib.colors.ColorConverter. mid_colorstrColor corresponding to zero values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter. min_colorstrColor corresponding to minimum data values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter. neg_colorstr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:197809,Modifiability,config,configuration,197809,"source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198427,Modifiability,variab,variables,198427,"mes \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198998,Modifiability,variab,variables,198998,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:199085,Modifiability,variab,variables,199085,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:199165,Modifiability,variab,variables,199165,"ntly two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, m",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:200807,Modifiability,config,configuration,200807,"rco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:209094,Modifiability,variab,variables,209094,"ization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau ar",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:211912,Modifiability,variab,variable,211912,"of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:212427,Modifiability,variab,variable,212427,"e from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type. (See FidelityCo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:217553,Modifiability,variab,variables,217553,"ff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau arr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220369,Modifiability,variab,variable,220369,"f the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The k",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220884,Modifiability,variab,variable,220884," from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See TimeslotComputer; classes for details). tslot_paramsdictParameters for the Tim",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:246558,Modifiability,coupling,coupling,246558,"nerate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thflo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:249941,Modifiability,variab,variable,249941,"This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:250355,Modifiability,variab,variables,250355,"values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of qutip.parallel_map. Parameters. tas",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:250415,Modifiability,variab,variables,250415," or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of qutip.parallel_map. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for w",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58980,Performance,concurren,concurrence,58980,"bjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:59021,Performance,concurren,concurrence,59021,"bjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:72144,Performance,perform,perform,72144,"sured_valuefloatThe result of the measurement (one of the eigenvalues of op). stateQobjThe new state (a ket if a ket was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measurement_statistics(state, ops, targets=None)[source]¶; A dispatch method that provides measurement statistics handling both; observable style measurements and projector style measurements(POVMs and; PVMs).; For return signatures, please check:. measurement_statistics_observable for observable measurements.; measurement_statistics_povm for POVM measurements. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opsQobj or list of Qobj; measurement observable (:class:.Qobj); or; list of measurement operators \(M_i\) or kets (list of; Qobj) Either:. specifying a POVM",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:72196,Performance,perform,perform,72196,"was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measurement_statistics(state, ops, targets=None)[source]¶; A dispatch method that provides measurement statistics handling both; observable style measurements and projector style measurements(POVMs and; PVMs).; For return signatures, please check:. measurement_statistics_observable for observable measurements.; measurement_statistics_povm for POVM measurements. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opsQobj or list of Qobj; measurement observable (:class:.Qobj); or; list of measurement operators \(M_i\) or kets (list of; Qobj) Either:. specifying a POVM s.t. \(E_i = M_i^\dagger * M_i\); projection operators if ops correspond to projectors (s.t.; \(E_i = M_i^\dagger =",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:137053,Performance,perform,perform,137053,"olvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:137360,Performance,perform,perform,137360,"ed into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:164824,Performance,perform,performance,164824,"hbar via hbar=2/g^2 giving the default; value hbar=1. methodstring {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparsebool {False, True}Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parforbool {False, True}Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns. WarrayValues representing the Wigner function calculated over the specified; range [xvec,yvec]. yvexarrayFFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None, label_top=True)[source]¶; Draws a Hinton diagram for visualizing a density matrix or superoperator. Parameters. rhoqobjInput density matrix or superoperator. xlabelsli",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198359,Performance,optimiz,optimize,198359,"mes \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:199815,Performance,optimiz,optimization,199815," CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:203295,Performance,optimiz,optimize,203295,"r each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (s",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:203480,Performance,optimiz,optimize,203480,"rol amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:203988,Performance,optimiz,optimize,203988," above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) com",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207983,Performance,optimiz,optimizer,207983,"ng pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:208056,Performance,optimiz,optimizer,208056,"are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:211723,Performance,perform,performane,211723,"idelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribut",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:212053,Performance,optimiz,optimize,212053,"are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see P",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:212350,Performance,optimiz,optimize,212350,"rride these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Option",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220179,Performance,perform,performance,220179,"delity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; as",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220510,Performance,optimiz,optimize,220510,"re specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the Fideli",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220807,Performance,optimiz,optimize,220807,"ride these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only on",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:227933,Performance,optimiz,optimize,227933,"or each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dyna",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:228119,Performance,optimiz,optimize,228119," squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. pr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:228619,Performance,optimiz,optimize,228619,"thm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; dyn_type (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradie",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:236623,Performance,optimiz,optimize,236623,"or each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:236808,Performance,optimiz,optimize,236808,"trol amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParame",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:237314,Performance,optimiz,optimize,237314,"ee above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC.;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:245868,Performance,perform,performing,245868,"hill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular.; This function looks at both the structure and ABS values of the underlying; matrix. Parameters. Acsc_matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(v",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:248622,Performance,load,loaded,248622,". n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=',')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {‘complex, ‘real’}Type of numerical data. numformatstr {‘decimal’,’exp’}Format for written data. sepstrSingle-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters. namestrName of data file to be loaded. Returns. qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters. datainstance/array_likeInput Python object to be stored. filenamestrName of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslis",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:252432,Performance,load,load-balanced,252432,"the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for each; value in values. Semidefinite Programming¶; This module implements internal-use functions for semidefinite programming. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:253153,Performance,load,load-balanced,253153,"w_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instanc",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:254081,Performance,load,load-balanced,254081,"ing the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:254755,Performance,load,load-balanced,254755,"view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string contai",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:44836,Safety,avoid,avoids,44836," a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part of collapse operator. bQobj or QobjEvo (optional)Right part of collapse operator. If not specified, b defaults to a. Returns. Dqobj, QobjEvoLindblad dissipator superoperator. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters. HQobj or QobjEvoSystem Hamiltonian. c_opsarray_like of Qobj or QobjEvoA list or array of collapse operators. Returns. LQobj or QobjEvoLiouvillian superoperator. operator_to_vector(op)[source]¶; Create a vector representation given a quantum operator in matrix form.; The passed object should have a Qobj.type of ‘oper’ or ‘super’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in matrix form. This must have a type of ‘oper’ or; ‘super’. Returns. Qobj or QobjEvoThe same object, but re-cast into a column-stacked-vector form of type; ‘operator-ket’. The output is the same type as the passed object. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters. AQobj or QobjEvoQuantum operator for post multiplication. Returns. superQobj or QobjEvoSuperoperator formed from input qauntum object. spre(A)[source]¶;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:60980,Safety,detect,detect,60980,"alculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters. rhoqutip.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. E",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:109029,Safety,predict,predictor-correctorGeneralization,109029,"ticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:109317,Safety,predict,predictor-corrector,109317,"sesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:111648,Safety,predict,predictor,111648,"ochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolutio",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:256335,Safety,detect,detecting,256335,"n the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:172550,Security,access,access,172550,"be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iterationint (default 0) or ‘grid_iteration’ or ‘all’Show labels for first 2*legend_iteration particles. Option; ‘grid_iteration’ sets the same number of particles as for; grid_iteration. Option ‘all’ makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn. figsize(width, height)The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Notes; See also [1].; References. 1; J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, Qubism: self-similar visualization of many-body; wavefunctions, New J. Phys. 14 053028, arXiv:1112.3560; (2012), open access. plot_schmidt(ket, splitting=None, labels_iteration=(3, 2), theme='light', fig=None, ax=None, figsize=(6, 6))[source]¶; Plotting scheme related to Schmidt decomposition.; Converts a state into a matrix (A_ij -> A_i^j),; where rows are first particles and columns - last.; See also: plot_qubism with how=’before_after’ for a similar plot. Parameters. ketQobjPure state for plotting. splittingintPlot for a number of first particles versus the rest.; If not given, it is (number of particles + 1) // 2. theme‘light’ (default) or ‘dark’Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. labels_iterationint or pair of ints (default (3,2))Number of particles to be shown as tick labels,; for first (vertical) and last (horizontal) particles, respectively. figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn. figsize(width, height)The size of the m",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198277,Security,access,accessible,198277,"nsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207640,Security,access,accessible,207640,"is value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, gue",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207828,Security,access,accessed,207828," for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207931,Security,access,accessed,207931,"added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:216080,Security,access,accessible,216080,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system a",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:224052,Security,access,accessible,224052,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:232530,Security,access,accessible,232530,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:240603,Security,access,accessible,240603,"s only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RN",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:59563,Testability,log,logarithm,59563,"m; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(r",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:60314,Testability,log,logarithm,60314,"45, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters. rhoqutip.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:60811,Testability,log,logarithm,60811,"tLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters. rhoqutip.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-N",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:61618,Testability,log,log,61618,"p.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters. AQobjQuantum object representing a superoperator. targetQobjQuantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns. fidfloatFidelity pseudo-metric between A",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:61893,Testability,log,logarithm,61893," the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters. AQobjQuantum object representing a superoperator. targetQobjQuantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns. fidfloatFidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. bures_angle(A, B)[source]¶; Returns the Bures Angle between two density matrices A & B.; The Bures angle ranges from 0, for states with unit fidelity, to pi/2. Parameters. AqobjDensity matrix o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:63765,Testability,test,testing,63765,"atrices A & B.; The Bures angle ranges from 0, for states with unit fidelity, to pi/2. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. anglefloatBures angle between density matrices. bures_dist(A, B)[source]¶; Returns the Bures distance between two density matrices A & B.; The Bures distance ranges from 0, for states with unit fidelity,; to sqrt(2). Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatBures distance between density matrices. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. fidfloatFidelity pseudo-metric between A and B. Examples; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332). hilbert_dist(A, B)[source]¶; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:64821,Testability,test,testing,64821,"32). hilbert_dist(A, B)[source]¶; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:67762,Testability,log,logarithmic,67762,"ue hbar=1. Returns. corr_matndarrayArray of complex numbers or Qobj’s; A 2-dimensional array of covariance values for the field quadratures,; or, if rho=0, a matrix of operators. covariance_matrix(basis, rho, symmetrized=True)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \langle a_n\rangle\]. Parameters. basislistList of operators that defines the basis for the covariance matrix. rhoQobjDensity matrix for which to calculate the covariance matrix. symmetrizedbool {True, False}Flag indicating whether the symmetrized (default) or non-symmetrized; correlation matrix is to be calculated. Returns. corr_matndarrayA 2-dimensional array of covariance values. logarithmic_negativity(V, g=1.4142135623730951)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters. V2d arrayThe covariance matrix. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the value of hbar in the commutation; relation [x, y] = i * hbar via hbar=2/g ** 2 giving the default; value hbar=1. Returns. NfloatThe logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. wigner_covariance_matrix(a1=None, a2=None, R=None, rho=None, g=1.4142135623730951)[source]¶; Calculates the Wigner covariance matrix; \(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\), given; the quadrature correlation matrix; \(R_{ij} = \langle R_{i} R_{j}\rangle -; \langle R_{i}\rangle \langle R_{j}\rangle\), where; \(R = (q_1, p_1, q_2, p_2)^T\) is the vector with quadrature operators; for the two mode",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:68264,Testability,log,logarithmic,68264,"\rangle\]. Parameters. basislistList of operators that defines the basis for the covariance matrix. rhoQobjDensity matrix for which to calculate the covariance matrix. symmetrizedbool {True, False}Flag indicating whether the symmetrized (default) or non-symmetrized; correlation matrix is to be calculated. Returns. corr_matndarrayA 2-dimensional array of covariance values. logarithmic_negativity(V, g=1.4142135623730951)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters. V2d arrayThe covariance matrix. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the value of hbar in the commutation; relation [x, y] = i * hbar via hbar=2/g ** 2 giving the default; value hbar=1. Returns. NfloatThe logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. wigner_covariance_matrix(a1=None, a2=None, R=None, rho=None, g=1.4142135623730951)[source]¶; Calculates the Wigner covariance matrix; \(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\), given; the quadrature correlation matrix; \(R_{ij} = \langle R_{i} R_{j}\rangle -; \langle R_{i}\rangle \langle R_{j}\rangle\), where; \(R = (q_1, p_1, q_2, p_2)^T\) is the vector with quadrature operators; for the two modes.; Alternatively, if R = None, and if annihilation operators a1 and a2; for the two modes are supplied instead, the quadrature correlation matrix; is constructed from the annihilation operators before then the covariance; matrix is calculated. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. RndarrayThe quadrature correlation matrix. rhoQobjDensity matrix for which to calculate the covariance matrix. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:108572,Testability,test,tested,108572,". sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207173,Testability,log,logger,207173,"is the guess_pulse_type. init_pulse_paramsdictParameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:211951,Testability,test,tested,211951,"um allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, A",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:215373,Testability,log,logger,215373,"tribute name value pairs. They applied after the; object is created. guess_pulse_actionstring, default ‘MODULATE’Determines how the guess pulse is applied to the pulse generated by the; basis expansion. Options are: MODULATE, ADD. pulse_scalingfloatLinear scale factor for generated guess pulses. By default initial; pulses are generated with amplitudes in the range (-1.0, 1.0). These; will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220408,Testability,test,tested,220408,"m allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:223345,Testability,log,logger,223345,"to be attribute name value pairs. They applied after the; object is created. guess_pulse_actionstring, ‘MODULATE’Determines how the guess pulse is applied to the pulse generated by the; basis expansion. Options are: MODULATE, ADD. pulse_scalingfloatLinear scale factor for generated guess pulses. By default initial; pulses are generated with amplitudes in the range (-1.0, 1.0). These; will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:231823,Testability,log,logger,231823,"he guess_pulse_type. init_pulse_paramsdictParameters for the initial / guess pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:239898,Testability,log,logger,239898,"he guess_pulse_type. init_pulse_paramsdictParameters for the initial / guess pulse generator object. The key; value pairs are assumed to be attribute name value pairs. They applied; after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. Pulse generator - Generate pulses fo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:83879,Usability,progress bar,progress bar,83879,"_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolev will be removed in QuTiP 5. Please use sesolve; or mesolve for general-purpose integration of the; Schroedinge",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:108399,Usability,simpl,simple,108399,", see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:109748,Usability,usab,usable,109748,"uations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (\(\alpha = 1/2\), \(\beta\) doesn’t matter). See eq.; (2.18) of chapter 12.2 of [1]. Order strong 1.5; Code: 'taylor1.5-imp' or 'taylor15-imp'. explicit1.5Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than taylor15 but usable by; general_stochastic. See eq. (2.13) of chapter 11.2 of; [1]. O",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:110671,Usability,usab,usable,110671,"in while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (\(\alpha = 1/2\), \(\beta\) doesn’t matter). See eq.; (2.18) of chapter 12.2 of [1]. Order strong 1.5; Code: 'taylor1.5-imp' or 'taylor15-imp'. explicit1.5Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than taylor15 but usable by; general_stochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredic",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:111032,Usability,usab,usable,111032,"strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (\(\alpha = 1/2\), \(\beta\) doesn’t matter). See eq.; (2.18) of chapter 12.2 of [1]. Order strong 1.5; Code: 'taylor1.5-imp' or 'taylor15-imp'. explicit1.5Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than taylor15 but usable by; general_stochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:140902,Usability,progress bar,progress bar,140902,"\(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters. Hqobj or listHamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). tfloat or array-likeTime or list of times for which to evaluate the propagator. c_op_listlistList of qobj collapse operators. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWh",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:141408,Usability,clear,clears,141408,"t Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:196774,Usability,learn,learningtimes,196774," for QASM file to be imported. In case of; string input, the parameter strmode must be True. modestrQASM mode to be read in. When mode is “qiskit”,; the “qelib1.inc” include is automatically included,; without checking externally. Otherwise, each include is; processed. versionstrQASM version of the QASM file. Only version 2.0 is currently supported. strmodeboolif specified as True, indicates that qasm_input is in string format; rather than from file. Returns. qcQubitCircuitReturns a QubitCircuit object specified in the QASM file. save_qasm(qc, file_loc)[source]¶; Save QASM output of circuit object to file. Parameters. qc: :class:`.QubitCircuit`circuit object to produce QASM output for. Non-Markovian Solvers¶; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1].; [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014). ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs)[source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and exe",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:217111,Usability,simpl,simply,217111,"which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:233586,Usability,simpl,simply,233586,"error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent contro",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:253553,Usability,progress bar,progress bar,253553,". Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Cl",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:255155,Usability,progress bar,progress bar,255155," these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/development/contributing.html:6136,Availability,reliab,reliably,6136,"f you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try t",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:6674,Availability,avail,available,6674,"until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make c",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8639,Availability,failure,failures,8639,"cstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on oc",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8692,Availability,error,error,8692,"cstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on oc",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:9602,Availability,down,down,9602,"for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10602,Availability,avail,available,10602,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10830,Availability,avail,available,10830,"that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been ch",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11941,Availability,failure,failure,11941,"ning pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you hav",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12829,Availability,error,errors,12829," build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3016,Deployability,update,update,3016," result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are i",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3359,Deployability,install,installing,3359,"e “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3507,Deployability,install,installation,3507," is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer,",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3525,Deployability,release,release,3525," is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer,",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3719,Deployability,install,installation,3719," a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementati",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3786,Deployability,install,installation,3786," a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementati",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4251,Deployability,install,installed,4251,"ding the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes y",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4298,Deployability,install,install,4298,"ding the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes y",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4452,Deployability,install,installed,4452,"hon environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup com",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4473,Deployability,install,install,4473,"hon environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup com",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4527,Deployability,install,install,4527,"n of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sourc",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4968,Deployability,install,installation,4968,"t.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this comm",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4996,Deployability,install,installation,4996,"t.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this comm",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:6071,Deployability,install,install,6071," python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:6284,Deployability,update,updated,6284," is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are fun",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:7471,Deployability,release,release,7471," is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:7776,Deployability,update,update,7776,"e this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use som",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8524,Deployability,install,installed,8524,"r release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the doc",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10015,Deployability,install,install,10015,"test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modif",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10173,Deployability,configurat,configuration,10173,"p repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10234,Deployability,install,install,10234,"p repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10279,Deployability,configurat,configuration,10279,"pydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you shoul",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10429,Deployability,install,install,10429,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10542,Deployability,update,update,10542,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10944,Deployability,release,release,10944,"nt containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10997,Deployability,install,install,10997,"nt containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11241,Deployability,install,installed,11241,"wn-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11612,Deployability,install,installation,11612,"te their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11797,Deployability,update,update,11797,"n.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests f",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11985,Deployability,install,installed,11985,"ning pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you hav",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:13358,Deployability,update,updated,13358," build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4543,Integrability,depend,dependencies,4543,"n of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sourc",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:5592,Integrability,rout,routines,5592,"ary development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8446,Integrability,depend,depending,8446,"r release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the doc",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:9417,Integrability,depend,dependencies,9417," take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend y",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:9785,Integrability,depend,dependencies,9785,"features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.;",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10035,Integrability,depend,dependencies,10035,"test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modif",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10437,Integrability,depend,dependencies,10437,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11949,Integrability,message,messages,11949,"ning pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you hav",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12015,Integrability,depend,dependencies,12015,"ning pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you hav",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:7212,Modifiability,variab,variable,7212,"think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the AP",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10173,Modifiability,config,configuration,10173,"p repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10279,Modifiability,config,configuration,10279,"pydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you shoul",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:5133,Performance,load,load,5133,"version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temp",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:5862,Safety,detect,detect,5862,"r you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:6117,Safety,detect,detection,6117,"f you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try t",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11099,Security,access,accessible,11099,"requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will b",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:1049,Testability,test,testing,1049," Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Contributing to QuTiP Development. Contributing to QuTiP Development¶. Quick Start¶; QuTiP is developed through wide collaboration using the git version-control system, with the main repositories hosted in the qutip organisation on GitHub.; You will need to be familiar with git as a tool, and the GitHub Flow workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:2041,Testability,test,tests,2041,"vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of thi",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:2658,Testability,test,tests,2658,"h to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation fr",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:2753,Testability,test,tests,2753,"h to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation fr",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:2788,Testability,test,tests,2788,"h to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation fr",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3833,Testability,test,tests,3833,"es are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to bu",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3953,Testability,test,testing,3953,"them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows inst",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3985,Testability,test,tests,3985,"them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows inst",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4122,Testability,test,test,4122,"ndards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. f",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:6695,Testability,test,test,6695,"until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make c",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8323,Testability,test,test,8323,"o not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several add",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8363,Testability,test,test,8363,"s to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rt",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8399,Testability,test,tests,8399,"s to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rt",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8558,Testability,test,tests,8558,"ry to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8833,Testability,test,tests,8833,"other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8953,Testability,test,tests,8953,"nd classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; co",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:9027,Testability,test,tests,9027,"nd classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; co",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:9068,Testability,test,tests,9068,"me it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10723,Testability,test,test,10723,"o keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you w",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12773,Testability,test,tests,12773," build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12951,Testability,test,test,12951," build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:2873,Usability,feedback,feedback,2873,"add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The b",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3352,Usability,simpl,simply,3352,"e “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3664,Usability,guid,guide,3664," a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementati",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:5009,Usability,guid,guide,5009,"t.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this comm",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:7299,Usability,guid,guidelines,7299,"think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the AP",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:9539,Usability,simpl,simply,9539,"for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10923,Usability,guid,guide,10923,"nt containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11304,Usability,simpl,simply,11304,"wn-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12219,Usability,guid,guide,12219,"stalled all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12324,Usability,guid,guide,12324,"in library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.;",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/development.html:589,Deployability,release,releases,589,". Development Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation bui",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1064,Deployability,integrat,integration,1064,". ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monito",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1247,Deployability,release,release,1247,"t; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D.",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1910,Deployability,release,release,1910,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1938,Deployability,release,release,1938,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1975,Deployability,release,release,1975,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2011,Deployability,release,release,2011,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2036,Deployability,deploy,deploy,2036,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2054,Deployability,deploy,deploy,2054,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2125,Deployability,release,release,2125,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2182,Deployability,update,updates,2182,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2409,Deployability,update,updated,2409,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1064,Integrability,integrat,integration,1064,". ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monito",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/docs.html:5848,Deployability,update,updated,5848,"2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. (png, hires.png, pdf). A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code is being run in the namespace of the previous plot block within the; same file.; By default, each rendered figure in one plot block (when using :context:); is carried over to the next block.; When the context argument is specified with the reset option; as :context: reset, the namespace is reset to a new one and all figures are; erased.; When the context argument is specified with the close-figs option; as :context: reset, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:1066,Modifiability,config,configured,1066,"ion. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:1457,Testability,test,tests,1457,"lbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, te",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2082,Testability,test,test,2082," in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the sa",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2120,Testability,test,testcode,2120,"can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2180,Testability,test,testcode,2180," the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use ",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2275,Testability,test,testoutput,2275,"ease refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To c",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2299,Testability,test,testoutput,2299,"individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of ",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2337,Testability,test,testcode,2337," directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities betw",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2452,Testability,test,tests,2452,"est way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doc",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2616,Testability,test,testcode,2616,"he documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directiv",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2778,Testability,test,testcode,2778,"y the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; >>> prompts), tests a",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:3247,Testability,test,tested,3247,"). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; >>> prompts), tests also include those specified under the plot directive.; Example:; First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:3790,Testability,test,tests,3790,"efault, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; >>> prompts), tests also include those specified under the plot directive.; Example:; First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. (png, hires.png, pdf). A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code i",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:5485,Testability,test,testing,5485,"2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. (png, hires.png, pdf). A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code is being run in the namespace of the previous plot block within the; same file.; By default, each rendered figure in one plot block (when using :context:); is carried over to the next block.; When the context argument is specified with the reset option; as :context: reset, the namespace is reset to a new one and all figures are; erased.; When the context argument is specified with the close-figs option; as :context: reset, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:588,Usability,guid,guide,588,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:646,Usability,guid,guide,646,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:806,Usability,learn,learn,806,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:882,Usability,guid,guide,882,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:1195,Usability,guid,guide,1195,"ide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is ",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:1352,Usability,guid,guidelines,1352,"Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:1410,Usability,guid,guide,1410,"Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:1498,Usability,simpl,simplest,1498,". Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; spec",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2376,Usability,simpl,simpler,2376," directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities betw",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:5560,Usability,learn,learn,5560,"2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. (png, hires.png, pdf). A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code is being run in the namespace of the previous plot block within the; same file.; By default, each rendered figure in one plot block (when using :context:); is carried over to the next block.; When the context argument is specified with the reset option; as :context: reset, the namespace is reset to a new one and all figures are; erased.; When the context argument is specified with the close-figs option; as :context: reset, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/ideas.html:820,Deployability,release,releases,820,". Ideas for future QuTiP development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas.html
https://qutip.org/docs/4.6/development/ideas.html:1244,Deployability,update,updated,1244,". Ideas for future QuTiP development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas.html
https://qutip.org/docs/4.6/development/release_distribution.html:6269,Availability,down,download,6269,"d.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version numb",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6681,Availability,down,down,6681,"c directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the n",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7725,Availability,avail,available,7725," branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deploymen",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:8145,Availability,down,download,8145,"evious deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:8829,Availability,down,down,8829,"t files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, o",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9653,Availability,down,down,9653," might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10074,Availability,down,down,10074,"tion” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11240,Availability,down,downloads,11240,"e may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases sec",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11931,Availability,down,download,11931," Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-fee",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:431,Deployability,release,release,431,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:459,Deployability,release,release,459,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:496,Deployability,release,release,496,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:532,Deployability,release,release,532,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:557,Deployability,deploy,deploy,557,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:575,Deployability,deploy,deploy,575,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:646,Deployability,release,release,646,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:703,Deployability,update,updates,703,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:915,Deployability,update,updates,915,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:944,Deployability,release,release,944,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:967,Deployability,release,releases,967,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1162,Deployability,release,release,1162,"cumentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1251,Deployability,release,release,1251," Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this bra",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1297,Deployability,release,release,1297," Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this bra",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1336,Deployability,release,release,1336," Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this bra",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1380,Deployability,release,release,1380,"ase; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstrea",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1423,Deployability,release,release,1423,"ase; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstrea",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1479,Deployability,patch,patch,1479,"ase; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstrea",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1498,Deployability,release,release,1498,"ase; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstrea",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1595,Deployability,deploy,deploy,1595,"Hub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, ch",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1663,Deployability,deploy,deploy,1663,"Hub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, ch",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1699,Deployability,release,release,1699,"Hub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, ch",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1751,Deployability,update,update,1751,"Hub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, ch",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1817,Deployability,update,update,1817,"tribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pu",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1845,Deployability,deploy,deploying,1845,"tribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pu",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1916,Deployability,release,release,1916,"; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the lat",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2054,Deployability,release,release,2054,"; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the lat",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2508,Deployability,patch,patch,2508," both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number i",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2606,Deployability,release,release,2606,"tion; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end i",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2981,Deployability,release,release,2981,"mmit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3057,Deployability,release,release,3057,"test release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3169,Deployability,release,release,3169,"similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new versio",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3359,Deployability,release,release,3359,"p-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3627,Deployability,release,release,3627,"arlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, startin",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3780,Deployability,release,release,3780,"8a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4256,Deployability,release,release,4256,"tifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly rele",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4307,Deployability,release,release,4307,"tifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly rele",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4408,Deployability,release,release,4408,".; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4457,Deployability,release,release,4457,"The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4514,Deployability,release,release-candidate,4514," with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4532,Deployability,release,releases,4532," with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4628,Deployability,release,release,4628,"r or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should al",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4690,Deployability,release,release,4690,"y using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qut",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5155,Deployability,release,release,5155," change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This ste",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5288,Deployability,release,released,5288,"e first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5365,Deployability,release,release,5365,"umbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP webs",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5517,Deployability,release,release,5517,"ese is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Cli",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5564,Deployability,update,updates,5564,"psectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Ru",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5591,Deployability,release,release,5591,"psectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Ru",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6003,Deployability,release,release,6003,"elopment Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6107,Deployability,release,release,6107," The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6132,Deployability,deploy,deploy,6132," The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6359,Deployability,deploy,deploy,6359," trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make a",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6519,Deployability,deploy,deploy,6519,"se.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6731,Deployability,release,release,6731,"c directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the n",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6869,Deployability,release,release,6869,"c/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, cl",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7019,Deployability,deploy,deployment,7019,"n, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the bel",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7171,Deployability,deploy,deployment,7171,"binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the sou",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7399,Deployability,upgrade,upgrades,7399,"ly by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7421,Deployability,release,releases,7421,"ly by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7457,Deployability,release,release,7457,"y.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7573,Deployability,deploy,deployment,7573,"left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7604,Deployability,deploy,deployment,7604,"ader notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, li",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7739,Deployability,install,install,7739," branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deploymen",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7754,Deployability,install,install,7754," branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deploymen",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:8695,Deployability,deploy,deployment,8695,"n will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the versio",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:8958,Deployability,deploy,deployment,8958,"success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summa",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9030,Deployability,deploy,deployment,9030,"success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summa",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9181,Deployability,deploy,deployed,9181,"n.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9319,Deployability,deploy,deploy,9319,"*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this descrip",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9330,Deployability,release,release,9330,"*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this descrip",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9429,Deployability,release,release,9429,"you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.;",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9561,Deployability,release,release,9561,"n workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you h",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9614,Deployability,release,release,9614,"subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip f",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10016,Deployability,release,release,10016,"tion” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10056,Deployability,release,release,10056,"tion” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10215,Deployability,release,release,10215,"eployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10629,Deployability,release,release,10629,"ip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into t",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10809,Deployability,update,updated,10809,"ion 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10833,Deployability,release,release,10833,"ion 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11057,Deployability,release,release,11057,"of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11139,Deployability,release,releases,11139,"log you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Sourc",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11380,Deployability,release,release,11380,"nd qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11539,Deployability,release,release,11539,"those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and z",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11916,Deployability,update,updates,11916,"site repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11958,Deployability,release,release,11958,"les into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/q",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11994,Deployability,update,updated,11994,"les into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/q",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12054,Deployability,release,release,12054," and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generat",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12070,Deployability,update,updated,12070," and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generat",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12364,Deployability,release,release,12364,"ation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to yo",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12396,Deployability,release,release,12396,"ation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to yo",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12476,Deployability,release,releases,12476,"ation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to yo",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12536,Deployability,release,release,12536,"which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12563,Deployability,update,updated,12563,"which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12621,Deployability,release,release,12621,"l into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12752,Deployability,update,updated,12752,"removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-fo",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12799,Deployability,release,release,12799,"hub.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prer",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12854,Deployability,release,releases,12854,"hub.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prer",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:14123,Deployability,update,updated,14123,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7950,Energy Efficiency,monitor,monitor,7950,"; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instru",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:8486,Energy Efficiency,monitor,monitor,8486," to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” secti",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6792,Integrability,depend,depending,6792,"nf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version ap",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9144,Integrability,message,message,9144,"n.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:13761,Modifiability,config,config,13761,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7551,Performance,perform,perform,7551,"left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2136,Security,hash,hash,2136,"ow to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tes",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2633,Security,hash,hash,2633," deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on th",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11017,Security,access,access,11017,"of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2097,Testability,log,log,2097,"ow to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tes",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3131,Testability,test,tests,3131,"copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_rea",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7385,Testability,test,testing,7385,"ly by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:13521,Testability,test,tests,13521,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:13572,Testability,test,tests,13572,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:13684,Testability,test,test,13684,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6066,Usability,guid,guide,6066,"h them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/roadmap.html:3434,Availability,mainten,maintence,3434,"kages that are; somehow related to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics.; Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavo",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12042,Availability,mask,masking,12042,"uch] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status mes",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:13703,Availability,error,errors,13703,"rally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is i",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15856,Availability,avail,available,15856,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:494,Deployability,integrat,integration,494,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:677,Deployability,release,release,677,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:1213,Deployability,release,release,1213,"ment Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in the sense of a group; of people working collaboratively towards common objectives, and also a web; presence qutip.org. The QuTiP Community includes all the; people who have supported the project since in",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:4002,Deployability,release,release,4002," as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installe",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:4185,Deployability,install,installed,4185,"pe of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a depen",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:4796,Deployability,integrat,integrated,4796,"ompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family pac",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:4879,Deployability,install,installed,4879,"he freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components int",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:5048,Deployability,install,installed,5048," could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:5929,Deployability,integrat,integrated,5929,"der structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Fram",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:6325,Deployability,integrat,integrated,6325,"p. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:6540,Deployability,integrat,integrated,6540," fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairl",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:6963,Deployability,integrat,integrated,6963," core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:10297,Deployability,integrat,integration,10297,"providing full control over how the; data-layer dispatchers choose the most appropriate output type. qutip main reorganization¶. tag; qmain-reorg. status; development [pretty much] complete. admin lead; Eric. main dev; Jake Lishman. Reorganise qutip main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:10528,Deployability,deploy,deploying,10528,"main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP contro",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:11301,Deployability,integrat,integrated,11301,"dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. s",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:11445,Deployability,integrat,integrated,11445," for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functi",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15149,Deployability,toggle,toggle,15149," file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15514,Deployability,release,release,15514,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15598,Deployability,release,release,15598,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15703,Deployability,integrat,integration,15703,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15789,Deployability,release,release,15789,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:16023,Deployability,release,release,16023,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:16068,Deployability,release,released,16068,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:16283,Deployability,update,updated,16283,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:494,Integrability,integrat,integration,494,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:3466,Integrability,depend,dependences,3466,"kages that are; somehow related to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics.; Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavo",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:3538,Integrability,depend,depend,3538,"iP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics.; Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; des",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:4796,Integrability,integrat,integrated,4796,"ompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family pac",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:5115,Integrability,depend,dependency,5115," could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:5929,Integrability,integrat,integrated,5929,"der structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Fram",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:6325,Integrability,integrat,integrated,6325,"p. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:6540,Integrability,integrat,integrated,6540," fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairl",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:6963,Integrability,integrat,integrated,6963," core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:7222,Integrability,depend,depends,7222,"g, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, devel",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:7284,Integrability,depend,dependency,7284,"ch; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:7662,Integrability,wrap,wrapper,7662," provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:10297,Integrability,integrat,integration,10297,"providing full control over how the; data-layer dispatchers choose the most appropriate output type. qutip main reorganization¶. tag; qmain-reorg. status; development [pretty much] complete. admin lead; Eric. main dev; Jake Lishman. Reorganise qutip main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:10557,Integrability,depend,dependent,10557,"main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP contro",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:11301,Integrability,integrat,integrated,11301,"dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. s",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:11445,Integrability,integrat,integrated,11445," for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functi",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12107,Integrability,depend,dependent,12107,"onents used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12380,Integrability,wrap,wrapper,12380,"al codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, con",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12618,Integrability,interface,interface,12618,"new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python log",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14484,Integrability,interface,interface,14484,"t it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major r",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15703,Integrability,integrat,integration,15703,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:3862,Modifiability,enhance,enhancement,3862," as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installe",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:11973,Modifiability,variab,variables,11973,"uch] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status mes",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12117,Modifiability,variab,variable,12117,"onents used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12398,Modifiability,variab,variable,12398,"al codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, con",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:13450,Modifiability,layers,layers,13450," optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14716,Modifiability,flexible,flexible,14716," errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14759,Modifiability,flexible,flexible,14759,"ing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15212,Modifiability,config,configure,15212,"s. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Li",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:9208,Performance,perform,performance,9208,"develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. data layer abstraction¶. tag; dl-abs. status; majority of development completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements throughout qutip.; Some developments tasks remain, including providing full control over how the; data-layer dispatchers choose the most appropriate output type. qutip main reorganization¶. tag; qmain-reorg. status; development [pretty much] complete. admin lead; Eric. main dev; Jake Lishman. Reorganise qutip main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for docume",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:10454,Performance,perform,performance,10454,"g. status; development [pretty much] complete. admin lead; Eric. main dev; Jake Lishman. Reorganise qutip main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12460,Performance,optimiz,optimize,12460,"mplemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:13886,Safety,avoid,avoided,13886,"h fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotl",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15017,Safety,avoid,avoid,15017,"tates, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full releas",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14552,Security,access,accessible,14552,"t it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major r",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:3683,Testability,test,testing,3683," scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTi",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:7884,Testability,test,tests,7884,"te packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. data layer abstraction¶. tag; dl-abs. status; majority of development completed. admin lead; Eric. main dev; Jake Lishman. Development completed as ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:13228,Testability,log,logging,13228,"ining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, c",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:13635,Testability,log,logging,13635," a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in educa",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14208,Testability,log,logging,14208,". main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have slider",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15892,Testability,test,test,15892,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:16008,Testability,test,testing,16008,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:16053,Testability,test,tested,16053,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:8023,Usability,simpl,simplifcation,8023,"e status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. data layer abstraction¶. tag; dl-abs. status; majority of development completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data fr",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12556,Usability,learn,learning,12556,"mplemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12935,Usability,simpl,simplify,12935,"Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized component",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14354,Usability,simpl,simple,14354,"olvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuit",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14631,Usability,learn,learners,14631,"icised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 rele",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/guide/guide-basics.html:1257,Availability,avail,available,1257,"Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this us",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:9570,Availability,error,error,9570,"atrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); ------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-33-0b599f41213e> in <module>; ----> 1 print(q * x). ~/Documents/qutip_dev/qutip/qutip/qobj.py in __mul__(self, other); 553; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators “is equal” == and “is not equal” != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Check Hermicity; Q.check_herm(); Check if quantum object is Hermitian. Conjugate; Q.conj(); Conjugate of quantum object. Cosine; Q.cosm(); Cosine of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Diamond Norm; Q.dnorm(); Returns the diamond norm. Eige",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:1120,Deployability,install,installation,1120,"rontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structu",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:14555,Deployability,update,updated,14555,"97 0.035077 ]; [0.08826704 0.08822695 0.06263061 0.035077 0.0211765 ]]. >>> coherent_dm(5, 1).diag(); array([0.36791117, 0.36757705, 0.18523331, 0.05810197, 0.0211765 ]). >>> coherent_dm(5, 1).full(); array([[0.36791117+0.j, 0.36774407+0.j, 0.26105441+0.j, 0.14620658+0.j,; 0.08826704+0.j],; [0.36774407+0.j, 0.36757705+0.j, 0.26093584+0.j, 0.14614018+0.j,; 0.08822695+0.j],; [0.26105441+0.j, 0.26093584+0.j, 0.18523331+0.j, 0.10374209+0.j,; 0.06263061+0.j],; [0.14620658+0.j, 0.14614018+0.j, 0.10374209+0.j, 0.05810197+0.j,; 0.035077 +0.j],; [0.08826704+0.j, 0.08822695+0.j, 0.06263061+0.j, 0.035077 +0.j,; 0.0211765 +0.j]]). >>> coherent_dm(5, 1).norm(); 1.0000000175063126. >>> coherent_dm(5, 1).sqrtm(); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0.36791117+3.66778589e-09j 0.36774407-2.13388761e-09j; 0.26105441-1.51480558e-09j 0.14620658-8.48384618e-10j; 0.08826704-5.12182118e-10j]; [0.36774407-2.13388761e-09j 0.36757705+2.41479965e-09j; 0.26093584-1.11446422e-09j 0.14614018+8.98971115e-10j; 0.08822695+6.40705133e-10j]; [0.26105441-1.51480558e-09j 0.26093584-1.11446422e-09j; 0.18523331+4.02032413e-09j 0.10374209-3.39161017e-10j; 0.06263061-3.71421368e-10j]; [0.14620658-8.48384618e-10j 0.14614018+8.98971115e-10j; 0.10374209-3.39161017e-10j 0.05810197+3.36300708e-10j; 0.035077 +2.36883273e-10j]; [0.08826704-5.12182118e-10j 0.08822695+6.40705133e-10j; 0.06263061-3.71421368e-10j 0.035077 +2.36883273e-10j; 0.0211765 +1.71630348e-10j]]. >>> coherent_dm(5, 1).tr(); 1.0. >>> (basis(4, 2) + basis(4, 1)).unit(); Quantum object: dims = [[4], [1]], shape = (4, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0.70710678]; [0. ]]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:4897,Energy Efficiency,charge,charge,4897,"ying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used; types such as the; ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states.; Therefore, QuTiP includes predefined objects for a variety of states and operators:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m)/fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alpha); same as coherent(N,alpha). Thermal density matrix; (for n particles); thermal_dm(N,n); n = particle number expectation value. Operators; Command (# means optional); Inputs. Charge operator; charge(N,M=-N); Diagonal operator with entries; from M..0..N. Commutator; commutator(A, B, kind); Kind = ‘normal’ or ‘anti’. Diagonals operator; qdiags(N); Quantum object created from arrays of; diagonals at given offsets. Displacement operator; (Single-mode); displace(N,alpha); N=number of levels in Hilbert space,; alpha = complex displacement amplitude. Higher spin operators; jmat(j,#s); j = integer or half-integer; representing spin, s = ‘x’, ‘y’, ‘z’,; ‘+’, or ‘-‘. Identity; qeye(N); N = number of levels in Hilbert space. Lowering (destruction); operator; destroy(N); same as above. Momentum operator; momentum(N); same as above. Number operator; num(N); same as above. Phase operator; (Single-mode); phase(N, phi0); Single-mode Pegg-Barnett phase; operator with ref phase phi0. Position operator; position(N); same as above. Raising (creation); operator; create(N); same as above. Squeezing operator; (Single-mode); squeeze(N, sp); N=number of levels in Hilbert space,; sp = squeezing parameter. Squeezing op",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:8478,Integrability,message,message,8478,"es (properties) of a Qobj object (or any Python object) can be retrieved using the Q.attribute notation.; In addition to the those shown with the print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. ",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:1959,Modifiability,variab,variables,1959,"ment Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; print(Qobj()). Output:; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, the names of Python classes, such as Qobj(), are capitalized whereas the names of functions are not. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; print(Qobj([[1],[2],[3],[4],[5]])). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), t",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:1147,Performance,load,load,1147," on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra ",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:1236,Performance,load,load,1236,"Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this us",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:1615,Performance,load,loaded,1615," of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; print(Qobj()). Output:; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, the",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:7366,Security,access,accessed,7366," =; [[0.]; [0.]; [0.]; [1.]; [0.]]. >>> coherent(5,0.5-0.5j); Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.7788017 +0.j ]; [ 0.38939142-0.38939142j]; [ 0. -0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. >>> destroy(4); Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. ]; [0. 0. 1.41421356 0. ]; [0. 0. 0. 1.73205081]; [0. 0. 0. 0. ]]. >>> sigmaz(); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. >>> jmat(5/2.0,'+'); Quantum object: dims = [[6], [6]], shape = (6, 6), type = oper, isherm = False; Qobj data =; [[0. 2.23606798 0. 0. 0. 0. ]; [0. 0. 2.82842712 0. 0. 0. ]; [0. 0. 0. 3. 0. 0. ]; [0. 0. 0. 0. 2.82842712 0. ]; [0. 0. 0. 0. 0. 2.23606798]; [0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; >>> q = destroy(4). >>> q.dims; [[4], [4]]. >>> q.shape; (4, 4). In general, the attributes (properties) of a Qobj object (or any Python object) can be retrieved using the Q.attribute notation.; In addition to the those shown with the print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex1",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:8602,Security,access,access,8602,"e print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); -----------------------------------",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:10012,Testability,log,logic,10012,">>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); ------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-33-0b599f41213e> in <module>; ----> 1 print(q * x). ~/Documents/qutip_dev/qutip/qutip/qobj.py in __mul__(self, other); 553; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators “is equal” == and “is not equal” != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Check Hermicity; Q.check_herm(); Check if quantum object is Hermitian. Conjugate; Q.conj(); Conjugate of quantum object. Cosine; Q.cosm(); Cosine of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Diamond Norm; Q.dnorm(); Returns the diamond norm. Eigenenergies; Q.eigenenergies(); Eigenenergies (values) of operator. Eigenstates; Q.eigenstates(); Returns eigenvalues and eigenvectors. Eliminate States; Q.eliminate_states(inds); Returns quantum object with states in; list inds removed. Exponential; Q.expm(); Matrix exponential of operator. Extract States; Q.extract_states(inds); Qobj with states listed in inds only. Full; Q.full(); Returns full (not spars",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:2167,Availability,avail,available,2167,"en studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). (png, hires.png, pdf). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). (png, hires.png, pdf). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). where we have removed the extra show() commands. Replaci",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:5982,Availability,down,down,5982,"(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). (png, hires.png, pdf). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). (png, hires.png, pdf). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). (png, hires.png, pdf). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The Bloch class uses Matplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In this sense the Bloch3d class is much more advanced, as objects are rendered in 3D leadi",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:14483,Deployability,install,installing,14483,"pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Sha",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:14649,Deployability,install,install,14649,"utip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:15549,Deployability,update,updated,15549," 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:13209,Modifiability,evolve,evolve,13209,"the save() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; import numpy as np; import qutip. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); sm = qutip.sigmam(); H = w * (np.cos(theta) * sz + np.sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(np.sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sz); # evolve and calculate expectation values; output = qutip.mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to te",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:1781,Performance,load,load,1781,"tes & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). (png, hires.png, pdf). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). (png, hires.png, pdf). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for construc",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:1866,Performance,load,loads,1866,"g; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). (png, hires.png, pdf). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). (png, hires.png, pdf). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b ",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:11064,Security,access,accessed,11064,"ay'. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; ['r', 'g', 'b', 'y']. b.point_mode; Type of point markers to draw; 'sphere'. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; '#808080'. b.size; Sets size of figure window; [500, 500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; ['r', 'g', 'b', 'y']. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45, 65]. b.xlabel; Labels for x-axis; ['|x>', ''] +x and -x. b.xlpos; Position of x-axis labels; [1.07, -1.07]. b.ylabel; Labels for y-axis; ['$y$', ''] +y and -y. b.ylpos; Position of y-axis labels; [1.07, -1.07]. b.zlabel; Labels for z-axis; ['|0>', '|1>'] +z and -z. b.zlpos; Position of z-axis labels; [1.07, -1.07]. These properties can also be accessed via the print command:; >>> b = qutip.Bloch(). >>> print(b) ; Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:1956,Usability,simpl,simply,1956,"pment Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). (png, hires.png, pdf). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). (png, hires.png, pdf). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec =",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:3389,Usability,clear,clear,3389,"render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). (png, hires.png, pdf). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). (png, hires.png, pdf). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). (png, hires.png, pdf). Notice that, in contr",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:3493,Usability,clear,clear,3493,"the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). (png, hires.png, pdf). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). (png, hires.png, pdf). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). (png, hires.png, pdf). Notice that, in contrast to states or vectors, each point remains the same color as the initial poin",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:3924,Usability,clear,clear,3924,"nts(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). (png, hires.png, pdf). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). (png, hires.png, pdf). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). (png, hires.png, pdf). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_point",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:4214,Usability,clear,clear,4214,"rates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). (png, hires.png, pdf). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). (png, hires.png, pdf). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). (png, hires.png, pdf). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). (png, hires.png, pdf). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:4227,Usability,clear,clear,4227,"plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). (png, hires.png, pdf). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). (png, hires.png, pdf). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). (png, hires.png, pdf). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). (png, hires.png, pdf). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set o",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:5526,Usability,clear,clear,5526,"multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). (png, hires.png, pdf). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). (png, hires.png, pdf). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). (png, hires.png, pdf). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important d",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:5538,Usability,clear,clear,5538,"nts using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). (png, hires.png, pdf). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). (png, hires.png, pdf). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). (png, hires.png, pdf). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to co",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:11989,Usability,clear,clear,11989," [1.07, -1.07]. These properties can also be accessed via the print command:; >>> b = qutip.Bloch(). >>> print(b) ; Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the output file based on how many times the object has been saved (this is stored in b.savenum). The easiest way to animate data on the Bloch sphere is to use the save() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; import numpy as np; import qutip. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); sm = qutip.sigmam(); H = w * (np.cos(theta) * sz + np.sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0:",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:14081,Usability,clear,clear,14081,"e > 0.0: c_op_list.append(np.sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sz); # evolve and calculate expectation values; output = qutip.mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax.",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:14331,Usability,simpl,simple,14331,"turn output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be view",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:14940,Usability,clear,clear,14940," 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-control.html:5955,Availability,error,error,5955,"then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:11627,Availability,down,down,11627,"orithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for dir",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:11698,Availability,avail,available,11698,"a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integrat",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:12755,Availability,error,errors,12755,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:11509,Deployability,integrat,integration,11509,"orithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for dir",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:12565,Deployability,integrat,integration,12565,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:12707,Deployability,integrat,integration,12707,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:13182,Deployability,integrat,integrated,13182,"espect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and method",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:14279,Deployability,configurat,configuration,14279,"optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic tran",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:14503,Deployability,configurat,configuration,14503,"is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:17213,Deployability,configurat,configuration,17213,"s shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:18125,Deployability,update,updated,18125,"s shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:7957,Energy Efficiency,efficient,efficient,7957,"dency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bou",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:8245,Energy Efficiency,reduce,reduces,8245,"rom here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather t",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:9013,Energy Efficiency,reduce,reduces,9013,"ith respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performi",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:9210,Energy Efficiency,efficient,efficient,9210,"s typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-p",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:9560,Energy Efficiency,efficient,efficient,9560,"s of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algo",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:11026,Energy Efficiency,efficient,efficiently,11026,"adients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] tha",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:17854,Energy Efficiency,efficient,efficient,17854,"s shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:4231,Integrability,depend,dependent,4231,"d}{dt} \ket{\psi} = -i H(t)\ket{\psi}\]; Note we use units where \(\hbar=1\) throughout. The solutions to Schrödinger’s equation are of the form:. \[\ket{\psi(t)} = U(t)\ket{\psi_0}\]; where \(\psi_0\) is the state of the system at \(t=0\) and \(U(t)\) is a unitary operator on the Hilbert space containing the states. \(U(t)\) is a solution to the Schrödinger operator equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\ket{\psi_0}\) to \(\ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The GRadient Ascent Pulse Engineering was first proposed in [2]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\c",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:8872,Integrability,wrap,wrapper,8872,"h the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goa",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:11509,Integrability,integrat,integration,11509,"orithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for dir",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:12565,Integrability,integrat,integration,12565,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:12707,Integrability,integrat,integration,12707,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:13182,Integrability,integrat,integrated,13182,"espect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and method",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:14023,Integrability,interface,interface,14023,"escribed here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:14547,Integrability,wrap,wrapper,14547,"nded for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be ac",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:4414,Modifiability,evolve,evolve,4414,"at \(t=0\) and \(U(t)\) is a unitary operator on the Hilbert space containing the states. \(U(t)\) is a solution to the Schrödinger operator equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\ket{\psi_0}\) to \(\ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The GRadient Ascent Pulse Engineering was first proposed in [2]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of meri",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:6151,Modifiability,variab,variables,6151,"X_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimis",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:6265,Modifiability,variab,variable,6265,"X_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimis",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:6518,Modifiability,variab,variables,6518,"the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossib",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:6586,Modifiability,variab,variable,6586,"the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossib",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:6892,Modifiability,variab,variable,6892," phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:8062,Modifiability,variab,variables,8062,"ocal peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:9083,Modifiability,variab,variable,9083,"ith respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performi",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:13265,Modifiability,variab,variable,13265,"-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:13541,Modifiability,extend,extended,13541,"ws for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrap",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:13776,Modifiability,config,configurability,13776,"ling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:13938,Modifiability,flexible,flexible,13938,"rate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a conta",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:14279,Modifiability,config,configuration,14279,"optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic tran",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:14503,Modifiability,config,configuration,14503,"is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:17213,Modifiability,config,configuration,17213,"s shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:17745,Modifiability,config,configure,17745,"s shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:10036,Performance,perform,performing,10036,"o store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:11038,Performance,optimiz,optimize,11038,"adients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] tha",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:12658,Performance,optimiz,optimization,12658,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:13225,Performance,optimiz,optimize,13225,"-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:13247,Performance,perform,perform,13247,"-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:14444,Performance,load,loadparams,14444,"is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:14568,Performance,optimiz,optimize,14568," of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some k",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:14592,Performance,perform,perform,14592," of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some k",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:15666,Performance,perform,performed,15666,"orithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported.; There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised. TerminationConditionsThis is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The opti",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:16988,Performance,perform,performance,16988,"is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previo",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:6392,Usability,simpl,simplest,6392," target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches ze",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:6836,Usability,clear,clearly,6836," phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:9294,Usability,simpl,simple,9294,"The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:13995,Usability,simpl,simple,13995,"escribed here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:14264,Usability,simpl,simply,14264,"optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic tran",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:15936,Usability,simpl,simply,15936,"on operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported.; There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised. TerminationConditionsThis is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termi",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:17076,Usability,simpl,simplest,17076,"f course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. G",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:17584,Usability,simpl,simply,17584,"s shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-correlation.html:2670,Availability,avail,available,2670,"ite. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,\]; which is independent of \(t\), so that we only have one time coordinate \(\tau\).; QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument solver. QuTiP function; Correlation function. qutip.correlation.correlation_2op_2t; \(\left<A(t+\tau)B(t)\right>\) or; \(\left<A(t)B(t+\tau)\right>\). qutip.correlation.correlation_2op_1t; \(\left<A(\tau)B(0)\right>\) or; \(\left<A(0)B(\tau)\right>\). qutip.correlation.correlation_3op_1t; \(\left<A(0)B(\tau)C(0)\right>\). qutip.correlation.correlation_3op_2t; \(\left<A(t)B(t+\tau)C(t)\right>\). The most common use-case is to calculate correlation functions of the kind \(\left<A(\tau)B(0)\right>\), in which case we use the correlation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function solvers return a vector or matrix (in general complex) with the correlations as a function of the delays",MatchSource.WIKI,docs/4.6/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html
https://qutip.org/docs/4.6/guide/guide-correlation.html:12898,Deployability,update,updated,12898,"ip.correlation.correlation_3op_1t, which computes a correlation function on the form \(\left<A(0)B(\tau)C(0)\right>\) (three operators, one delay-time vector).; We first have to combine the central two operators into one single one as they are evaluated at the same time, e.g. here we do \(a^\dagger(\tau)a(\tau) = (a^\dagger a)(\tau)\).; The following code calculates and plots \(g^{(2)}(\tau)\) as a function of \(\tau\) for a coherent, thermal and fock state.; import numpy as np; import matplotlib.pyplot as plt; import qutip. N = 25; taus = np.linspace(0, 25.0, 200); a = qutip.destroy(N); H = 2 * np.pi * a.dag() * a. kappa = 0.25; n_th = 2.0 # bath temperature in terms of excitation number; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag()]. states = [; {'state': qutip.coherent_dm(N, np.sqrt(2)), 'label': ""coherent state""},; {'state': qutip.thermal_dm(N, 2), 'label': ""thermal state""},; {'state': qutip.fock_dm(N, 2), 'label': ""Fock state""},; ]. fig, ax = plt.subplots(1, 1). for state in states:; rho0 = state['state']. # first calculate the occupation number as a function of time; n = qutip.mesolve(H, rho0, taus, c_ops, [a.dag() * a]).expect[0]. # calculate the correlation function G2 and normalize with n(0)n(t) to; # obtain g2; G2 = qutip.correlation_3op_1t(H, rho0, taus, c_ops, a.dag(), a.dag()*a, a); g2 = G2 / (n[0] * n). ax.plot(taus, np.real(g2), label=state['label'], lw=2). ax.legend(loc=0); ax.set_xlabel(r'$\tau$'); ax.set_ylabel(r'$g^{(2)}(\tau)$'); plt.show(). (png, hires.png, pdf). For convenience, the steps for calculating the second-order coherence function have been collected in the function qutip.correlation.coherence_function_g2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html
https://qutip.org/docs/4.6/guide/guide-correlation.html:4560,Energy Efficiency,power,power,4560,".g., the qutip.correlation.correlation_2op_1t function. These correlation function solvers return a vector or matrix (in general complex) with the correlations as a function of the delays times. Steadystate correlation function¶; The following code demonstrates how to calculate the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qu",MatchSource.WIKI,docs/4.6/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html
https://qutip.org/docs/4.6/guide/guide-correlation.html:5152,Energy Efficiency,power,power,5152,", x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting s",MatchSource.WIKI,docs/4.6/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html
https://qutip.org/docs/4.6/guide/guide-correlation.html:6302,Energy Efficiency,power,power,6302,"upling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = qutip.correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = qutip.spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 = np.linspace(0.25, 1.75, 200) * 2 * np.pi; spec2 = qutip.spectrum(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = pyplot.subplots(1, 1); ax.plot(wlist1 / (2 * np.pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * np.pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*np.pi), wlist2[-1]/(2*np.pi)); plt.show(). (png, hires.png, pdf). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steadystate. In QuTiP, we can evoluate such correlation functions using the function qutip.correlation.correlation_2op_2t. The default behavior of this function is to return a matrix with the correlations as a function of the two",MatchSource.WIKI,docs/4.6/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html
https://qutip.org/docs/4.6/guide/guide-correlation.html:4824,Integrability,depend,dependent,4824," a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve",MatchSource.WIKI,docs/4.6/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html
https://qutip.org/docs/4.6/guide/guide-correlation.html:1222,Modifiability,evolve,evolved,1222,"n and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\",MatchSource.WIKI,docs/4.6/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html
https://qutip.org/docs/4.6/guide/guide-correlation.html:5349,Modifiability,coupling,coupling,5349,"n $\left<x(t)x(0)\right>$'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = qutip.correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = qutip.spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolv",MatchSource.WIKI,docs/4.6/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html
https://qutip.org/docs/4.6/guide/guide-correlation.html:4851,Performance,perform,performs,4851," a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve",MatchSource.WIKI,docs/4.6/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html
https://qutip.org/docs/4.6/guide/guide-dynamics.html:2636,Deployability,update,updated,2636,"ng on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-dynamics.html
https://qutip.org/docs/4.6/guide/guide-dynamics.html:495,Integrability,depend,dependent,495,. Time Evolution and Quantum System Dynamics — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Bas,MatchSource.WIKI,docs/4.6/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-dynamics.html
https://qutip.org/docs/4.6/guide/guide-dynamics.html:1687,Integrability,depend,dependent,1687,"ng on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-dynamics.html
https://qutip.org/docs/4.6/guide/guide-dynamics.html:2168,Integrability,depend,dependent,2168,"ng on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-dynamics.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:1855,Availability,down,down,1855,"ining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. ",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:1886,Availability,down,down,1886,"ry; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:1979,Availability,down,down,1979," Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:2930,Availability,down,down,2930," spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator ",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:3173,Availability,down,down,3173,"gmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvecto",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:3337,Availability,down,down,3337,"rement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:3361,Availability,down,down,3361,"tself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement wil",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:3432,Availability,down,down,3432,"ne of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - ",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:3761,Availability,down,down,3761,"ment is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:3785,Availability,down,down,3785,"ment is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:4451,Availability,down,down,4451,"nd down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conven",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:4479,Availability,down,down,4479,"1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspace",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:5351,Availability,down,down,5351,"ill select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension \(1\). However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state \(\ket{0+}\); state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the ",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:5374,Availability,down,down,5374,"ill select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension \(1\). However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state \(\ket{0+}\); state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the ",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:11752,Deployability,update,updated,11752,"cond argument being a list of projectors.; Consider again, the state \(\ket{0+}\).; Suppose, now we want to obtain the measurement outcomes for the second qubit. We; must use the projectors specified earlier by PZ2 which allow us to measure only; on the second qubit. Since the second qubit has the state \(\ket{+}\), we get; the following result.; collapsed_states, probabilities = measurement_statistics(state_0plus, PZ2). print(collapsed_states). Output:; [Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]], Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]]. print(probabilities). Output:; [0.4999999999999999, 0.4999999999999999]. The function measurement_statistics then returns two values:. collapsed_states is an array of the possible final states after the; measurement is complete. Each element of the array is a Qobj.; probabilities is a list of the probabilities of each measurement outcome. Note that the collapsed_states are exactly \(\ket{00}\) and \(\ket{01}\); with equal probability, as expected. The two lists are in the same order. Note; When measurement_statistics; is invoked with the second argument; being a list of projectors, it acts as an alias to; measurement_statistics_povm. The measurement_statistics function can provide statistics for measurements; of density matrices too.; You can read about these and other details at; measurement_statistics_observable; and measurement_statistics_povm.; Furthermore, the measure_povm; and measurement_statistics_povm functions can; handle POVM measurements which are more general than projective measurements. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:1514,Performance,perform,perform,1514,"Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to pr",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:6752,Performance,perform,perform,6752,"lus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:7012,Performance,perform,perform,7012," \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we woul",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:8031,Performance,perform,perform,8031," What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we would have to perform the measurement many many times,; but in QuTiP we can peak at the state itself and determine the probability; distribution of the outcomes exactly in a single line:; >>> eigenvalues, eigenstates, probabilities = measurement_statistics(up, spin_x). >>> eigenvalues ; array([-1., 1.]). >>> eigenstates ; array([Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.70710678]; [-0.70710678]],; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]]], dtype=object). >>> probabilities ; [0.5000000000000001, 0.4999999999999999]. The measurement_statistics function then returns three values; when called with a single observable:. eigenvalues is an array of eigenvalues of the measurement operator, i.e.; a list of the possible measurement results. In our example; the value is array([-1., -1.]).; eigenstates is an array of the eigenstates of the measurement operator, i.e.; a list of the possible final states after the measurement is complete.; Each element of the array is a Qobj.; probab",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:1522,Usability,simpl,simple,1522,"Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to pr",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:5087,Usability,simpl,simply,5087,"he x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension \(1\). However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state \(\ket{0+}\); state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:6997,Usability,learn,learned,6997," \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we woul",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-measurement.html:7060,Usability,learn,learned,7060," \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we woul",MatchSource.WIKI,docs/4.6/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html
https://qutip.org/docs/4.6/guide/guide-overview.html:1693,Availability,avail,available,1693,"antum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-overview.html
https://qutip.org/docs/4.6/guide/guide-overview.html:2083,Deployability,update,updated,2083,"antum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-overview.html
https://qutip.org/docs/4.6/guide/guide-overview.html:1775,Security,access,accessible,1775,"antum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-overview.html
https://qutip.org/docs/4.6/guide/guide-overview.html:888,Usability,guid,guide,888,"﻿. Guide Overview — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Sh",MatchSource.WIKI,docs/4.6/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-overview.html
https://qutip.org/docs/4.6/guide/guide-overview.html:977,Usability,guid,guide,977,"TiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. L",MatchSource.WIKI,docs/4.6/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-overview.html
https://qutip.org/docs/4.6/guide/guide-overview.html:1189,Usability,guid,guide,1189,"antum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-overview.html
https://qutip.org/docs/4.6/guide/guide-parfor.html:6052,Deployability,configurat,configurations,6052,"rved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html
https://qutip.org/docs/4.6/guide/guide-parfor.html:6675,Deployability,update,updated,6675,"rved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html
https://qutip.org/docs/4.6/guide/guide-parfor.html:6343,Energy Efficiency,power,powerful,6343,"rved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html
https://qutip.org/docs/4.6/guide/guide-parfor.html:1547,Modifiability,variab,variables,1547,"ed parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; >>> result = parfor(func1, range(5)). >>> print(result); [ar",MatchSource.WIKI,docs/4.6/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html
https://qutip.org/docs/4.6/guide/guide-parfor.html:1596,Modifiability,variab,variables,1596,"ed parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; >>> result = parfor(func1, range(5)). >>> print(result); [ar",MatchSource.WIKI,docs/4.6/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html
https://qutip.org/docs/4.6/guide/guide-parfor.html:6052,Modifiability,config,configurations,6052,"rved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html
https://qutip.org/docs/4.6/guide/guide-parfor.html:1281,Performance,perform,performing,1281,"s and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.pa",MatchSource.WIKI,docs/4.6/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html
https://qutip.org/docs/4.6/guide/guide-parfor.html:1359,Performance,perform,performed,1359,"ime correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_",MatchSource.WIKI,docs/4.6/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html
https://qutip.org/docs/4.6/guide/guide-parfor.html:4623,Performance,perform,performance,4623,"ere the qutip.parallel.parallel_map and qutip.parallel.parfor functions behaves differently:; While qutip.parallel.parallel_map only iterate over the values arguments, the qutip.parallel.parfor function simultaneously iterates over all arguments:; >>> def sum_diff(x, y, z=0): return x + y, x - y, z. >>> parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5.0); [array([5, 7, 9]), array([-3, -3, -3]), array([5., 5., 5.])]. >>> parallel_map(sum_diff, [1, 2, 3], task_args=(np.array([4, 5, 6]),), task_kwargs=dict(z=5.0)); [(array([5, 6, 7]), array([-3, -4, -5]), 5.0),; (array([6, 7, 8]), array([-2, -3, -4]), 5.0),; (array([7, 8, 9]), array([-1, -2, -3]), 5.0)]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance. In qutip.parallel.parallel_map, keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:",MatchSource.WIKI,docs/4.6/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html
https://qutip.org/docs/4.6/guide/guide-parfor.html:2402,Safety,avoid,avoid,2402,"el.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; >>> result = parfor(func1, range(5)). >>> print(result); [array([0, 1, 2, 3, 4]), array([ 0, 1, 4, 9, 16]), array([ 0, 1, 8, 27, 64])]. >>> result = parallel_map(func1, range(5)). >>> print(result); [(0, 0, 0), (1, 1, 1), (2, 4, 8), (3, 9, 27), (4, 16, 64)]. The qutip.parallel.parallel_map and qutip.parallel.parfor functions are not limited to just numbers, but also works for a variety of outputs:; >>> def func2(x): return x, Qobj(x), 'a' * x. >>> a, b, c = parfor(func2, range(5)). >>> print(a); [0 1 2 3 4]. >>> print(b); [Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[1.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[2.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[3.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[4.",MatchSource.WIKI,docs/4.6/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html
https://qutip.org/docs/4.6/guide/guide-qip.html:1676,Deployability,update,updated,1676,". Quantum Information Processing — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-qip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-qip.html
https://qutip.org/docs/4.6/guide/guide-qip.html:1386,Energy Efficiency,schedul,scheduler,1386,". Quantum Information Processing — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-qip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-qip.html
https://qutip.org/docs/4.6/guide/guide-random.html:2694,Availability,down,down,2694,"6 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; -0.34240902+0.2879303j 0. +0.j ]]. Random Variable Type; Sampling Functions; Dimensions. State vector (ket); rand_ket, rand_ket_haar; \(N \times 1\). Hermitian operator (oper); rand_herm; \(N \times 1\). Density operator (oper); rand_dm, rand_dm_hs, rand_dm_ginibre; \(N \times N\). Unitary operator (oper); rand_unitary, rand_unitary_haar; \(N \times N\). CPTP channel (super); rand_super, rand_super_bcsz; \((N \times N) \times (N \times N)\). In all cases, these functions can be called with a single parameter \(N\) that specifies the dimension of the relevant Hilbert space. The optional; dims keyword argument allows for the dimensions of a random state, unitary or channel to be broken down into subsystems.; >>> rand_super_bcsz(7).dims; [[[7], [7]], [[7], [7]]]; >>> rand_super_bcsz(6, dims=[[[2, 3], [2, 3]], [[2, 3], [2, 3]]]).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. Several of the distributions supported by QuTiP support additional parameters as well, namely density and rank. In particular,; the rand_herm and rand_dm functions return quantum objects such that a fraction of the elements are identically equal to zero.; The ratio of nonzero elements is passed as the density keyword argument. By contrast, the rand_dm_ginibre and; rand_super_bcsz take as an argument the rank of the generated object, such that passing rank=1 returns a random; pure state or unitary channel, respectively. Passing rank=None specifies that the generated object should be; full-rank for the given dimension.; For example,; >>> rand_dm(5, density=0.5); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0.",MatchSource.WIKI,docs/4.6/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-random.html
https://qutip.org/docs/4.6/guide/guide-random.html:7667,Deployability,update,updated,7667,"0.81161447+2.02283642e-01j]; [ 0.81161447-2.02283642e-01j 1.375 +0.00000000e+00j; 0. +0.00000000e+00j -0.76700198+5.53011066e-01j; 0.375 +0.00000000e+00j]; [ 0. +0.00000000e+00j 0. +0.00000000e+00j; 2. +0.00000000e+00j 0. +0.00000000e+00j; 0. +0.00000000e+00j]; [ 0.875 -3.35634092e-01j -0.76700198-5.53011066e-01j; 0. +0.00000000e+00j 2.73612946+0.00000000e+00j; -0.76700198-5.53011066e-01j]; [ 0.81161447-2.02283642e-01j 0.375 +0.00000000e+00j; 0. +0.00000000e+00j -0.76700198+5.53011066e-01j; 1.375 +0.00000000e+00j]]. >>> H.eigenenergies() ; array([7.70647994e-17, 1.00000000e+00, 2.00000000e+00, 3.00000000e+00,; 4.00000000e+00]). In order to generate a random object with a given spectrum QuTiP applies a series of random complex Jacobi rotations. This technique requires many steps to build the desired quantum object, and is thus suitable only for objects with Hilbert dimensionality \(\lesssim 1000\). Composite random objects¶; In many cases, one is interested in generating random quantum objects that correspond to composite systems generated using the qutip.tensor.tensor function. Specifying the tensor structure of a quantum object is done using the dims keyword argument in the same fashion as one would do for a qutip.Qobj object:; >>> rand_dm(4, 0.5, dims=[[2,2], [2,2]]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 0.13622928+0.j 0. +0.j 0.01180807-0.01739166j; 0. +0.j ]; [ 0. +0.j 0.14600238+0.j 0.10335328+0.21790786j; -0.00426027-0.02193627j]; [ 0.01180807+0.01739166j 0.10335328-0.21790786j 0.57566072+0.j; -0.0670631 +0.04124094j]; [ 0. +0.j -0.00426027+0.02193627j -0.0670631 -0.04124094j; 0.14210761+0.j ]]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-random.html
https://qutip.org/docs/4.6/guide/guide-random.html:1162,Testability,test,testing,1162,"ion. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; >>> rand_herm(5) ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; -0.34240902+0.2879303j 0. +0.j ]]. Random Variable Type; Sampling Fu",MatchSource.WIKI,docs/4.6/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-random.html
https://qutip.org/docs/4.6/guide/guide-saving.html:8525,Deployability,update,updated,8525,"8632045+0.0000000000j,0.2143080535+0.0000000000j,-0.0067820038+0.0000000000j; 7.0707070707+0.0000000000j,1.3321818015+0.0000000000j,0.0950352763+0.0000000000j,-0.1630920429+0.0000000000j; 8.0808080808+0.0000000000j,1.2533244850+0.0000000000j,-0.0771210981+0.0000000000j,-0.1468923919+0.0000000000j. In this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=""real"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real""); >>> with open(""expect.dat"", ""r"") as f:; ... print('\n'.join(f.readlines()[:5])); # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the numformat=""exp"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; input_data = file_data_read('expect.dat'); plt.plot(input_data[:,0], input_data[:,1]); # plot the data. (png, hires.png, pdf). (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=""_"" if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:566,Performance,load,loading,566,"﻿. Saving QuTiP Objects and Data Sets — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename exte",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:601,Performance,load,loading,601,"﻿. Saving QuTiP Objects and Data Sets — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename exte",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:1469,Performance,perform,performed,1469,"l computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steady",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:1643,Performance,load,loading,1643,"ternal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; ",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:1680,Performance,load,load,1680,"ternal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; ",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:2103,Performance,load,loads,2103,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example ",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:2629,Performance,load,loaded,2629," qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:3057,Performance,load,load,3057,"tip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must ",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:3428,Performance,load,loaded,3428,"adystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and thre",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:3874,Performance,load,loading,3874,"ect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="","") . where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the ",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:4258,Performance,load,load,4258,"10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="","") . where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does; >>> a = dest",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:7930,Performance,load,loaded,7930,"8632045+0.0000000000j,0.2143080535+0.0000000000j,-0.0067820038+0.0000000000j; 7.0707070707+0.0000000000j,1.3321818015+0.0000000000j,0.0950352763+0.0000000000j,-0.1630920429+0.0000000000j; 8.0808080808+0.0000000000j,1.2533244850+0.0000000000j,-0.0771210981+0.0000000000j,-0.1468923919+0.0000000000j. In this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=""real"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real""); >>> with open(""expect.dat"", ""r"") as f:; ... print('\n'.join(f.readlines()[:5])); # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the numformat=""exp"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; input_data = file_data_read('expect.dat'); plt.plot(input_data[:,0], input_data[:,1]); # plot the data. (png, hires.png, pdf). (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=""_"" if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:2851,Testability,test,testing,2851,"e takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-saving.html:2205,Usability,simpl,simple,2205,"ad back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) *",MatchSource.WIKI,docs/4.6/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html
https://qutip.org/docs/4.6/guide/guide-settings.html:1435,Availability,toler,tolerance,1435,"re; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a ",MatchSource.WIKI,docs/4.6/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-settings.html
https://qutip.org/docs/4.6/guide/guide-settings.html:1877,Availability,toler,tolerance,1877,"Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possi",MatchSource.WIKI,docs/4.6/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-settings.html
https://qutip.org/docs/4.6/guide/guide-settings.html:3448,Deployability,update,updated,3448,"bug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-settings.html
https://qutip.org/docs/4.6/guide/guide-settings.html:3083,Integrability,depend,dependent,3083,"bug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-settings.html
https://qutip.org/docs/4.6/guide/guide-settings.html:2545,Performance,load,loaded,2545,"bug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-settings.html
https://qutip.org/docs/4.6/guide/guide-settings.html:1939,Usability,simpl,simple,1939,"ifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openm",MatchSource.WIKI,docs/4.6/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-settings.html
https://qutip.org/docs/4.6/guide/guide-settings.html:2717,Usability,simpl,simple,2717,"bug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-settings.html
https://qutip.org/docs/4.6/guide/guide-states.html:13653,Availability,down,downarrow,13653,". Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The qutip.operators.sigmap operator acting on the spin state returns the zero vector. Why is this? To see what happened, let us use the qutip.operators.sigmaz operator:; print(sigmaz()). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. spin2 = basis(2, 1). print(spin2). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. print(sigmaz() * spin2). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) sta",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:14346,Availability,down,downarrow,14346," The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:14612,Availability,down,downarrow,14612,"corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of ",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:16454,Availability,down,down,16454,", 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is ",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:16579,Availability,down,down,16579,"ity matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). ",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:33279,Deployability,update,updated,33279,"positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the dims and superrep attributes to reflect the; structure of the underlying Hilbert space and the chosen representation.; J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). Output:; False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, \(\Lambda(\rho) = (\Lambda(\rho))^\dagger\) for all \(\rho\) such that; \(\rho = \rho^\dagger\). To see this, we note that \((\rho^{\mathrm{T}})^\dagger; = \rho^*\), the complex conjugate of \(\rho\). By assumption, \(\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}\), though, such that \(\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*\).; We can confirm this by checking the ishp attribute:; print(J.ishp). Output:; True. Next, we note that the transpose map does preserve the trace of its inputs, such that; \(\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)\) for all \(\rho\).; This can be confirmed by the istp attribute:; print(J.istp). Output:; False. Finally, a map is called a quantum channel if it always maps valid states to valid; states. Formally, a map is a channel if it is both completely positive and trace preserving.; Thus, QuTiP provides a single attribute to quickly check that this is true.; >>> print(J.iscptp); False. >>> print(to_super(qeye(2)).iscptp); True. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:11480,Energy Efficiency,energy,energy,11480,"9080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the \(\left|1\right>\) state:; print(vac). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. c = create(2). print(c * vac). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator qutip.operators.sigmap. Operating on the spin state gives:; print(",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:3772,Integrability,depend,dependence,3772," =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; c = create(5). print(c * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; print(c * c * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; print(c ** 2 * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; print(c * a * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the \(\left| 1\right>\) state:; print(c * a * (c * vac)). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the \(\left| 2\right>\) state:; print(c * a * (c**2 * vac)). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; print(c * a * (c**2 * vac).unit()). Output:; Quant",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:19679,Modifiability,extend,extended,19679,"pace can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle\). Because; the Pauli basis is Hermitian, \(S_{\mu,\nu}\) is a real number for all Hermitian-preserving superoperators; \(S\),; allowing us to plot the elements of \(S\) as a Hinton diagra",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:1356,Performance,perform,performing,1356,"ors and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; a = destroy(5). print(a). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; print(a * vac). Output:; Quantum object: dims = [[5]",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:30509,Performance,perform,perform,30509,"+0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). Output:; (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space \(\mathcal{H}\). As with the superoperator; and Choi representations, the \(\chi\) representation is; denoted by the superrep, such that to_super,; to_choi, to_kraus,; to_stinespring and to_chi; all convert from the \(\chi\) representation appropriately. Properties of Quantum Maps¶; In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses superrep to automatically perform any needed conversions.; In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map \(\Lambda(\rho) = \rho^{\mathrm{T}}\) is a positive map. We run into; problems, however, if we tensor \(\Lambda\) with the identity to get a partial; transpose map.; rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). Output:; [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. ",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:19523,Security,expose,exposed,19523," Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \r",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:10325,Testability,test,testing,10325,"29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. print(thermal_dm(5, 1.25)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:;",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:10376,Testability,test,testing,10376,"2109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. print(thermal_dm(5, 1.25)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask ",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:10765,Testability,test,testing,10765,". ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.si",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:10930,Testability,assert,assert,10930,"o each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a ha",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:15174,Testability,test,testing,15174," the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values ",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:15225,Testability,test,testing,15225,"e underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect functio",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:15304,Testability,test,testing,15304,"ith the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the i",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:15421,Testability,test,testing,15421,"tion. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and o",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:16477,Testability,test,testing,16477,"98j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuT",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:16534,Testability,test,testing,16534,"ays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator fun",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:16842,Testability,test,testing,16842,"0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = ope",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:16901,Testability,test,testing,16901,"ple, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. rho2 = ve",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:17935,Testability,test,testing,17935,", two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The type attribute indicates whether a quantum object is; a vector corresponding to an operator (operator-ket), or its Hermitian; conjugate (operator-bra).; Note that QuTiP uses the column-stacking convention for the isomorphism; between \(\mathcal{L}(\mathcal{H})\) and \(\mathcal{H} \otimes \mathcal{H}\):; A = Qobj(np.arange(4).reshape((2, 2))). print(A). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. print(operator_to_vector(A)). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:19117,Testability,test,testing,19117,"jugate (operator-bra).; Note that QuTiP uses the column-stacking convention for the isomorphism; between \(\mathcal{L}(\mathcal{H})\) and \(\mathcal{H} \otimes \mathcal{H}\):; A = Qobj(np.arange(4).reshape((2, 2))). print(A). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. print(operator_to_vector(A)). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], sha",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:29752,Testability,test,testing,29752,").eigenenergies()). Output:; [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the \(\chi\)-matrix representation,. \[\Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,\]; where \(\{B_\alpha\}\) is a basis for the space of matrices acting; on \(\mathcal{H}\). In QuTiP, this basis is taken to be the Pauli; basis \(B_\alpha = \sigma_\alpha / \sqrt{2}\). Conversion to the; \(\chi\) formalism is handled by the to_chi; function.; chi = to_chi(S); print(chi). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). Output:; (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space \(\mathcal{H}\). As with the superoperator; and Choi representations, the \(\chi\) representation is; denoted by the superrep, such that to_super,; to_choi, to_kraus,; to_stinespring and to_chi; all convert from the \(\chi\) representation appropriately. Properties of Quantum Maps¶; In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses superrep to automatically perform any needed conversions.; In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map \(\Lambda(\rho) = \rho^{\math",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:1178,Usability,guid,guide,1178," Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; a = destroy(5). print(a). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0.",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:1333,Usability,guid,guide,1333,"ors and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; a = destroy(5). print(a). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; print(a * vac). Output:; Quantum object: dims = [[5]",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:7507,Usability,simpl,simplest,7507,"int(d * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. print(d * s * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in qutip.states.coherent function. Density matrices¶; One of the main purpose of QuTiP is to explore the dynamics of open quantum systems, where the most general state of a system is not longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures.; The simplest density matrix is created by forming the outer-product \(\left|\psi\right>\left<\psi\right|\) of a ket vector:; ket = basis(5, 2). print(ket * ket.dag()). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the qutip.states.fock_dm or qutip.states.ket2dm functions:; print(fock_dm(5, 2)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. print(ket2dm(ket)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the \(\left|2\right>\) or \(\left|4\right>\) number states we can do the following:; prin",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:22947,Usability,simpl,simply,22947,"\otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|].\]; In QuTiP, \(J(\Lambda)\) can be found by calling the to_choi; function on a type=""super"" Qobj.; X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. print(to_choi(spre(qeye(2)))). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a Qobj instance is already in the Choi superrep, then calling to_choi; does nothing:; print(to_choi(J)). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the to_super function.; As with to_choi, to_super is idempotent:; print(to_super(J) - S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. print(to_super(S)). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let \(\{A_i\}\) be a set of operators such that; \(J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|\).; We can write \(J(\Lambda)\) in this way; for any hermicity-preserving map; that is, for any map \(\Lambda\) such that \(J(\Lambda) = J^\dagger(\Lambda)\).; These operators then form the Kraus representation of \(\Lambda\). In particular, for any input \(\rho\),. \[\Lambda(\",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-states.html:31645,Usability,simpl,simply,31645,"spose map \(\Lambda(\rho) = \rho^{\mathrm{T}}\) is a positive map. We run into; problems, however, if we tensor \(\Lambda\) with the identity to get a partial; transpose map.; rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). Output:; [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the dims and superrep attributes to reflect the; structure of the underlying Hilbert space and the chosen representation.; J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). Output:; False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, \(\Lambda(\rho) = (\Lambda(\rho))^\dagger\) for all \(\rho\) such that; \(\rho = \rho^\dagger\). To see this, we note that \((\rho^{\mathrm{T}})^\dagger; = \rho^*\), the complex conjugate of \(\rho\). By assumption, \(\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}\), though, such that \(\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*\).; We can confirm this by checking the ishp attribute:; print(J.ishp). Output:; True. Next, we note that the transpose map does preserve the trace of its inputs, such that; \(\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)\) for all \(\rho\).; This can be confirmed by the istp attribute:; p",MatchSource.WIKI,docs/4.6/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html
https://qutip.org/docs/4.6/guide/guide-steady.html:5514,Availability,down,downside,5514,"n be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. QuTiP can make use of an incomplete LU preconditioner when using the iterative 'gmres', 'lgmres', and 'bicgstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the precond",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:6861,Availability,error,error,6861,"ate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. QuTiP can make use of an incomplete LU preconditioner when using the iterative 'gmres', 'lgmres', and 'bicgstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:7457,Availability,avail,available,7457,"gstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted ",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:11847,Deployability,update,updated,11847,"ate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = qutip.steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = qutip.expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = qutip.mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = qutip.mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); plt.axhline(y=fexpt, color='r', lw=1.5); plt.ylim([0, 10]); plt.xlabel('Time', fontsize=14); plt.ylabel('Number of excitations', fontsize=14); plt.legend(('Monte-Carlo', 'Master Equation', 'Steady State')); plt.title(; r'Decay of Fock state $\left|10\rangle\right.$'; r' in a thermal environment with $\langle n\rangle=2$'; ); plt.show(). (png, hires.png, pdf). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:2492,Energy Efficiency,power,power,2492,"-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:2524,Energy Efficiency,power,power,2524,"-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:3365,Energy Efficiency,power,power,3365,"teratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel Python distributions. This gives a substantial increase in performance compared with the standard SuperLU method used by SciPy. To verify that QuTiP can find the necessary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory nee",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:4630,Energy Efficiency,reduce,reduced,4630,"essary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these it",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:4932,Energy Efficiency,power,power,4932,"m with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditi",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:4969,Energy Efficiency,power,power,4969,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:5016,Energy Efficiency,power,power,5016,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:5154,Energy Efficiency,power,power,5154,"e solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:7579,Energy Efficiency,power,power,7579,"econditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a i",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:5090,Integrability,rout,routine,5090,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:10431,Modifiability,coupling,coupling,10431," decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = qutip.steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = qutip.expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = qutip.mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = qutip.mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); plt.axhline(y=fexpt, color='r', lw=1.5); plt.ylim([0, 10]); plt.xlabel('Time', fontsize=14); plt.ylabel('Number of excitations', fontsize=14); plt.legend(('Monte",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:3566,Performance,perform,performance,3566,"MRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel Python distributions. This gives a substantial increase in performance compared with the standard SuperLU method used by SciPy. To verify that QuTiP can find the necessary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) ",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:8802,Performance,perform,perform,8802,"ng factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) nu",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:10086,Performance,perform,perform,10086,"er number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = qutip.steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = qutip.expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = qutip.mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = qutip.mesolve(H, psi0, tlist, c_op_list, [a.d",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:1780,Usability,simpl,simple,1780,"tum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Solving for Steady-State Solutions. Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution v",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-steady.html:9609,Usability,simpl,simple,9609,"less explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay ope",MatchSource.WIKI,docs/4.6/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:3119,Availability,down,down,3119,"qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:; print(tensor(basis(2, 0), basis(2, 0))). Output:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the list format:; print(tensor([basis(2, 0), basis(2, 0)])). Output:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). Output:; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; print(tensor(sigmax(), sigmax())). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(si",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:13131,Deployability,update,updated,13131,", [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting one or more pairs of indices. As detailed in; the channel contraction tutorial, this can be used to find; superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from \(3 \times 3\) operators to \(2 \times 2\); operators:; >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:4598,Energy Efficiency,energy,energy,4598,"0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:4752,Energy Efficiency,energy,energy,4752,"only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:6156,Energy Efficiency,energy,energy,6156,"entity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; N = 10. omega_a = 1.0. omega_c = 1.25. g = 0.05. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). print(H). Output:; Quantum object: dims = [[2, 10], [2, 10]], shape = (20, 20), type = oper, isherm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 1.75 0. 0. 0. 0.; 0. 0. 0. 0. 0.05 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 3. 0. 0. 0.; 0. 0. 0. 0. 0. 0.07071068; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 4.25 0. 0.; 0. 0. 0. 0. 0. 0.; 0.08660254 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 5.5 0.; 0. 0. 0. 0. 0. 0.; 0. 0.1 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 6.75; 0. 0. 0. 0. 0. 0.; 0. 0. 0.1118034 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 8. 0. 0. 0. 0. 0.; 0. 0. 0. 0.12247449 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 9.",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:8311,Energy Efficiency,reduce,reduces,8311,"0. 0. 0. 0. 0. 0.14142136; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0. 11.75 0. 0.; 0. 0. 0. 0. 0. 0.; 0.15 0. ]; [ 0. 0.05 0. 0. 0. 0.; 0. 0. 0. 0. -0.5 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0.07071068 0. 0. 0.; 0. 0. 0. 0. 0. 0.75; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0.08660254 0. 0.; 0. 0. 0. 0. 0. 0.; 2. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0.1 0.; 0. 0. 0. 0. 0. 0.; 0. 3.25 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.1118034; 0. 0. 0. 0. 0. 0.; 0. 0. 4.5 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0.12247449 0. 0. 0. 0. 0.; 0. 0. 0. 5.75 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0.13228757 0. 0. 0. 0.; 0. 0. 0. 0. 7. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0.14142136 0. 0. 0.; 0. 0. 0. 0. 0. 8.25; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0.15 0. 0.; 0. 0. 0. 0. 0. 0.; 9.5 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 10.75 ]]. Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it takes one argument sel, which is a list of integers that mark the component systems that should be kept. All other components are traced out.; For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:; >>> psi = tensor(basis(2, 0), basis(2, 1)). >>> psi.ptrace(0); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. >>> psi.ptrace(1); Quantum object: dims = [[2], [2]], shape = (2, ",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:12509,Integrability,contract,contracting,12509,", [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting one or more pairs of indices. As detailed in; the channel contraction tutorial, this can be used to find; superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from \(3 \times 3\) operators to \(2 \times 2\); operators:; >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:12579,Integrability,contract,contraction,12579,", [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting one or more pairs of indices. As detailed in; the channel contraction tutorial, this can be used to find; superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from \(3 \times 3\) operators to \(2 \times 2\); operators:; >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:3217,Modifiability,extend,extended,3217,"ut:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the list format:; print(tensor([basis(2, 0), basis(2, 0)])). Output:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). Output:; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; print(tensor(sigmax(), sigmax())). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:6052,Modifiability,coupling,coupling,6052,"hape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; N = 10. omega_a = 1.0. omega_c = 1.25. g = 0.05. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). print(H). Output:; Quantum object: dims = [[2, 10], [2, 10]], shape = (20, 20), type = oper, isherm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 1.75 0. 0. 0. 0.; 0. 0. 0. 0. 0.05 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 3. 0. 0. 0.; 0. 0. 0. 0. 0. 0.07071068; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 4.25 0. 0.; 0. 0. 0. 0. 0. 0.; 0.08660254 0. 0. 0. 0. 0.; 0. 0. ]",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:11495,Performance,perform,performs,11495,"near operators.; Superoperators can be represented; using the isomorphism; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\) [Hav03], [Wat13].; To represent superoperators acting on \(\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)\) thus takes some tensor rearrangement to get the desired ordering; \(\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2\).; In particular, this means that qutip.tensor does not act as; one might expect on the results of qutip.to_super:; >>> A = qeye([2]). >>> B = qeye([3]). >>> to_super(tensor(A, B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting on",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:4473,Usability,simpl,simple,4473," two qubits:; print(tensor(sigmax(), sigmax())). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-tensor.html:5908,Usability,simpl,simplest,5908,"hape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; N = 10. omega_a = 1.0. omega_c = 1.25. g = 0.05. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). print(H). Output:; Quantum object: dims = [[2, 10], [2, 10]], shape = (20, 20), type = oper, isherm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 1.75 0. 0. 0. 0.; 0. 0. 0. 0. 0.05 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 3. 0. 0. 0.; 0. 0. 0. 0. 0. 0.07071068; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 4.25 0. 0.; 0. 0. 0. 0. 0. 0.; 0.08660254 0. 0. 0. 0. 0.; 0. 0. ]",MatchSource.WIKI,docs/4.6/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html
https://qutip.org/docs/4.6/guide/guide-visualization.html:11277,Availability,error,errors,11277,"or lbls in lbls_list]):; xlabels.append("""".join([lbls_list[k][inds[k]] for k in range(len(lbls_list))])). fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). ax.view_init(azim=-55, elev=45). plt.show(). (png, hires.png, pdf). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). hinton(rho_ss). plt.show(). (png, hires.png, pdf). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the m",MatchSource.WIKI,docs/4.6/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-visualization.html
https://qutip.org/docs/4.6/guide/guide-visualization.html:15854,Deployability,update,updated,15854,"seful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.qip.operations.iswap generates the unitary transformation for the state kets:; from qutip.qip.operations import iswap. U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2; op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; chi = qpt(U_rho, op_basis). fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). plt.show(). (png, hires.png, pdf). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-visualization.html
https://qutip.org/docs/4.6/guide/guide-visualization.html:8599,Energy Efficiency,efficient,efficient,8599,"ires.png, pdf). Husimi Q-function¶; The Husimi Q function is, like the Wigner function, a quasiprobability; distribution for harmonic modes. It is defined as. \[Q(\alpha) = \frac{1}{\pi}\left<\alpha|\rho|\alpha\right>\]; where \(\left|\alpha\right>\) is a coherent state and; \(\alpha = x + iy\). In QuTiP, the Husimi Q function can be computed given; a state ket or density matrix using the function qfunc, as; demonstrated below.; Q_coherent = qfunc(rho_coherent, xvec, xvec); Q_thermal = qfunc(rho_thermal, xvec, xvec); Q_fock = qfunc(rho_fock, xvec, xvec); fig, axes = plt.subplots(1, 3, figsize=(12,3)); cont0 = axes[0].contourf(xvec, xvec, Q_coherent, 100); lbl0 = axes[0].set_title(""Coherent state""); cont1 = axes[1].contourf(xvec, xvec, Q_thermal, 100); lbl1 = axes[1].set_title(""Thermal state""); cont0 = axes[2].contourf(xvec, xvec, Q_fock, 100); lbl2 = axes[2].set_title(""Fock state""); plt.show(). (png, hires.png, pdf). If you need to calculate the Q function for many states with the same; phase-space coordinates, it is more efficient to use the QFunc class.; This stores various intermediary results to achieve an order-of-magnitude; improvement compared to calling qfunc in a loop.; xs = np.linspace(-1, 1, 101); qfunc_calculator = qutip.QFunc(xs, xs); q_state1 = qfunc_calculator(qutip.rand_dm(5)); q_state2 = qfunc_calculator(qutip.rand_ket(100)). Visualizing operators¶; Sometimes, it may also be useful to directly visualizing the underlying matrix; representation of an operator. The density matrix, for example, is an operator; whose elements can give insights about the state it represents, but one might; also be interesting in plotting the matrix of an Hamiltonian to inspect the; structure and relative importance of various elements.; QuTiP offers a few functions for quickly visualizing matrix data in the; form of histograms, qutip.visualization.matrix_histogram and; qutip.visualization.matrix_histogram_complex, and as Hinton diagram of weighted; squares, qutip.visualiza",MatchSource.WIKI,docs/4.6/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-visualization.html
https://qutip.org/docs/4.6/guide/guide-visualization.html:15548,Integrability,depend,dependent,15548,"seful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.qip.operations.iswap generates the unitary transformation for the state kets:; from qutip.qip.operations import iswap. U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2; op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; chi = qpt(U_rho, op_basis). fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). plt.show(). (png, hires.png, pdf). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-visualization.html
https://qutip.org/docs/4.6/guide/guide-visualization.html:1660,Performance,perform,perform,1660,"on in QuTiP. Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,docs/4.6/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-visualization.html
https://qutip.org/docs/4.6/guide/guide-visualization.html:12620,Security,access,access,12620,"terpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the map as. (2)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger.\]; where \(\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*\) and \(A_i = \sum_{m} b_{im}B_{m}\). Here, matrix \(\chi\) is the transformation matrix we are after, since it describes how much \(B_m \rho_{\rm in} B_n^\dagger\) contributes to \(\rho_{\rm out}\).; In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. (1). Instead, what we usually can do is to calculate the propagator \(U\) for the density matrix in superoperator form, using for example the QuTiP function qutip.propagator.propagator. We can then write. \[\epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}\]; where \(\tilde{\rho}\) is the vector representation of the density matrix \(\rho\). If we write Eq. (2) in superoperator form as well we obtain. \[\tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}.\]; so we can identify. \[U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger.\]; Now this is a linear equation systems for the \(N^2 \times N^2\) elements in \(\chi\). We can solve it by writing \(\chi\) and the superoperator propagator as \([N^4]\) vectors, and likewise write the superoperator product \(\tilde{B}_m\tilde{B}_n^\dagger\) as a \([N^4\times N^4]\) matrix \(",MatchSource.WIKI,docs/4.6/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-visualization.html
https://qutip.org/docs/4.6/guide/guide.html:3522,Deployability,update,updated,3522,"t Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide.html
https://qutip.org/docs/4.6/guide/guide.html:1615,Integrability,depend,dependent,1615,"ing Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and p",MatchSource.WIKI,docs/4.6/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide.html
https://qutip.org/docs/4.6/guide/guide.html:2677,Performance,load,loading,2677,"t Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide.html
https://qutip.org/docs/4.6/guide/guide.html:2712,Performance,load,loading,2712,"t Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide.html
https://qutip.org/docs/4.6/modules/index.html:321,Availability,avail,available,321,. Overview: module code — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyr,MatchSource.WIKI,docs/4.6/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/index.html
https://qutip.org/docs/4.6/modules/index.html:2182,Deployability,update,updated,2182,"e code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/index.html
https://qutip.org/docs/4.6/modules/index.html:1349,Energy Efficiency,schedul,scheduler,1349,"e code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/index.html
https://qutip.org/docs/4.6/modules/index.html:489,Performance,optimiz,optimizer,489,. Overview: module code — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyr,MatchSource.WIKI,docs/4.6/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/index.html
https://qutip.org/docs/4.6/development/ideas/heom-gpu.html:2258,Deployability,update,updated,2258,"Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/heom-gpu.html
https://qutip.org/docs/4.6/development/ideas/heom-gpu.html:1308,Modifiability,extend,extend,1308," Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a",MatchSource.WIKI,docs/4.6/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/heom-gpu.html
https://qutip.org/docs/4.6/development/ideas/heom-gpu.html:1463,Modifiability,extend,extended,1463,"Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/heom-gpu.html
https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html:3784,Deployability,update,updated,3784,"es will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in qutip.qip.device and; qutip.qip.compiler. Skills¶. Git, Python and familiarity with the Python scientific computing stack; quantum information processing and quantum computing (quantum circuit formalism). Difficulty¶. Medium. Mentors¶. Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; McKay D C, Alexander T, Bello L, et al. Qiskit backend specifications for openqasm and openpulse experiments[J]. arXiv preprint arXiv:1809.03452, 2018. 2; Häffner H, Roos C F, Blatt R, Quantum computing with trapped ions, Physics reports, 2008, 469(4): 155-203. 3; Krantz P, Kjaergaard M, Yan F, et al. A quantum engineer’s guide to superconducting qubits, Applied Physics Reviews, 2019, 6(2): 021318. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html:2226,Integrability,depend,depend,2226,"20,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in qutip.qip.device and; qutip.qip.compiler. Skills¶. Git, Python and familiarity with the Python scientific computing stack; quantum information processing and quantum computing (quantum circuit formalism). Difficulty¶. Medium. Mentors¶. Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; McKay D C, Alexander T, Bello L, et al. Qiskit b",MatchSource.WIKI,docs/4.6/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html:947,Modifiability,enhance,enhance,947,"﻿. Pulse level description of quantum circuits — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse ",MatchSource.WIKI,docs/4.6/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html:1230,Modifiability,enhance,enhanced,1230,"P Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical sy",MatchSource.WIKI,docs/4.6/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html:1485,Modifiability,enhance,enhance,1485,"tion; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Ham",MatchSource.WIKI,docs/4.6/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html:1721,Usability,simpl,simple,1721,"l description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code c",MatchSource.WIKI,docs/4.6/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html:3501,Usability,guid,guide,3501,"es will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in qutip.qip.device and; qutip.qip.compiler. Skills¶. Git, Python and familiarity with the Python scientific computing stack; quantum information processing and quantum computing (quantum circuit formalism). Difficulty¶. Medium. Mentors¶. Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; McKay D C, Alexander T, Bello L, et al. Qiskit backend specifications for openqasm and openpulse experiments[J]. arXiv preprint arXiv:1809.03452, 2018. 2; Häffner H, Roos C F, Blatt R, Quantum computing with trapped ions, Physics reports, 2008, 469(4): 155-203. 3; Krantz P, Kjaergaard M, Yan F, et al. A quantum engineer’s guide to superconducting qubits, Applied Physics Reviews, 2019, 6(2): 021318. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:1665,Availability,error,error,1665,"thon. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python sci",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2088,Availability,error,error,2088,"classes are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Krista",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2358,Availability,error,error,2358,"n a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future appli",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2489,Availability,error,error,2489,"odels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:3355,Availability,error,error,3355," of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:878,Deployability,release,release,878,"﻿. Quantum Error Mitigation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pul",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:1528,Deployability,integrat,integration,1528,"ion of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation pro",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2247,Deployability,integrat,integrate,2247," simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2526,Deployability,integrat,integration,2526,"odels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:3866,Deployability,update,updated,3866," of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:1885,Energy Efficiency,schedul,schedule,1885,".qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (eta",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:3620,Energy Efficiency,schedul,schedule,3620," of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:1528,Integrability,integrat,integration,1528,"ion of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation pro",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2247,Integrability,integrat,integrate,2247," simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2506,Integrability,protocol,protocols,2506,"odels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2526,Integrability,integrat,integration,2526,"odels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:995,Modifiability,enhance,enhanced,995,"﻿. Quantum Error Mitigation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pul",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2350,Performance,perform,perform,2350,"n a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future appli",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2307,Safety,avoid,avoid,2307," simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,docs/4.6/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html:1660,Deployability,toggle,toggle,1660,"on. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills¶. Git, Python and familiarity with the Python scientific computing stack; elementary understanding of quantum dynamics. Difficulty¶. Variable. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Simon Cross (hodgestar@gm",MatchSource.WIKI,docs/4.6/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html:2936,Deployability,update,updated,2936,"l user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills¶. Git, Python and familiarity with the Python scientific computing stack; elementary understanding of quantum dynamics. Difficulty¶. Variable. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Simon Cross (hodgestar@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html:1044,Integrability,interface,interface,1044,"Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP cir",MatchSource.WIKI,docs/4.6/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html:1350,Modifiability,flexible,flexible,1350,"ctive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks int",MatchSource.WIKI,docs/4.6/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html:1911,Modifiability,config,configure,1911,"evel for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills¶. Git, Python and familiarity with the Python scientific computing stack; elementary understanding of quantum dynamics. Difficulty¶. Variable. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Simon Cross (hodgestar@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updat",MatchSource.WIKI,docs/4.6/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html:1112,Security,access,accessible,1112,"Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP cir",MatchSource.WIKI,docs/4.6/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html:914,Usability,simpl,simple,914,"﻿. QuTiP Interactive — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operat",MatchSource.WIKI,docs/4.6/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html:1191,Usability,learn,learners,1191,"; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processi",MatchSource.WIKI,docs/4.6/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:3416,Deployability,update,updated,3416," doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:1528,Energy Efficiency,efficient,efficiently,1528,"s. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; TensorFlow Data Backend. TensorFlow Data Backend¶. Contents. Why a TensorFlow backend?; Challenges. Expected outcomes; Skills; Difficulty; Mentors; References. QuTiP’s data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some i",MatchSource.WIKI,docs/4.6/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:2004,Energy Efficiency,efficient,efficiently,2004,"i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not requi",MatchSource.WIKI,docs/4.6/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:2094,Energy Efficiency,efficient,efficiently,2094,"itten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (ja",MatchSource.WIKI,docs/4.6/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:2329,Performance,perform,performance,2329,"es already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. Next ; Previous. © Co",MatchSource.WIKI,docs/4.6/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:2516,Testability,benchmark,benchmark,2516," doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:2628,Testability,benchmark,benchmark,2628," doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:2759,Testability,benchmark,benchmark,2759," doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.6/gallery/build/index.html:928,Deployability,update,updated,928,". Gallery — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery. Gallery¶; This is the gallery for QuTiP examples, you can click on the image to see the source code. Quantum Information Processing¶. Basic use of Processor¶. T2 Relaxation¶. Control Amplitude Noise¶. Download all examples in Python source code: build_python.zip. Download all examples in Jupyter notebooks: build_jupyter.zip. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/gallery/build/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/index.html
https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html:423,Availability,down,download,423,". Control Amplitude Noise — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f24ea6622b0>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.094 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li,",MatchSource.WIKI,docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html
https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html:2048,Deployability,update,updated,2048,"Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f24ea6622b0>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.094 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html
https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_intro_processor.html:421,Availability,down,download,421,". Basic use of Processor — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 1.187 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on F",MatchSource.WIKI,docs/4.6/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_intro_processor.html:731,Deployability,continuous,continuous,731,". Basic use of Processor — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 1.187 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on F",MatchSource.WIKI,docs/4.6/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_intro_processor.html:1989,Deployability,update,updated,1989,". 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 1.187 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_relaxation.html:403,Availability,down,download,403,". T2 Relaxation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.147 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross",MatchSource.WIKI,docs/4.6/gallery/build/qip/plot_qip_relaxation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_relaxation.html
https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_relaxation.html:2027,Deployability,update,updated,2027,"; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.147 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/gallery/build/qip/plot_qip_relaxation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_relaxation.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:2904,Availability,down,downside,2904,"es, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:3274,Availability,robust,robust,3274,"ten desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)¶\[ \frac{d}{dt}\rho_S(t) = - \hb",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:5484,Deployability,integrat,integration,5484,"ho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:18769,Deployability,update,updated,18769," 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). (png, hires.png, pdf). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:2138,Energy Efficiency,energy,energy,2138,"ime Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:2438,Energy Efficiency,power,power,2438,"ime Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:8197,Energy Efficiency,power,power,8197,"esponding the eigenstate \(\left|m\right>\), we obtain in matrix form in the Schrödinger picture. \[\begin{split}\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); -\hbar^{-2}; \sum_{\alpha,\beta}; \sum_{c,d}^{\rm sec}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)¶\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:8479,Energy Efficiency,energy,energy,8479," g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)¶\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\bet",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:9378,Energy Efficiency,power,power,9378,"u) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nest",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14613,Energy Efficiency,efficient,efficient,14613,"-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations preven",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14760,Energy Efficiency,efficient,efficient,14760,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Ha",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14918,Energy Efficiency,power,power,14918,"section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, s",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15302,Energy Efficiency,power,power,15302,"the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:17749,Energy Efficiency,power,power,17749,"appa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). (png, hires.png, pdf). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, a",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:484,Integrability,depend,dependent,484,"﻿. Bloch-Redfield master equation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, an",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:634,Integrability,depend,dependent,634,"﻿. Bloch-Redfield master equation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, an",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:4893,Integrability,depend,depends,4893," are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath deca",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:5434,Integrability,depend,dependence,5434,"; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:5484,Integrability,integrat,integration,5484,"ho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:13575,Integrability,depend,dependent,13575,"nd \(\sigma_z\) operators for the example above, we can use the following code:; tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). (png, hires.png, pdf). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:13689,Integrability,depend,dependent,13689,"e:; tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). (png, hires.png, pdf). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems th",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:13955,Integrability,depend,dependent,13955,"r_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). (png, hires.png, pdf). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14206,Integrability,depend,dependent,14206,"uments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14705,Integrability,depend,dependent,14705,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Ha",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14827,Integrability,depend,dependent,14827,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Ha",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14891,Integrability,depend,dependent,14891,"section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, s",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15049,Integrability,depend,dependent,15049,"aster equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponen",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15350,Integrability,depend,dependent,15350,"the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15624,Integrability,depend,dependent,15624,"l, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15674,Integrability,depend,dependent,15674,"elies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kap",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15875,Integrability,depend,dependent,15875,"such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:16159,Integrability,depend,dependent,16159,"rmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:17269,Integrability,depend,dependence,17269,"Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:17774,Integrability,depend,dependence,17774,"appa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). (png, hires.png, pdf). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, a",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:18489,Integrability,depend,dependent,18489," 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). (png, hires.png, pdf). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:2750,Modifiability,coupling,coupling,2750,"rators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Def",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:5470,Modifiability,extend,extending,5470,"ho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:10460,Modifiability,coupling,coupling,10460,"ectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nested list of operator \(A_\alpha\), spectral density functions \(S_\alpha(\omega)\) pairs that characterize the coupling between system and bath. The spectral density functions are Python callback functions that takes the (angular) frequency as a single argument.; To illustrate how to calculate the Bloch-Redfield tensor, let’s consider a two-level atom. (8)¶\[ H = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z\]; delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5. H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). def ohmic_spectrum(w):; if w == 0.0: # dephasing inducing noise; return gamma1; else: # relaxation inducing noise; return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, [[sigmax(), ohmic_spectrum]]). print(R). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j; 0.24514517+0.j ]; [ 0. +0.j -0.16103412-6.4076169j 0. +0.j; 0. +0.j ]; [ 0. +0.j 0. +0.j -0.16103412+6.4076169j;",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15890,Modifiability,coupling,coupling,15890,"such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:16269,Modifiability,coupling,coupling,16269,"nt, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this ti",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:16333,Modifiability,coupling,coupling,16333,"nto time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to a",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:16668,Modifiability,coupling,coupling,16668,"endent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:17055,Modifiability,coupling,coupling,17055,"(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) +",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:17636,Modifiability,coupling,coupling,17636,") * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). (png, hires.png, pdf). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 and later, P.D",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14460,Performance,scalab,scalability,14460," psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, exc",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15469,Safety,avoid,avoid,15469,"l, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:1928,Usability,clear,clear,1928,"ects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the result",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:9483,Usability,simpl,simplify,9483," =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nested list of operator \(A_\alpha\), spectral density functions \(S_\alpha(\omega)\) pairs that characterize the coupling between system and bath. The spectral density functions are Python callback functions that takes the (angular) frequency as a single ar",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:6182,Deployability,update,updated,6182,"pt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:563,Integrability,depend,dependent,563,". Dynamics Simulation Results — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. resu",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:2851,Security,access,access,2851,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:3898,Security,access,access,3898,"do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload f",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:4387,Security,access,accessed,4387,"om the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_res",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:2914,Usability,guid,guide,2914,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:3090,Usability,simpl,simply,3090," used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style index",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:4815,Usability,simpl,simplicity,4815,"using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_resul",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:1450,Deployability,integrat,integration,1450,"s with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:19063,Deployability,update,updated,19063,"H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_ref = output.expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'r--', tlist, 1-np.real(p_ex), 'b--'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). (png, hires.png, pdf). Alternatively, we can let the qutip.floquet.fmmesolve function transform the density matrix at each time step back to the computational basis, and calculating the expectation values for us, but using:; output = fmmesolve(H, psi0, tlist, [sigmax()], [num(2)], [noise_spectrum], T, args); p_ex = output.expect[0]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:1681,Energy Efficiency,efficient,efficiently,1681,"he Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:12476,Energy Efficiency,efficient,efficiently,12476,", f_coeff, t, H, T, args); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). (png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:12629,Energy Efficiency,efficient,efficiently,12629,"e; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). (png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:17216,Energy Efficiency,power,power,17216,"ccept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_ref = output.expect[0]. # plot the results; pyplot.plot(tlist,",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:471,Integrability,depend,dependent,471,"﻿. Floquet Formalism — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms sho",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:1336,Integrability,depend,dependent,1336,"d Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamil",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:1450,Integrability,integrat,integration,1450,"s with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:1516,Integrability,depend,dependent,1516,"s with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:2048,Integrability,depend,dependent,2048,"ternal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solu",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:2210,Integrability,depend,dependent,2210,"entation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. Accordi",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:2316,Integrability,depend,dependent,2316,"lism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:2622,Integrability,depend,dependent,2622,"ndependent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but o",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:2850,Integrability,depend,dependent,2850," Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wav",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:3054,Integrability,depend,dependence,3054,"stem with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wavefunction \(\Psi(t=0)\) in the Floquet states and immediately obtain the solution for arbitrary \(t\). (3)¶\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:4914,Integrability,depend,dependent,4914,"\). (3)¶\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where the coefficients \(c_\alpha\) are determined by the initial wavefunction \(\Psi(0) = \sum_\alpha c_\alpha \Psi_\alpha(0)\).; This formalism is useful for finding \(\Psi(t)\) for a given \(H(t)\) only if we can obtain the Floquet modes \(\Phi_a(t)\) and quasienergies \(\epsilon_\alpha\) more easily than directly solving (1). By substituting (2) into the Schrödinger equation (1) we obtain an eigenvalue equation for the Floquet modes and quasienergies. (4)¶\[ \mathcal{H}(t)\Phi_\alpha(t) = \epsilon_\alpha\Phi_\alpha(t),\]; where \(\mathcal{H}(t) = H(t) - i\hbar\partial_t\). This eigenvalue problem could be solved analytically or numerically, but in QuTiP we use an alternative approach for numerically finding the Floquet states and quasienergies [see e.g. Creffield et al., Phys. Rev. B 67, 165301 (2003)]. Consider the propagator for the time-dependent Schrödinger equation (1), which by definition satisfies. \[U(T+t,t)\Psi(t) = \Psi(T+t).\]; Inserting the Floquet states from (2) into this expression results in. \[U(T+t,t)\exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha(T+t)/\hbar)\Phi_\alpha(T+t),\]; or, since \(\Phi_\alpha(T+t)=\Phi_\alpha(t)\),. \[U(T+t,t)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha T/\hbar)\Phi_\alpha(t) = \eta_\alpha \Phi_\alpha(t),\]; which shows that the Floquet modes are eigenstates of the one-period propagator. We can therefore find the Floquet modes and quasienergies \(\epsilon_\alpha = -\hbar\arg(\eta_\alpha)/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet mod",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:6493,Integrability,depend,dependent,6493,")/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet modes yields. \[U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; so that \(\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)\). Since \(\Phi_\alpha(t)\) is periodic we only need to evaluate it for \(t \in [0, T]\), and from \(\Phi_\alpha(t \in [0,T])\) we can directly evaluate \(\Phi_\alpha(t)\), \(\Psi_\alpha(t)\) and \(\Psi(t)\) for arbitrary large \(t\). Floquet formalism in QuTiP¶; QuTiP provides a family of functions to calculate the Floquet modes and quasi energies, Floquet state decomposition, etc., given a time-dependent Hamiltonian on the callback format, list-string format and list-callback format (see, e.g., qutip.mesolve for details).; Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. (5)¶\[ H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z.\]; In QuTiP we can define this Hamiltonian as follows:; >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> A = 2.5 * 2*np.pi; >>> omega = 1.0 * 2*np.pi; >>> H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); >>> H1 = A/2.0 * sigmaz(); >>> args = {'w': omega}; >>> H = [H0, [H1, 'sin(w * t)']]. (png, hires.png, pdf). The \(t=0\) Floquet modes corresponding to the Hamiltonian (5) can then be calculated using the qutip.floquet.floquet_modes function, which returns lists containing the Floquet modes and the quasienergies; >>> T = 2*np.pi / omega; >>> f_modes_0, f_energies = floquet_modes(H, T, args); >>> f_energies ; array([-2.83131212, 2.83131212]); >>> f_modes_0 ; [Quantum object: dims = [[2",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:11105,Integrability,depend,dependent,11105,"(-0.645265993068382+0.7304552549315746j),; (0.15517002114250228-0.1612116102238258j)]. and given this decomposition of the initial state in the Floquet states we can easily evaluate the wavefunction that is the solution to (5) at an arbitrary time \(t\) using the function qutip.floquet.floquet_wavefunction_t; >>> t = 10 * np.random.rand(); >>> psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args). The following example illustrates how to use the functions introduced above to calculate and plot the time-evolution of (5).; import numpy as np; from matplotlib import pyplot. import qutip. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.5 * 2*np.pi; omega = 1.0 * 2*np.pi; T = (2*np.pi)/omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2, 0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmaz(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; psi_t = qutip.floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). (png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When eval",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:13145,Integrability,depend,dependent,13145,"ction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); psi_t = qutip.floquet_wavefunction(f_modes_t, f_energies, f_coeff, t); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:15004,Integrability,depend,dependent,15004,"tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). (png, hires.png, pdf). Note that the parameters and the Hamiltonian used in this example is not the same as in the previous section, and hence the different appearance of the resulting figure.; For convenience, all the steps described above for calculating the evolution of a quantum system using the Floquet formalisms are encapsulated in the function qutip.floquet.fsesolve. Using this function, we could have achieved the same results as in the examples above using; output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. Floquet theory for dissipative evolution¶; A driven system that is interacting with its environment is not necessarily well described by the standard Lindblad master equation, since its dissipation process could be time-dependent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:15613,Integrability,depend,dependent,15613,"above using; output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. Floquet theory for dissipative evolution¶; A driven system that is interacting with its environment is not necessarily well described by the standard Lindblad master equation, since its dissipation process could be time-dependent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. Th",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:17351,Integrability,depend,dependent,17351," implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_ref = output.expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'r--', tlist, 1-np.real(p_ex), 'b--'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); py",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:15969,Modifiability,coupling,coupling,15969,"pendent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:16252,Modifiability,coupling,coupling,16252,"he Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noi",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:16688,Modifiability,extend,extends,16688,"onment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, ar",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:14751,Deployability,update,updated,14751,"axation process (describing the dissipation of energy from the; spin to its environment), by adding np.sqrt(0.05) * sigmax() to; the previously empty list in the fourth parameter to the qutip.mesolve function:; >>> times = np.linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]); >>> fig, ax = plt.subplots(); >>> ax.plot(times, result.expect[0]) ; >>> ax.plot(times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . (png, hires.png, pdf). Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon Fock state, the dynamics is calculated with the lines following code; >>> times = np.linspace(0.0, 10.0, 200); >>> psi0 = tensor(fock(2,0), fock(10, 5)); >>> a = tensor(qeye(2), destroy(10)); >>> sm = tensor(destroy(2), qeye(10)); >>> H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); >>> result = mesolve(H, psi0, times, [np.sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm]); >>> plt.figure() ; >>> plt.plot(times, result.expect[0]) ; >>> plt.plot(times, result.expect[1]) ; >>> plt.xlabel('Time') ; >>> plt.ylabel('Expectation values') ; >>> plt.legend((""cavity photon number"", ""atom excitation probability"")) ; >>> plt.show() . (png, hires.png, pdf). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:2814,Energy Efficiency,efficient,efficient,2814,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 =",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:6501,Energy Efficiency,energy,energy,6501,"plots(); >>> ax.plot(result.times, result.expect[0]) ; >>> ax.plot(result.times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . (png, hires.png, pdf). If an empty list of operators is passed as fifth parameter, the qutip.mesolve function returns a qutip.solver.Result instance that contains a list of state vectors for the times specified in times; >>> times = [0.0, 1.0]; >>> result = mesolve(H, psi0, times, [], []); >>> result.states ; [Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]], Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.80901699+0.j ]; [0. -0.58778526j]]]. Non-unitary evolution¶; While the evolution of the state vector in a closed quantum system is deterministic, open quantum systems are stochastic in nature. The effect of an environment on the system of interest is to induce stochastic transitions between energy levels, and to introduce uncertainty in the phase difference between states of the system. The state of an open quantum system is therefore described in terms of ensemble averaged states using the density matrix formalism. A density matrix \(\rho\) describes a probability distribution of quantum states \(\left|\psi_n\right>\), in a matrix representation \(\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|\), where \(p_n\) is the classical probability that the system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:8273,Energy Efficiency,reduce,reduced,8273,"acting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires:",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:10320,Energy Efficiency,energy,energy,10320," not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; mast",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:10902,Energy Efficiency,energy,energy,10902,"med a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the same function (qutip.mesolve) is used for; evolution both according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems)",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:11115,Energy Efficiency,energy,energy,11115,"at elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the same function (qutip.mesolve) is used for; evolution both according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems) than using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation a",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:12899,Energy Efficiency,energy,energy,12899,"an using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes.; In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (c_ops) is passed as the fourth argument to the; qutip.mesolve function in order to define the dissipation processes in the master; equation. When the c_ops isn’t empty, the qutip.mesolve function will use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding np.sqrt(0.05) * sigmax() to; the previously empty list in the fourth parameter to the qutip.mesolve function:; >>> times = np.linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]); >>> fig, ax = plt.subplots(); >>> ax.plot(times, result.expect[0]) ; >>> ax.plot(times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . (png, hires.png, pdf). Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon Fock state, t",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:557,Integrability,depend,dependent,557,"﻿. Lindblad Master Equation Solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; wh",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:3319,Modifiability,evolve,evolves,3319,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 = basis(2, 0); >>> times = np.linspace(0.0, 10.0, 20); >>> result = sesolve(H, psi0, times, [sigmaz()]). The brackets in the fourth argument is an empty list of collapse operators, since we consider unitary evolution in this example. See the next section for examples on how dissipation is included by defining a list of collapse operators.; The function returns an instance of qutip.solver.Result, as described in the previous section Dynamics Simulation Results. The attribute expect in result is a list of expectation values for the operators that are included in the list in the fifth argument. Adding operators to this list results",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:2244,Performance,perform,perform,2244,"ter Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) u",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:7983,Performance,perform,perform,7983,"system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculati",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:8959,Performance,perform,perform,8959,"ystem, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that the state of the environment does not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a tim",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:2828,Security,access,accessible,2828,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 =",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:7958,Availability,error,errors,7958," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; ntraj = [1, 10, 100, 1000]. Keep in mind that the input ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:9598,Availability,avail,available,9598,"er 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; ntraj = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reu",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:9969,Availability,down,down,9969," = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qey",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:1566,Deployability,continuous,continuously,1566,"ng for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:10320,Deployability,configurat,configuration,10320,"data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:12262,Deployability,update,updated,12262,"s. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H, psi1, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], options=opts). plt.figure(); plt.plot(times, data1.expect[0], times, data1.expect[1], lw=2); plt.plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); plt.title('Monte Carlo time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). (png, hires.png, pdf). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:1579,Energy Efficiency,monitor,monitored,1579,"ng for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:6958,Energy Efficiency,efficient,efficient,6958,"pdf)¶. The advantage of the Monte Carlo method over the master equation approach is that only the state vector is required to be kept in the computers memory, as opposed to the entire density matrix. For large quantum system this becomes a significant advantage, and the Monte Carlo solver is therefore generally recommended for such systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins with random parameters and initial states takes almost 7 times longer using the master equation rather than Monte Carlo approach with the default number of trajectories running on a quad-CPU machine. Furthermore, it takes about 7 times the memory as well. However, for small systems, the added overhead of averaging a large number of stochastic trajectories to obtain the open system dynamics, as well as starting the multiprocessing functionality, outweighs the benefit of the minor (in this case) memory saving. Master equation methods are therefore generally more efficient when Hilbert space sizes are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:508,Integrability,depend,dependent,508,"﻿. Monte Carlo Solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse ope",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:11958,Integrability,depend,dependent,11958,"s. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H, psi1, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], options=opts). plt.figure(); plt.plot(times, data1.expect[0], times, data1.expect[1], lw=2); plt.plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); plt.title('Monte Carlo time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). (png, hires.png, pdf). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:12013,Integrability,depend,dependent,12013,"s. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H, psi1, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], options=opts). plt.figure(); plt.plot(times, data1.expect[0], times, data1.expect[1], lw=2); plt.plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); plt.title('Monte Carlo time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). (png, hires.png, pdf). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:10320,Modifiability,config,configuration,10320,"data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:5069,Performance,perform,performed,5069,"ystem at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r_2\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot(times, data.expect[0], times, data.expect[1]); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. The advantage of the Monte Carlo method over the mas",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:8270,Usability,simpl,simply,8270,"e, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; ntraj = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the a",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:9979,Usability,simpl,simpler,9979," = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qey",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:2188,Availability,toler,tolerance,2188,ystem Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state,MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:2228,Availability,toler,tolerance,2228,e Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the s,MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:4215,Availability,toler,tolerance,4215,"options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; print(options). Output:; Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_li",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:3295,Deployability,install,installed,3295,"options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:3957,Deployability,install,installed,3957,"rices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; print(options). Output:; Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new s",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:5666,Deployability,update,updated,5666,"ochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; print(options). Output:; Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:493,Integrability,depend,dependent,493,. Setting Options for the Dynamics Solvers — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: ,MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:3053,Integrability,depend,dependent,3053,hese properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_open,MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:4557,Modifiability,variab,variable,4557,"er of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; print(options). Output:; Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford,",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html:1414,Deployability,continuous,continuous,1414,"sults; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of t",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html:2485,Deployability,integrat,integrates,2485," system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html:4320,Deployability,update,updated,4320,"ight|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html:3188,Energy Efficiency,efficient,efficient,3188,"ability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html:513,Integrability,depend,dependent,513,". Stochastic Solver - Photocurrent — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html:2485,Integrability,integrat,integrates,2485," system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html:1492,Modifiability,evolve,evolve,1492,"lving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly int",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html:1583,Modifiability,evolve,evolve,1583,"iance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state accor",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html:2584,Modifiability,evolve,evolves,2584,"he system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html:3386,Modifiability,evolve,evolves,3386,"ight|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html:7732,Deployability,update,updated,7732,"; The GHZ-state density matrix in the Dicke (default) basis for N number of TLS. Collapse operators of the ensemble; Dicke.c_ops(); The collapse operators for the ensemble can be called by the c_ops method of the Dicke class. Note that the mathematical object representing the density matrix of the full system that is manipulated (or obtained from steadystate) in the Dicke-basis formalism used here is a representative of the density matrix. This representative object is of linear size N^2, whereas the full density matrix is defined over a 2^N Hilbert space. In order to calculate nonlinear functions of such density matrix, such as the Von Neumann entropy or the purity, it is necessary to take into account the degeneracy of each block of such block-diagonal density matrix. Note that as long as one calculates expected values of operators, being Tr[A*rho] a linear function of rho, the representative density matrix give straightforwardly the correct result. When a nonlinear function of the density matrix needs to be calculated, one needs to weigh each degenerate block correctly; this is taken care by the dicke_function_trace in qutip.piqs, and the user can use it to define general nonlinear functions that can be described as the trace of a Taylor expandable function. Two nonlinear functions that use dicke_function_trace and are already implemented are purity_dicke, to calculate the purity of a density matrix in the Dicke basis, and entropy_vn_dicke, which can be used to calculate the Von Neumann entropy.; More functions relative to the qutip.piqs module can be found at API documentation. Attributes to the qutip.piqs.Dicke and qutip.piqs.Pim class can also be found there. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html:478,Integrability,depend,dependent,478,"﻿. Permutational Invariance — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\do",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html:3189,Usability,simpl,simply,3189,"{2}\mathcal{L}_{J_{+}}[\rho]\\+\sum_{n=1}^{N}\left(; \frac{\gamma_\text{E}}{2}\mathcal{L}_{J_{-,n}}[\rho]; +\frac{\gamma_\text{D}}{2}\mathcal{L}_{J_{z,n}}[\rho]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right)\end{aligned}\end{align} \]; where \(J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}\) are SU(2) Pauli spin operators, with \({\alpha=x,y,z}\) and \(J_{\pm,n}=\sigma_{\pm,n}\). The collective spin operators are \(J_{\alpha} = \sum_{n}J_{\alpha,n}\) . The Lindblad super-operators are \(\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A\).; The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension \(4^N\). By exploiting the permutational invariance of identical particles [2-8], the Liouvillian \(\mathcal{D}_\text{TLS}(\rho)\) can be built as a block-diagonal matrix in the basis of Dicke states \(|j, m \rangle\).; The system under study is defined by creating an object of the; Dicke class, e.g. simply named; system, whose first attribute is. system.N, the number of TLSs of the system \(N\). The rates for collective and local processes are simply defined as. collective_emission defines \(\gamma_\text{CE}\), collective (superradiant) emission; collective_dephasing defines \(\gamma_\text{CD}\), collective dephasing; collective_pumping defines \(\gamma_\text{CP}\), collective pumping.; emission defines \(\gamma_\text{E}\), incoherent emission (losses); dephasing defines \(\gamma_\text{D}\), local dephasing; pumping defines \(\gamma_\text{P}\), incoherent pumping. Then the system.lindbladian() creates the total TLS Lindbladian superoperator matrix. Similarly, system.hamiltonian defines the TLS hamiltonian of the system \(H_\text{TLS}\).; The system’s Liouvillian can be built using system.liouvillian(). The properties of a Piqs object can be visualized by simply calling; system. We give two basic examples on the use of PIQS. In the first example the incoherent emission of N driven TLSs is considered.; fr",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html:3336,Usability,simpl,simply,3336,"\frac{\gamma_\text{D}}{2}\mathcal{L}_{J_{z,n}}[\rho]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right)\end{aligned}\end{align} \]; where \(J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}\) are SU(2) Pauli spin operators, with \({\alpha=x,y,z}\) and \(J_{\pm,n}=\sigma_{\pm,n}\). The collective spin operators are \(J_{\alpha} = \sum_{n}J_{\alpha,n}\) . The Lindblad super-operators are \(\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A\).; The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension \(4^N\). By exploiting the permutational invariance of identical particles [2-8], the Liouvillian \(\mathcal{D}_\text{TLS}(\rho)\) can be built as a block-diagonal matrix in the basis of Dicke states \(|j, m \rangle\).; The system under study is defined by creating an object of the; Dicke class, e.g. simply named; system, whose first attribute is. system.N, the number of TLSs of the system \(N\). The rates for collective and local processes are simply defined as. collective_emission defines \(\gamma_\text{CE}\), collective (superradiant) emission; collective_dephasing defines \(\gamma_\text{CD}\), collective dephasing; collective_pumping defines \(\gamma_\text{CP}\), collective pumping.; emission defines \(\gamma_\text{E}\), incoherent emission (losses); dephasing defines \(\gamma_\text{D}\), local dephasing; pumping defines \(\gamma_\text{P}\), incoherent pumping. Then the system.lindbladian() creates the total TLS Lindbladian superoperator matrix. Similarly, system.hamiltonian defines the TLS hamiltonian of the system \(H_\text{TLS}\).; The system’s Liouvillian can be built using system.liouvillian(). The properties of a Piqs object can be visualized by simply calling; system. We give two basic examples on the use of PIQS. In the first example the incoherent emission of N driven TLSs is considered.; from piqs import Dicke; from qutip import steadystate; N = 10; system = Dicke(N, emission = 1, pumping = 2); L",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html:4061,Usability,simpl,simply,4061,"gonal matrix in the basis of Dicke states \(|j, m \rangle\).; The system under study is defined by creating an object of the; Dicke class, e.g. simply named; system, whose first attribute is. system.N, the number of TLSs of the system \(N\). The rates for collective and local processes are simply defined as. collective_emission defines \(\gamma_\text{CE}\), collective (superradiant) emission; collective_dephasing defines \(\gamma_\text{CD}\), collective dephasing; collective_pumping defines \(\gamma_\text{CP}\), collective pumping.; emission defines \(\gamma_\text{E}\), incoherent emission (losses); dephasing defines \(\gamma_\text{D}\), local dephasing; pumping defines \(\gamma_\text{P}\), incoherent pumping. Then the system.lindbladian() creates the total TLS Lindbladian superoperator matrix. Similarly, system.hamiltonian defines the TLS hamiltonian of the system \(H_\text{TLS}\).; The system’s Liouvillian can be built using system.liouvillian(). The properties of a Piqs object can be visualized by simply calling; system. We give two basic examples on the use of PIQS. In the first example the incoherent emission of N driven TLSs is considered.; from piqs import Dicke; from qutip import steadystate; N = 10; system = Dicke(N, emission = 1, pumping = 2); L = system.liouvillian(); steady = steadystate(L). For more example of use, see the “Permutational Invariant Lindblad Dynamics” section in the tutorials section of the website, http://qutip.org/tutorials.html. Useful PIQS functions.¶. Operators; Command; Description. Collective spin algebra \(J_x,\ J_y,\ J_z\); jspin(N); The collective spin algebra \(J_x,\ J_y,\ J_z\) for \(N\) TLSs. Collective spin \(J_x\); jspin(N, ""x""); The collective spin operator \(Jx\). Requires \(N\) number of TLSs. Collective spin \(J_y\); jspin(N, ""y""); The collective spin operator \(J_y\). Requires \(N\) number of TLSs. Collective spin \(J_z\); jspin(N, ""z""); The collective spin operator \(J_z\). Requires \(N\) number of TLSs. Collective spi",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:5331,Availability,avail,available,5331,"re monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). (png, hires.png, pdf). For other",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:6428,Availability,avail,available,6428,"pecified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). (png, hires.png, pdf). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:1316,Deployability,continuous,continuous,1316,"onte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]). (2)¶\[d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) a",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:6735,Deployability,update,updated,6735,"pecified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). (png, hires.png, pdf). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:4335,Energy Efficiency,monitor,monitored,4335,"mulated by passing the arguments method='homodyne' or method='heterodyne' to qutip.stochastic.ssesolve.; Examples of how to solve the stochastic Schrodinger equation using QuTiP can be found in this development notebook. Stochastic Master Equation¶; When the initial state of the system is a density matrix \(\rho\), the stochastic master equation solver qutip.stochastic.smesolve must be used. The stochastic master equation is given by (see section 4.4, [Wis09]). (6)¶\[ d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passe",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:4955,Energy Efficiency,monitor,monitored,4955," A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; stor",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:532,Integrability,depend,dependent,532,"﻿. Stochastic Solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.genera",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:1357,Safety,detect,detection,1357,"onte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]). (2)¶\[d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) a",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:3273,Safety,detect,detections,3273,"ight) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) are the stochastic collapse operators, and \(e_n\) is. (3)¶\[e_n = \left<\psi(t)|S_n + S_n^\dagger|\psi(t)\right>\]; In QuTiP, this equation can be solved using the function qutip.stochastic.ssesolve, which is implemented by defining \(d_1\) and \(d_{2,n}\) from Equation (1) as. (4)¶\[d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),\]; and. (5)¶\[d_{2, n} = S_n - \frac{e_n}{2}.\]; The solver qutip.stochastic.ssesolve will construct the operators \(d_1\) and \(d_{2,n}\) once the user passes the Hamiltonian (H) and the stochastic operator list (sc_ops). As with the qutip.mcsolve, the number of trajectories and the seed for the noise realisation can be fixed using the arguments: ntraj and noise, respectively. If the user also requires the measurement output, the argument store_measurement=True should be included.; Additionally, homodyne and heterodyne detections can be easily simulated by passing the arguments method='homodyne' or method='heterodyne' to qutip.stochastic.ssesolve.; Examples of how to solve the stochastic Schrodinger equation using QuTiP can be found in this development notebook. Stochastic Master Equation¶; When the initial state of the system is a density matrix \(\rho\), the stochastic master equation solver qutip.stochastic.smesolve must be used. The stochastic master equation is given by (see section 4.4, [Wis09]). (6)¶\[ d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:4811,Safety,detect,detection,4811,"t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rh",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:4980,Safety,detect,detection,4980," A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; stor",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:6474,Safety,detect,detection,6474,"pecified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). (png, hires.png, pdf). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:6497,Safety,detect,detection,6497,"pecified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). (png, hires.png, pdf). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:6512,Usability,feedback,feedback,6512,"pecified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). (png, hires.png, pdf). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:14227,Availability,error,errors,14227,"oject; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. (png, hires.png, pdf). Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). (png, hires.png, pdf). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). (png, hires.png, pdf). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. To turn these data ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:16696,Availability,avail,available,16696,"d. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which bei",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:11467,Deployability,install,installed,11467,")**2). (png, hires.png, pdf). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). (png, hires.png, pdf). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). (png, hires.png, pdf). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:11551,Deployability,install,installing,11551,"rgs):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). (png, hires.png, pdf). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). (png, hires.png, pdf). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3,",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:16855,Deployability,update,updated,16855,"me-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; quti",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:22992,Deployability,update,updated,22992," = -delta / 2.0 * sx; H1 = [sz, '-eps / 2.0 + A / 2.0 * sin(w * t)']; H_td = [H0, H1]; Hargs = {'w': w, 'eps': eps_list[0], 'A': A_list[0]}. where the last code block sets up the problem using a string-based Hamiltonian, and Hargs is a dictionary of arguments to be passed into the Hamiltonian. In this example, we are going to use the qutip.propagator and qutip.propagator.propagator_steadystate to find expectation; values for different values of \(\epsilon\) and \(A\) in the; Hamiltonian \(H = -\frac{1}{2}\Delta\sigma_x -\frac{1}{2}\epsilon\sigma_z- \frac{1}{2}A\sin(\omega t)\).; We must now tell the qutip.mesolve function, that is called by qutip.propagator to reuse a; pre-generated Hamiltonian constructed using the qutip.rhs_generate command:; opts = Options(rhs_reuse=True); rhs_generate(H_td, c_ops, Hargs, name='lz_func'). Here, we have given the generated file a custom name lz_func, however this is not necessary as a generic name will automatically be given. Now we define the function task that is called by qutip.parallel.parfor with the m-index parallelized in loop over the elements of p_mat[m,n]:; def task(args):; m, eps = args; p_mat_m = np.zeros(len(A_list)); for n, A in enumerate(A_list):; # change args sent to solver, w is really a constant though.; Hargs = {'w': w, 'eps': eps,'A': A}; U = propagator(H_td, T, c_ops, Hargs, opts) #<- IMPORTANT LINE; rho_ss = propagator_steadystate(U); p_mat_m[n] = expect(sn, rho_ss); return [m, p_mat_m]. Notice the Options opts in the call to the qutip.propagator function. This is tells the qutip.mesolve function used in the propagator to call the pre-generated file lz_func. If this were missing then the routine would fail. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:3706,Energy Efficiency,efficient,efficient,3706,"ring] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:5138,Energy Efficiency,efficient,efficient,5138," or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficie",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:30,Integrability,depend,dependent,30,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:503,Integrability,depend,dependent,503,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:1568,Integrability,depend,dependent,1568,"s for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:1619,Integrability,depend,dependent,1619,"t Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: T",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:1878,Integrability,depend,dependence,1878," Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:2019,Integrability,depend,depend,2019," Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:2252,Integrability,depend,dependent,2252,"tors; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:2358,Integrability,depend,dependent,2358," Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:2488,Integrability,depend,dependent,2488,"de »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:2722,Integrability,depend,dependent,2722,"erators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:3252,Integrability,depend,dependence,3252,"olve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:3951,Integrability,depend,dependent,3951,"al and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:4081,Integrability,depend,dependent,4081,"ependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be use",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:5074,Integrability,depend,dependence,5074,"blems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:5276,Integrability,depend,dependent,5276,"nh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 i",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:5371,Integrability,depend,dependent,5371,"nh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 i",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:5458,Integrability,depend,dependent,5458,"ports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:5585,Integrability,depend,dependent,5585,"; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:5669,Integrability,depend,dependent,5669,"; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:5770,Integrability,depend,dependent,5770,"sing the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any o",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:6350,Integrability,depend,dependent,6350,"essed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:6524,Integrability,depend,dependent,6524,"n Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate;",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:6640,Integrability,depend,dependent,6640,"lapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.a",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:6697,Integrability,depend,dependent,6697,"a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(b",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:6869,Integrability,depend,dependent,6869,"o do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:6952,Integrability,depend,dependent,6952,"o do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:8112,Integrability,depend,dependent,8112,"ited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). (png, hires.png, pdf). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the ex",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:8184,Integrability,depend,dependent,8184,"und * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). (png, hires.png, pdf). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this exa",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:8461,Integrability,depend,dependents,8461,"e; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). (png, hires.png, pdf). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:9587,Integrability,depend,dependent,9587,"must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). (png, hires.png, pdf). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). (png, hires.png, pdf). or equivalently,; def H1_coeff(t, args):; A = args['A'",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:11592,Integrability,depend,dependent,11592,"ires.png, pdf). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). (png, hires.png, pdf). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), gr",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:11824,Integrability,depend,dependent,11824,"well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). (png, hires.png, pdf). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:12139,Integrability,depend,dependent,12139,"() * a], args={'A': 9, 'sigma': 5}). (png, hires.png, pdf). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:12332,Integrability,depend,dependent,12332,"mes, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:13509,Integrability,depend,dependent,13509,"ited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. (png, hires.png, pdf). Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). (png, hires.png, pdf). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). (png, hires.png, pdf). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:14483,Integrability,depend,dependent,14483,"me-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. (png, hires.png, pdf). Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). (png, hires.png, pdf). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). (png, hires.png, pdf). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubi",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:14719,Integrability,depend,dependent,14719,"sed format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). (png, hires.png, pdf). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). (png, hires.png, pdf). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). (png, hires.png, pdf). Note that, at present, only equally spaced real or complex dat",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:15834,Integrability,depend,dependent,15834,"tion class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). (png, hires.png, pdf). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the ar",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:16266,Integrability,depend,dependent,16266,"Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). (png, hires.png, pdf). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:16549,Integrability,depend,dependent,16549,"a, 'o'); plt.plot(t, S(t), lw=2); plt.show(). (png, hires.png, pdf). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{t",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:16714,Integrability,depend,dependent,16714,"d. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which bei",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:18066,Integrability,depend,dependent,18066,"ix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Prob",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:19306,Integrability,depend,dependent,19306," reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:19439,Integrability,depend,dependent,19439,"for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists and a new one should not be generated. As an example, we will look at the Landau-Zener-Stuckelberg interferometry example that can be found in th",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:20460,Integrability,depend,dependent,20460,"ms inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists and a new one should not be generated. As an example, we will look at the Landau-Zener-Stuckelberg interferometry example that can be found in the notebook “Time-dependent master equation: Landau-Zener-Stuckelberg inteferometry” in the tutorials section of the QuTiP web site.; To set up the problem, we run the following code:; delta = 0.1 * 2 * np.pi # qubit sigma_x coefficient; w = 2.0 * 2 * np.pi # driving frequency; T = 2 * np.pi / w # driving period; gamma1 = 0.00001 # relaxation rate; gamma2 = 0.005 # dephasing rate. eps_list = np.linspace(-10.0, 10.0, 51) * 2 * np.pi # epsilon; A_list = np.linspace(0.0, 20.0, 51) * 2 * np.pi # Amplitude. sx = sigmax(); sz = sigmaz(); sm = destroy(2); sn = num(2). c_ops = [np.sqrt(gamma1) * sm, np.sqrt(gamma2) * sz] # relaxation and dephasing; H0 = -delta / 2.0 * sx; H1 = [sz, '-eps / 2.0 + A / 2.0 * sin(w * t)']; H_td = [H0, H1]; Hargs = {'w': w, 'eps': eps_list[0], 'A': A_list[0]}. where the last code block sets up the problem using a string-based Hamiltonian, and Hargs is a dictionary of arguments to be passed into the Hamiltonian. In this example, we are going to use the qutip.propagator and qutip",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:22767,Integrability,rout,routine,22767," = -delta / 2.0 * sx; H1 = [sz, '-eps / 2.0 + A / 2.0 * sin(w * t)']; H_td = [H0, H1]; Hargs = {'w': w, 'eps': eps_list[0], 'A': A_list[0]}. where the last code block sets up the problem using a string-based Hamiltonian, and Hargs is a dictionary of arguments to be passed into the Hamiltonian. In this example, we are going to use the qutip.propagator and qutip.propagator.propagator_steadystate to find expectation; values for different values of \(\epsilon\) and \(A\) in the; Hamiltonian \(H = -\frac{1}{2}\Delta\sigma_x -\frac{1}{2}\epsilon\sigma_z- \frac{1}{2}A\sin(\omega t)\).; We must now tell the qutip.mesolve function, that is called by qutip.propagator to reuse a; pre-generated Hamiltonian constructed using the qutip.rhs_generate command:; opts = Options(rhs_reuse=True); rhs_generate(H_td, c_ops, Hargs, name='lz_func'). Here, we have given the generated file a custom name lz_func, however this is not necessary as a generic name will automatically be given. Now we define the function task that is called by qutip.parallel.parfor with the m-index parallelized in loop over the elements of p_mat[m,n]:; def task(args):; m, eps = args; p_mat_m = np.zeros(len(A_list)); for n, A in enumerate(A_list):; # change args sent to solver, w is really a constant though.; Hargs = {'w': w, 'eps': eps,'A': A}; U = propagator(H_td, T, c_ops, Hargs, opts) #<- IMPORTANT LINE; rho_ss = propagator_steadystate(U); p_mat_m[n] = expect(sn, rho_ss); return [m, p_mat_m]. Notice the Options opts in the call to the qutip.propagator function. This is tells the qutip.mesolve function used in the propagator to call the pre-generated file lz_func. If this were missing then the routine would fail. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:1954,Modifiability,coupling,coupling,1954," Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:7976,Modifiability,coupling,coupling,7976,"(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). (png, hires.png, pdf). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:8591,Modifiability,variab,variables,8591,"mma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). (png, hires.png, pdf). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial sta",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:9739,Modifiability,variab,variable,9739,", psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). (png, hires.png, pdf). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). (png, hires.png, pdf). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). (png, hires.png, pdf). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:9798,Modifiability,variab,variables,9798,", psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). (png, hires.png, pdf). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). (png, hires.png, pdf). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). (png, hires.png, pdf). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:10399,Modifiability,variab,variable,10399," def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). (png, hires.png, pdf). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). (png, hires.png, pdf). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). (png, hires.png, pdf). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). (png, hires.png, pdf). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Mo",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:10949,Modifiability,variab,variables,10949,"his is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). (png, hires.png, pdf). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). (png, hires.png, pdf). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). (png, hires.png, pdf). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse op",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:13373,Modifiability,coupling,coupling,13373,"g would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. (png, hires.png, pdf). Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). (png, hires.png, pdf). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). (png, hires.png, pdf). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Paramet",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:13885,Modifiability,variab,variable,13885,"tio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. (png, hires.png, pdf). Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). (png, hires.png, pdf). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). (png, hires.png, pdf). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:13940,Modifiability,rewrite,rewrite,13940,"tio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. (png, hires.png, pdf). Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). (png, hires.png, pdf). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). (png, hires.png, pdf). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:14188,Modifiability,variab,variables,14188,"r(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. (png, hires.png, pdf). Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). (png, hires.png, pdf). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). (png, hires.png, pdf). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). (png, hires.",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:18076,Modifiability,variab,variables,18076,"ix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Prob",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:18186,Safety,avoid,avoid,18186,"ix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Prob",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:4349,Testability,log,log,4349,"ependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be use",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:17792,Testability,test,tests,17792,"gument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qu",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:8337,Usability,simpl,simply,8337,"e(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. (png, hires.png, pdf). Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). (png, hires.png, pdf). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa ",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:9287,Usability,simpl,simple,9287,"efficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). (png, hires.png, pdf). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). (png, hires.png, pdf). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly wr",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:9508,Usability,simpl,simple,9508,"must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). (png, hires.png, pdf). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). (png, hires.png, pdf). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). (png, hires.png, pdf). or equivalently,; def H1_coeff(t, args):; A = args['A'",MatchSource.WIKI,docs/4.6/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:1925,Availability,avail,available,1925,"ement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name, target qubits and arguments.; Gates can also be controlled on a classical bit by specifying the register number; with the argument classical_controls.; Measurements: We can also carry out measurements on individual qubit (both in the middle and at the end of the circuit).; Each measurement is saved as a class object Measurement with parameters such as targets,; the target qubit on which the measurement will be carried out, and classical_store,; the index of the classical register which stores the result of the measurement. A circuit with the various gates and registers available is demonstrated below:; from qutip.qip.circuit import QubitCircuit, Gate; from qutip import tensor, basis. qc = QubitCircuit(N=2, num_cbits=1); swap_gate = Gate(name=""SWAP"", targets=[0, 1]). qc.add_gate(swap_gate); qc.a",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:2636,Availability,avail,available,2636,"ircuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name, target qubits and arguments.; Gates can also be controlled on a classical bit by specifying the register number; with the argument classical_controls.; Measurements: We can also carry out measurements on individual qubit (both in the middle and at the end of the circuit).; Each measurement is saved as a class object Measurement with parameters such as targets,; the target qubit on which the measurement will be carried out, and classical_store,; the index of the classical register which stores the result of the measurement. A circuit with the various gates and registers available is demonstrated below:; from qutip.qip.circuit import QubitCircuit, Gate; from qutip import tensor, basis. qc = QubitCircuit(N=2, num_cbits=1); swap_gate = Gate(name=""SWAP"", targets=[0, 1]). qc.add_gate(swap_gate); qc.add_measurement(""M0"", targets=[1], classical_store=0) # measurement gate; qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""X"", targets=0, classical_controls=[0]) # classically controlled gate; qc.add_gate(swap_gate). print(qc.gates). Output:; [Gate(SWAP, targets=[0, 1], controls=None, classical controls=None, control_value=None),; Measurement(M0, target=[1], classical_store=0),; Gate(CNOT, targets=[1], controls=[0], classical controls=None, control_value=None),; Gate(X, targets=[0], controls=None, classical controls=[0], control_value=None),; Gate(SWAP, targets=[0, 1], controls=None, classical controls=None, control_value=None)]. Unitaries¶; There are a few useful functions associated with the circuit object. For example,; the propagators method returns",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:9484,Availability,down,download,9484,"+0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exa",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:9287,Deployability,install,installed,9287,"shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1. +0.j 0. +0.j 0. +0.j; 0. +0.j ]; [0. +0.j 0.70710678+0.j 0. +0.j; 0. -0.70710678j]; [0. +0.j 0. +0.j 1. +0.j; 0. +0.j ]; [0. +0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:9320,Deployability,install,install,9320,"shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1. +0.j 0. +0.j 0. +0.j; 0. +0.j ]; [0. +0.j 0.70710678+0.j 0. +0.j; 0. -0.70710678j]; [0. +0.j 0. +0.j 1. +0.j; 0. +0.j ]; [0. +0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:9358,Deployability,install,installed,9358,"shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1. +0.j 0. +0.j 0. +0.j; 0. +0.j ]; [0. +0.j 0.70710678+0.j 0. +0.j; 0. -0.70710678j]; [0. +0.j 0. +0.j 1. +0.j; 0. +0.j ]; [0. +0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:9399,Deployability,install,installation,9399,"710678+0.j 0. +0.j; 0. -0.70710678j]; [0. +0.j 0. +0.j 1. +0.j; 0. +0.j ]; [0. +0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application ",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:9497,Deployability,install,install,9497,"+0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exa",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:9517,Deployability,install,installer,9517,"+0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exa",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:9702,Deployability,install,installed,9702,"]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different me",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:11208,Deployability,update,updated,11208,"mand conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different method of circuit simulation employs driving Hamiltonians with the ability to; simulate circuits in the presence of noise. This can be achieved through the various classes; in device.A short guide to processors for QIP simulation can be found at Pulse-level circuit simulation. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:6766,Energy Efficiency,reduce,reduced,6766,"tation around x axis. “CRY”; Controlled rotation around y axis. “CRZ”; Controlled rotation around z axis. “CX”; Controlled X gate. “CY”; Controlled Y gate. “CZ”; Controlled Z gate. “CS”; Controlled S gate. “CT”; Controlled T gate. “CPHASE”; Controlled phase gate. “CNOT”; Controlled NOT gate. “CSIGN”; Same as CPHASE. “QASMU”; U rotation gate used as a primitive in the QASM standard. “BERKELEY”; Berkeley gate. “SWAPalpha”; SWAPalpha gate. “SWAP”; Swap the states of two qubits. “ISWAP”; Swap gate with additional phase for 01 and 10 states. “SQRTSWAP”; Square root of the SWAP gate. “SQRTISWAP”; Square root of the ISWAP gate. “FREDKIN”; Fredkin gate. “TOFFOLI”; Toffoli gate. “GLOBALPHASE”; Global phase. For some of the gates listed above, QubitCircuit also has a primitive resolve_gates method that decomposes them into elementary gate sets such as CNOT or SWAP with single-qubit gates (RX, RY and RZ). However, this method is not fully optimized. It is very likely that the depth of the circuit can be further reduced by merging quantum gates. It is required that the gate resolution be carried out before the measurements to the circuit are added.; Custom Gates; In addition to these pre-defined gates, QuTiP also allows the user to define their own gate.; The following example shows how to define a customized gate.; The key step is to define a; gate function returning a qutip.Qobj and save it in the attribute user_gates.; from qutip.qip.circuit import Gate; from qutip.qip.operations import rx. def user_gate1(arg_value):; # controlled rotation X; mat = np.zeros((4, 4), dtype=np.complex); mat[0, 0] = mat[1, 1] = 1.; mat[2:4, 2:4] = rx(arg_value); return Qobj(mat, dims=[[2, 2], [2, 2]]). def user_gate2():; # S gate; mat = np.array([[1., 0],; [0., 1.j]]); return Qobj(mat, dims=[[2], [2]]). qc = QubitCircuit(2); qc.user_gates = {""CTRLRX"": user_gate1,; ""S"" : user_gate2}. # qubit 0 controls qubit 1; qc.add_gate(""CTRLRX"", targets=[0,1], arg_value=np.pi/2). # qubit 1 controls qubit 0; qc",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:9604,Integrability,depend,dependency,9604,"= [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exa",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:9685,Integrability,depend,dependencies,9685,"]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different me",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:6692,Performance,optimiz,optimized,6692,"rd gate. “PHASEGATE”; Add a phase one the state 1. “CRX”; Controlled rotation around x axis. “CRY”; Controlled rotation around y axis. “CRZ”; Controlled rotation around z axis. “CX”; Controlled X gate. “CY”; Controlled Y gate. “CZ”; Controlled Z gate. “CS”; Controlled S gate. “CT”; Controlled T gate. “CPHASE”; Controlled phase gate. “CNOT”; Controlled NOT gate. “CSIGN”; Same as CPHASE. “QASMU”; U rotation gate used as a primitive in the QASM standard. “BERKELEY”; Berkeley gate. “SWAPalpha”; SWAPalpha gate. “SWAP”; Swap the states of two qubits. “ISWAP”; Swap gate with additional phase for 01 and 10 states. “SQRTSWAP”; Square root of the SWAP gate. “SQRTISWAP”; Square root of the ISWAP gate. “FREDKIN”; Fredkin gate. “TOFFOLI”; Toffoli gate. “GLOBALPHASE”; Global phase. For some of the gates listed above, QubitCircuit also has a primitive resolve_gates method that decomposes them into elementary gate sets such as CNOT or SWAP with single-qubit gates (RX, RY and RZ). However, this method is not fully optimized. It is very likely that the depth of the circuit can be further reduced by merging quantum gates. It is required that the gate resolution be carried out before the measurements to the circuit are added.; Custom Gates; In addition to these pre-defined gates, QuTiP also allows the user to define their own gate.; The following example shows how to define a customized gate.; The key step is to define a; gate function returning a qutip.Qobj and save it in the attribute user_gates.; from qutip.qip.circuit import Gate; from qutip.qip.operations import rx. def user_gate1(arg_value):; # controlled rotation X; mat = np.zeros((4, 4), dtype=np.complex); mat[0, 0] = mat[1, 1] = 1.; mat[2:4, 2:4] = rx(arg_value); return Qobj(mat, dims=[[2, 2], [2, 2]]). def user_gate2():; # S gate; mat = np.array([[1., 0],; [0., 1.j]]); return Qobj(mat, dims=[[2], [2]]). qc = QubitCircuit(2); qc.user_gates = {""CTRLRX"": user_gate1,; ""S"" : user_gate2}. # qubit 0 controls qubit 1; qc.add_gate(""CTR",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:1269,Usability,simpl,simple,1269,"; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name, target qubits and arguments.; Gates can also be controlled on a classical bit by specifying the register number; with the argument classical_controls.; Measurements: We can a",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:10577,Usability,guid,guide,10577,"mand conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different method of circuit simulation employs driving Hamiltonians with the ability to; simulate circuits in the presence of noise. This can be achieved through the various classes; in device.A short guide to processors for QIP simulation can be found at Pulse-level circuit simulation. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-basics.html:10916,Usability,guid,guide,10916,"mand conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different method of circuit simulation employs driving Hamiltonians with the ability to; simulate circuits in the presence of noise. This can be achieved through the various classes; in device.A short guide to processors for QIP simulation can be found at Pulse-level circuit simulation. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:4568,Availability,avail,available,4568,"ferent physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrice",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:4831,Availability,avail,available,4831," find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will become very inefficient.; In the following we describe the predefined subclasses for Processor:",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:8557,Availability,avail,available,8557,"e device parameters including the cavity frequency, qubits frequency, detuning and interaction strength etc. Note; The run_state method of DispersiveCavityQED; returns the full simulation result of the solver,; hence including the cavity.; To obtain the circuit result, one needs to first trace out the cavity state. OptPulseProcessor; The OptPulseProcessor uses the function in optimize_pulse_unitary in the optimal control module to find the control pulses. The Hamiltonian includes a drift part and a control part and only the control part will be optimized. The unitary evolution follows. \[U(\Delta t)=\exp(\rm{i} \cdot \Delta t [H_d + \sum_j u_j H_j] )\]; To let it find the optimal pulses, we need to give the parameters for optimize_pulse_unitary as keyword arguments to load_circuit. Usually, the minimal requirements are the evolution time evo_time and the number of time slices num_tslots for each gate. Other parameters can also be given in the keyword arguments. For available choices, see optimize_pulse_unitary. It is also possible to specify different parameters for different gates, as shown in the following example:; from qutip.qip.device import OptPulseProcessor; from qutip.operators import sigmaz, sigmax, sigmay; from qutip.tensor import tensor. # Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). # Different parameters for different gates; qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigma",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13896,Availability,error,errors,13896,"eats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude dam",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:14268,Availability,error,error,14268,"gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compar",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:14434,Availability,error,error,14434,"shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:14496,Availability,error,error,14496,"he qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the r",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:14543,Availability,error,error,14543,"he qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the r",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:14586,Availability,error,error,14586,"he qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the r",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:14673,Availability,error,error,14673,"n be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the real experiment and, therefore, more convenient in some cases, such as when coherent noise or correlated noise exist. For ins",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:3158,Deployability,continuous,continuous,3158,"nction or with cubic spline. For step function, tlist specifies the start and the end of each pulse and thus is one element longer the coeffs. One example of defining the control pulse coefficients and the time array is as follows:; import numpy as np; from qutip import sigmaz; from qutip.qip.device import Processor. processor = Processor(2); processor.add_control(sigmaz(), cyclic_permutation=True) # sigmaz for all qubits; processor.pulses[0].coeffs = np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); processor.pulses[0].tlist = np.array([0.1, 0.2, 0.4, 0.5]). It defines a \(\sigma_z\) operator on both qubits and a pulse that acts on the first qubit.; An equivalent approach is using the add_pulse method.; from qutip.qip.pulse import Pulse. processor = Processor(2); coeff=np.array([0.1, 0.2, 0.4, 0.5]); tlist=np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); pulse = Pulse(sigmaz(), targets=0, coeff=coeff, tlist=tlist); processor.add_pulse(pulse). One can also use choose the pulse_mode attribute of Processor; between ""discrete"" and ""continuous"". Note; If the coefficients represent dicrete pulse, the length of each array is 1 element shorter than tlist. If it is supposed to be a continuous function, the length should be the same as tlist. The above example shows the framework and the most essential part of the simulator’s API. So far, it looks like just a wrapper for the open system solvers. However, based on this, we can implement different physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case wher",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:3306,Deployability,continuous,continuous,3306,"the time array is as follows:; import numpy as np; from qutip import sigmaz; from qutip.qip.device import Processor. processor = Processor(2); processor.add_control(sigmaz(), cyclic_permutation=True) # sigmaz for all qubits; processor.pulses[0].coeffs = np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); processor.pulses[0].tlist = np.array([0.1, 0.2, 0.4, 0.5]). It defines a \(\sigma_z\) operator on both qubits and a pulse that acts on the first qubit.; An equivalent approach is using the add_pulse method.; from qutip.qip.pulse import Pulse. processor = Processor(2); coeff=np.array([0.1, 0.2, 0.4, 0.5]); tlist=np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); pulse = Pulse(sigmaz(), targets=0, coeff=coeff, tlist=tlist); processor.add_pulse(pulse). One can also use choose the pulse_mode attribute of Processor; between ""discrete"" and ""continuous"". Note; If the coefficients represent dicrete pulse, the length of each array is 1 element shorter than tlist. If it is supposed to be a continuous function, the length should be the same as tlist. The above example shows the framework and the most essential part of the simulator’s API. So far, it looks like just a wrapper for the open system solvers. However, based on this, we can implement different physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED mode",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:14456,Deployability,continuous,continuous-time,14456,"shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:20877,Deployability,update,updated,20877,"andom.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at http://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:818,Energy Efficiency,schedul,scheduler,818,"﻿. Pulse-level circuit simulation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Pulse-level circuit simulation. Pulse-level circuit simulation¶. Modelling quantum hardware with Processor¶; Based on the open system solver, Processor in the qutip.qip module simulates quantum circuits at the level of time evolution. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented.; The procedure is illustrated in the figure below.; It first compiles circuit into a Hamiltonian model, adds noisy dynamics and then uses the QuTiP open time evolution solvers to simulation the evolution. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution is then computed. A control pulse is characterized by Pulse, consisting of the control Hamilt",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:9849,Energy Efficiency,schedul,scheduler,9849," Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). # Different parameters for different gates; qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigmay(), sigmay()])). setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. tlist, coeffs = processor.load_circuit(; qc, setting_args=setting_args, merge_gates=False). Compiler and scheduler¶. Note; New in QuTiP 4.6. In order to simulate quantum circuits at the level of time evolution.; We need to first compile the circuit into the Hamiltonian model, i.e.; the control pulses.; Hence each Processor has a corresponding; GateCompiler class.; The compiler takes a QubitCircuit; and returns the compiled tlist and coeffs.; It is called implicitly when calling the method; run_state.; from qutip.qip.compiler import SpinChainCompiler; qc = QubitCircuit(2); qc.add_gate(""X"", targets=0); qc.add_gate(""X"", targets=1). processor = LinearSpinChain(2); compiler = SpinChainCompiler(; 2, params=processor.params, pulse_dict=processor.pulse_dict); resolved_qc = qc.resolve_gates([""RX"", ""RZ"", ""ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:11474,Energy Efficiency,schedul,scheduler,11474,"piler(; 2, params=processor.params, pulse_dict=processor.pulse_dict); resolved_qc = qc.resolve_gates([""RX"", ""RZ"", ""ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain ` model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end no",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:11515,Energy Efficiency,schedul,scheduler,11515,"WAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain ` model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:11625,Energy Efficiency,schedul,schedules,11625,"rray([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain ` model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorith",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:11842,Energy Efficiency,schedul,scheduler,11842,"rdware parameters of the SpinChain ` model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; f",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:12536,Energy Efficiency,schedul,schedule,12536," the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.G",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:12819,Energy Efficiency,schedul,scheduling,12819,"truction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carri",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13250,Energy Efficiency,schedul,scheduler,13250," by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13290,Energy Efficiency,schedul,scheduler,13290," by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13300,Energy Efficiency,schedul,schedule,13300,"l gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the pr",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13407,Energy Efficiency,schedul,scheduling,13407," to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way t",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13473,Energy Efficiency,schedul,schedule,13473,"ast step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added ",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13486,Energy Efficiency,schedul,scheduling,13486,"ast step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added ",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:20447,Energy Efficiency,schedul,schedule,20447,"andom.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at http://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:3486,Integrability,wrap,wrapper,3486,"gmaz(), cyclic_permutation=True) # sigmaz for all qubits; processor.pulses[0].coeffs = np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); processor.pulses[0].tlist = np.array([0.1, 0.2, 0.4, 0.5]). It defines a \(\sigma_z\) operator on both qubits and a pulse that acts on the first qubit.; An equivalent approach is using the add_pulse method.; from qutip.qip.pulse import Pulse. processor = Processor(2); coeff=np.array([0.1, 0.2, 0.4, 0.5]); tlist=np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); pulse = Pulse(sigmaz(), targets=0, coeff=coeff, tlist=tlist); processor.add_pulse(pulse). One can also use choose the pulse_mode attribute of Processor; between ""discrete"" and ""continuous"". Note; If the coefficients represent dicrete pulse, the length of each array is 1 element shorter than tlist. If it is supposed to be a continuous function, the length should be the same as tlist. The above example shows the framework and the most essential part of the simulator’s API. So far, it looks like just a wrapper for the open system solvers. However, based on this, we can implement different physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:4888,Integrability,depend,dependent,4888," find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will become very inefficient.; In the following we describe the predefined subclasses for Processor:",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:11884,Integrability,depend,dependency,11884,"rdware parameters of the SpinChain ` model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; f",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:12067,Integrability,depend,dependent,12067," to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) ",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:12230,Integrability,depend,dependency,12230,"h the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13546,Integrability,wrap,wrap,13546,"ast step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added ",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:19671,Integrability,rout,routines,19671,"N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at http://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then b",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:20161,Integrability,depend,dependent,20161,"andom.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at http://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:20180,Integrability,depend,dependent,20180,"andom.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at http://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:8128,Performance,optimiz,optimized,8128,"rocessor.load_circuit(qc); fig, axis = processor.plot_pulses(); fig.show(). (png, hires.png, pdf). DispersiveCavityQED; Same as above, DispersiveCavityQED is a simulator based on Cavity Quantum Electrodynamics. The workflow is similar to the one for the spin chain, except that the component systems are a multi-level cavity and a qubits system. The control Hamiltonians are the single-qubit rotation together with the qubits-cavity interaction \(a^{\dagger} \sigma^{-} + a \sigma^{+}\). The device parameters including the cavity frequency, qubits frequency, detuning and interaction strength etc. Note; The run_state method of DispersiveCavityQED; returns the full simulation result of the solver,; hence including the cavity.; To obtain the circuit result, one needs to first trace out the cavity state. OptPulseProcessor; The OptPulseProcessor uses the function in optimize_pulse_unitary in the optimal control module to find the control pulses. The Hamiltonian includes a drift part and a control part and only the control part will be optimized. The unitary evolution follows. \[U(\Delta t)=\exp(\rm{i} \cdot \Delta t [H_d + \sum_j u_j H_j] )\]; To let it find the optimal pulses, we need to give the parameters for optimize_pulse_unitary as keyword arguments to load_circuit. Usually, the minimal requirements are the evolution time evo_time and the number of time slices num_tslots for each gate. Other parameters can also be given in the keyword arguments. For available choices, see optimize_pulse_unitary. It is also possible to specify different parameters for different gates, as shown in the following example:; from qutip.qip.device import OptPulseProcessor; from qutip.operators import sigmaz, sigmax, sigmay; from qutip.tensor import tensor. # Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keywor",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:20339,Performance,load,loading,20339,"andom.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at http://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:4752,Testability,log,logic,4752,"persiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will bec",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:6307,Usability,simpl,simple,6307,"perators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will become very inefficient.; In the following we describe the predefined subclasses for Processor:; SpinChain; LinearSpinChain and CircularSpinChain are quantum computing models base on the spin chain realization. The control Hamiltonians are \(\sigma_x\), \(\sigma_z\) and \(\sigma_x \sigma_x + \sigma_y \sigma_y\). This processor will first decompose the gate into the universal gate set with ISWAP or SQRTISWAP as two-qubit gates, resolve them into quantum gates of adjacent qubits and then calculate the pulse coefficients.; An example of simulating a simple circuit is shown below:; from qutip import basis; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device import LinearSpinChain. qc = QubitCircuit(2); qc.add_gate(""X"", targets=0); qc.add_gate(""X"", targets=1); processor = LinearSpinChain(2); processor.load_circuit(qc); result = processor.run_state(basis([2,2], [0,0])); print(result.states[-1].tidyup(1.0e-6)). Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [-1.]]. We can also visualize the pulses implementing this circuit:; from qutip import basis; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device import LinearSpinChain. qc = QubitCircuit(2); qc.add_gate(""X"", targets=0); qc.add_gate(""X"", targets=1); processor = LinearSpinChain(2); processor.load_circuit(qc); fig, axis = processor.plot_pulses(); fig.show(). (png, hires.png, pdf). DispersiveCavityQED; Same as above, DispersiveCavityQED is a simulator based on Cavity Quantum Electrodynamics. The workflow is similar to th",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:16761,Usability,simpl,simplest,16761,"ecrease. It is not always easy or even possible to define a noisy gate matrix. In our simulator, it can be done by defining a ControlAmpNoise (Control Amplitude Noise).; In the simulation, noise can be added to the processor at different levels:. The decoherence time T1 and T2 can be defined for the processor or for each qubit. When calculating the evolution, the corresponding collapse operators will be added automatically to the solver.; The noise of the physical parameters (e.g. detuned frequency) can be simulated by changing the parameters in the model, e.g. laser frequency in cavity QED. (This can only be time-independent since QuTiP open system solver only allows varying coefficients, not varying Hamiltonian operators.); The noise of the pulse intensity can be simulated by modifying the coefficients of the Hamiltonian operators or even adding new Hamiltonians. To add noise to a processor, one needs to first define a noise object Noise. The simplest relaxation noise can be defined directly in the processor with relaxation time. Other pre-defined noise can be found as subclasses of Noise. We can add noise to the simulator with the method add_noise.; Below, we show two examples.; The first example is a processor with one qubit under rotation around the z-axis and relaxation time \(T_2=5\). We measure the population of the \(\left| + \right\rangle\) state and observe the Ramsey signal:; import numpy as np; import matplotlib.pyplot as plt; from qutip import sigmaz, destroy, basis; from qutip.qip.device import Processor; from qutip.qip.operations import snot. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length ",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-processor.html:19686,Usability,guid,guide,19686,"lses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at http://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 and later, P.D.",MatchSource.WIKI,docs/4.6/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html
https://qutip.org/docs/4.6/guide/qip/qip-simulator.html:10263,Deployability,update,updated,10263,"targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0); qc.add_measurement(""M0"", targets=[0], classical_store=0); qc.add_measurement(""M0"", targets=[1], classical_store=0); qc.add_measurement(""M0"", targets=[2], classical_store=0); sim = CircuitSimulator(qc, mode=""density_matrix_simulator""); print(sim.run(zero_state).get_final_states()[0]). Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0.33333257 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0.33333257 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0.33333486 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]]. We are left with a mixed state. Import and export quantum circuits¶; QuTiP supports importation and exportation of quantum circuit in the OpenQASM 2 format; through the functions read_qasm and save_qasm.; We demonstrate this using the w-state generation circuit.; The following code is in OpenQASM format:; // Name of Experiment: W-state v1. OPENQASM 2.0;; include ""qelib1.inc"";. qreg q[4];; creg c[3];; gate cH a,b {; h b;; sdg b;; cx a,b;; h b;; t b;; cx a,b;; t b;; h b;; s b;; x b;; s a;; }. u3(1.91063,0,0) q[0];; cH q[0],q[1];; ccx q[0],q[1],q[2];; x q[0];; x q[1];; cx q[0],q[1];. measure q[0] -> c[0];; measure q[1] -> c[1];; measure q[2] -> c[2];. One can save it in a .qasm file and import it using the following code:; from qutip.qip.qasm import read_qasm; qc = read_qasm(""guide/qip/w-state.qasm""). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html
https://qutip.org/docs/4.6/guide/qip/qip-simulator.html:7299,Energy Efficiency,efficient,efficient,7299,"y=True). print(sim.ops). [Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = False; Qobj data =; [[ 0. 0.57734961 0. -0.57734961 0. 0.40824922; 0. -0.40824922]; [ 0.57734961 0. -0.57734961 0. 0.40824922 0.; -0.40824922 0. ]; [ 0.57734961 0. 0.57734961 0. 0.40824922 0.; 0.40824922 0. ]; [ 0. 0.57734961 0. 0.57734961 0. 0.40824922; 0. 0.40824922]; [ 0.57735159 0. 0. 0. -0.81649565 0.; 0. 0. ]; [ 0. 0.57735159 0. 0. 0. -0.81649565; 0. 0. ]; [ 0. 0. 0.57735159 0. 0. 0.; -0.81649565 0. ]; [ 0. 0. 0. 0.57735159 0. 0.; 0. -0.81649565]],; Measurement(M0, target=[0], classical_store=0),; Measurement(M1, target=[1], classical_store=1),; Measurement(M2, target=[2], classical_store=2)]. Here, sim.ops stores all the circuit operations that are going to be applied during; state evolution. As observed above, all the unitaries of the circuit are compressed into; a single unitary product with the precompute optimization enabled.; This is more efficient if one runs the same circuit one multiple initial states.; However, as the number of qubits increases, this will consume more and more memory; and become unfeasible. Density Matrix Simulation¶; By default, the state evolution is carried out in the “state_vector_simulator” mode; (specified by the mode argument) as described before.; In the “density_matrix_simulator” mode, the input state can be either a ket or a density; matrix. If it is a ket, it is converted into a density matrix before the evolution is; carried out. Unlike the “state_vector_simulator” mode, upon measurement, the state; does not collapse to one of the post-measurement states. Rather, the new state is now; the density matrix representing the ensemble of post-measurement states.; In this sense, we measure the qubits and forget all the results.; To demonstrate this consider the original W-state preparation circuit which is followed; just by measurement on the first qubit:; qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": cont",MatchSource.WIKI,docs/4.6/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html
https://qutip.org/docs/4.6/guide/qip/qip-simulator.html:7263,Performance,optimiz,optimization,7263,"putes the product of the unitaries (in between the measurements):; sim = CircuitSimulator(qc, precompute_unitary=True). print(sim.ops). [Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = False; Qobj data =; [[ 0. 0.57734961 0. -0.57734961 0. 0.40824922; 0. -0.40824922]; [ 0.57734961 0. -0.57734961 0. 0.40824922 0.; -0.40824922 0. ]; [ 0.57734961 0. 0.57734961 0. 0.40824922 0.; 0.40824922 0. ]; [ 0. 0.57734961 0. 0.57734961 0. 0.40824922; 0. 0.40824922]; [ 0.57735159 0. 0. 0. -0.81649565 0.; 0. 0. ]; [ 0. 0.57735159 0. 0. 0. -0.81649565; 0. 0. ]; [ 0. 0. 0.57735159 0. 0. 0.; -0.81649565 0. ]; [ 0. 0. 0. 0.57735159 0. 0.; 0. -0.81649565]],; Measurement(M0, target=[0], classical_store=0),; Measurement(M1, target=[1], classical_store=1),; Measurement(M2, target=[2], classical_store=2)]. Here, sim.ops stores all the circuit operations that are going to be applied during; state evolution. As observed above, all the unitaries of the circuit are compressed into; a single unitary product with the precompute optimization enabled.; This is more efficient if one runs the same circuit one multiple initial states.; However, as the number of qubits increases, this will consume more and more memory; and become unfeasible. Density Matrix Simulation¶; By default, the state evolution is carried out in the “state_vector_simulator” mode; (specified by the mode argument) as described before.; In the “density_matrix_simulator” mode, the input state can be either a ket or a density; matrix. If it is a ket, it is converted into a density matrix before the evolution is; carried out. Unlike the “state_vector_simulator” mode, upon measurement, the state; does not collapse to one of the post-measurement states. Rather, the new state is now; the density matrix representing the ensemble of post-measurement states.; In this sense, we measure the qubits and forget all the results.; To demonstrate this consider the original W-state preparation circuit which is foll",MatchSource.WIKI,docs/4.6/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html
https://qutip.org/docs/4.6/guide/qip/qip-simulator.html:1255,Usability,simpl,simple,1255,"tial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Operator-level circuit simulation. Operator-level circuit simulation¶. Note; New in QuTiP 4.6. Run a quantum circuit¶; Let’s start off by defining a simple circuit which we use to demonstrate a few; examples of circuit evolution.; We take a circuit from OpenQASM 2; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.operations import controlled_gate, hadamard_transform; def controlled_hadamard():; # Controlled Hadamard; return controlled_gate(; hadamard_transform(1), 2, control=0, target=1, control_value=1); qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0). It corresponds to the following circuit:. We will add the measurement gates later. This circuit prepares the W-state \((\ket{001} + \ket{010} + \ket{100})/\sqrt{3}\).; The simplest way to carry out state evolution through a quantum circuit is; providing a input state to the run; method.; from q",MatchSource.WIKI,docs/4.6/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html
https://qutip.org/docs/4.6/guide/qip/qip-simulator.html:2145,Usability,simpl,simplest,2145,". Run a quantum circuit¶; Let’s start off by defining a simple circuit which we use to demonstrate a few; examples of circuit evolution.; We take a circuit from OpenQASM 2; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.operations import controlled_gate, hadamard_transform; def controlled_hadamard():; # Controlled Hadamard; return controlled_gate(; hadamard_transform(1), 2, control=0, target=1, control_value=1); qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0). It corresponds to the following circuit:. We will add the measurement gates later. This circuit prepares the W-state \((\ket{001} + \ket{010} + \ket{100})/\sqrt{3}\).; The simplest way to carry out state evolution through a quantum circuit is; providing a input state to the run; method.; from qutip import tensor; zero_state = tensor(basis(2, 0), basis(2, 0), basis(2, 0)); result = qc.run(state=zero_state); wstate = result. print(wstate). Output:; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0. ]; [0.57734961]; [0.57734961]; [0. ]; [0.57735159]; [0. ]; [0. ]; [0. ]]. As expected, the state returned is indeed the required W-state.; As soon as we introduce measurements into the circuit, it can lead to multiple outcomes; with associated probabilities. We can also carry out circuit evolution in a manner such that it returns all the possible state; outputs along with their corresponding probabilities. Suppose, in the previous circuit,; we measure each of the three qubits at the end.; qc.add_measurement(""M0"", targets=[0], classical_store=0); qc.add_measurement(""M1"", targets=[1], classical_store=1); qc.add_measurement(""M2"", targets=[2], classical_store=2). To get all the ",MatchSource.WIKI,docs/4.6/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html
https://qutip.org/docs/4.6/guide/qip/qip-simulator.html:10032,Usability,guid,guide,10032,"targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0); qc.add_measurement(""M0"", targets=[0], classical_store=0); qc.add_measurement(""M0"", targets=[1], classical_store=0); qc.add_measurement(""M0"", targets=[2], classical_store=0); sim = CircuitSimulator(qc, mode=""density_matrix_simulator""); print(sim.run(zero_state).get_final_states()[0]). Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0.33333257 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0.33333257 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0.33333486 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]]. We are left with a mixed state. Import and export quantum circuits¶; QuTiP supports importation and exportation of quantum circuit in the OpenQASM 2 format; through the functions read_qasm and save_qasm.; We demonstrate this using the w-state generation circuit.; The following code is in OpenQASM format:; // Name of Experiment: W-state v1. OPENQASM 2.0;; include ""qelib1.inc"";. qreg q[4];; creg c[3];; gate cH a,b {; h b;; sdg b;; cx a,b;; h b;; t b;; cx a,b;; t b;; h b;; s b;; x b;; s a;; }. u3(1.91063,0,0) q[0];; cH q[0],q[1];; ccx q[0],q[1],q[2];; x q[0];; x q[1];; cx q[0],q[1];. measure q[0] -> c[0];; measure q[1] -> c[1];; measure q[2] -> c[2];. One can save it in a .qasm file and import it using the following code:; from qutip.qip.qasm import read_qasm; qc = read_qasm(""guide/qip/w-state.qasm""). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html
https://qutip.org/docs/4.6/modules/qutip/about.html:4511,Deployability,update,updated,4511,"nt(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman and Simon Cross.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ""; ""See https://github.com/qutip for details.""); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except ImportError:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % available_cpu_count()); print(""BLAS Info: %s"" % _blas_info()); print(""OPENMP Installed: %s"" % str(qutip.settings.has_openmp)); print(""INTEL MKL Ext: %s"" % str(qutip.settings.has_mkl)); print(""Platform Info: %s (%s)"" % (platform.system(),; platform.machine())); qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); print(""Installation path: %s"" % qutip_install_path). # citation; longbar = ""="" * 80; cite_msg = ""For your convenience a bibtex reference can be easily""; cite_msg += "" generated using `qutip.cite()`""; print(longbar); print(""Please cite QuTiP in your publication.""); print(longbar); print(cite_msg). if __name__ == ""__main__"":; about(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/about.html
https://qutip.org/docs/4.6/modules/qutip/about.html:2128,Integrability,depend,dependencies,2128,"f its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Command line output of information on QuTiP and dependencies.; """"""; __all__ = ['about']. import sys; import os; import platform; import numpy; import scipy; import inspect; from qutip.utilities import _blas_info, available_cpu_count; import qutip.settings. [docs]def about():; """"""; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib.; """"""; print(""""); print(""QuTiP: Quantum Toolbox in Python""); print(""================================""); print(""Copyright (c) QuTiP team 2011 and later.""); print(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman and Simon Cross.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ",MatchSource.WIKI,docs/4.6/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/about.html
https://qutip.org/docs/4.6/modules/qutip/bloch.html:2509,Deployability,patch,patches,2509,"IRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['Bloch']. import os. from numpy import (ndarray, array, linspace, pi, outer, cos, sin, ones, size,; sqrt, real, mod, append, ceil, arange). from packaging.version import parse as parse_version. from qutip.qobj import Qobj; from qutip.expect import expect; from qutip.operators import sigmax, sigmay, sigmaz. try:; import matplotlib; import matplotlib.pyplot as plt; from mpl_toolkits.mplot3d import Axes3D; from matplotlib.patches import FancyArrowPatch; from mpl_toolkits.mplot3d import proj3d. # Define a custom _axes3D function based on the matplotlib version.; # The auto_add_to_figure keyword is new for matplotlib>=3.4.; if parse_version(matplotlib.__version__) >= parse_version('3.4'):; def _axes3D(fig, *args, **kwargs):; ax = Axes3D(fig, *args, auto_add_to_figure=False, **kwargs); return fig.add_axes(ax); else:; def _axes3D(*args, **kwargs):; return Axes3D(*args, **kwargs). class Arrow3D(FancyArrowPatch):; def __init__(self, xs, ys, zs, *args, **kwargs):; FancyArrowPatch.__init__(self, (0, 0), (0, 0), *args, **kwargs). self._verts3d = xs, ys, zs. def draw(self, renderer):; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M). self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); FancyArrowPatch.draw(self, renderer); except ImportError:; pass. try:; from IPython.display import display; except ImportError:; pass. [docs]class Bloch:; r""""""; Class for plotting data on the Bloch sphere. ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html
https://qutip.org/docs/4.6/modules/qutip/bloch.html:16740,Deployability,update,update,16740,"calls display.; plt.close(self.fig). if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_front(); self.plot_axes_labels(); self.plot_annotations(); # Trigger an update of the Bloch sphere if it is already shown:; self.fig.canvas.draw(). def plot_back(self):; # back half of sphere; u = linspace(0, pi, 25); v = linspace(0, pi, 25); x = outer(cos(u), sin(v)); y = outer(sin(u), sin(v)); z = outer(ones(size(u)), cos(v)); self.axes.plot_surface(x, y, z, rstride=2, cstride=2,; color=self.sphere_color, linewidth=0,; alpha=self.sphere_alpha); # wireframe; self.axes.plot_wireframe(x, y, z, rstride=5, cstride=5,; color=self.frame_color,; alpha=self.frame_alpha); # equator; self.axes.plot(1.0 * cos(u), 1.0 * sin(u), zs=0, zdir='z',; lw=self.frame_width, color=self.frame_color); self.axes.plot(1.0 * cos(u), 1.0 * sin(u), zs=0, zdir='x',; lw=self.frame_width, color=self.frame_color). def plot_front(self):; # front half of sphere; u = linspace(-pi, 0, 25); v = linspace(0, pi, 25); x = outer(cos(u), sin(v)); y = outer(sin(u), sin(v)); z = outer(ones(size(u)), cos(v)); self.axes.plot_surface(x, y, z, rstride=2, cstride=2,; color=self.sphere_color, linewidth=0,; alpha=self",MatchSource.WIKI,docs/4.6/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html
https://qutip.org/docs/4.6/modules/qutip/bloch.html:21917,Deployability,update,update,21917,"== 'm':; pnt_colors = array(self.point_color *; int(ceil(num / float(len(self.point_color))))). pnt_colors = pnt_colors[0:num]; pnt_colors = list(pnt_colors[indperm]); marker = self.point_marker[mod(k, len(self.point_marker))]; s = self.point_size[mod(k, len(self.point_size))]; self.axes.scatter(real(self.points[k][1][indperm]),; -real(self.points[k][0][indperm]),; real(self.points[k][2][indperm]),; s=s, alpha=1, edgecolor=None,; zdir='z', color=pnt_colors,; marker=marker). elif self.point_style[k] == 'l':; color = self.point_color[mod(k, len(self.point_color))]; self.axes.plot(real(self.points[k][1]),; -real(self.points[k][0]),; real(self.points[k][2]),; alpha=0.75, zdir='z',; color=color). def plot_annotations(self):; # -X and Y data are switched for plotting purposes; for annotation in self.annotations:; vec = annotation['position']; opts = {'fontsize': self.font_size,; 'color': self.font_color,; 'horizontalalignment': 'center',; 'verticalalignment': 'center'}; opts.update(annotation['opts']); self.axes.text(vec[1], -vec[0], vec[2],; annotation['text'], **opts). [docs] def show(self):; """"""; Display Bloch sphere and corresponding data sets. Notes; -----. When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This ov",MatchSource.WIKI,docs/4.6/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html
https://qutip.org/docs/4.6/modules/qutip/bloch.html:24208,Deployability,update,updated,24208,"; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory.; dpin : int; Resolution in dots per inch. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(); # Conditional variable for first argument to savefig; # that is set in subsequent if-elses; complete_path = """"; if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; complete_path = os.getcwd() + ""/"" + str(dirc) + '/bloch_' \; + str(self.savenum) + '.' + format; else:; complete_path = os.getcwd() + '/bloch_' + \; str(self.savenum) + '.' + format; else:; complete_path = name. if dpin:; self.fig.savefig(complete_path, dpi=dpin); else:; self.fig.savefig(complete_path); self.savenum += 1; if self.fig:; plt.close(self.fig). def _hide_tick_lines_and_labels(axis):; '''; Set visible property of ticklines and ticklabels of an axis to False; '''; for a in axis.get_ticklines() + axis.get_ticklabels():; a.set_visible(False). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html
https://qutip.org/docs/4.6/modules/qutip/bloch.html:23229,Modifiability,variab,variable,23229,"use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory.; dpin : int; Resolution in dots per inch. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(); # Conditional variable for first argument to savefig; # that is set in subsequent if-elses; complete_path = """"; if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; complete_path = os.getcwd() + ""/"" + str(dirc) + '/bloch_' \; + str(self.savenum) + '.' + format; else:; complete_path = os.getcwd() + '/bloch_' + \; str(self.savenum) + '.' + format; else:; complete_path = name. if dpin:; self.fig.savefig(complete_path, dpi=dpin); else:; self.fig.savefig(complete_path); self.savenum += 1; if self.fig:; plt.close(self.fig). def _hide_tick_lines_and_labels(axis):; '''; Set visible property of ticklines and ticklabels of an axis to False; '''; for a in axis.get_ticklines() + axis.get_ticklabels():; a.set_visible(False). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme",MatchSource.WIKI,docs/4.6/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html
https://qutip.org/docs/4.6/modules/qutip/bloch.html:15702,Safety,avoid,avoid,15702,"rror:; return False. def _is_inline_backend(self):; backend = matplotlib.get_backend(); return backend == ""module://matplotlib_inline.backend_inline"". [docs] def render(self):; """"""; Render the Bloch sphere and its data sets in on given figure and axes.; """"""; if not self._ext_fig and not self._is_inline_backend():; # If no external figure was supplied, we check to see if the; # figure we created in a previous call to .render() has been; # closed, and re-create if has been. This has the unfortunate; # side effect of losing any modifications made to the axes or; # figure, but the alternative is to crash the matplotlib backend.; #; # The inline backend used by, e.g. jupyter notebooks, is happy to; # use closed figures so we leave those figures intact.; if (; self.fig is not None and; not plt.fignum_exists(self.fig.number); ):; self.fig = None; self.axes = None. if self.fig is None:; self.fig = plt.figure(figsize=self.figsize); if self._is_inline_backend():; # We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.; plt.close(self.fig). if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_front(); self.plot_axe",MatchSource.WIKI,docs/4.6/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html
https://qutip.org/docs/4.6/modules/qutip/bloch.html:7565,Usability,simpl,simple,7565,"1; self.frame_width = 1; # Transparency of wireframe, default = 0.2; self.frame_alpha = 0.2; # Labels for x-axis (in LaTex), default = ['$x$', '']; self.xlabel = ['$x$', '']; # Position of x-axis labels, default = [1.2, -1.2]; self.xlpos = [1.2, -1.2]; # Labels for y-axis (in LaTex), default = ['$y$', '']; self.ylabel = ['$y$', '']; # Position of y-axis labels, default = [1.1, -1.1]; self.ylpos = [1.2, -1.2]; # Labels for z-axis (in LaTex),; # default = [r'$\left\|0\right>$', r'$\left|1\right>$']; self.zlabel = [r'$\left|0\right>$', r'$\left|1\right>$']; # Position of z-axis labels, default = [1.2, -1.2]; self.zlpos = [1.2, -1.2]; # ---font options---; # Color of fonts, default = 'black'; self.font_color = 'black'; # Size of fonts, default = 20; self.font_size = 20. # ---vector options---; # List of colors for Bloch vectors, default = ['b','g','r','y']; self.vector_color = ['g', '#CC6600', 'b', 'r']; #: Width of Bloch vectors, default = 5; self.vector_width = 3; #: Style of Bloch vectors, default = '-\|>' (or 'simple'); self.vector_style = '-|>'; #: Sets the width of the vectors arrowhead; self.vector_mutation = 20. # ---point options---; # List of colors for Bloch point markers, default = ['b','g','r','y']; self.point_color = ['b', 'r', 'g', '#CC6600']; # Size of point markers, default = 25; self.point_size = [25, 32, 35, 45]; # Shape of point markers, default = ['o','^','d','s']; self.point_marker = ['o', 's', 'd', '^']. # ---data lists---; # Data for point markers; self.points = []; # Data for Bloch vectors; self.vectors = []; # Data for annotations; self.annotations = []; # Number of times sphere has been saved; self.savenum = 0; # Style of points, 'm' for multiple colors, 's' for single color; self.point_style = []. [docs] def set_label_convention(self, convention):; """"""Set x, y and z labels according to one of conventions. Parameters; ----------; convention : string; One of the following:. - ""original""; - ""xyz""; - ""sx sy sz""; - ""01""; - ""polarization jones""; - ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html
https://qutip.org/docs/4.6/modules/qutip/bloch.html:11827,Usability,clear,clear,11827,"_color: "" + str(self.sphere_color) + ""\n""; s += ""figsize: "" + str(self.figsize) + ""\n""; s += ""vector_color: "" + str(self.vector_color) + ""\n""; s += ""vector_width: "" + str(self.vector_width) + ""\n""; s += ""vector_style: "" + str(self.vector_style) + ""\n""; s += ""vector_mutation: "" + str(self.vector_mutation) + ""\n""; s += ""view: "" + str(self.view) + ""\n""; s += ""xlabel: "" + str(self.xlabel) + ""\n""; s += ""xlpos: "" + str(self.xlpos) + ""\n""; s += ""ylabel: "" + str(self.ylabel) + ""\n""; s += ""ylpos: "" + str(self.ylpos) + ""\n""; s += ""zlabel: "" + str(self.zlabel) + ""\n""; s += ""zlpos: "" + str(self.zlpos) + ""\n""; return s. def _repr_png_(self):; from IPython.core.pylabtools import print_figure; self.render(); fig_data = print_figure(self.fig, 'png'); plt.close(self.fig); return fig_data. def _repr_svg_(self):; from IPython.core.pylabtools import print_figure; self.render(); fig_data = print_figure(self.fig, 'svg').decode('utf-8'); plt.close(self.fig); return fig_data. [docs] def clear(self):; """"""Resets Bloch sphere data sets to empty.; """"""; self.points = []; self.vectors = []; self.point_style = []; self.annotations = []. [docs] def add_points(self, points, meth='s'):; """"""Add a list of data points to bloch sphere. Parameters; ----------; points : array_like; Collection of data points. meth : {'s', 'm', 'l'}; Type of points to plot, use 'm' for multicolored, 'l' for points; connected with a line.; """"""; if not isinstance(points[0], (list, ndarray)):; points = [[points[0]], [points[1]], [points[2]]]; points = array(points); if meth == 's':; if len(points[0]) == 1:; pnts = array([[points[0][0]], [points[1][0]], [points[2][0]]]); pnts = append(pnts, points, axis=1); else:; pnts = points; self.points.append(pnts); self.point_style.append('s'); elif meth == 'l':; self.points.append(points); self.point_style.append('l'); else:; self.points.append(points); self.point_style.append('m'). [docs] def add_states(self, state, kind='vector'):; """"""Add a state vector Qobj to Bloch sphere. Parameters",MatchSource.WIKI,docs/4.6/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html
https://qutip.org/docs/4.6/modules/qutip/bloch.html:16047,Usability,clear,clear,16047,"o see if the; # figure we created in a previous call to .render() has been; # closed, and re-create if has been. This has the unfortunate; # side effect of losing any modifications made to the axes or; # figure, but the alternative is to crash the matplotlib backend.; #; # The inline backend used by, e.g. jupyter notebooks, is happy to; # use closed figures so we leave those figures intact.; if (; self.fig is not None and; not plt.fignum_exists(self.fig.number); ):; self.fig = None; self.axes = None. if self.fig is None:; self.fig = plt.figure(figsize=self.figsize); if self._is_inline_backend():; # We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.; plt.close(self.fig). if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_front(); self.plot_axes_labels(); self.plot_annotations(); # Trigger an update of the Bloch sphere if it is already shown:; self.fig.canvas.draw(). def plot_back(self):; # back half of sphere; u = linspace(0, pi, 25); v = linspace(0, pi, 25); x = outer(cos(u), sin(v)); y = outer(sin(u), sin(v)); z = outer(ones(size(u)), cos(v)); self.axes.plot_surface(x, y, z, rstride=2, cstride=2,; ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html
https://qutip.org/docs/4.6/modules/qutip/bloch.html:19685,Usability,simpl,simple,19685,"f.xlpos[0], 0, self.xlabel[0], **opts); self.axes.text(0, -self.xlpos[1], 0, self.xlabel[1], **opts). self.axes.text(self.ylpos[0], 0, 0, self.ylabel[0], **opts); self.axes.text(self.ylpos[1], 0, 0, self.ylabel[1], **opts). self.axes.text(0, 0, self.zlpos[0], self.zlabel[0], **opts); self.axes.text(0, 0, self.zlpos[1], self.zlabel[1], **opts). for a in (self.axes.w_xaxis.get_ticklines() +; self.axes.w_xaxis.get_ticklabels()):; a.set_visible(False); for a in (self.axes.w_yaxis.get_ticklines() +; self.axes.w_yaxis.get_ticklabels()):; a.set_visible(False); for a in (self.axes.w_zaxis.get_ticklines() +; self.axes.w_zaxis.get_ticklabels()):; a.set_visible(False). def plot_vectors(self):; # -X and Y data are switched for plotting purposes; for k in range(len(self.vectors)):. xs3d = self.vectors[k][1] * array([0, 1]); ys3d = -self.vectors[k][0] * array([0, 1]); zs3d = self.vectors[k][2] * array([0, 1]). color = self.vector_color[mod(k, len(self.vector_color))]. if self.vector_style == '':; # simple line style; self.axes.plot(xs3d, ys3d, zs3d,; zs=0, zdir='z', label='Z',; lw=self.vector_width, color=color); else:; # decorated style, with arrow heads; a = Arrow3D(xs3d, ys3d, zs3d,; mutation_scale=self.vector_mutation,; lw=self.vector_width,; arrowstyle=self.vector_style,; color=color). self.axes.add_artist(a). def plot_points(self):; # -X and Y data are switched for plotting purposes; for k in range(len(self.points)):; num = len(self.points[k][0]); dist = [sqrt(self.points[k][0][j] ** 2 +; self.points[k][1][j] ** 2 +; self.points[k][2][j] ** 2) for j in range(num)]; if any(abs(dist - dist[0]) / dist[0] > 1e-12):; # combine arrays so that they can be sorted together; zipped = list(zip(dist, range(num))); zipped.sort() # sort rates from lowest to highest; dist, indperm = zip(*zipped); indperm = array(indperm); else:; indperm = arange(num); if self.point_style[k] == 's':; self.axes.scatter(; real(self.points[k][1][indperm]),; - real(self.points[k][0][indperm]),; real(self.points",MatchSource.WIKI,docs/4.6/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html
https://qutip.org/docs/4.6/modules/qutip/bloch.html:22465,Usability,simpl,simplest,22465,"lor[mod(k, len(self.point_color))]; self.axes.plot(real(self.points[k][1]),; -real(self.points[k][0]),; real(self.points[k][2]),; alpha=0.75, zdir='z',; color=color). def plot_annotations(self):; # -X and Y data are switched for plotting purposes; for annotation in self.annotations:; vec = annotation['position']; opts = {'fontsize': self.font_size,; 'color': self.font_color,; 'horizontalalignment': 'center',; 'verticalalignment': 'center'}; opts.update(annotation['opts']); self.axes.text(vec[1], -vec[0], vec[2],; annotation['text'], **opts). [docs] def show(self):; """"""; Display Bloch sphere and corresponding data sets. Notes; -----. When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory.; dpin : int; Resolution in dots per inch. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(); # Conditional variable for first argument to savefig; # that is set in subsequent if-elses; complete_path = """"; if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; comp",MatchSource.WIKI,docs/4.6/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:16837,Availability,error,error,16837,"); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dim",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:2206,Deployability,integrat,integrate,2206," PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:10105,Deployability,integrat,integrator,10105,"r the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progre",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:10171,Deployability,integrat,integrate,10171,"tip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmeso",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:10649,Deployability,update,update,10649,"0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None, ; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):; ; if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]; ; H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_lengths = []; coupled_spectra = []; ; if",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:11089,Deployability,integrat,integrate,11089,"; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None, ; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):; ; if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]; ; H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_lengths = []; coupled_spectra = []; ; if isinstance(H, Qobj):; H_terms.append(H.full('f')); H_td_terms.append('1'); else: ; for kk, h in enumerate(H):; if isinstance(h, Qobj):; H_terms.append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'); ; ; for kk, c",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:15369,Deployability,integrat,integrate,15369,"None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.appe",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:16762,Deployability,update,update,16762,"e, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_f",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:16825,Deployability,integrat,integration,16825,"); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dim",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:17458,Deployability,integrat,integrate,17458,"s = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:18092,Deployability,update,updated,18092,"s = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:2206,Integrability,integrat,integrate,2206," PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:3885,Integrability,depend,dependent,3885,"tip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ---",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:4018,Integrability,depend,dependent,4018,"tip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ---",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:4192,Integrability,depend,dependence,4192,"e(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:4352,Integrability,depend,dependence,4352,"e, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to ; the bath degrees of freedom, along with their associated; spectra. e_ops : li",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:4573,Integrability,depend,dependence,4573,"l as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to ; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict ; Placeholder for future implementation, kept ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:4870,Integrability,depend,dependence,4870,"lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to ; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict ; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms.; ; sec_cutoff : float {0.1}; Cutoff for secular approximation.; ; tol : float {qutip.setttings.atol}; Tolerance used for removing small values after ; basis transformation.; ; spectra_cb : list; DEPRECIATED. D",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:7037,Integrability,depend,dependent,7037,":`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); ; # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; if n_str == 0:; ; R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output; ; elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops, ; c_ops=c_ops, args=args, use_secular=use_secular, ; sec_cutoff=sec_cutoff,; tol=tol, options=options, ; progress_bar=progress_bar,; _",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:7361,Integrability,depend,dependence,7361,"llows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); ; # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; if n_str == 0:; ; R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output; ; elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops, ; c_ops=c_ops, args=args, use_secular=use_secular, ; sec_cutoff=sec_cutoff,; tol=tol, options=options, ; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose, ; _prep_time=_prep_time); ; return output; ; else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield m",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:10105,Integrability,integrat,integrator,10105,"r the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progre",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:10171,Integrability,integrat,integrate,10171,"tip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmeso",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:11089,Integrability,integrat,integrate,11089,"; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None, ; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):; ; if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]; ; H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_lengths = []; coupled_spectra = []; ; if isinstance(H, Qobj):; H_terms.append(H.full('f')); H_td_terms.append('1'); else: ; for kk, h in enumerate(H):; if isinstance(h, Qobj):; H_terms.append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'); ; ; for kk, c",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:15369,Integrability,integrat,integrate,15369,"None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.appe",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:16825,Integrability,integrat,integration,16825,"); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dim",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:17458,Integrability,integrat,integrate,17458,"s = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:2424,Modifiability,config,config,2424,"RPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:3464,Modifiability,coupling,coupling,3464,"Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:3663,Modifiability,coupling,coupling,3663," TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:3805,Modifiability,variab,variable,3805," TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:4073,Modifiability,variab,variable,4073,"e(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:4137,Modifiability,variab,variables,4137,"e(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:4220,Modifiability,variab,variable,4220,"e(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:5624,Modifiability,coupling,coupling,5624,"ely.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to ; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict ; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms.; ; sec_cutoff : float {0.1}; Cutoff for secular approximation.; ; tol : float {qutip.setttings.atol}; Tolerance used for removing small values after ; basis transformation.; ; spectra_cb : list; DEPRECIATED. Do not use.; ; options : :class:`qutip.solver.Options`; Options for the solver.; ; progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):;",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:7311,Modifiability,config,config,7311,"fied by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); ; # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; if n_str == 0:; ; R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output; ; elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops, ; c_ops=c_ops, args=args, use_secular=use_secular, ; sec_cutoff=sec_cutoff,; tol=tol, options=options, ; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose, ; _prep_time=_prep_time); ; return output; ; else:; raise Exception('Cannot mix func and str formats.'). # ----------------------------------------------------------",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:7336,Modifiability,config,config,7336,"llows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); ; # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; if n_str == 0:; ; R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output; ; elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops, ; c_ops=c_ops, args=args, use_secular=use_secular, ; sec_cutoff=sec_cutoff,; tol=tol, options=options, ; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose, ; _prep_time=_prep_time); ; return output; ; else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield m",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:7397,Modifiability,config,config,7397,"llows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); ; # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; if n_str == 0:; ; R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output; ; elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops, ; c_ops=c_ops, args=args, use_secular=use_secular, ; sec_cutoff=sec_cutoff,; tol=tol, options=options, ; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose, ; _prep_time=_prep_time); ; return output; ; else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield m",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:12904,Modifiability,coupling,coupling,12904,"append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'); ; ; for kk, c in enumerate(c_ops):; if isinstance(c, Qobj):; C_terms.append(c.full('f')); C_td_terms.append('1'); elif isinstance(c, list):; C_terms.append(c[0].full('f')); if isinstance(c[1], Cubic_Spline):; CA_obj.append(c[1].coeffs); spline_count[0] += 1; C_td_terms.append(c[1]); else:; raise Exception('Invalid collapse operator specification.'); ; coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'); ; coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:13453,Modifiability,coupling,coupling,13453,".'); ; coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'); ; coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(co",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:14323,Modifiability,config,config,14323,"isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vecto",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:14381,Modifiability,config,config,14381,"[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.inte",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:14428,Modifiability,config,config,14428,"raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:14453,Modifiability,config,config,14453," bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_s",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:14834,Modifiability,config,config,14834,".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_va",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:14841,Modifiability,config,config,14841,".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_va",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:15083,Modifiability,config,config,15083,"olver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):;",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:15133,Modifiability,config,config,15133,"r(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:15219,Modifiability,config,config,15219,"se:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; ou",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
