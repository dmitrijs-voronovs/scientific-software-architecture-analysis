id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:299,Energy Efficiency,efficient,efficiently,299,"/// Twine - A lightweight data structure for efficiently representing the; /// concatenation of temporary values as strings.; ///; /// A Twine is a kind of rope, it represents a concatenated string using a; /// binary-tree, where the string is the preorder of the nodes. Since the; /// Twine can be efficiently rendered into a buffer when its result is used,; /// it avoids the cost of generating temporary values for intermediate string; /// results -- particularly in cases when the Twine result is never; /// required. By explicitly tracking the type of leaf nodes, we can also avoid; /// the creation of temporary strings for conversions operations (such as; /// appending an integer to a string).; ///; /// A Twine is not intended for use directly and should not be stored, its; /// implementation relies on the ability to store pointers to temporary stack; /// objects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:2547,Energy Efficiency,efficient,efficient,2547,"oncatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - If a Twine has another Twine as a child, that child should always be; /// binary (otherwise it could have been folded into the parent).; ///; /// These invariants are check by \see isValid().; ///; /// \b Efficiency Considerations; ///; /// The Twine is designed to yield efficient and small code for common; /// situations. For this reason, the concat() method is inlined so that; /// concatenations of leaf nodes can be optimized into stores directly into a; /// single stack allocated object.; ///; /// In practice, not all compilers can be trusted to optimize concat() fully,; /// so we provide two additional methods (and accompanying operator+; /// overloads) to guarantee that particularly important cases (cstring plus; /// StringRef) codegen as desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:2753,Energy Efficiency,allocate,allocated,2753,"oncatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - If a Twine has another Twine as a child, that child should always be; /// binary (otherwise it could have been folded into the parent).; ///; /// These invariants are check by \see isValid().; ///; /// \b Efficiency Considerations; ///; /// The Twine is designed to yield efficient and small code for common; /// situations. For this reason, the concat() method is inlined so that; /// concatenations of leaf nodes can be optimized into stores directly into a; /// single stack allocated object.; ///; /// In practice, not all compilers can be trusted to optimize concat() fully,; /// so we provide two additional methods (and accompanying operator+; /// overloads) to guarantee that particularly important cases (cstring plus; /// StringRef) codegen as desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:1264,Performance,perform,performed,1264,"ring is the preorder of the nodes. Since the; /// Twine can be efficiently rendered into a buffer when its result is used,; /// it avoids the cost of generating temporary values for intermediate string; /// results -- particularly in cases when the Twine result is never; /// required. By explicitly tracking the type of leaf nodes, we can also avoid; /// the creation of temporary strings for conversions operations (such as; /// appending an integer to a string).; ///; /// A Twine is not intended for use directly and should not be stored, its; /// implementation relies on the ability to store pointers to temporary stack; /// objects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:2697,Performance,optimiz,optimized,2697,"oncatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - If a Twine has another Twine as a child, that child should always be; /// binary (otherwise it could have been folded into the parent).; ///; /// These invariants are check by \see isValid().; ///; /// \b Efficiency Considerations; ///; /// The Twine is designed to yield efficient and small code for common; /// situations. For this reason, the concat() method is inlined so that; /// concatenations of leaf nodes can be optimized into stores directly into a; /// single stack allocated object.; ///; /// In practice, not all compilers can be trusted to optimize concat() fully,; /// so we provide two additional methods (and accompanying operator+; /// overloads) to guarantee that particularly important cases (cstring plus; /// StringRef) codegen as desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:2830,Performance,optimiz,optimize,2830,"oncatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - If a Twine has another Twine as a child, that child should always be; /// binary (otherwise it could have been folded into the parent).; ///; /// These invariants are check by \see isValid().; ///; /// \b Efficiency Considerations; ///; /// The Twine is designed to yield efficient and small code for common; /// situations. For this reason, the concat() method is inlined so that; /// concatenations of leaf nodes can be optimized into stores directly into a; /// single stack allocated object.; ///; /// In practice, not all compilers can be trusted to optimize concat() fully,; /// so we provide two additional methods (and accompanying operator+; /// overloads) to guarantee that particularly important cases (cstring plus; /// StringRef) codegen as desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:367,Safety,avoid,avoids,367,"/// Twine - A lightweight data structure for efficiently representing the; /// concatenation of temporary values as strings.; ///; /// A Twine is a kind of rope, it represents a concatenated string using a; /// binary-tree, where the string is the preorder of the nodes. Since the; /// Twine can be efficiently rendered into a buffer when its result is used,; /// it avoids the cost of generating temporary values for intermediate string; /// results -- particularly in cases when the Twine result is never; /// required. By explicitly tracking the type of leaf nodes, we can also avoid; /// the creation of temporary strings for conversions operations (such as; /// appending an integer to a string).; ///; /// A Twine is not intended for use directly and should not be stored, its; /// implementation relies on the ability to store pointers to temporary stack; /// objects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:581,Safety,avoid,avoid,581,"/// Twine - A lightweight data structure for efficiently representing the; /// concatenation of temporary values as strings.; ///; /// A Twine is a kind of rope, it represents a concatenated string using a; /// binary-tree, where the string is the preorder of the nodes. Since the; /// Twine can be efficiently rendered into a buffer when its result is used,; /// it avoids the cost of generating temporary values for intermediate string; /// results -- particularly in cases when the Twine result is never; /// required. By explicitly tracking the type of leaf nodes, we can also avoid; /// the creation of temporary strings for conversions operations (such as; /// appending an integer to a string).; ///; /// A Twine is not intended for use directly and should not be stored, its; /// implementation relies on the ability to store pointers to temporary stack; /// objects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:1899,Testability,test,testing,1899,"jects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - If a Twine has another Twine as a child, that child should always be; /// binary (otherwise it could have been folded into the parent).; ///; /// These invariants are check by \see isValid().; ///; /// \b Efficiency Considerations; ///; /// The Twine is designed to yield efficient and small code for common; /// situations. For this reason, the concat() method is inlined so that; /// concatenations of leaf nodes can be optimized into stores directly into a; /// single stack allocated object.; ///; /// In practice, not all compilers can be trusted to optimize concat() fully,; /// so we prov",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:62,Performance,optimiz,optimize,62,"/// Construct from a C string.; ///; /// We take care here to optimize """" into the empty twine -- this will be; /// optimized out for string constants. This allows Twine arguments have; /// default """" values, without introducing unnecessary string constants.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:116,Performance,optimiz,optimized,116,"/// Construct from a C string.; ///; /// We take care here to optimize """" into the empty twine -- this will be; /// optimized out for string constants. This allows Twine arguments have; /// default """" values, without introducing unnecessary string constants.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:137,Safety,avoid,avoids,137,"/// Construct from an std::string_view by converting it to a pointer and; /// length. This handles string_views on a pure API basis, and avoids; /// storing one (or a pointer to one) inside a Twine, which avoids problems; /// when mixing code compiled under various C++ standards.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:205,Safety,avoid,avoids,205,"/// Construct from an std::string_view by converting it to a pointer and; /// length. This handles string_views on a pure API basis, and avoids; /// storing one (or a pointer to one) inside a Twine, which avoids problems; /// when mixing code compiled under various C++ standards.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:214,Availability,down,down,214,"// FIXME: Unfortunately, to make sure this is as efficient as possible we; // need extra binary constructors from particular types. We can't rely on; // the compiler to be smart enough to fold operator+()/concat() down to the; // right thing. Yet.; /// Construct as the concatenation of a C string and a StringRef.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:49,Energy Efficiency,efficient,efficient,49,"// FIXME: Unfortunately, to make sure this is as efficient as possible we; // need extra binary constructors from particular types. We can't rely on; // the compiler to be smart enough to fold operator+()/concat() down to the; // right thing. Yet.; /// Construct as the concatenation of a C string and a StringRef.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:49,Security,access,accessed,49,/// Return true if this twine can be dynamically accessed as a single; /// StringRef value with getSingleStringRef().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:37,Usability,simpl,simplified,37,/// Additional overload to guarantee simplified codegen; this is equivalent to; /// concat().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:37,Usability,simpl,simplified,37,/// Additional overload to guarantee simplified codegen; this is equivalent to; /// concat().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h:103,Performance,optimiz,optimization,103,"// This is marked always_inline and nodebug so it doesn't show up in stack; // traces at -O0 (or other optimization levels). Large TypeSwitch's are; // common, are equivalent to a switch, and don't add any value to stack; // traces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h:179,Usability,simpl,simple,179,"/// Invoke a case on the derived class, inferring the type of the Case from; /// the first input of the given callable.; /// Note: This inference rules for this overload are very simple: strip; /// pointers and references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h:343,Testability,Log,LogicalResult,343,"// end namespace detail; /// This class implements a switch-like dispatch statement for a value of 'T'; /// using dyn_cast functionality. Each `Case<T>` takes a callable to be invoked; /// if the root value isa<T>, the callable is invoked with the result of; /// dyn_cast<T>() as a parameter.; ///; /// Example:; /// Operation *op = ...;; /// LogicalResult result = TypeSwitch<Operation *, LogicalResult>(op); /// .Case<ConstantOp>([](ConstantOp op) { ... }); /// .Default([](Operation *op) { ... });; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h:390,Testability,Log,LogicalResult,390,"// end namespace detail; /// This class implements a switch-like dispatch statement for a value of 'T'; /// using dyn_cast functionality. Each `Case<T>` takes a callable to be invoked; /// if the root value isa<T>, the callable is invoked with the result of; /// dyn_cast<T>() as a parameter.; ///; /// Example:; /// Operation *op = ...;; /// LogicalResult result = TypeSwitch<Operation *, LogicalResult>(op); /// .Case<ConstantOp>([](ConstantOp op) { ... }); /// .Default([](Operation *op) { ... });; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/UniqueVector.h:12,Usability,Clear,Clears,12,/// reset - Clears all the entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/UniqueVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/UniqueVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:54,Integrability,Interface,Interface,54,"//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the generic AliasAnalysis interface, which is used as the; // common interface used by all clients of alias analysis information, and; // implemented by all alias analysis implementations. Mod/Ref information is; // also captured by this interface.; //; // Implementations of this interface must implement the various virtual methods,; // which automatically provides functionality for the entire suite of client; // APIs.; //; // This API identifies memory regions with the MemoryLocation class. The pointer; // component specifies the base memory address of the region. The Size specifies; // the maximum size (in address units) of the memory region, or; // MemoryLocation::UnknownSize if the size is not known. The TBAA tag; // identifies the ""type"" of the memory reference; see the; // TypeBasedAliasAnalysis class for details.; //; // Some non-obvious details include:; // - Pointers that point to two completely different objects in memory never; // alias, regardless of the value of the Size component.; // - NoAlias doesn't imply inequal pointers. The most obvious example of this; // is two pointers to constant memory. Even if they are equal, constant; // memory is never stored to, so there will never be any dependencies.; // In this and other situations, the pointers may be both NoAlias and; // MustAlias at the same time. The current API can only return one result,; // though this is rarely a problem in practice.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:427,Integrability,interface,interface,427,"//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the generic AliasAnalysis interface, which is used as the; // common interface used by all clients of alias analysis information, and; // implemented by all alias analysis implementations. Mod/Ref information is; // also captured by this interface.; //; // Implementations of this interface must implement the various virtual methods,; // which automatically provides functionality for the entire suite of client; // APIs.; //; // This API identifies memory regions with the MemoryLocation class. The pointer; // component specifies the base memory address of the region. The Size specifies; // the maximum size (in address units) of the memory region, or; // MemoryLocation::UnknownSize if the size is not known. The TBAA tag; // identifies the ""type"" of the memory reference; see the; // TypeBasedAliasAnalysis class for details.; //; // Some non-obvious details include:; // - Pointers that point to two completely different objects in memory never; // alias, regardless of the value of the Size component.; // - NoAlias doesn't imply inequal pointers. The most obvious example of this; // is two pointers to constant memory. Even if they are equal, constant; // memory is never stored to, so there will never be any dependencies.; // In this and other situations, the pointers may be both NoAlias and; // MustAlias at the same time. The current API can only return one result,; // though this is rarely a problem in practice.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:470,Integrability,interface,interface,470,"//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the generic AliasAnalysis interface, which is used as the; // common interface used by all clients of alias analysis information, and; // implemented by all alias analysis implementations. Mod/Ref information is; // also captured by this interface.; //; // Implementations of this interface must implement the various virtual methods,; // which automatically provides functionality for the entire suite of client; // APIs.; //; // This API identifies memory regions with the MemoryLocation class. The pointer; // component specifies the base memory address of the region. The Size specifies; // the maximum size (in address units) of the memory region, or; // MemoryLocation::UnknownSize if the size is not known. The TBAA tag; // identifies the ""type"" of the memory reference; see the; // TypeBasedAliasAnalysis class for details.; //; // Some non-obvious details include:; // - Pointers that point to two completely different objects in memory never; // alias, regardless of the value of the Size component.; // - NoAlias doesn't imply inequal pointers. The most obvious example of this; // is two pointers to constant memory. Even if they are equal, constant; // memory is never stored to, so there will never be any dependencies.; // In this and other situations, the pointers may be both NoAlias and; // MustAlias at the same time. The current API can only return one result,; // though this is rarely a problem in practice.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:639,Integrability,interface,interface,639,"//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the generic AliasAnalysis interface, which is used as the; // common interface used by all clients of alias analysis information, and; // implemented by all alias analysis implementations. Mod/Ref information is; // also captured by this interface.; //; // Implementations of this interface must implement the various virtual methods,; // which automatically provides functionality for the entire suite of client; // APIs.; //; // This API identifies memory regions with the MemoryLocation class. The pointer; // component specifies the base memory address of the region. The Size specifies; // the maximum size (in address units) of the memory region, or; // MemoryLocation::UnknownSize if the size is not known. The TBAA tag; // identifies the ""type"" of the memory reference; see the; // TypeBasedAliasAnalysis class for details.; //; // Some non-obvious details include:; // - Pointers that point to two completely different objects in memory never; // alias, regardless of the value of the Size component.; // - NoAlias doesn't imply inequal pointers. The most obvious example of this; // is two pointers to constant memory. Even if they are equal, constant; // memory is never stored to, so there will never be any dependencies.; // In this and other situations, the pointers may be both NoAlias and; // MustAlias at the same time. The current API can only return one result,; // though this is rarely a problem in practice.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:682,Integrability,interface,interface,682,"//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the generic AliasAnalysis interface, which is used as the; // common interface used by all clients of alias analysis information, and; // implemented by all alias analysis implementations. Mod/Ref information is; // also captured by this interface.; //; // Implementations of this interface must implement the various virtual methods,; // which automatically provides functionality for the entire suite of client; // APIs.; //; // This API identifies memory regions with the MemoryLocation class. The pointer; // component specifies the base memory address of the region. The Size specifies; // the maximum size (in address units) of the memory region, or; // MemoryLocation::UnknownSize if the size is not known. The TBAA tag; // identifies the ""type"" of the memory reference; see the; // TypeBasedAliasAnalysis class for details.; //; // Some non-obvious details include:; // - Pointers that point to two completely different objects in memory never; // alias, regardless of the value of the Size component.; // - NoAlias doesn't imply inequal pointers. The most obvious example of this; // is two pointers to constant memory. Even if they are equal, constant; // memory is never stored to, so there will never be any dependencies.; // In this and other situations, the pointers may be both NoAlias and; // MustAlias at the same time. The current API can only return one result,; // though this is rarely a problem in practice.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:1621,Integrability,depend,dependencies,1621,"//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the generic AliasAnalysis interface, which is used as the; // common interface used by all clients of alias analysis information, and; // implemented by all alias analysis implementations. Mod/Ref information is; // also captured by this interface.; //; // Implementations of this interface must implement the various virtual methods,; // which automatically provides functionality for the entire suite of client; // APIs.; //; // This API identifies memory regions with the MemoryLocation class. The pointer; // component specifies the base memory address of the region. The Size specifies; // the maximum size (in address units) of the memory region, or; // MemoryLocation::UnknownSize if the size is not known. The TBAA tag; // identifies the ""type"" of the memory reference; see the; // TypeBasedAliasAnalysis class for details.; //; // Some non-obvious details include:; // - Pointers that point to two completely different objects in memory never; // alias, regardless of the value of the Size component.; // - NoAlias doesn't imply inequal pointers. The most obvious example of this; // is two pointers to constant memory. Even if they are equal, constant; // memory is never stored to, so there will never be any dependencies.; // In this and other situations, the pointers may be both NoAlias and; // MustAlias at the same time. The current API can only return one result,; // though this is rarely a problem in practice.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:264,Testability,test,testing,264,"/// The possible results of an alias query.; ///; /// These results are always computed between two MemoryLocation objects as; /// a query to some alias analysis.; ///; /// Note that these are unscoped enumerations because we would like to support; /// implicitly testing a result for the existence of any possible aliasing with; /// a conversion to bool, but an ""enum class"" doesn't support this. The; /// canonical names from the literature are suffixed and unique anyways, and so; /// they serve as global constants in LLVM for these results.; ///; /// See docs/AliasAnalysis.html for more information on the specific meanings; /// of these values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:58,Performance,cache,caches,58,"/// Context-free CaptureInfo provider, which computes and caches whether an; /// object is captured in the function at all, but does not distinguish whether; /// it was captured before or after the context instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:63,Performance,cache,caches,63,"/// Context-sensitive CaptureInfo provider, which computes and caches the; /// earliest common dominator closure of all captures. It provides a good; /// approximation to a precise ""captures before"" analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:101,Performance,cache,cache,101,/// Reverse map from instruction to the objects it is the earliest escape for.; /// This is used for cache invalidation purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:4,Performance,Cache,Cache,4,"/// Cache key for BasicAA results. It only includes the pointer and size from; /// MemoryLocation, as BasicAA is AATags independent. Additionally, it includes; /// the value of MayBeCrossIteration, which may affect BasicAA results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:463,Integrability,wrap,wrapper,463,"/// This class stores info we want to provide to or retain within an alias; /// query. By default, the root query is stateless and starts with a freshly; /// constructed info object. Specific alias analyses can use this query info to; /// store per-query state that is important for recursive or nested queries to; /// avoid recomputing. To enable preserving this state across multiple queries; /// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.; /// The information stored in an `AAQueryInfo` is currently limitted to the; /// caches used by BasicAA, but can further be extended to fit other AA needs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:597,Modifiability,extend,extended,597,"/// This class stores info we want to provide to or retain within an alias; /// query. By default, the root query is stateless and starts with a freshly; /// constructed info object. Specific alias analyses can use this query info to; /// store per-query state that is important for recursive or nested queries to; /// avoid recomputing. To enable preserving this state across multiple queries; /// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.; /// The information stored in an `AAQueryInfo` is currently limitted to the; /// caches used by BasicAA, but can further be extended to fit other AA needs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:554,Performance,cache,caches,554,"/// This class stores info we want to provide to or retain within an alias; /// query. By default, the root query is stateless and starts with a freshly; /// constructed info object. Specific alias analyses can use this query info to; /// store per-query state that is important for recursive or nested queries to; /// avoid recomputing. To enable preserving this state across multiple queries; /// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.; /// The information stored in an `AAQueryInfo` is currently limitted to the; /// caches used by BasicAA, but can further be extended to fit other AA needs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:319,Safety,avoid,avoid,319,"/// This class stores info we want to provide to or retain within an alias; /// query. By default, the root query is stateless and starts with a freshly; /// constructed info object. Specific alias analyses can use this query info to; /// store per-query state that is important for recursive or nested queries to; /// avoid recomputing. To enable preserving this state across multiple queries; /// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.; /// The information stored in an `AAQueryInfo` is currently limitted to the; /// caches used by BasicAA, but can further be extended to fit other AA needs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:405,Safety,safe,safe,405,"/// This class stores info we want to provide to or retain within an alias; /// query. By default, the root query is stateless and starts with a freshly; /// constructed info object. Specific alias analyses can use this query info to; /// store per-query state that is important for recursive or nested queries to; /// avoid recomputing. To enable preserving this state across multiple queries; /// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.; /// The information stored in an `AAQueryInfo` is currently limitted to the; /// caches used by BasicAA, but can further be extended to fit other AA needs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:64,Performance,perform,performed,64,// Alias analysis result aggregration using which this query is performed.; // Can be used to perform recursive queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:94,Performance,perform,perform,94,// Alias analysis result aggregration using which this query is performed.; // Can be used to perform recursive queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:140,Performance,cache,cache,140,/// Location pairs for which an assumption based result is currently stored.; /// Used to remove all potentially incorrect results from the cache if an; /// assumption is disproven.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:433,Performance,load,load,433,"/// Tracks whether the accesses may be on different cycle iterations.; ///; /// When interpret ""Value"" pointer equality as value equality we need to make; /// sure that the ""Value"" is not part of a cycle. Otherwise, two uses could; /// come from different ""iterations"" of a cycle and see different values for; /// the same ""Value"" pointer.; ///; /// The following example shows the problem:; /// %p = phi(%alloca1, %addr2); /// %l = load %ptr; /// %addr1 = gep, %alloca2, 0, %l; /// %addr2 = gep %alloca2, 0, (%l + 1); /// alias(%p, %addr1) -> MayAlias !; /// store %l, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:23,Security,access,accesses,23,"/// Tracks whether the accesses may be on different cycle iterations.; ///; /// When interpret ""Value"" pointer equality as value equality we need to make; /// sure that the ""Value"" is not part of a cycle. Otherwise, two uses could; /// come from different ""iterations"" of a cycle and see different values for; /// the same ""Value"" pointer.; ///; /// The following example shows the problem:; /// %p = phi(%alloca1, %addr2); /// %l = load %ptr; /// %addr1 = gep, %alloca2, 0, %l; /// %addr2 = gep %alloca2, 0, (%l + 1); /// alias(%p, %addr1) -> MayAlias !; /// store %l, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:100,Deployability,update,update,100,"/// Whether alias analysis is allowed to use the dominator tree, for use by; /// passes that lazily update the DT while performing AA queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:120,Performance,perform,performing,120,"/// Whether alias analysis is allowed to use the dominator tree, for use by; /// passes that lazily update the DT while performing AA queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:26,Usability,Simpl,SimpleCaptureInfo,26,/// AAQueryInfo that uses SimpleCaptureInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:72,Modifiability,polymorphi,polymorphic,72,// FIXME: We should use a much lighter weight system than the usual; // polymorphic pattern because we don't own AAResult. It should; // ideally involve two pointers and no separate allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:65,Integrability,depend,depends,65,/// Register a function analysis ID that the results aggregation depends on.; ///; /// This is used in the new pass manager to implement the invalidation logic; /// where we must invalidate the results aggregation if any of our component; /// analyses become invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:154,Testability,log,logic,154,/// Register a function analysis ID that the results aggregation depends on.; ///; /// This is used in the new pass manager to implement the invalidation logic; /// where we must invalidate the results aggregation if any of our component; /// analyses become invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:136,Integrability,interface,interface,136,//===--------------------------------------------------------------------===//; /// \name Alias Queries; /// @{; /// The main low level interface to the alias analysis implementation.; /// Returns an AliasResult indicating whether the two pointers are aliased to; /// each other. This is the interface that must be implemented by specific; /// alias analysis implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:292,Integrability,interface,interface,292,//===--------------------------------------------------------------------===//; /// \name Alias Queries; /// @{; /// The main low level interface to the alias analysis implementation.; /// Returns an AliasResult indicating whether the two pointers are aliased to; /// each other. This is the interface that must be implemented by specific; /// alias analysis implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the primary \c alias interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:54,Integrability,interface,interface,54,/// A convenience wrapper around the primary \c alias interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the primary \c alias interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:54,Integrability,interface,interface,54,/// A convenience wrapper around the primary \c alias interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the \c isNoAlias helper interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:57,Integrability,interface,interface,57,/// A convenience wrapper around the \c isNoAlias helper interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the \c isNoAlias helper interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:57,Integrability,interface,interface,57,/// A convenience wrapper around the \c isNoAlias helper interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the \c isMustAlias helper interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:59,Integrability,interface,interface,59,/// A convenience wrapper around the \c isMustAlias helper interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the primary \c pointsToConstantMemory; /// interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:76,Integrability,interface,interface,76,/// A convenience wrapper around the primary \c pointsToConstantMemory; /// interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:98,Usability,Simpl,Simple,98,"/// @}; //===--------------------------------------------------------------------===//; /// \name Simple mod/ref information; /// @{; /// Returns a bitmask that should be unconditionally applied to the ModRef; /// info of a memory location. This allows us to eliminate Mod and/or Ref; /// from the ModRef info based on the knowledge that the memory location; /// points to constant and/or locally-invariant memory.; ///; /// If IgnoreLocals is true, then this method returns NoModRef for memory; /// that points to a local alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the primary \c getModRefInfoMask; /// interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:71,Integrability,interface,interface,71,/// A convenience wrapper around the primary \c getModRefInfoMask; /// interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:266,Performance,optimiz,optimizations,266,"/// Checks if the specified call is known to never read or write memory.; ///; /// Note that if the call only reads from known-constant memory, it is also; /// legal to return true. Also, calls that unwind the stack are legal for; /// this predicate.; ///; /// Many optimizations (such as CSE and LICM) can be performed on such calls; /// without worrying about aliasing properties, and many calls have this; /// property (e.g. calls to 'sin' and 'cos').; ///; /// This property corresponds to the GCC 'const' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:310,Performance,perform,performed,310,"/// Checks if the specified call is known to never read or write memory.; ///; /// Note that if the call only reads from known-constant memory, it is also; /// legal to return true. Also, calls that unwind the stack are legal for; /// this predicate.; ///; /// Many optimizations (such as CSE and LICM) can be performed on such calls; /// without worrying about aliasing properties, and many calls have this; /// property (e.g. calls to 'sin' and 'cos').; ///; /// This property corresponds to the GCC 'const' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:277,Performance,optimiz,optimizations,277,"/// Checks if the specified function is known to never read or write memory.; ///; /// Note that if the function only reads from known-constant memory, it is; /// also legal to return true. Also, function that unwind the stack are legal; /// for this predicate.; ///; /// Many optimizations (such as CSE and LICM) can be performed on such calls; /// to such functions without worrying about aliasing properties, and many; /// functions have this property (e.g. 'sin' and 'cos').; ///; /// This property corresponds to the GCC 'const' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:321,Performance,perform,performed,321,"/// Checks if the specified function is known to never read or write memory.; ///; /// Note that if the function only reads from known-constant memory, it is; /// also legal to return true. Also, function that unwind the stack are legal; /// for this predicate.; ///; /// Many optimizations (such as CSE and LICM) can be performed on such calls; /// to such functions without worrying about aliasing properties, and many; /// functions have this property (e.g. 'sin' and 'cos').; ///; /// This property corresponds to the GCC 'const' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:227,Performance,optimiz,optimizations,227,"/// Checks if the specified call is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Calls that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:247,Performance,perform,performed,247,"/// Checks if the specified call is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Calls that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:93,Security,access,access,93,"/// Checks if the specified call is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Calls that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:235,Performance,optimiz,optimizations,235,"/// Checks if the specified function is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Functions that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:255,Performance,perform,performed,255,"/// Checks if the specified function is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Functions that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:97,Security,access,access,97,"/// Checks if the specified function is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Functions that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper for constructing the memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper to synthesize a memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper synthesizing a memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper synthesizing a memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:20,Integrability,wrap,wrapper,20,"/// This class is a wrapper over an AAResults, and it is intended to be used; /// only when there are no IR changes inbetween queries. BatchAAResults is; /// reusing the same `AAQueryInfo` to preserve the state across queries,; /// esentially making AA work in ""batch mode"". The internal state cannot be; /// cleared, so to go ""out-of-batch-mode"", the user must either use AAResults,; /// or create a new BatchAAResults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:309,Usability,clear,cleared,309,"/// This class is a wrapper over an AAResults, and it is intended to be used; /// only when there are no IR changes inbetween queries. BatchAAResults is; /// reusing the same `AAQueryInfo` to preserve the state across queries,; /// esentially making AA work in ""batch mode"". The internal state cannot be; /// cleared, so to go ""out-of-batch-mode"", the user must either use AAResults,; /// or create a new BatchAAResults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:125,Integrability,interface,interface,125,/// A private abstract base class describing the concept of an individual alias; /// analysis implementation.; ///; /// This interface is implemented by any \c Model instantiation. It is also the; /// interface which a type used to instantiate the model must provide.; ///; /// All of these methods model methods by the same name in the \c; /// AAResults class. Only differences and specifics to how the; /// implementations are called are documented here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:201,Integrability,interface,interface,201,/// A private abstract base class describing the concept of an individual alias; /// analysis implementation.; ///; /// This interface is implemented by any \c Model instantiation. It is also the; /// interface which a type used to instantiate the model must provide.; ///; /// All of these methods model methods by the same name in the \c; /// AAResults class. Only differences and specifics to how the; /// implementations are called are documented here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:136,Integrability,interface,interface,136,//===--------------------------------------------------------------------===//; /// \name Alias Queries; /// @{; /// The main low level interface to the alias analysis implementation.; /// Returns an AliasResult indicating whether the two pointers are aliased to; /// each other. This is the interface that must be implemented by specific; /// alias analysis implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:292,Integrability,interface,interface,292,//===--------------------------------------------------------------------===//; /// \name Alias Queries; /// @{; /// The main low level interface to the alias analysis implementation.; /// Returns an AliasResult indicating whether the two pointers are aliased to; /// each other. This is the interface that must be implemented by specific; /// alias analysis implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:98,Usability,Simpl,Simple,98,/// @}; //===--------------------------------------------------------------------===//; /// \name Simple mod/ref information; /// @{; /// Returns a bitmask that should be unconditionally applied to the ModRef; /// info of a memory location. This allows us to eliminate Mod and/or Ref from; /// the ModRef info based on the knowledge that the memory location points to; /// constant and/or locally-invariant memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:63,Integrability,wrap,wraps,63,/// A private class template which derives from \c Concept and wraps some other; /// type.; ///; /// This models the concept by directly forwarding each interface point to the; /// wrapped type which must implement a compatible interface. This provides; /// a type erased binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:153,Integrability,interface,interface,153,/// A private class template which derives from \c Concept and wraps some other; /// type.; ///; /// This models the concept by directly forwarding each interface point to the; /// wrapped type which must implement a compatible interface. This provides; /// a type erased binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:181,Integrability,wrap,wrapped,181,/// A private class template which derives from \c Concept and wraps some other; /// type.; ///; /// This models the concept by directly forwarding each interface point to the; /// wrapped type which must implement a compatible interface. This provides; /// a type erased binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:228,Integrability,interface,interface,228,/// A private class template which derives from \c Concept and wraps some other; /// type.; ///; /// This models the concept by directly forwarding each interface point to the; /// wrapped type which must implement a compatible interface. This provides; /// a type erased binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:199,Integrability,interface,interface,199,"/// A base class to help implement the function alias analysis results concept.; ///; /// Because of the nature of many alias analysis implementations, they often; /// only implement a subset of the interface. This base class will attempt to; /// implement the remaining portions of the interface in terms of simpler forms; /// of the interface where possible, and otherwise provide conservatively; /// correct fallback implementations.; ///; /// Implementors of an alias analysis should derive from this class, and then; /// override specific methods that they wish to customize. There is no need to; /// use virtual anywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:287,Integrability,interface,interface,287,"/// A base class to help implement the function alias analysis results concept.; ///; /// Because of the nature of many alias analysis implementations, they often; /// only implement a subset of the interface. This base class will attempt to; /// implement the remaining portions of the interface in terms of simpler forms; /// of the interface where possible, and otherwise provide conservatively; /// correct fallback implementations.; ///; /// Implementors of an alias analysis should derive from this class, and then; /// override specific methods that they wish to customize. There is no need to; /// use virtual anywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:335,Integrability,interface,interface,335,"/// A base class to help implement the function alias analysis results concept.; ///; /// Because of the nature of many alias analysis implementations, they often; /// only implement a subset of the interface. This base class will attempt to; /// implement the remaining portions of the interface in terms of simpler forms; /// of the interface where possible, and otherwise provide conservatively; /// correct fallback implementations.; ///; /// Implementors of an alias analysis should derive from this class, and then; /// override specific methods that they wish to customize. There is no need to; /// use virtual anywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:309,Usability,simpl,simpler,309,"/// A base class to help implement the function alias analysis results concept.; ///; /// Because of the nature of many alias analysis implementations, they often; /// only implement a subset of the interface. This base class will attempt to; /// implement the remaining portions of the interface in terms of simpler forms; /// of the interface where possible, and otherwise provide conservatively; /// correct fallback implementations.; ///; /// Implementors of an alias analysis should derive from this class, and then; /// override specific methods that they wish to customize. There is no need to; /// use virtual anywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:118,Modifiability,Variab,Variables,118,/// Return true if this pointer refers to a distinct and identifiable object.; /// This returns true for:; /// Global Variables and Functions (but not Global Aliases); /// Allocas; /// ByVal and NoAlias Arguments; /// NoAlias returns (e.g. calls to malloc); ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:113,Integrability,depend,depend,113,"/// Return true if Object memory is not visible after an unwind, in the sense; /// that program semantics cannot depend on Object containing any particular; /// value on unwind. If the RequiresNoCaptureBeforeUnwind out parameter is set; /// to true, then the memory is only not visible if the object has not been; /// captured prior to the unwind. Otherwise it is not visible even if captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:113,Performance,load,loaded,113,"/// Return true if the Object is writable, in the sense that any location based; /// on this pointer that can be loaded can also be stored to without trapping.; /// Additionally, at the point Object is declared, stores can be introduced; /// without data races. At later points, this is only the case if the pointer; /// can not escape to a different thread.; ///; /// If ExplicitlyDereferenceableOnly is set to true, this property only holds; /// for the part of Object that is explicitly marked as dereferenceable, e.g.; /// using the dereferenceable(N) attribute. It does not necessarily hold for; /// parts that are only known to be dereferenceable due to the presence of; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:681,Performance,load,loads,681,"/// Return true if the Object is writable, in the sense that any location based; /// on this pointer that can be loaded can also be stored to without trapping.; /// Additionally, at the point Object is declared, stores can be introduced; /// without data races. At later points, this is only the case if the pointer; /// can not escape to a different thread.; ///; /// If ExplicitlyDereferenceableOnly is set to true, this property only holds; /// for the part of Object that is explicitly marked as dereferenceable, e.g.; /// using the dereferenceable(N) attribute. It does not necessarily hold for; /// parts that are only known to be dereferenceable due to the presence of; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:258,Availability,avail,available,258,"/// A manager for alias analyses.; ///; /// This class can have analyses registered with it and when run, it will run; /// all of them and aggregate their results into single AA results interface; /// that dispatches across all of the alias analysis results available.; ///; /// Note that the order in which analyses are registered is very significant.; /// That is the order in which the results will be aggregated and queried.; ///; /// This manager effectively wraps the AnalysisManager for registering alias; /// analyses. When you register your alias analysis with this manager, it will; /// ensure the analysis itself is registered with its AnalysisManager.; ///; /// The result of this analysis is only invalidated if one of the particular; /// aggregated AA results end up being invalidated. This removes the need to; /// explicitly preserve the results of `AAManager`. Note that analyses should no; /// longer be registered once the `AAManager` is run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:186,Integrability,interface,interface,186,"/// A manager for alias analyses.; ///; /// This class can have analyses registered with it and when run, it will run; /// all of them and aggregate their results into single AA results interface; /// that dispatches across all of the alias analysis results available.; ///; /// Note that the order in which analyses are registered is very significant.; /// That is the order in which the results will be aggregated and queried.; ///; /// This manager effectively wraps the AnalysisManager for registering alias; /// analyses. When you register your alias analysis with this manager, it will; /// ensure the analysis itself is registered with its AnalysisManager.; ///; /// The result of this analysis is only invalidated if one of the particular; /// aggregated AA results end up being invalidated. This removes the need to; /// explicitly preserve the results of `AAManager`. Note that analyses should no; /// longer be registered once the `AAManager` is run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:464,Integrability,wrap,wraps,464,"/// A manager for alias analyses.; ///; /// This class can have analyses registered with it and when run, it will run; /// all of them and aggregate their results into single AA results interface; /// that dispatches across all of the alias analysis results available.; ///; /// Note that the order in which analyses are registered is very significant.; /// That is the order in which the results will be aggregated and queried.; ///; /// This manager effectively wraps the AnalysisManager for registering alias; /// analyses. When you register your alias analysis with this manager, it will; /// ensure the analysis itself is registered with its AnalysisManager.; ///; /// The result of this analysis is only invalidated if one of the particular; /// aggregated AA results end up being invalidated. This removes the need to; /// explicitly preserve the results of `AAManager`. Note that analyses should no; /// longer be registered once the `AAManager` is run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:6,Integrability,wrap,wrapper,6,/// A wrapper pass to provide the legacy pass manager access to a suitably; /// prepared AAResults object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:54,Security,access,access,54,/// A wrapper pass to provide the legacy pass manager access to a suitably; /// prepared AAResults object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:6,Integrability,wrap,wrapper,6,/// A wrapper pass for external alias analyses. This just squirrels away the; /// callback used to run any analyses and register their results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:403,Deployability,pipeline,pipeline,403,"/// A wrapper pass around a callback which can be used to populate the; /// AAResults in the AAResultsWrapperPass from an external AA.; ///; /// The callback provided here will be used each time we prepare an AAResults; /// object, and will receive a reference to the function wrapper pass, the; /// function, and the AAResults object to populate. This should be used when; /// setting up a custom pass pipeline to inject a hook into the AA results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:6,Integrability,wrap,wrapper,6,"/// A wrapper pass around a callback which can be used to populate the; /// AAResults in the AAResultsWrapperPass from an external AA.; ///; /// The callback provided here will be used each time we prepare an AAResults; /// object, and will receive a reference to the function wrapper pass, the; /// function, and the AAResults object to populate. This should be used when; /// setting up a custom pass pipeline to inject a hook into the AA results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:277,Integrability,wrap,wrapper,277,"/// A wrapper pass around a callback which can be used to populate the; /// AAResults in the AAResultsWrapperPass from an external AA.; ///; /// The callback provided here will be used each time we prepare an AAResults; /// object, and will receive a reference to the function wrapper pass, the; /// function, and the AAResults object to populate. This should be used when; /// setting up a custom pass pipeline to inject a hook into the AA results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:415,Integrability,inject,inject,415,"/// A wrapper pass around a callback which can be used to populate the; /// AAResults in the AAResultsWrapperPass from an external AA.; ///; /// The callback provided here will be used each time we prepare an AAResults; /// object, and will receive a reference to the function wrapper pass, the; /// function, and the AAResults object to populate. This should be used when; /// setting up a custom pass pipeline to inject a hook into the AA results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:415,Security,inject,inject,415,"/// A wrapper pass around a callback which can be used to populate the; /// AAResults in the AAResultsWrapperPass from an external AA.; ///; /// The callback provided here will be used each time we prepare an AAResults; /// object, and will receive a reference to the function wrapper pass, the; /// function, and the AAResults object to populate. This should be used when; /// setting up a custom pass pipeline to inject a hook into the AA results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h:783,Deployability,pipeline,pipeline,783,"//===- AliasAnalysisEvaluator.h - Alias Analysis Accuracy Evaluator -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a simple N^2 alias analysis accuracy evaluator. The; /// analysis result is a set of statistics of how many times the AA; /// infrastructure provides each kind of alias result and mod/ref result when; /// queried with all pairs of pointers in the function.; ///; /// It can be used to evaluate a change in an alias analysis implementation,; /// algorithm, or the AA pipeline infrastructure itself. It acts like a stable; /// and easily tested consumer of all AA information exposed.; ///; /// This is inspired and adapted from code by: Naveen Neelakantam, Francesco; /// Spadini, and Wojciech Stryjewski.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h:931,Energy Efficiency,adapt,adapted,931,"//===- AliasAnalysisEvaluator.h - Alias Analysis Accuracy Evaluator -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a simple N^2 alias analysis accuracy evaluator. The; /// analysis result is a set of statistics of how many times the AA; /// infrastructure provides each kind of alias result and mod/ref result when; /// queried with all pairs of pointers in the function.; ///; /// It can be used to evaluate a change in an alias analysis implementation,; /// algorithm, or the AA pipeline infrastructure itself. It acts like a stable; /// and easily tested consumer of all AA information exposed.; ///; /// This is inspired and adapted from code by: Naveen Neelakantam, Francesco; /// Spadini, and Wojciech Stryjewski.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h:931,Modifiability,adapt,adapted,931,"//===- AliasAnalysisEvaluator.h - Alias Analysis Accuracy Evaluator -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a simple N^2 alias analysis accuracy evaluator. The; /// analysis result is a set of statistics of how many times the AA; /// infrastructure provides each kind of alias result and mod/ref result when; /// queried with all pairs of pointers in the function.; ///; /// It can be used to evaluate a change in an alias analysis implementation,; /// algorithm, or the AA pipeline infrastructure itself. It acts like a stable; /// and easily tested consumer of all AA information exposed.; ///; /// This is inspired and adapted from code by: Naveen Neelakantam, Francesco; /// Spadini, and Wojciech Stryjewski.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h:891,Security,expose,exposed,891,"//===- AliasAnalysisEvaluator.h - Alias Analysis Accuracy Evaluator -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a simple N^2 alias analysis accuracy evaluator. The; /// analysis result is a set of statistics of how many times the AA; /// infrastructure provides each kind of alias result and mod/ref result when; /// queried with all pairs of pointers in the function.; ///; /// It can be used to evaluate a change in an alias analysis implementation,; /// algorithm, or the AA pipeline infrastructure itself. It acts like a stable; /// and easily tested consumer of all AA information exposed.; ///; /// This is inspired and adapted from code by: Naveen Neelakantam, Francesco; /// Spadini, and Wojciech Stryjewski.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h:853,Testability,test,tested,853,"//===- AliasAnalysisEvaluator.h - Alias Analysis Accuracy Evaluator -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a simple N^2 alias analysis accuracy evaluator. The; /// analysis result is a set of statistics of how many times the AA; /// infrastructure provides each kind of alias result and mod/ref result when; /// queried with all pairs of pointers in the function.; ///; /// It can be used to evaluate a change in an alias analysis implementation,; /// algorithm, or the AA pipeline infrastructure itself. It acts like a stable; /// and easily tested consumer of all AA information exposed.; ///; /// This is inspired and adapted from code by: Naveen Neelakantam, Francesco; /// Spadini, and Wojciech Stryjewski.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h:419,Usability,simpl,simple,419,"//===- AliasAnalysisEvaluator.h - Alias Analysis Accuracy Evaluator -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a simple N^2 alias analysis accuracy evaluator. The; /// analysis result is a set of statistics of how many times the AA; /// infrastructure provides each kind of alias result and mod/ref result when; /// queried with all pairs of pointers in the function.; ///; /// It can be used to evaluate a change in an alias analysis implementation,; /// algorithm, or the AA pipeline infrastructure itself. It acts like a stable; /// and easily tested consumer of all AA information exposed.; ///; /// This is inspired and adapted from code by: Naveen Neelakantam, Francesco; /// Spadini, and Wojciech Stryjewski.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:450,Integrability,interface,interfaces,450,"//===- llvm/Analysis/AliasSetTracker.h - Build Alias Sets -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines two classes: AliasSetTracker and AliasSet. These interfaces; // are used to classify a collection of memory locations into a maximal number; // of disjoint sets. Each AliasSet object constructed by the AliasSetTracker; // object refers to memory disjoint from the other sets.; //; // An AliasSetTracker can only be used on immutable IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:17,Security,access,access,17,"/// The kinds of access this alias set models.; ///; /// We keep track of whether this alias set merely refers to the locations of; /// memory (and not any particular access), whether it modifies or references; /// the memory, or whether it does both. The lattice goes from ""NoAccess"" to; /// either RefAccess or ModAccess, then to ModRefAccess as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:167,Security,access,access,167,"/// The kinds of access this alias set models.; ///; /// We keep track of whether this alias set merely refers to the locations of; /// memory (and not any particular access), whether it modifies or references; /// the memory, or whether it does both. The lattice goes from ""NoAccess"" to; /// either RefAccess or ModAccess, then to ModRefAccess as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:4,Security,Access,Accessors,4,/// Accessors...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:31,Security,access,access,31,// Alias Set iteration - Allow access to all of the memory locations which are; // part of this alias set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:110,Performance,load,load,110,"/// Create an empty collection of AliasSets, and use the specified alias; /// analysis object to disambiguate load and store addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:3,Deployability,Update,Update,3,"// Update an alias set field to point to its real destination. If the field is; // pointing to a set that has been merged with another set and is forwarding,; // the field is updated to point to the set obtained by following the; // forwarding links. The Forward fields of intermediate alias sets are; // collapsed as well, and alias set reference counts are updated to reflect; // the new situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:175,Deployability,update,updated,175,"// Update an alias set field to point to its real destination. If the field is; // pointing to a set that has been merged with another set and is forwarding,; // the field is updated to point to the set obtained by following the; // forwarding links. The Forward fields of intermediate alias sets are; // collapsed as well, and alias set reference counts are updated to reflect; // the new situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:359,Deployability,update,updated,359,"// Update an alias set field to point to its real destination. If the field is; // pointing to a set that has been merged with another set and is forwarding,; // the field is updated to point to the set obtained by following the; // forwarding links. The Forward fields of intermediate alias sets are; // collapsed as well, and alias set reference counts are updated to reflect; // the new situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumeBundleQueries.h:153,Integrability,depend,depends,153,/// A mapping from intrinsics (=`llvm.assume` calls) to a value range; /// (=knowledge) that is encoded in them. How the value range is interpreted; /// depends on the RetainedKnowledgeKey that was used to get this out of the; /// RetainedKnowledgeMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumeBundleQueries.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumeBundleQueries.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:574,Performance,optimiz,optimizer,574,"//===- llvm/Analysis/AssumptionCache.h - Track @llvm.assume -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that keeps track of @llvm.assume intrinsics in; // the functions of a module (allowing assumptions within any function to be; // found cheaply by other parts of the optimizer).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:6,Performance,cache,cache,6,/// A cache of \@llvm.assume calls within a function.; ///; /// This cache provides fast lookup of assumptions within a function by caching; /// them and amortizing the cost of scanning for them across all queries. Passes; /// that create new assumptions are required to call registerAssumption() to; /// register any new \@llvm.assume calls that they create. Deletions of; /// \@llvm.assume calls do not require special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:69,Performance,cache,cache,69,/// A cache of \@llvm.assume calls within a function.; ///; /// This cache provides fast lookup of assumptions within a function by caching; /// them and amortizing the cost of scanning for them across all queries. Passes; /// that create new assumptions are required to call registerAssumption() to; /// register any new \@llvm.assume calls that they create. Deletions of; /// \@llvm.assume calls do not require special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:32,Performance,cache,cache,32,/// The function for which this cache is handling assumptions.; ///; /// We track this to lazily populate our assumptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:64,Performance,cache,cache,64,/// Get the vector of assumptions which affect a value from the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:32,Performance,cache,cache,32,/// Move affected values in the cache for OV to be affected values for NV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:58,Performance,cache,cache,58,/// Scan the function for assumptions and add them to the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:9,Performance,cache,cache,9,/// This cache is designed to be self-updating and so it should never be; /// invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:54,Performance,cache,cache,54,/// Add an \@llvm.assume intrinsic to this function's cache.; ///; /// The call passed in must be an instruction within this function and must; /// not already be in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:170,Performance,cache,cache,170,/// Add an \@llvm.assume intrinsic to this function's cache.; ///; /// The call passed in must be an instruction within this function and must; /// not already be in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:59,Performance,cache,cache,59,/// Remove an \@llvm.assume intrinsic from this function's cache if it has; /// been added to the cache earlier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:98,Performance,cache,cache,98,/// Remove an \@llvm.assume intrinsic from this function's cache if it has; /// been added to the cache earlier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:4,Deployability,Update,Update,4,/// Update the cache of values being affected by this assumption (i.e.; /// the values about which this assumption provides information).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:15,Performance,cache,cache,15,/// Update the cache of values being affected by this assumption (i.e.; /// the values about which this assumption provides information).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:14,Performance,cache,cache,14,/// Clear the cache of \@llvm.assume intrinsics for a function.; ///; /// It will be re-scanned the next time it is requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:4,Usability,Clear,Clear,4,/// Clear the cache of \@llvm.assume intrinsics for a function.; ///; /// It will be re-scanned the next time it is requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:4,Security,Access,Access,4,/// Access the list of assumption handles currently tracked for this; /// function.; ///; /// Note that these produce weak handles that may be null. The caller must; /// handle that case.; /// FIXME: We should replace this with pointee_iterator<filter_iterator<...>>; /// when we can write that to filter out the null values. Then caller code; /// will become simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:360,Usability,simpl,simpler,360,/// Access the list of assumption handles currently tracked for this; /// function.; ///; /// Note that these produce weak handles that may be null. The caller must; /// handle that case.; /// FIXME: We should replace this with pointee_iterator<filter_iterator<...>>; /// when we can write that to filter out the null values. Then caller code; /// will become simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:4,Security,Access,Access,4,/// Access the list of assumptions which affect this value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:162,Performance,cache,caches,162,/// A function analysis which provides an \c AssumptionCache.; ///; /// This analysis is intended for use with the new pass manager and will vend; /// assumption caches for a given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:204,Performance,cache,cache,204,/// An immutable pass that tracks lazily created \c AssumptionCache; /// objects.; ///; /// This is essentially a workaround for the legacy pass manager's weaknesses; /// which associates each assumption cache with Function and clears it if the; /// function is deleted. The nature of the AssumptionCache is that it is not; /// invalidated by any changes to the function body and so this is sufficient; /// to be conservatively correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:228,Usability,clear,clears,228,/// An immutable pass that tracks lazily created \c AssumptionCache; /// objects.; ///; /// This is essentially a workaround for the legacy pass manager's weaknesses; /// which associates each assumption cache with Function and clears it if the; /// function is deleted. The nature of the AssumptionCache is that it is not; /// invalidated by any changes to the function body and so this is sufficient; /// to be conservatively correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:89,Performance,cache,cache,89,"/// A callback value handle applied to function objects, which we use to; /// delete our cache of intrinsics for a function when it is deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:12,Performance,cache,cached,12,"/// Get the cached assumptions for a function.; ///; /// If no assumptions are cached, this will scan the function. Otherwise, the; /// existing cache will be returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:79,Performance,cache,cached,79,"/// Get the cached assumptions for a function.; ///; /// If no assumptions are cached, this will scan the function. Otherwise, the; /// existing cache will be returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:145,Performance,cache,cache,145,"/// Get the cached assumptions for a function.; ///; /// If no assumptions are cached, this will scan the function. Otherwise, the; /// existing cache will be returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:15,Performance,cache,cached,15,/// Return the cached assumptions for a function if it has already been; /// scanned. Otherwise return nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:403,Integrability,interface,interface,403,"//===- BasicAliasAnalysis.h - Stateless, local Alias Analysis ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This is the interface for LLVM's primary stateless and local alias analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:117,Integrability,interface,interface,117,"/// This is the AA result object for the basic, local, and stateless alias; /// analysis. It implements the AA query interface in an entirely stateless; /// manner. As one consequence, it is never invalidated due to IR changes.; /// While it does retain some storage, that is used as an optimization and not; /// to preserve information from query to query. However it does retain handles; /// to various other analyses and must be recomputed when those analyses are.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:287,Performance,optimiz,optimization,287,"/// This is the AA result object for the basic, local, and stateless alias; /// analysis. It implements the AA query interface in an entirely stateless; /// manner. As one consequence, it is never invalidated due to IR changes.; /// While it does retain some storage, that is used as an optimization and not; /// to preserve information from query to query. However it does retain handles; /// to various other analyses and must be recomputed when those analyses are.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:27,Security,access,accessing,27,"/// Use getDT() instead of accessing this member directly, in order to; /// respect the AAQI.UseDominatorTree option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:82,Modifiability,variab,variables,82,"/// A Heuristic for aliasGEP that searches for a constant offset; /// between the variables.; ///; /// GetLinearExpression has some limitations, as generally zext(%x + 1); /// != zext(%x) + zext(1) if the arithmetic overflows. GetLinearExpression; /// will therefore conservatively refuse to decompose these expressions.; /// However, we know that, for all %x, zext(%x) != zext(%x + 1), even if; /// the addition overflows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the BasicAAResult object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h:399,Usability,simpl,simplified,399,"//===- BlockFrequencyInfo.h - Block Frequency Analysis ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loops should be simplified before this analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h:287,Safety,avoid,avoid,287,"/// getblockFreq - Return block frequency. Return 0 if we don't have the; /// information. Please note that initial frequency is equal to ENTRY_FREQ. It; /// means that we should not rely on the value itself, but only on the; /// comparison to the other block frequencies. We do this to avoid using of; /// floating points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h:168,Availability,avail,available,168,/// Returns the estimated profile count of \p BB.; /// This computes the relative block frequency of \p BB and multiplies it by; /// the enclosing function's count (if available) and returns the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h:150,Availability,avail,available,150,/// Returns the estimated profile count of \p Freq.; /// This uses the frequency \p Freq and multiplies it by; /// the enclosing function's count (if available) and returns the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:244,Usability,Simpl,Simple,244,"/// Mass of a block.; ///; /// This class implements a sort of fixed-point fraction always between 0.0 and; /// 1.0. getMass() == std::numeric_limits<uint64_t>::max() indicates a value of; /// 1.0.; ///; /// Masses can be added and subtracted. Simple saturation arithmetic is used,; /// so arithmetic operations never overflow or underflow.; ///; /// Masses can be multiplied. Multiplication treats full mass as 1.0 and uses; /// an inexpensive floating-point algorithm that's off-by-one (almost, but not; /// quite, maximum precision).; ///; /// Masses can be scaled by \a BranchProbability at maximum precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:217,Integrability,depend,depend,217,"// end namespace bfi_detail; /// Base class for BlockFrequencyInfoImpl; ///; /// BlockFrequencyInfoImplBase has supporting data structures and some; /// algorithms for BlockFrequencyInfoImplBase. Only algorithms that depend on; /// the block type (or that call such algorithms) are skipped here.; ///; /// Nevertheless, the majority of the overall algorithm documentation lives with; /// BlockFrequencyInfoImpl. See there for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:58,Integrability,wrap,wrapper,58,"/// Representative of a block.; ///; /// This is a simple wrapper around an index into the reverse-post-order; /// traversal of the blocks.; ///; /// Unlike a block pointer, its order has meaning (location in the; /// topological sort) and it's class is the same regardless of block type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:51,Usability,simpl,simple,51,"/// Representative of a block.; ///; /// This is a simple wrapper around an index into the reverse-post-order; /// traversal of the blocks.; ///; /// Unlike a block pointer, its order has meaning (location in the; /// topological sort) and it's class is the same regardless of block type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:116,Availability,down,down,116,"/// Normalize the distribution.; ///; /// Combines multiple edges to the same \a Weight::TargetNode and scales; /// down so that \a Total fits into 32-bits.; ///; /// This is linear in the size of \a Weights. For the vast majority of; /// cases, adjacent edge weights are combined by sorting WeightList and; /// combining adjacent weights. However, for very large edge lists an; /// auxiliary hash table is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:393,Security,hash,hash,393,"/// Normalize the distribution.; ///; /// Combines multiple edges to the same \a Weight::TargetNode and scales; /// down so that \a Total fits into 32-bits.; ///; /// This is linear in the size of \a Weights. For the vast majority of; /// cases, adjacent edge weights are combined by sorting WeightList and; /// combining adjacent weights. However, for very large edge lists an; /// auxiliary hash table is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:40,Availability,down,downstream,40,/// Data about each block. This is used downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:72,Availability,down,downstream,72,/// Whether each block is an irreducible loop header.; /// This is used downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:63,Availability,mask,mask,63,/// Virtual destructor.; ///; /// Need a virtual destructor to mask the compiler warning about; /// getBlockName().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:306,Safety,abort,aborted,306,"/// Add an edge to the distribution.; ///; /// Adds an edge to Succ to Dist. If \c LoopHead.isValid(), then whether the; /// edge is local/exit/backedge is in the context of LoopHead. Otherwise,; /// every edge should be a local edge (since all the loops are packaged up).; ///; /// \return \c true unless aborted due to an irreducible backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:4,Deployability,Update,Update,4,"/// Update a loop after packaging irreducible SCCs inside of it.; ///; /// Update \c OuterLoop. Before finding irreducible control flow, it was; /// partway through \a computeMassInLoop(), so \a LoopData::Exits and \a; /// LoopData::BackedgeMass need to be reset. Also, nodes that were packaged; /// up need to be removed from \a OuterLoop::Nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:75,Deployability,Update,Update,75,"/// Update a loop after packaging irreducible SCCs inside of it.; ///; /// Update \c OuterLoop. Before finding irreducible control flow, it was; /// partway through \a computeMassInLoop(), so \a LoopData::Exits and \a; /// LoopData::BackedgeMass need to be reset. Also, nodes that were packaged; /// up need to be removed from \a OuterLoop::Nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:4,Usability,Clear,Clear,4,/// Clear all memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:4079,Availability,down,down,4079,"ersal through; /// the loop. Start by assigning full mass to the Loop header. For each; /// node in the loop:; ///; /// - Fetch and categorize the weight distribution for its successors.; /// If this is a packaged-subloop, the weight distribution is stored; /// in \a LoopData::Exits. Otherwise, fetch it from; /// BranchProbabilityInfo.; ///; /// - Each successor is categorized as \a Weight::Local, a local edge; /// within the current loop, \a Weight::Backedge, a backedge to the; /// loop header, or \a Weight::Exit, any successor outside the loop.; /// The weight, the successor, and its category are stored in \a; /// Distribution. There can be multiple edges to each successor.; ///; /// - If there's a backedge to a non-header, there's an irreducible SCC.; /// The usual flow is temporarily aborted. \a; /// computeIrreducibleMass() finds the irreducible SCCs within the; /// loop, packages them up, and restarts the flow.; ///; /// - Normalize the distribution: scale weights down so that their sum; /// is 32-bits, and coalesce multiple edges to the same node.; ///; /// - Distribute the mass accordingly, dithering to minimize mass loss,; /// as described in \a distributeMass().; ///; /// In the case of irreducible loops, instead of a single loop header,; /// there will be several. The computation of backedge masses is similar; /// but instead of having a single backedge mass, there will be one; /// backedge per loop header. In these cases, each backedge will carry; /// a mass proportional to the edge weights along the corresponding; /// path.; ///; /// At the end of propagation, the full mass assigned to the loop will be; /// distributed among the loop headers proportionally according to the; /// mass flowing through their backedges.; ///; /// Finally, calculate the loop scale from the accumulated backedge mass.; ///; /// 3. Distribute mass in the function (\a computeMassInFunction()).; ///; /// Finally, distribute mass through the DAG resulting from packaging all; /// lo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:5402,Availability,down,down,5402,"/// but instead of having a single backedge mass, there will be one; /// backedge per loop header. In these cases, each backedge will carry; /// a mass proportional to the edge weights along the corresponding; /// path.; ///; /// At the end of propagation, the full mass assigned to the loop will be; /// distributed among the loop headers proportionally according to the; /// mass flowing through their backedges.; ///; /// Finally, calculate the loop scale from the accumulated backedge mass.; ///; /// 3. Distribute mass in the function (\a computeMassInFunction()).; ///; /// Finally, distribute mass through the DAG resulting from packaging all; /// loops in the function. This uses the same algorithm as distributing; /// mass in a loop, except that there are no exit or backedge edges.; ///; /// 4. Unpackage loops (\a unwrapLoops()).; ///; /// Initialize each block's frequency to a floating point representation of; /// its mass.; ///; /// Visit loops top-down, scaling the frequencies of its immediate members; /// by the loop's pseudo-node's frequency.; ///; /// 5. Convert frequencies to a 64-bit range (\a finalizeMetrics()).; ///; /// Using the min and max frequencies as a guide, translate floating point; /// frequencies to an appropriate range in uint64_t.; ///; /// It has some known flaws.; ///; /// - The model of irreducible control flow is a rough approximation.; ///; /// Modelling irreducible control flow exactly involves setting up and; /// solving a group of infinite geometric series. Such precision is; /// unlikely to be worthwhile, since most of our algorithms give up on; /// irreducible control flow anyway.; ///; /// Nevertheless, we might find that we need to get closer. Here's a sort; /// of TODO list for the model with diminishing returns, to be completed as; /// necessary.; ///; /// - The headers for the \a LoopData representing an irreducible SCC; /// include non-entry blocks. When these extra blocks exist, they; /// indicate a self-contained irreducible s",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:1637,Integrability,wrap,wrapper,1637,"ble; /// SCCs, which are SCCs with multiple entry blocks. Irreducible SCCs are; /// discovered on the fly, and modelled as loops with multiple headers.; ///; /// The headers of irreducible sub-SCCs consist of its entry blocks and all; /// nodes that are targets of a backedge within it (excluding backedges within; /// true sub-loops). Block frequency calculations act as if a block is; /// inserted that intercepts all the edges to the headers. All backedges and; /// entries point to this block. Its successors are the headers, which split; /// the frequency evenly.; ///; /// This algorithm leverages BlockMass and ScaledNumber to maintain precision,; /// separates mass distribution from loop scaling, and dithers to eliminate; /// probability mass loss.; ///; /// The implementation is split between BlockFrequencyInfoImpl, which knows the; /// type of graph being modelled (BasicBlock vs. MachineBasicBlock), and; /// BlockFrequencyInfoImplBase, which doesn't. The base class uses \a; /// BlockNode, a wrapper around a uint32_t. BlockNode is numbered from 0 in; /// reverse-post order. This gives two advantages: it's easy to compare the; /// relative ordering of two nodes, and maps keyed on BlockT can be represented; /// by vectors.; ///; /// This algorithm is O(V+E), unless there is irreducible control flow, in; /// which case it's O(V*E) in the worst case.; ///; /// These are the main stages:; ///; /// 0. Reverse post-order traversal (\a initializeRPOT()).; ///; /// Run a single post-order traversal and save it (in reverse) in RPOT.; /// All other stages make use of this ordering. Save a lookup from BlockT; /// to BlockNode (the index into RPOT) in Nodes.; ///; /// 1. Loop initialization (\a initializeLoops()).; ///; /// Translate LoopInfo/MachineLoopInfo into a form suitable for the rest of; /// the algorithm. In particular, store the immediate members of each loop; /// in reverse post-order.; ///; /// 2. Calculate mass and scale in loops (\a computeMassInLoops()).; ///; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:3893,Safety,abort,aborted,3893,"le (number of loop iterations). Immediate; /// members that represent sub-loops will already have been visited and; /// packaged into a pseudo-node.; ///; /// Distributing mass in a loop is a reverse-post-order traversal through; /// the loop. Start by assigning full mass to the Loop header. For each; /// node in the loop:; ///; /// - Fetch and categorize the weight distribution for its successors.; /// If this is a packaged-subloop, the weight distribution is stored; /// in \a LoopData::Exits. Otherwise, fetch it from; /// BranchProbabilityInfo.; ///; /// - Each successor is categorized as \a Weight::Local, a local edge; /// within the current loop, \a Weight::Backedge, a backedge to the; /// loop header, or \a Weight::Exit, any successor outside the loop.; /// The weight, the successor, and its category are stored in \a; /// Distribution. There can be multiple edges to each successor.; ///; /// - If there's a backedge to a non-header, there's an irreducible SCC.; /// The usual flow is temporarily aborted. \a; /// computeIrreducibleMass() finds the irreducible SCCs within the; /// loop, packages them up, and restarts the flow.; ///; /// - Normalize the distribution: scale weights down so that their sum; /// is 32-bits, and coalesce multiple edges to the same node.; ///; /// - Distribute the mass accordingly, dithering to minimize mass loss,; /// as described in \a distributeMass().; ///; /// In the case of irreducible loops, instead of a single loop header,; /// there will be several. The computation of backedge masses is similar; /// but instead of having a single backedge mass, there will be one; /// backedge per loop header. In these cases, each backedge will carry; /// a mass proportional to the edge weights along the corresponding; /// path.; ///; /// At the end of propagation, the full mass assigned to the loop will be; /// distributed among the loop headers proportionally according to the; /// mass flowing through their backedges.; ///; /// Finally, calculat",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:5625,Usability,guid,guide,5625,"ing; /// path.; ///; /// At the end of propagation, the full mass assigned to the loop will be; /// distributed among the loop headers proportionally according to the; /// mass flowing through their backedges.; ///; /// Finally, calculate the loop scale from the accumulated backedge mass.; ///; /// 3. Distribute mass in the function (\a computeMassInFunction()).; ///; /// Finally, distribute mass through the DAG resulting from packaging all; /// loops in the function. This uses the same algorithm as distributing; /// mass in a loop, except that there are no exit or backedge edges.; ///; /// 4. Unpackage loops (\a unwrapLoops()).; ///; /// Initialize each block's frequency to a floating point representation of; /// its mass.; ///; /// Visit loops top-down, scaling the frequencies of its immediate members; /// by the loop's pseudo-node's frequency.; ///; /// 5. Convert frequencies to a 64-bit range (\a finalizeMetrics()).; ///; /// Using the min and max frequencies as a guide, translate floating point; /// frequencies to an appropriate range in uint64_t.; ///; /// It has some known flaws.; ///; /// - The model of irreducible control flow is a rough approximation.; ///; /// Modelling irreducible control flow exactly involves setting up and; /// solving a group of infinite geometric series. Such precision is; /// unlikely to be worthwhile, since most of our algorithms give up on; /// irreducible control flow anyway.; ///; /// Nevertheless, we might find that we need to get closer. Here's a sort; /// of TODO list for the model with diminishing returns, to be completed as; /// necessary.; ///; /// - The headers for the \a LoopData representing an irreducible SCC; /// include non-entry blocks. When these extra blocks exist, they; /// indicate a self-contained irreducible sub-SCC. We could treat them; /// as sub-loops, rather than arbitrarily shoving the problematic; /// blocks into the headers of the main irreducible SCC.; ///; /// - Entry frequencies are assumed to be even",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:128,Safety,abort,aborts,128,"/// Compute mass in all loops.; ///; /// For each loop bottom-up, call \a computeMassInLoop().; ///; /// \a computeMassInLoop() aborts (and returns \c false) on loops that; /// contain a irreducible sub-SCCs. Use \a computeIrreducibleMass() and then; /// re-enter \a computeMassInLoop().; ///; /// \post \a computeMassInLoop() has returned \c true for every loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:238,Deployability,update,updates,238,"/// The current implementation for computing relative block frequencies does; /// not handle correctly control-flow graphs containing irreducible loops. To; /// resolve the problem, we apply a post-processing step, which iteratively; /// updates block frequencies based on the frequencies of their predesessors.; /// This corresponds to finding the stationary point of the Markov chain by; /// an iterative method aka ""PageRank computation"".; /// The algorithm takes at most O(|E| * IterativeBFIMaxIterations) steps but; /// typically converges faster.; ///; /// Decide whether we want to apply iterative inference for a given function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:76,Safety,avoid,avoid,76,"// We don't erase corresponding items from `Freqs`, `RPOT` and other to; // avoid invalidating indices. Doing so would have saved some memory, but; // it's not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:291,Testability,test,tests,291,"/// Print the frequencies for the current function.; ///; /// Prints the frequencies for the blocks in the current function.; ///; /// Blocks are printed in the natural iteration order of the function, rather; /// than reverse post-order. This provides two advantages: writing -analyze; /// tests is easier (since blocks come out in source order), and even; /// unreachable blocks are printed.; ///; /// \a BlockFrequencyInfoImplBase::print() only knows reverse post-order, so; /// we need to override it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:6,Safety,detect,detect,6,"// To detect BFI queries for unknown blocks, add entries for unreachable; // blocks, if any. This is to distinguish between known/existing unreachable; // blocks and unknown blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:19,Availability,down,down,19,// Visit loops top down and assign them an index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:301,Deployability,update,update,301,"// As a heuristic, if some headers don't have a weight, give them the; // minimum weight seen (not to disrupt the existing trends too much by; // using a weight that's in the general range of the other headers' weights,; // and the minimum seems to perform better than the average.); // FIXME: better update in the passes that drop the header weight.; // If no headers have a weight, give them even weight (use weight 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:249,Performance,perform,perform,249,"// As a heuristic, if some headers don't have a weight, give them the; // minimum weight seen (not to disrupt the existing trends too much by; // using a weight that's in the general range of the other headers' weights,; // and the minimum seems to perform better than the average.); // FIXME: better update in the passes that drop the header weight.; // If no headers have a weight, give them even weight (use weight 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:97,Deployability,update,updated,97,"// To speedup computation, we maintain a set of ""active"" blocks whose; // frequencies need to be updated based on the incoming edges.; // The set is dynamic and changes after every update. Initially all blocks; // with a positive frequency are active",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:181,Deployability,update,update,181,"// To speedup computation, we maintain a set of ""active"" blocks whose; // frequencies need to be updated based on the incoming edges.; // The set is dynamic and changes after every update. Initially all blocks; // with a positive frequency are active",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:3,Deployability,Update,Update,3,// Update the frequency for the block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:777,Testability,log,logically,777,"/// Analysis providing branch probability information.; ///; /// This is a function analysis which provides information on the relative; /// probabilities of each ""edge"" in the function's CFG where such an edge is; /// defined by a pair (PredBlock and an index in the successors). The; /// probability of an edge from one block is always relative to the; /// probabilities of other edges from the block. The probabilites of all edges; /// from a block sum to exactly one (100%).; /// We use a pair (PredBlock and an index in the successors) to uniquely; /// identify an edge, since we can have multiple edges from Src to Dst.; /// As an example, we can have a switch which jumps to Dst with value 0 and; /// value 10.; ///; /// Process of computing branch probabilities can be logically viewed as three; /// step process:; ///; /// First, if there is a profile information associated with the branch then; /// it is trivially translated to branch probabilities. There is one exception; /// from this rule though. Probabilities for edges leading to ""unreachable""; /// blocks (blocks with the estimated weight not greater than; /// UNREACHABLE_WEIGHT) are evaluated according to static estimation and; /// override profile information. If no branch probabilities were calculated; /// on this step then take the next one.; ///; /// Second, estimate absolute execution weights for each block based on; /// statically known information. Roots of such information are ""cold"",; /// ""unreachable"", ""noreturn"" and ""unwind"" blocks. Those blocks get their; /// weights set to BlockExecWeight::COLD, BlockExecWeight::UNREACHABLE,; /// BlockExecWeight::NORETURN and BlockExecWeight::UNWIND respectively. Then the; /// weights are propagated to the other blocks up the domination line. In; /// addition, if all successors have estimated weights set then maximum of these; /// weights assigned to the block itself (while this is not ideal heuristic in; /// theory it's simple and works reasonably well in most cases)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:1954,Usability,simpl,simple,1954,"hen; /// it is trivially translated to branch probabilities. There is one exception; /// from this rule though. Probabilities for edges leading to ""unreachable""; /// blocks (blocks with the estimated weight not greater than; /// UNREACHABLE_WEIGHT) are evaluated according to static estimation and; /// override profile information. If no branch probabilities were calculated; /// on this step then take the next one.; ///; /// Second, estimate absolute execution weights for each block based on; /// statically known information. Roots of such information are ""cold"",; /// ""unreachable"", ""noreturn"" and ""unwind"" blocks. Those blocks get their; /// weights set to BlockExecWeight::COLD, BlockExecWeight::UNREACHABLE,; /// BlockExecWeight::NORETURN and BlockExecWeight::UNWIND respectively. Then the; /// weights are propagated to the other blocks up the domination line. In; /// addition, if all successors have estimated weights set then maximum of these; /// weights assigned to the block itself (while this is not ideal heuristic in; /// theory it's simple and works reasonably well in most cases) and the process; /// repeats. Once the process of weights propagation converges branch; /// probabilities are set for all such branches that have at least one successor; /// with the weight set. Default execution weight (BlockExecWeight::DEFAULT) is; /// used for any successors which doesn't have its weight set. For loop back; /// branches we use their weights scaled by loop trip count equal to; /// 'LBH_TAKEN_WEIGHT/LBH_NOTTAKEN_WEIGHT'.; ///; /// Here is a simple example demonstrating how the described algorithm works.; ///; /// BB1; /// / \; /// v v; /// BB2 BB3; /// / \; /// v v; /// ColdBB UnreachBB; ///; /// Initially, ColdBB is associated with COLD_WEIGHT and UnreachBB with; /// UNREACHABLE_WEIGHT. COLD_WEIGHT is set to BB2 as maximum between its; /// successors. BB1 and BB3 has no explicit estimated weights and assumed to; /// have DEFAULT_WEIGHT. Based on assigned weights branc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:2465,Usability,simpl,simple,2465,"e"", ""noreturn"" and ""unwind"" blocks. Those blocks get their; /// weights set to BlockExecWeight::COLD, BlockExecWeight::UNREACHABLE,; /// BlockExecWeight::NORETURN and BlockExecWeight::UNWIND respectively. Then the; /// weights are propagated to the other blocks up the domination line. In; /// addition, if all successors have estimated weights set then maximum of these; /// weights assigned to the block itself (while this is not ideal heuristic in; /// theory it's simple and works reasonably well in most cases) and the process; /// repeats. Once the process of weights propagation converges branch; /// probabilities are set for all such branches that have at least one successor; /// with the weight set. Default execution weight (BlockExecWeight::DEFAULT) is; /// used for any successors which doesn't have its weight set. For loop back; /// branches we use their weights scaled by loop trip count equal to; /// 'LBH_TAKEN_WEIGHT/LBH_NOTTAKEN_WEIGHT'.; ///; /// Here is a simple example demonstrating how the described algorithm works.; ///; /// BB1; /// / \; /// v v; /// BB2 BB3; /// / \; /// v v; /// ColdBB UnreachBB; ///; /// Initially, ColdBB is associated with COLD_WEIGHT and UnreachBB with; /// UNREACHABLE_WEIGHT. COLD_WEIGHT is set to BB2 as maximum between its; /// successors. BB1 and BB3 has no explicit estimated weights and assumed to; /// have DEFAULT_WEIGHT. Based on assigned weights branches will have the; /// following probabilities:; /// P(BB1->BB2) = COLD_WEIGHT/(COLD_WEIGHT + DEFAULT_WEIGHT) =; /// 0xffff / (0xffff + 0xfffff) = 0.0588(5.9%); /// P(BB1->BB3) = DEFAULT_WEIGHT_WEIGHT/(COLD_WEIGHT + DEFAULT_WEIGHT) =; /// 0xfffff / (0xffff + 0xfffff) = 0.941(94.1%); /// P(BB2->ColdBB) = COLD_WEIGHT/(COLD_WEIGHT + UNREACHABLE_WEIGHT) = 1(100%); /// P(BB2->UnreachBB) =; /// UNREACHABLE_WEIGHT/(COLD_WEIGHT+UNREACHABLE_WEIGHT) = 0(0%); ///; /// If no branch probabilities were calculated on this step then take the next; /// one.; ///; /// Third, apply different kinds",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:86,Integrability,rout,routine,86,"/// Get an edge's probability, relative to other out-edges of the Src.; ///; /// This routine provides access to the fractional probability between zero; /// (0%) and one (100%) of this edge executing, relative to other edges; /// leaving the 'Src' block. The returned probability is never zero, and can; /// only be one if the source block has only one successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:103,Security,access,access,103,"/// Get an edge's probability, relative to other out-edges of the Src.; ///; /// This routine provides access to the fractional probability between zero; /// (0%) and one (100%) of this edge executing, relative to other edges; /// leaving the 'Src' block. The returned probability is never zero, and can; /// only be one if the source block has only one successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:4,Testability,Test,Test,4,/// Test if an edge is hot relative to other out-edges of the Src.; ///; /// Check whether this edge out of the source block is 'hot'. We define hot; /// as having a relative probability >= 80%.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:190,Deployability,update,update,190,/// Set the raw probabilities for all edges from the given block.; ///; /// This allows a pass to explicitly set edge probabilities for a block. It; /// can be used when updating the CFG to update the branch probability; /// information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:415,Integrability,interface,interfaces,415,"//===- CallGraph.h - Build a Module's call graph ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides interfaces used to build and manipulate a call graph,; /// which is a very useful tool for interprocedural optimization.; ///; /// Every function in a module is represented as a node in the call graph. The; /// callgraph node keeps track of which functions are called by the function; /// corresponding to the node.; ///; /// A call graph may contain nodes where the function that they correspond to; /// is null. These 'external' nodes are used to represent control flow that is; /// not represented (or analyzable) in the module. In particular, this; /// analysis builds one external node such that:; /// 1. All functions in the module without internal linkage will have edges; /// from this external node, indicating that they could be called by; /// functions outside of the module.; /// 2. All functions whose address is used for something more than a direct; /// call, for example being stored into a memory location will also have; /// an edge from this external node. Since they may be called by an; /// unknown caller later, they must be tracked as such.; ///; /// There is a second external node added for calls that leave this module.; /// Functions have a call edge to the external node iff:; /// 1. The function is external, reflecting the fact that they could call; /// anything without internal linkage or that has its address taken.; /// 2. The function contains an indirect function call.; ///; /// As an extension in the future, there may be multiple nodes with a null; /// function. These will be used when we can prove (through pointer analysis); /// that an indirec",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:522,Performance,optimiz,optimization,522,"//===- CallGraph.h - Build a Module's call graph ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides interfaces used to build and manipulate a call graph,; /// which is a very useful tool for interprocedural optimization.; ///; /// Every function in a module is represented as a node in the call graph. The; /// callgraph node keeps track of which functions are called by the function; /// corresponding to the node.; ///; /// A call graph may contain nodes where the function that they correspond to; /// is null. These 'external' nodes are used to represent control flow that is; /// not represented (or analyzable) in the module. In particular, this; /// analysis builds one external node such that:; /// 1. All functions in the module without internal linkage will have edges; /// from this external node, indicating that they could be called by; /// functions outside of the module.; /// 2. All functions whose address is used for something more than a direct; /// call, for example being stored into a memory location will also have; /// an edge from this external node. Since they may be called by an; /// unknown caller later, they must be tracked as such.; ///; /// There is a second external node added for calls that leave this module.; /// Functions have a call edge to the external node iff:; /// 1. The function is external, reflecting the fact that they could call; /// anything without internal linkage or that has its address taken.; /// 2. The function contains an indirect function call.; ///; /// As an extension in the future, there may be multiple nodes with a null; /// function. These will be used when we can prove (through pointer analysis); /// that an indirec",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:205,Deployability,update,updated,205,/// The basic data container for the call graph of a \c Module of IR.; ///; /// This class exposes both the interface to the call graph for a module of IR.; ///; /// The core call graph itself can also be updated to reflect changes to the IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:108,Integrability,interface,interface,108,/// The basic data container for the call graph of a \c Module of IR.; ///; /// This class exposes both the interface to the call graph for a module of IR.; ///; /// The core call graph itself can also be updated to reflect changes to the IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:91,Security,expose,exposes,91,/// The basic data container for the call graph of a \c Module of IR.; ///; /// This class exposes both the interface to the call graph for a module of IR.; ///; /// The core call graph itself can also be updated to reflect changes to the IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:67,Deployability,update,update,67,"/// Old node has been deleted, and New is to be used in its place, update the; /// ExternalCallingNode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:209,Performance,cache,cache,209,/// An analysis pass to compute the \c CallGraph for a \c Module.; ///; /// This class implements the concept of an analysis pass used by the \c; /// ModuleAnalysisManager to run an analysis over a module and cache the; /// resulting data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:28,Integrability,wrap,wraps,28,/// The \c ModulePass which wraps up a \c CallGraph and the logic to; /// build it.; ///; /// This class exposes both the interface to the call graph container and the; /// module pass which runs over a module of IR and produces the call graph. The; /// call graph interface is entirelly a wrapper around a \c CallGraph object; /// which is stored internally for each module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:122,Integrability,interface,interface,122,/// The \c ModulePass which wraps up a \c CallGraph and the logic to; /// build it.; ///; /// This class exposes both the interface to the call graph container and the; /// module pass which runs over a module of IR and produces the call graph. The; /// call graph interface is entirelly a wrapper around a \c CallGraph object; /// which is stored internally for each module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:265,Integrability,interface,interface,265,/// The \c ModulePass which wraps up a \c CallGraph and the logic to; /// build it.; ///; /// This class exposes both the interface to the call graph container and the; /// module pass which runs over a module of IR and produces the call graph. The; /// call graph interface is entirelly a wrapper around a \c CallGraph object; /// which is stored internally for each module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:290,Integrability,wrap,wrapper,290,/// The \c ModulePass which wraps up a \c CallGraph and the logic to; /// build it.; ///; /// This class exposes both the interface to the call graph container and the; /// module pass which runs over a module of IR and produces the call graph. The; /// call graph interface is entirelly a wrapper around a \c CallGraph object; /// which is stored internally for each module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:105,Security,expose,exposes,105,/// The \c ModulePass which wraps up a \c CallGraph and the logic to; /// build it.; ///; /// This class exposes both the interface to the call graph container and the; /// module pass which runs over a module of IR and produces the call graph. The; /// call graph interface is entirelly a wrapper around a \c CallGraph object; /// which is stored internally for each module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:60,Testability,log,logic,60,/// The \c ModulePass which wraps up a \c CallGraph and the logic to; /// build it.; ///; /// This class exposes both the interface to the call graph container and the; /// module pass which runs over a module of IR and produces the call graph. The; /// call graph interface is entirelly a wrapper around a \c CallGraph object; /// which is stored internally for each module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:60,Integrability,interface,interface,60,/// The internal \c CallGraph around which the rest of this interface; /// is wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:78,Integrability,wrap,wrapped,78,/// The internal \c CallGraph around which the rest of this interface; /// is wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:112,Integrability,interface,interface,112,//===---------------------------------------------------------------------; // Implementation of the ModulePass interface needed here.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h:374,Deployability,update,update,374,"/// runOnSCC - This method should be implemented by the subclass to perform; /// whatever action is necessary for the specified SCC. Note that; /// non-recursive (or only self-recursive) functions will have an SCC size of; /// 1, where recursive portions of the call graph will have SCC size > 1.; ///; /// SCC passes that add or delete functions to the SCC are required to update; /// the SCC list, otherwise stale pointers may be dereferenced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h:68,Performance,perform,perform,68,"/// runOnSCC - This method should be implemented by the subclass to perform; /// whatever action is necessary for the specified SCC. Note that; /// non-recursive (or only self-recursive) functions will have an SCC size of; /// 1, where recursive portions of the call graph will have SCC size > 1.; ///; /// SCC passes that add or delete functions to the SCC are required to update; /// the SCC list, otherwise stale pointers may be dereferenced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h:111,Performance,optimiz,optimization,111,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when optimization bisect is over the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallPrinter.h:52,Integrability,interface,interface,52,"//===-- CallPrinter.h - Call graph printer external interface ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines external functions that can be called to explicitly; // instantiate the call graph printer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h:402,Integrability,rout,routines,402,"//===----- llvm/Analysis/CaptureTracking.h - Pointer capture ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains routines that help determine which pointers are captured.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h:143,Integrability,rout,routine,143,"/// PointerMayBeCaptured - Return true if this pointer value may be captured; /// by the enclosing function (which is required to exist). This routine can; /// be expensive, so consider caching the results. The boolean ReturnCaptures; /// specifies whether returning the value (or part of it) from the function; /// counts as capturing it or not. The boolean StoreCaptures specified; /// whether storing the value (or part of it) into memory anywhere; /// automatically counts as capturing it or not.; /// MaxUsesToExplore specifies how many uses the analysis should explore for; /// one value before giving up due too ""too many uses"". If MaxUsesToExplore; /// is zero, a default value is assumed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h:263,Integrability,rout,routine,263,"/// PointerMayBeCapturedBefore - Return true if this pointer value may be; /// captured by the enclosing function (which is required to exist). If a; /// DominatorTree is provided, only captures which happen before the given; /// instruction are considered. This routine can be expensive, so consider; /// caching the results. The boolean ReturnCaptures specifies whether; /// returning the value (or part of it) from the function counts as capturing; /// it or not. The boolean StoreCaptures specified whether storing the value; /// (or part of it) into memory anywhere automatically counts as capturing it; /// or not. Captures by the provided instruction are considered if the; /// final parameter is true.; /// MaxUsesToExplore specifies how many uses the analysis should explore for; /// one value before giving up due too ""too many uses"". If MaxUsesToExplore; /// is zero, a default value is assumed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h:92,Integrability,interface,interface,92,"/// This callback is used in conjunction with PointerMayBeCaptured. In; /// addition to the interface here, you'll need to provide your own getters; /// to see whether anything was captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h:151,Safety,avoid,avoid,151,/// isDereferenceableOrNull - Overload to allow clients with additional; /// knowledge about pointer dereferenceability to provide it and thereby; /// avoid conservative responses when a pointer is compared to null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:408,Performance,perform,performs,408,"//===-- Analysis/CFG.h - BasicBlock Analyses --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions performs analyses on basic blocks, and instructions; // contained within basic blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:147,Availability,error,error,147,/// Search for the specified successor of basic block BB and return its position; /// in the terminator instruction's list of successors. It is an error to call; /// this with a block that is not a successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:473,Availability,down,down,473,"/// Determine whether instruction 'To' is reachable from 'From', without passing; /// through any blocks in ExclusionSet, returning true if uncertain.; ///; /// Determine whether there is a path from From to To within a single function.; /// Returns false only if we can prove that once 'From' has been executed then; /// 'To' can not be executed. Conservatively returns true.; ///; /// This function is linear with respect to the number of blocks in the CFG,; /// walking down successors from From to reach To, with a fixed threshold.; /// Using DT or LI allows us to answer more quickly. LI reduces the cost of; /// an entire loop of any number of blocks to be the same as the cost of a; /// single block. DT reduces the cost by allowing the search to terminate when; /// we find a block that dominates the block containing 'To'. DT is most useful; /// on branchy code but not loops, and LI is most useful on code with loops but; /// does not help on branchy code outside loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:593,Energy Efficiency,reduce,reduces,593,"/// Determine whether instruction 'To' is reachable from 'From', without passing; /// through any blocks in ExclusionSet, returning true if uncertain.; ///; /// Determine whether there is a path from From to To within a single function.; /// Returns false only if we can prove that once 'From' has been executed then; /// 'To' can not be executed. Conservatively returns true.; ///; /// This function is linear with respect to the number of blocks in the CFG,; /// walking down successors from From to reach To, with a fixed threshold.; /// Using DT or LI allows us to answer more quickly. LI reduces the cost of; /// an entire loop of any number of blocks to be the same as the cost of a; /// single block. DT reduces the cost by allowing the search to terminate when; /// we find a block that dominates the block containing 'To'. DT is most useful; /// on branchy code but not loops, and LI is most useful on code with loops but; /// does not help on branchy code outside loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:711,Energy Efficiency,reduce,reduces,711,"/// Determine whether instruction 'To' is reachable from 'From', without passing; /// through any blocks in ExclusionSet, returning true if uncertain.; ///; /// Determine whether there is a path from From to To within a single function.; /// Returns false only if we can prove that once 'From' has been executed then; /// 'To' can not be executed. Conservatively returns true.; ///; /// This function is linear with respect to the number of blocks in the CFG,; /// walking down successors from From to reach To, with a fixed threshold.; /// Using DT or LI allows us to answer more quickly. LI reduces the cost of; /// an entire loop of any number of blocks to be the same as the cost of a; /// single block. DT reduces the cost by allowing the search to terminate when; /// we find a block that dominates the block containing 'To'. DT is most useful; /// on branchy code but not loops, and LI is most useful on code with loops but; /// does not help on branchy code outside loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:444,Availability,avail,available,444,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:488,Availability,avail,available,488,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:573,Energy Efficiency,efficient,efficient,573,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:957,Integrability,interface,interfaces,957,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:117,Safety,detect,detect,117,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:591,Safety,detect,detect,591,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:808,Security,access,access,808,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:44,Integrability,interface,interface,44,"//===-- CFGPrinter.h - CFG printer external interface -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a 'dot-cfg' analysis pass, which emits the; // cfg.<fnname>.dot file for each function in the program, with a graph of the; // CFG for that function.; //; // This file defines external functions that can be called to explicitly; // instantiate the CFG printer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:33,Availability,avail,available,33,// Print EdgeWeights when BPI is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:32,Availability,avail,available,32,// Print RawWeights when BFI is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:3,Integrability,Wrap,Wrap,3,// Wrap lines.; // Wrap very long names even though we can't find a space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:19,Integrability,Wrap,Wrap,19,// Wrap lines.; // Wrap very long names even though we can't find a space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:3,Performance,Cache,Cache,3,// Cache for is hidden property,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3126,Deployability,update,update,3126,"erprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3994,Deployability,update,update,3994,"more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The patterns used to ensure the goals of post-order visitation of the fully; /// refined graph:; ///; /// 1) Sink toward the ""bottom"" as the graph is refined. This means that any; /// iteration continues in some valid post-order sequence after the mutation; /// has altered the structure.; ///; /// 2) Enqueue in post-order, including the current entity. If the current; /// entity's shape changes, it and everything after it in post-order needs; /// to be visited to observe that shape.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:4178,Deployability,update,update,4178,"more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The patterns used to ensure the goals of post-order visitation of the fully; /// refined graph:; ///; /// 1) Sink toward the ""bottom"" as the graph is refined. This means that any; /// iteration continues in some valid post-order sequence after the mutation; /// has altered the structure.; ///; /// 2) Enqueue in post-order, including the current entity. If the current; /// entity's shape changes, it and everything after it in post-order needs; /// to be visited to observe that shape.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:551,Performance,optimiz,optimizations,551,"//===- CGSCCPassManager.h - Call graph pass management ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:721,Performance,optimiz,optimizations,721,"//===- CGSCCPassManager.h - Call graph pass management ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:856,Performance,optimiz,optimizations,856,"//===- CGSCCPassManager.h - Call graph pass management ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:928,Performance,optimiz,optimized,928,"//===- CGSCCPassManager.h - Call graph pass management ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:1090,Performance,optimiz,optimization,1090,"; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:1179,Performance,optimiz,optimizations,1179,"-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reac",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:1401,Performance,optimiz,optimizations,1401,"ses over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the referen",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:1952,Performance,optimiz,optimize,1952,"neral goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call grap",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:2131,Performance,optimiz,optimizations,2131,"neral goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call grap",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:2157,Performance,optimiz,optimized,2157,"neral goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call grap",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:2983,Performance,optimiz,optimization,2983," /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3187,Performance,cache,cached,3187,"erprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3235,Performance,cache,cache-based,3235,"e independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The p",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3421,Performance,cache,cached,3421,"e independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The p",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3620,Performance,optimiz,optimization,3620,"e fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The patterns used to ensure the goals of post-order visitation of the fully; /// refined graph:; ///; /// 1) Sink toward the ""bottom"" as the graph is refined. This means that any; /// iteration continues in some valid post-order sequence after the mutation; /// has altered the structure.; ///; /// 2) Enqueue in post-o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3873,Testability,test,tests,3873,"is, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The patterns used to ensure the goals of post-order visitation of the fully; /// refined graph:; ///; /// 1) Sink toward the ""bottom"" as the graph is refined. This means that any; /// iteration continues in some valid post-order sequence after the mutation; /// has altered the structure.; ///; /// 2) Enqueue in post-order, including the current entity. If the current; /// entity's shape changes, it and everything after it in post-order needs; /// to be visited to observe t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:2804,Usability,usab,usability,2804,"is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be exp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:15,Testability,log,logging,15,// Allow debug logging in this inline function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:233,Deployability,integrat,integrate,233,/// The CGSCC analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This type serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:204,Energy Efficiency,adapt,adaptors,204,/// The CGSCC analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This type serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:233,Integrability,integrat,integrate,233,/// The CGSCC analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This type serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:204,Modifiability,adapt,adaptors,204,/// The CGSCC analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This type serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:96,Security,access,access,96,/// We need a specialized result for the \c CGSCCAnalysisManagerModuleProxy so; /// it can have access to the call graph in order to walk all the SCCs when; /// invalidating things.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:4,Security,Access,Accessor,4,/// Accessor for the analysis manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:273,Usability,clear,clear,273,"/// Handler for invalidation of the Module.; ///; /// If the proxy analysis itself is preserved, then we assume that the set of; /// SCCs in the Module hasn't changed. Thus any pointers to SCCs in the; /// CGSCCAnalysisManager are still valid, and we don't need to call \c clear; /// on the CGSCCAnalysisManager.; ///; /// Regardless of whether this analysis is marked as preserved, all of the; /// analyses in the \c CGSCCAnalysisManager are potentially invalidated based; /// on the set of preserved analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:52,Deployability,update,updates,52,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:197,Deployability,update,update,197,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:455,Deployability,update,updates,455,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:590,Deployability,update,update,590,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:655,Deployability,update,updates,655,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:668,Performance,perform,performed,668,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:28,Performance,queue,queued,28,"/// Worklist of the RefSCCs queued for processing.; ///; /// When a pass refines the graph and creates new RefSCCs or causes them to; /// have a different shape or set of component SCCs it should add the RefSCCs; /// to this worklist so that we visit them in the refined form.; ///; /// This worklist is in reverse post-order, as we pop off the back in order; /// to observe RefSCCs in post-order. When adding RefSCCs, clients should add; /// them in reverse post-order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:25,Performance,queue,queued,25,"/// Worklist of the SCCs queued for processing.; ///; /// When a pass refines the graph and creates new SCCs or causes them to have; /// a different shape or set of component functions it should add the SCCs to; /// this worklist so that we visit them in the refined form.; ///; /// Note that if the SCCs are part of a RefSCC that is added to the \c; /// RCWorklist, they don't need to be added here as visiting the RefSCC will; /// be sufficient to re-visit the SCCs within it.; ///; /// This worklist is in reverse post-order, as we pop off the back in order; /// to observe SCCs in post-order. When adding SCCs, clients should add them; /// in reverse post-order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:246,Safety,avoid,avoid,246,/// The set of invalidated RefSCCs which should be skipped if they are found; /// in \c RCWorklist.; ///; /// This is used to quickly prune out RefSCCs when they get deleted and; /// happen to already be on the worklist. We use this primarily to avoid; /// scanning the list and removing entries from it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:239,Safety,avoid,avoid,239,/// The set of invalidated SCCs which should be skipped if they are found; /// in \c CWorklist.; ///; /// This is used to quickly prune out SCCs when they get deleted and happen; /// to already be on the worklist. We use this primarily to avoid scanning; /// the list and removing entries from it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:168,Availability,down,down,168,"/// If non-null, the updated current \c SCC being processed.; ///; /// This is set when a graph refinement takes place and the ""current"" point; /// in the graph moves ""down"" or earlier in the post-order walk. This will; /// often cause the ""current"" SCC to be a newly created SCC object and the; /// old one to be added to the above worklist. When that happens, this; /// pointer is non-null and can be used to continue processing the ""top"" of; /// the post-order walk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:21,Deployability,update,updated,21,"/// If non-null, the updated current \c SCC being processed.; ///; /// This is set when a graph refinement takes place and the ""current"" point; /// in the graph moves ""down"" or earlier in the post-order walk. This will; /// often cause the ""current"" SCC to be a newly created SCC object and the; /// old one to be added to the above worklist. When that happens, this; /// pointer is non-null and can be used to continue processing the ""top"" of; /// the post-order walk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:549,Energy Efficiency,adapt,adaptors,549,"/// Preserved analyses across SCCs.; ///; /// We specifically want to allow CGSCC passes to mutate ancestor IR; /// (changing both the CG structure and the function IR itself). However,; /// this means we need to take special care to correctly mark what analyses; /// are preserved *across* SCCs. We have to track this out-of-band here; /// because within the main `PassManager` infrastructure we need to mark; /// everything within an SCC as preserved in order to avoid repeatedly; /// invalidating the same analyses as we unnest pass managers and adaptors.; /// So we track the cross-SCC version of the preserved analyses here from any; /// code that does direct invalidation of SCC analyses, and then use it; /// whenever we move forward in the post-order walk of SCCs before running; /// passes over the new SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:549,Modifiability,adapt,adaptors,549,"/// Preserved analyses across SCCs.; ///; /// We specifically want to allow CGSCC passes to mutate ancestor IR; /// (changing both the CG structure and the function IR itself). However,; /// this means we need to take special care to correctly mark what analyses; /// are preserved *across* SCCs. We have to track this out-of-band here; /// because within the main `PassManager` infrastructure we need to mark; /// everything within an SCC as preserved in order to avoid repeatedly; /// invalidating the same analyses as we unnest pass managers and adaptors.; /// So we track the cross-SCC version of the preserved analyses here from any; /// code that does direct invalidation of SCC analyses, and then use it; /// whenever we move forward in the post-order walk of SCCs before running; /// passes over the new SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:465,Safety,avoid,avoid,465,"/// Preserved analyses across SCCs.; ///; /// We specifically want to allow CGSCC passes to mutate ancestor IR; /// (changing both the CG structure and the function IR itself). However,; /// this means we need to take special care to correctly mark what analyses; /// are preserved *across* SCCs. We have to track this out-of-band here; /// because within the main `PassManager` infrastructure we need to mark; /// everything within an SCC as preserved in order to avoid repeatedly; /// invalidating the same analyses as we unnest pass managers and adaptors.; /// So we track the cross-SCC version of the preserved analyses here from any; /// code that does direct invalidation of SCC analyses, and then use it; /// whenever we move forward in the post-order walk of SCCs before running; /// passes over the new SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:207,Deployability,update,update,207,"/// A hacky area where the inliner can retain history about inlining; /// decisions that mutated the call graph's SCC structure in order to avoid; /// infinite inlining. See the comments in the inliner's CG update logic.; ///; /// FIXME: Keeping this here seems like a big layering issue, we should look; /// for a better technique.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:140,Safety,avoid,avoid,140,"/// A hacky area where the inliner can retain history about inlining; /// decisions that mutated the call graph's SCC structure in order to avoid; /// infinite inlining. See the comments in the inliner's CG update logic.; ///; /// FIXME: Keeping this here seems like a big layering issue, we should look; /// for a better technique.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:214,Testability,log,logic,214,"/// A hacky area where the inliner can retain history about inlining; /// decisions that mutated the call graph's SCC structure in order to avoid; /// infinite inlining. See the comments in the inliner's CG update logic.; ///; /// FIXME: Keeping this here seems like a big layering issue, we should look; /// for a better technique.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:65,Safety,detect,detecting,65,"/// Weak VHs to keep track of indirect calls for the purposes of detecting; /// devirtualization.; ///; /// This is a map to avoid having duplicate entries. If a Value is; /// deallocated, its corresponding WeakTrackingVH will be nulled out. When; /// checking if a Value is in the map or not, also check if the corresponding; /// WeakTrackingVH is null to avoid issues with a new Value sharing the same; /// address as a deallocated one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:125,Safety,avoid,avoid,125,"/// Weak VHs to keep track of indirect calls for the purposes of detecting; /// devirtualization.; ///; /// This is a map to avoid having duplicate entries. If a Value is; /// deallocated, its corresponding WeakTrackingVH will be nulled out. When; /// checking if a Value is in the map or not, also check if the corresponding; /// WeakTrackingVH is null to avoid issues with a new Value sharing the same; /// address as a deallocated one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:357,Safety,avoid,avoid,357,"/// Weak VHs to keep track of indirect calls for the purposes of detecting; /// devirtualization.; ///; /// This is a map to avoid having duplicate entries. If a Value is; /// deallocated, its corresponding WeakTrackingVH will be nulled out. When; /// checking if a Value is in the map or not, also check if the corresponding; /// WeakTrackingVH is null to avoid issues with a new Value sharing the same; /// address as a deallocated one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:503,Safety,safe,safely,503,/// The core module pass which does a post-order walk of the SCCs and; /// runs a CGSCC pass over each one.; ///; /// Designed to allow composition of a CGSCCPass(Manager) and; /// a ModulePassManager. Note that this pass must be run with a module analysis; /// manager as it uses the LazyCallGraph analysis. It will also run the; /// \c CGSCCAnalysisManagerModuleProxy analysis prior to running the CGSCC; /// pass over the module to enable a \c FunctionAnalysisManager to be used; /// within this run safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,Energy Efficiency,adapt,adaptor,80,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:50,Integrability,wrap,wrap,50,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,Modifiability,adapt,adaptor,80,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:307,Testability,log,logic,307,"/// A proxy from a \c FunctionAnalysisManager to an \c SCC.; ///; /// When a module pass runs and triggers invalidation, both the CGSCC and; /// Function analysis manager proxies on the module get an invalidation event.; /// We don't want to fully duplicate responsibility for most of the; /// invalidation logic. Instead, this layer is only responsible for SCC-local; /// invalidation events. We work with the module's FunctionAnalysisManager to; /// invalidate function analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:4,Security,Access,Accessor,4,/// Accessor for the analysis manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:14,Deployability,update,update,14,/// Helper to update the call graph after running a function pass.; ///; /// Function passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:183,Deployability,update,updates,183,/// Helper to update the call graph after running a function pass.; ///; /// Function passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:300,Deployability,update,update,300,/// Helper to update the call graph after running a function pass.; ///; /// Function passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:152,Integrability,rout,routine,152,/// Helper to update the call graph after running a function pass.; ///; /// Function passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:14,Deployability,update,update,14,/// Helper to update the call graph after running a CGSCC pass.; ///; /// CGSCC passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:177,Deployability,update,updates,177,/// Helper to update the call graph after running a CGSCC pass.; ///; /// CGSCC passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:294,Deployability,update,update,294,/// Helper to update the call graph after running a CGSCC pass.; ///; /// CGSCC passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:146,Integrability,rout,routine,146,/// Helper to update the call graph after running a CGSCC pass.; ///; /// CGSCC passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:4,Energy Efficiency,Adapt,Adaptor,4,/// Adaptor that maps from a SCC to its functions.; ///; /// Designed to allow composition of a FunctionPass(Manager) and; /// a CGSCCPassManager. Note that if this pass is constructed with a pointer; /// to a \c CGSCCAnalysisManager it will run the; /// \c FunctionAnalysisManagerCGSCCProxy analysis prior to running the function; /// pass over the SCC to enable a \c FunctionAnalysisManager to be used; /// within this run safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:4,Modifiability,Adapt,Adaptor,4,/// Adaptor that maps from a SCC to its functions.; ///; /// Designed to allow composition of a FunctionPass(Manager) and; /// a CGSCCPassManager. Note that if this pass is constructed with a pointer; /// to a \c CGSCCAnalysisManager it will run the; /// \c FunctionAnalysisManagerCGSCCProxy analysis prior to running the function; /// pass over the SCC to enable a \c FunctionAnalysisManager to be used; /// within this run safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:425,Safety,safe,safely,425,/// Adaptor that maps from a SCC to its functions.; ///; /// Designed to allow composition of a FunctionPass(Manager) and; /// a CGSCCPassManager. Note that if this pass is constructed with a pointer; /// to a \c CGSCCAnalysisManager it will run the; /// \c FunctionAnalysisManagerCGSCCProxy analysis prior to running the function; /// pass over the SCC to enable a \c FunctionAnalysisManager to be used; /// within this run safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,Energy Efficiency,adapt,adaptor,80,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:50,Integrability,wrap,wrap,50,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,Modifiability,adapt,adaptor,80,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:545,Performance,optimiz,optimizations,545,"/// A helper that repeats an SCC pass each time an indirect call is refined to; /// a direct call by that pass.; ///; /// While the CGSCC pass manager works to re-visit SCCs and RefSCCs as they; /// change shape, we may also want to repeat an SCC pass if it simply refines; /// an indirect call to a direct call, even if doing so does not alter the; /// shape of the graph. Note that this only pertains to direct calls to; /// functions where IPO across the SCC may be able to compute more precise; /// results. For intrinsics, we assume scalar optimizations already can fully; /// reason about them.; ///; /// This repetition has the potential to be very large however, as each one; /// might refine a single call site. As a consequence, in practice we use an; /// upper bound on the number of repetitions to limit things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:258,Usability,simpl,simply,258,"/// A helper that repeats an SCC pass each time an indirect call is refined to; /// a direct call by that pass.; ///; /// While the CGSCC pass manager works to re-visit SCCs and RefSCCs as they; /// change shape, we may also want to repeat an SCC pass if it simply refines; /// an indirect call to a direct call, even if doing so does not alter the; /// shape of the graph. Note that this only pertains to direct calls to; /// functions where IPO across the SCC may be able to compute more precise; /// results. For intrinsics, we assume scalar optimizations already can fully; /// reason about them.; ///; /// This repetition has the potential to be very large however, as each one; /// might refine a single call site. As a consequence, in practice we use an; /// upper bound on the number of repetitions to limit things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:13,Integrability,wrap,wrapped,13,"/// Runs the wrapped pass up to \c MaxIterations on the SCC, iterating; /// whenever an indirect call is refined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,Energy Efficiency,adapt,adaptor,80,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:50,Integrability,wrap,wrap,50,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,Modifiability,adapt,adaptor,80,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:23,Testability,log,logging,23,// Clear out the debug logging macro.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3,Usability,Clear,Clear,3,// Clear out the debug logging macro.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h:399,Integrability,rout,routines,399,"//===-- CmpInstAnalysis.h - Utils to help fold compare insts ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file holds routines to help analyse compare instructions; // and fold them into constants or other compare instructions; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h:45,Availability,mask,mask,45,"/// Encode a icmp predicate into a three bit mask. These bits are carefully; /// arranged to allow folding of expressions such as:; ///; /// (A < B) | (A > B) --> (A != B); ///; /// Note that this is only valid if the first and second predicates have the; /// same sign. It is illegal to do: (A u< B) | (A s> B); ///; /// Three bits are used to represent the condition, as follows:; /// 0 A > B; /// 1 A == B; /// 2 A < B; ///; /// <=> Value Definition; /// 000 0 Always false; /// 001 1 A > B; /// 010 2 A == B; /// 011 3 A >= B; /// 100 4 A < B; /// 101 5 A != B; /// 110 6 A <= B; /// 111 7 Always true; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h:96,Availability,mask,mask,96,/// Similar to getICmpCode but for FCmpInst. This encodes a fcmp predicate; /// into a four bit mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h:42,Availability,Mask,Mask,42,/// Decompose an icmp into the form ((X & Mask) pred 0) if possible. The; /// returned predicate is either == or !=. Returns false if decomposition; /// fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CodeMetrics.h:131,Security,expose,exposed,131,"/// The number of calls to internal functions with a single caller.; ///; /// These are likely targets for future inlining, likely exposed by; /// interleaved devirtualization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CodeMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CodeMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:402,Integrability,rout,routines,402,"//===-- ConstantFolding.h - Fold instructions into constants ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into constants when all; // operands are constants, for example ""sub i32 1, 0"" -> ""1"".; //; // Also, to supplement the basic VMCore ConstantExpr simplifications,; // this file declares some additional folding routines that can make use of; // DataLayout information. These functions cannot go in VMCore due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:645,Integrability,rout,routines,645,"//===-- ConstantFolding.h - Fold instructions into constants ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into constants when all; // operands are constants, for example ""sub i32 1, 0"" -> ""1"".; //; // Also, to supplement the basic VMCore ConstantExpr simplifications,; // this file declares some additional folding routines that can make use of; // DataLayout information. These functions cannot go in VMCore due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:758,Integrability,depend,dependency,758,"//===-- ConstantFolding.h - Fold instructions into constants ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into constants when all; // operands are constants, for example ""sub i32 1, 0"" -> ""1"".; //; // Also, to supplement the basic VMCore ConstantExpr simplifications,; // this file declares some additional folding routines that can make use of; // DataLayout information. These functions cannot go in VMCore due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:581,Usability,simpl,simplifications,581,"//===-- ConstantFolding.h - Fold instructions into constants ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into constants when all; // operands are constants, for example ""sub i32 1, 0"" -> ""1"".; //; // Also, to supplement the basic VMCore ConstantExpr simplifications,; // this file declares some additional folding routines that can make use of; // DataLayout information. These functions cannot go in VMCore due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:310,Performance,load,loads,310,"/// ConstantFoldInstruction - Try to constant fold the specified instruction.; /// If successful, the constant result is returned, if not, null is returned.; /// Note that this fails if not all of the operands are constant. Otherwise,; /// this function can only fail when attempting to fold instructions like loads; /// and stores, which have no constant expression form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:264,Performance,load,loads,264,"/// ConstantFoldInstOperands - Attempt to constant fold an instruction with the; /// specified operands. If successful, the constant result is returned, if not,; /// null is returned. Note that this function can fail when attempting to; /// fold instructions like loads and stores, which have no constant expression; /// form.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:169,Availability,failure,failure,169,/// Attempt to constant fold a compare instruction (icmp/fcmp) with the; /// specified operands. Returns null or a constant expression of the specified; /// operands on failure.; /// Denormal inputs may be flushed based on the denormal handling mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:96,Availability,failure,failure,96,/// Attempt to constant fold a unary operation with the specified operand.; /// Returns null on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:149,Availability,failure,failure,149,/// Attempt to constant fold a binary operation with the specified operands.; /// Returns null or a constant expression of the specified operands on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:221,Availability,failure,failure,221,"/// Attempt to constant fold a floating point binary operation with the; /// specified operands, applying the denormal handling mod to the operands.; /// Returns null or a constant expression of the specified operands on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:139,Availability,failure,failure,139,"/// Constant fold a zext, sext or trunc, depending on IsSigned and whether the; /// DestTy is wider or narrower than C. Returns nullptr on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:41,Integrability,depend,depending,41,"/// Constant fold a zext, sext or trunc, depending on IsSigned and whether the; /// DestTy is wider or narrower than C. Returns nullptr on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:94,Availability,mask,mask,94,"/// Attempt to constant fold a shufflevector instruction with the; /// specified operands and mask. See class ShuffleVectorInst for a description; /// of the mask representation. The constant result is returned if successful;; /// if not, null is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:158,Availability,mask,mask,158,"/// Attempt to constant fold a shufflevector instruction with the; /// specified operands and mask. See class ShuffleVectorInst for a description; /// of the mask representation. The constant result is returned if successful;; /// if not, null is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:99,Security,access,accessed,99,"/// Extract value of C at the given Offset reinterpreted as Ty. If bits past; /// the end of C are accessed, they are assumed to be poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:28,Performance,load,load,28,"/// Return the value that a load from C with offset Offset would produce if it; /// is constant and determinable. If this is not determinable, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:28,Performance,load,load,28,"/// Return the value that a load from C would produce if it is constant and; /// determinable. If this is not determinable, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:88,Integrability,rout,routimes,88,/// Check whether the given call has no side-effects.; /// Specifically checks for math routimes which sometimes set errno.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:13,Modifiability,variab,variables,13,/// A map of variables (IR values) to their corresponding index in the; /// constraint system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:16,Modifiability,variab,variable,16,/// Get list of variable names from the Value2Index map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:10,Modifiability,variab,variable,10,"// If all variable coefficients are 0, the constraint does not provide any; // usable information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:79,Usability,usab,usable,79,"// If all variable coefficients are 0, the constraint does not provide any; // usable information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:10,Modifiability,variab,variable,10,"// If all variable coefficients are 0, the constraint does not provide any; // usable information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:79,Usability,usab,usable,79,"// If all variable coefficients are 0, the constraint does not provide any; // usable information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:410,Integrability,Depend,Dependence,410,"//===- llvm/Analysis/DDG.h --------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the Data-Dependence Graph (DDG).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:9,Integrability,Depend,Dependence,9,/// Data Dependence Graph Node; /// The graph can represent the following types of nodes:; /// 1. Single instruction node containing just one instruction.; /// 2. Multiple instruction node where two or more instructions from; /// the same basic block are merged into one node.; /// 3. Pi-block node which is a group of other DDG nodes that are part of a; /// strongly-connected component of the graph.; /// A pi-block node contains more than one single or multiple instruction; /// nodes. The root node cannot be part of a pi-block.; /// 4. Root node is a special node that connects to all components such that; /// there is always a path from it to any node in the graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:9,Integrability,Depend,Dependency,9,/// Data Dependency Graph Edge.; /// An edge in the DDG can represent a def-use relationship or; /// a memory dependence based on the result of DependenceAnalysis.; /// A rooted edge connects the root node to one of the components; /// of the graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:110,Integrability,depend,dependence,110,/// Data Dependency Graph Edge.; /// An edge in the DDG can represent a def-use relationship or; /// a memory dependence based on the result of DependenceAnalysis.; /// A rooted edge connects the root node to one of the components; /// of the graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:144,Integrability,Depend,DependenceAnalysis,144,/// Data Dependency Graph Edge.; /// An edge in the DDG can represent a def-use relationship or; /// a memory dependence based on the result of DependenceAnalysis.; /// A rooted edge connects the root node to one of the components; /// of the graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:36,Integrability,depend,dependence,36,"/// Return true if this is a memory dependence edge, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:96,Integrability,depend,dependence,96,/// Encapsulate some common data and functionality needed for different; /// variations of data dependence graphs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:25,Integrability,depend,dependency,25,"/// Collect all the data dependency infos coming from any pair of memory; /// accesses from \p Src to \p Dst, and store them into \p Deps. Return true; /// if a dependence exists, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:161,Integrability,depend,dependence,161,"/// Collect all the data dependency infos coming from any pair of memory; /// accesses from \p Src to \p Dst, and store them into \p Deps. Return true; /// if a dependence exists, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:78,Security,access,accesses,78,"/// Collect all the data dependency infos coming from any pair of memory; /// accesses from \p Src to \p Dst, and store them into \p Deps. Return true; /// if a dependence exists, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:45,Integrability,depend,dependence,45,/// Return a string representing the type of dependence that the dependence; /// analysis identified between the two given nodes. This function assumes; /// that there is a memory dependence between the given two nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:65,Integrability,depend,dependence,65,/// Return a string representing the type of dependence that the dependence; /// analysis identified between the two given nodes. This function assumes; /// that there is a memory dependence between the given two nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:180,Integrability,depend,dependence,180,/// Return a string representing the type of dependence that the dependence; /// analysis identified between the two given nodes. This function assumes; /// that there is a memory dependence between the given two nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:19,Integrability,Depend,DependenceInfo,19,"// Store a copy of DependenceInfo in the graph, so that individual memory; // dependencies don't need to be stored. Instead when the dependence is; // queried it is recomputed using @DI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:78,Integrability,depend,dependencies,78,"// Store a copy of DependenceInfo in the graph, so that individual memory; // dependencies don't need to be stored. Instead when the dependence is; // queried it is recomputed using @DI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:133,Integrability,depend,dependence,133,"// Store a copy of DependenceInfo in the graph, so that individual memory; // dependencies don't need to be stored. Instead when the dependence is; // queried it is recomputed using @DI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:9,Integrability,Depend,Dependency,9,/// Data Dependency Graph,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:43,Integrability,depend,dependence,43,/// Concrete implementation of a pure data dependence graph builder. This class; /// provides custom implementation for the pure-virtual functions used in the; /// generic dependence graph build algorithm.; ///; /// For information about time complexity of the build algorithm see the; /// comments near the declaration of AbstractDependenceGraphBuilder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:172,Integrability,depend,dependence,172,/// Concrete implementation of a pure data dependence graph builder. This class; /// provides custom implementation for the pure-virtual functions used in the; /// generic dependence graph build algorithm.; ///; /// For information about time complexity of the build algorithm see the; /// comments near the declaration of AbstractDependenceGraphBuilder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:58,Usability,simpl,simple,58,/// Return true if the two nodes \pSrc and \pTgt are both simple nodes and; /// the consecutive instructions after merging belong to the same basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:83,Integrability,Depend,DependenceGraphInfo,83,//===--------------------------------------------------------------------===//; // DependenceGraphInfo Implementation; //===--------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:18,Security,access,access,18,// List of memory access instructions from src and dst nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:512,Integrability,Depend,Dependence,512,"//===- llvm/Analysis/DDGPrinter.h -------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; //; // This file defines the DOT printer for the Data-Dependence Graph (DDG).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:130,Availability,avail,available,130,"/// Print attributes of an edge in the DDG graph. If the edge; /// is a MemoryDependence edge, then detailed dependence info; /// available from DependenceAnalysis is displayed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:109,Integrability,depend,dependence,109,"/// Print attributes of an edge in the DDG graph. If the edge; /// is a MemoryDependence edge, then detailed dependence info; /// available from DependenceAnalysis is displayed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:145,Integrability,Depend,DependenceAnalysis,145,"/// Print attributes of an edge in the DDG graph. If the edge; /// is a MemoryDependence edge, then detailed dependence info; /// available from DependenceAnalysis is displayed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:117,Integrability,depend,dependence,117,/// Print a DDG node with more information including containing instructions; /// and detailed information about the dependence edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:89,Integrability,depend,dependence,89,/// Print a DDG edge with more information including detailed information; /// about the dependence edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:550,Testability,test,testing,550,"//===---- Delinearization.h - MultiDimensional Index Delinearization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements an analysis pass that tries to delinearize all GEP; // instructions in all loops using the SCEV analysis functionality. This pass is; // only used for testing purposes: if your pass needs delinearization, please; // use the on-demand SCEVAddRecExpr::delinearize() function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:92,Security,access,access,92,/// Compute the array dimensions Sizes from the set of Terms extracted from; /// the memory access function of this SCEVAddRecExpr (second step of; /// delinearization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:29,Security,access,access,29,/// Return in Subscripts the access functions for each dimension in Sizes; /// (third step of delinearization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:111,Security,access,access,111,"/// Split this SCEVAddRecExpr into two vectors of SCEVs representing the; /// subscripts and sizes of an array access.; ///; /// The delinearization is a 3 step process: the first two steps compute the; /// sizes of each subscript and the third step computes the access functions; /// for the delinearized array:; ///; /// 1. Find the terms in the step functions; /// 2. Compute the array size; /// 3. Compute the access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dime",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:263,Security,access,access,263,"/// Split this SCEVAddRecExpr into two vectors of SCEVs representing the; /// subscripts and sizes of an array access.; ///; /// The delinearization is a 3 step process: the first two steps compute the; /// sizes of each subscript and the third step computes the access functions; /// for the delinearized array:; ///; /// 1. Find the terms in the step functions; /// 2. Compute the array size; /// 3. Compute the access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dime",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:414,Security,access,access,414,"/// Split this SCEVAddRecExpr into two vectors of SCEVs representing the; /// subscripts and sizes of an array access.; ///; /// The delinearization is a 3 step process: the first two steps compute the; /// sizes of each subscript and the third step computes the access functions; /// for the delinearized array:; ///; /// 1. Find the terms in the step functions; /// 2. Compute the array size; /// 3. Compute the access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dime",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:786,Security,access,accesses,786,"/// Split this SCEVAddRecExpr into two vectors of SCEVs representing the; /// subscripts and sizes of an array access.; ///; /// The delinearization is a 3 step process: the first two steps compute the; /// sizes of each subscript and the third step computes the access functions; /// for the delinearized array:; ///; /// 1. Find the terms in the step functions; /// 2. Compute the array size; /// 3. Compute the access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dime",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:889,Security,access,accesses,889,"/// Split this SCEVAddRecExpr into two vectors of SCEVs representing the; /// subscripts and sizes of an array access.; ///; /// The delinearization is a 3 step process: the first two steps compute the; /// sizes of each subscript and the third step computes the access functions; /// for the delinearized array:; ///; /// 1. Find the terms in the step functions; /// 2. Compute the array size; /// 3. Compute the access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dime",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:1020,Security,access,accesses,1020,"/// Split this SCEVAddRecExpr into two vectors of SCEVs representing the; /// subscripts and sizes of an array access.; ///; /// The delinearization is a 3 step process: the first two steps compute the; /// sizes of each subscript and the third step computes the access functions; /// for the delinearized array:; ///; /// 1. Find the terms in the step functions; /// 2. Compute the array size; /// 3. Compute the access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dime",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:1754,Security,access,access,1754,"he access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dimension: [5i].; ///; /// b. Divide Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k by next outer size n; /// Quotient: {{{0,+,0}_i, +, 1}_j, +, 1}_k; /// Remainder: {{{0,+,2}_i, +, 0}_j, +, 0}_k; /// The Remainder is the subscript of the next array dimension: [2i].; ///; /// The subscript of the outermost dimension is the Quotient: [j+k].; ///; /// Overall, we have: A[][n][m], and the access function: A[j+k][2i][5i].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:2379,Security,access,access,2379,"he access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dimension: [5i].; ///; /// b. Divide Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k by next outer size n; /// Quotient: {{{0,+,0}_i, +, 1}_j, +, 1}_k; /// Remainder: {{{0,+,2}_i, +, 0}_j, +, 0}_k; /// The Remainder is the subscript of the next array dimension: [2i].; ///; /// The subscript of the outermost dimension is the Quotient: [j+k].; ///; /// Overall, we have: A[][n][m], and the access function: A[j+k][2i][5i].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:486,Availability,avail,available,486,"/// Gathers the individual index expressions from a GEP instruction.; ///; /// This function optimistically assumes the GEP references into a fixed size; /// array. If this is actually true, this function returns a list of array; /// subscript expressions in \p Subscripts and a list of integers describing; /// the size of the individual array dimensions in \p Sizes. Both lists have; /// either equal length or the size list is one element shorter in case there; /// is no known size available for the outermost array dimension. Returns true; /// if successful and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:256,Performance,load,load,256,"/// Implementation of fixed size array delinearization. Try to delinearize; /// access function for a fixed size multi-dimensional array, by deriving; /// subscripts from GEP instructions. Returns true upon success and false; /// otherwise. \p Inst is the load/store instruction whose pointer operand is; /// the one we want to delinearize. \p AccessFn is its corresponding SCEV; /// expression w.r.t. the surrounding loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:80,Security,access,access,80,"/// Implementation of fixed size array delinearization. Try to delinearize; /// access function for a fixed size multi-dimensional array, by deriving; /// subscripts from GEP instructions. Returns true upon success and false; /// otherwise. \p Inst is the load/store instruction whose pointer operand is; /// the one we want to delinearize. \p AccessFn is its corresponding SCEV; /// expression w.r.t. the surrounding loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:344,Security,Access,AccessFn,344,"/// Implementation of fixed size array delinearization. Try to delinearize; /// access function for a fixed size multi-dimensional array, by deriving; /// subscripts from GEP instructions. Returns true upon success and false; /// otherwise. \p Inst is the load/store instruction whose pointer operand is; /// the one we want to delinearize. \p AccessFn is its corresponding SCEV; /// expression w.r.t. the surrounding loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h:421,Availability,mask,mask,421,"/// Return the bits demanded from instruction I.; ///; /// For vector instructions individual vector elements are not distinguished:; /// A bit is demanded if it is demanded for any of the vector elements. The; /// size of the return value corresponds to the type size in bits of the; /// scalar type.; ///; /// Instructions that do not have integer or vector of integer type are; /// accepted, but will always produce a mask with all bits set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h:12,Availability,alive,alive,12,/// Compute alive bits of one addition operand from alive output and known; /// operand bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h:52,Availability,alive,alive,52,/// Compute alive bits of one addition operand from alive output and known; /// operand bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h:12,Availability,alive,alive,12,/// Compute alive bits of one subtraction operand from alive output and known; /// operand bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h:55,Availability,alive,alive,55,/// Compute alive bits of one subtraction operand from alive output and known; /// operand bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:22,Integrability,Depend,DependenceAnalysis,22,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:383,Integrability,Depend,DependenceAnalysis,383,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:432,Integrability,depend,dependences,432,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:555,Integrability,Depend,Dependence,555,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:668,Integrability,depend,dependence,668,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:764,Integrability,depend,dependence,764,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:826,Integrability,depend,dependence,826,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:891,Integrability,Depend,DependenceGraph,891,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:998,Integrability,depend,dependence,998,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1200,Integrability,Depend,DependenceAnalysis,1200,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1248,Integrability,Depend,DependenceGraph,1248,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1371,Integrability,interface,interface,1371,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1467,Integrability,depend,dependences,1467,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1499,Integrability,depend,dependence,1499,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:463,Security,access,accesses,463,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1219,Security,attack,attacks,1219,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1269,Security,attack,attack,1269,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:566,Testability,Test,Testing,566,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Integrability,Depend,Dependence,4,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:41,Integrability,depend,dependence,41,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:269,Integrability,depend,dependence,269,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:320,Integrability,depend,dependence,320,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:405,Integrability,depend,dependences,405,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:423,Integrability,depend,dependence,423,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:531,Integrability,depend,dependences,531,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:575,Integrability,depend,dependence,575,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:607,Integrability,Depend,Dependence,607,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:859,Integrability,depend,dependence,859,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Integrability,Depend,Dependence,4,"/// Dependence::DVEntry - Each level in the distance/direction vector; /// has a direction (or perhaps a union of several directions), and; /// perhaps a distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:42,Integrability,depend,dependence,42,// Peeling the first iteration will break dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,Integrability,depend,dependence,45,// Peeling the last iteration will break the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:33,Integrability,depend,dependence,33,// Splitting the loop will break dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:28,Availability,avail,available,28,// NULL implies no distance available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:53,Integrability,depend,dependence,53,/// getSrc - Returns the source instruction for this dependence.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:58,Integrability,depend,dependence,58,/// getDst - Returns the destination instruction for this dependence.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:47,Integrability,depend,dependence,47,/// isInput - Returns true if this is an input dependence.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:49,Integrability,depend,dependence,49,/// isOutput - Returns true if this is an output dependence.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:55,Integrability,depend,dependence,55,/// isFlow - Returns true if this is a flow (aka true) dependence.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,Integrability,depend,dependence,45,/// isAnti - Returns true if this is an anti dependence.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:32,Integrability,depend,dependence,32,"/// isOrdered - Returns true if dependence is Output, Flow, or Anti; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:34,Integrability,depend,dependence,34,/// isUnordered - Returns true if dependence is Input; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:72,Integrability,depend,dependence,72,/// isLoopIndependent - Returns true if this is a loop-independent; /// dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:38,Integrability,depend,dependence,38,/// isConfused - Returns true if this dependence is confused; /// (the compiler understands nothing and makes worst-case; /// assumptions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:40,Integrability,depend,dependence,40,/// isConsistent - Returns true if this dependence is consistent; /// (occurs every time the source and destination are executed).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:102,Integrability,depend,dependence,102,/// getLevels - Returns the number of common loops surrounding the; /// source and destination of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:174,Integrability,depend,dependence,174,"/// If the direction vector is negative, normalize the direction; /// vector to make it non-negative. Normalization is done by reversing; /// Src and Dst, plus reversing the dependence directions and distances; /// in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:98,Integrability,depend,dependence,98,/// isPeelFirst - Returns true if peeling the first iteration from; /// this loop will break this dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:96,Integrability,depend,dependence,96,/// isPeelLast - Returns true if peeling the last iteration from; /// this loop will break this dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:74,Integrability,depend,dependence,74,/// isSplitable - Returns true if splitting this loop will break; /// the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:147,Modifiability,variab,variable,147,"/// isScalar - Returns true if a particular level is scalar; that is,; /// if no subscript in the source or destination mention the induction; /// variable associated with the loop at this level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:43,Integrability,depend,dependence,43,"/// dump - For debugging purposes, dumps a dependence to OS.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,Integrability,depend,dependence,45,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:154,Integrability,depend,dependence,154,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:326,Integrability,depend,dependence,326,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:342,Integrability,Depend,Dependence,342,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:402,Integrability,depend,dependences,402,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:420,Integrability,depend,dependence,420,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:528,Integrability,depend,dependences,528,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:72,Integrability,depend,dependence,72,/// isLoopIndependent - Returns true if this is a loop-independent; /// dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:38,Integrability,depend,dependence,38,/// isConfused - Returns true if this dependence is confused; /// (the compiler understands nothing and makes worst-case; /// assumptions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:40,Integrability,depend,dependence,40,/// isConsistent - Returns true if this dependence is consistent; /// (occurs every time the source and destination are executed).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:102,Integrability,depend,dependence,102,/// getLevels - Returns the number of common loops surrounding the; /// source and destination of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:174,Integrability,depend,dependence,174,"/// If the direction vector is negative, normalize the direction; /// vector to make it non-negative. Normalization is done by reversing; /// Src and Dst, plus reversing the dependence directions and distances; /// in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:98,Integrability,depend,dependence,98,/// isPeelFirst - Returns true if peeling the first iteration from; /// this loop will break this dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:96,Integrability,depend,dependence,96,/// isPeelLast - Returns true if peeling the last iteration from; /// this loop will break this dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:73,Integrability,depend,dependence,73,/// isSplitable - Returns true if splitting the loop will break; /// the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:147,Modifiability,variab,variable,147,"/// isScalar - Returns true if a particular level is scalar; that is,; /// if no subscript in the source or destination mention the induction; /// variable associated with the loop at this level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Integrability,Depend,DependenceInfo,4,/// DependenceInfo - This class is the main dependence-analysis driver.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:44,Integrability,depend,dependence-analysis,44,/// DependenceInfo - This class is the main dependence-analysis driver.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:44,Performance,cache,cached,44,/// Handle transitive invalidation when the cached analysis results go away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Integrability,depend,depends,4,"/// depends - Tests for a dependence between the Src and Dst instructions.; /// Returns NULL if no dependence; otherwise, returns a Dependence (or a; /// FullDependence) with as much information as can be gleaned.; /// The flag PossiblyLoopIndependent should be set by the caller; /// if it appears that control flow can reach from Src to Dst; /// without traversing a loop back edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:26,Integrability,depend,dependence,26,"/// depends - Tests for a dependence between the Src and Dst instructions.; /// Returns NULL if no dependence; otherwise, returns a Dependence (or a; /// FullDependence) with as much information as can be gleaned.; /// The flag PossiblyLoopIndependent should be set by the caller; /// if it appears that control flow can reach from Src to Dst; /// without traversing a loop back edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:99,Integrability,depend,dependence,99,"/// depends - Tests for a dependence between the Src and Dst instructions.; /// Returns NULL if no dependence; otherwise, returns a Dependence (or a; /// FullDependence) with as much information as can be gleaned.; /// The flag PossiblyLoopIndependent should be set by the caller; /// if it appears that control flow can reach from Src to Dst; /// without traversing a loop back edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:132,Integrability,Depend,Dependence,132,"/// depends - Tests for a dependence between the Src and Dst instructions.; /// Returns NULL if no dependence; otherwise, returns a Dependence (or a; /// FullDependence) with as much information as can be gleaned.; /// The flag PossiblyLoopIndependent should be set by the caller; /// if it appears that control flow can reach from Src to Dst; /// without traversing a loop back edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:14,Testability,Test,Tests,14,"/// depends - Tests for a dependence between the Src and Dst instructions.; /// Returns NULL if no dependence; otherwise, returns a Dependence (or a; /// FullDependence) with as much information as can be gleaned.; /// The flag PossiblyLoopIndependent should be set by the caller; /// if it appears that control flow can reach from Src to Dst; /// without traversing a loop back edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:31,Integrability,depend,dependence,31,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:181,Integrability,depend,dependence,181,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:230,Integrability,depend,dependence,230,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:305,Integrability,depend,dependences,305,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:488,Integrability,depend,dependences,488,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:638,Integrability,depend,dependences,638,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1181,Integrability,depend,dependence,1181,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1266,Integrability,depend,dependence,1266,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1320,Integrability,depend,dependence,1320,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1449,Integrability,depend,dependence,1449,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1630,Integrability,depend,dependence,1630,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1214,Performance,load,load,1214,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1256,Testability,test,test,1256,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:168,Usability,guid,guide,168,/// Subscript - This private struct represents a pair of subscripts from; /// a pair of potentially multi-dimensional array references. We use a; /// vector of them to guide subscript partitioning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:110,Integrability,Depend,Dependence,110,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:272,Integrability,depend,dependence,272,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:387,Integrability,depend,dependence,387,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:446,Integrability,depend,dependence,446,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:515,Integrability,depend,dependence,515,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:583,Integrability,depend,dependence,583,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:121,Testability,Test,Testing,121,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:70,Testability,assert,assert,70,"/// getX - If constraint is a point <X, Y>, returns X.; /// Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:70,Testability,assert,assert,70,"/// getY - If constraint is a point <X, Y>, returns Y.; /// Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:74,Testability,assert,assert,74,"/// getA - If constraint is a line AX + BY = C, returns A.; /// Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:74,Testability,assert,assert,74,"/// getB - If constraint is a line AX + BY = C, returns B.; /// Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:74,Testability,assert,assert,74,"/// getC - If constraint is a line AX + BY = C, returns C.; /// Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:66,Testability,assert,assert,66,"/// getD - If constraint is a distance, returns D.; /// Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:595,Energy Efficiency,allocate,allocate,595,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:285,Integrability,rout,routine,285,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1566,Integrability,depend,dependence,1566,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:137,Modifiability,variab,variables,137,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:739,Modifiability,variab,variable,739,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1623,Performance,load,load,1623,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:76,Modifiability,extend,extending,76,/// Makes sure all subscript pairs share the same integer type by; /// sign-extending as necessary.; /// Sign-extending a subscript is safe because getelementptr assumes the; /// array subscripts are signed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:110,Modifiability,extend,extending,110,/// Makes sure all subscript pairs share the same integer type by; /// sign-extending as necessary.; /// Sign-extending a subscript is safe because getelementptr assumes the; /// array subscripts are signed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:135,Safety,safe,safe,135,/// Makes sure all subscript pairs share the same integer type by; /// sign-extending as necessary.; /// Sign-extending a subscript is safe because getelementptr assumes the; /// array subscripts are signed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:129,Modifiability,extend,extended,129,"/// removeMatchingExtensions - Examines a subscript pair.; /// If the source and destination are identically sign (or zero); /// extended, it strips off the extension in an effort to; /// simplify the actual analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:188,Usability,simpl,simplify,188,"/// removeMatchingExtensions - Examines a subscript pair.; /// If the source and destination are identically sign (or zero); /// extended, it strips off the extension in an effort to; /// simplify the actual analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:82,Integrability,wrap,wrapper,82,"/// isKnownPredicate - Compare X and Y using the predicate Pred.; /// Basically a wrapper for SCEV::isKnownPredicate,; /// but tries harder, especially in the presence of sign and zero; /// extensions and symbolics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:73,Integrability,wrap,wrapper,73,"/// isKnownLessThan - Compare to see if S is less than Size; /// Another wrapper for isKnownNegative(S - max(Size, 1)) with some extra; /// checking if S is an AddRec and we can prove lessthan using the loop; /// bounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:169,Integrability,wrap,wrapping,169,"/// isKnownNonNegative - Compare to see if S is known not to be negative; /// Uses the fact that S comes from Ptr, which may be an inbound GEP,; /// Proving there is no wrapping going on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:167,Availability,avail,available,167,"/// collectUpperBound - All subscripts are the same type (on my machine,; /// an i64). The loop bound may be a smaller type. collectUpperBound; /// find the bound, if available, and zero extends it to the Type T.; /// (I zero extend since the bound should always be >= 0.); /// If no upper bound is available, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:299,Availability,avail,available,299,"/// collectUpperBound - All subscripts are the same type (on my machine,; /// an i64). The loop bound may be a smaller type. collectUpperBound; /// find the bound, if available, and zero extends it to the Type T.; /// (I zero extend since the bound should always be >= 0.); /// If no upper bound is available, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:187,Modifiability,extend,extends,187,"/// collectUpperBound - All subscripts are the same type (on my machine,; /// an i64). The loop bound may be a smaller type. collectUpperBound; /// find the bound, if available, and zero extends it to the Type T.; /// (I zero extend since the bound should always be >= 0.); /// If no upper bound is available, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:226,Modifiability,extend,extend,226,"/// collectUpperBound - All subscripts are the same type (on my machine,; /// an i64). The loop bound may be a smaller type. collectUpperBound; /// find the bound, if available, and zero extends it to the Type T.; /// (I zero extend since the bound should always be >= 0.); /// If no upper bound is available, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:61,Integrability,depend,dependence,61,"/// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:107,Integrability,depend,dependence,107,"/// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:157,Integrability,depend,dependence,157,"/// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:196,Integrability,depend,dependence,196,"/// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Testability,test,testZIV,4,"/// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:14,Testability,Test,Tests,14,"/// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:61,Integrability,depend,dependence,61,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:267,Integrability,depend,dependence,267,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:317,Integrability,depend,dependence,317,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:453,Integrability,depend,dependence,453,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:159,Modifiability,variab,variables,159,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Testability,test,testSIV,4,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:14,Testability,Test,Tests,14,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:63,Integrability,depend,dependence,63,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:365,Integrability,depend,dependence,365,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:415,Integrability,depend,dependence,415,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:160,Modifiability,variab,variables,160,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Testability,test,testRDIV,4,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:15,Testability,Test,Tests,15,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:264,Testability,test,test,264,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:61,Integrability,depend,dependence,61,/// testMIV - Tests the MIV subscript pair (Src and Dst) for dependence.; /// Returns true if dependence disproved.; /// Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:94,Integrability,depend,dependence,94,/// testMIV - Tests the MIV subscript pair (Src and Dst) for dependence.; /// Returns true if dependence disproved.; /// Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Testability,test,testMIV,4,/// testMIV - Tests the MIV subscript pair (Src and Dst) for dependence.; /// Returns true if dependence disproved.; /// Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:14,Testability,Test,Tests,14,/// testMIV - Tests the MIV subscript pair (Src and Dst) for dependence.; /// Returns true if dependence disproved.; /// Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:79,Integrability,depend,dependence,79,"/// strongSIVtest - Tests the strong SIV subscript pair (Src and Dst); /// for dependence.; /// Things of the form [c1 + a*i] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction and distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:270,Integrability,depend,dependence,270,"/// strongSIVtest - Tests the strong SIV subscript pair (Src and Dst); /// for dependence.; /// Things of the form [c1 + a*i] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction and distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:320,Integrability,depend,dependence,320,"/// strongSIVtest - Tests the strong SIV subscript pair (Src and Dst); /// for dependence.; /// Things of the form [c1 + a*i] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction and distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:171,Modifiability,variab,variable,171,"/// strongSIVtest - Tests the strong SIV subscript pair (Src and Dst); /// for dependence.; /// Things of the form [c1 + a*i] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction and distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:20,Testability,Test,Tests,20,"/// strongSIVtest - Tests the strong SIV subscript pair (Src and Dst); /// for dependence.; /// Things of the form [c1 + a*i] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction and distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:92,Integrability,depend,dependence,92,"/// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2 - a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// Marks the dependence as splitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:284,Integrability,depend,dependence,284,"/// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2 - a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// Marks the dependence as splitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:334,Integrability,depend,dependence,334,"/// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2 - a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// Marks the dependence as splitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:445,Integrability,depend,dependence,445,"/// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2 - a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// Marks the dependence as splitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:184,Modifiability,variab,variable,184,"/// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2 - a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// Marks the dependence as splitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:26,Testability,Test,Tests,26,"/// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2 - a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// Marks the dependence as splitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:71,Integrability,depend,dependence,71,"/// ExactSIVtest - Tests the SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:272,Integrability,depend,dependence,272,"/// ExactSIVtest - Tests the SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:322,Integrability,depend,dependence,322,"/// ExactSIVtest - Tests the SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:165,Modifiability,variab,variable,165,"/// ExactSIVtest - Tests the SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:19,Testability,Test,Tests,19,"/// ExactSIVtest - Tests the SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:87,Integrability,depend,dependence,87,"/// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroDstSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:302,Integrability,depend,dependence,302,"/// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroDstSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:352,Integrability,depend,dependence,352,"/// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroDstSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:484,Integrability,depend,dependence,484,"/// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroDstSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:173,Modifiability,variab,variable,173,"/// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroDstSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:25,Testability,Test,Tests,25,"/// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroDstSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:87,Integrability,depend,dependence,87,"/// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroSrcSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:302,Integrability,depend,dependence,302,"/// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroSrcSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:352,Integrability,depend,dependence,352,"/// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroSrcSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:484,Integrability,depend,dependence,484,"/// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroSrcSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:173,Modifiability,variab,variable,173,"/// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroSrcSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:25,Testability,Test,Tests,25,"/// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroSrcSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:54,Integrability,depend,dependence,54,"/// exactRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that symbolicRDIVtest doesn't,; /// and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:256,Integrability,depend,dependence,256,"/// exactRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that symbolicRDIVtest doesn't,; /// and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:150,Modifiability,variab,variable,150,"/// exactRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that symbolicRDIVtest doesn't,; /// and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:20,Testability,Test,Tests,20,"/// exactRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that symbolicRDIVtest doesn't,; /// and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:57,Integrability,depend,dependence,57,"/// symbolicRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that exactRDIVtest doesn't,; /// and vice versa. Can also be used as a backup for; /// ordinary SIV tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:259,Integrability,depend,dependence,259,"/// symbolicRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that exactRDIVtest doesn't,; /// and vice versa. Can also be used as a backup for; /// ordinary SIV tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:153,Modifiability,variab,variable,153,"/// symbolicRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that exactRDIVtest doesn't,; /// and vice versa. Can also be used as a backup for; /// ordinary SIV tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:23,Testability,Test,Tests,23,"/// symbolicRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that exactRDIVtest doesn't,; /// and vice versa. Can also be used as a backup for; /// ordinary SIV tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:448,Testability,test,tests,448,"/// symbolicRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that exactRDIVtest doesn't,; /// and vice versa. Can also be used as a backup for; /// ordinary SIV tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:49,Integrability,depend,dependence,49,"/// gcdMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Can sometimes disprove the equal direction for 1 or more loops.; // Can handle some symbolics that even the SIV tests don't get,; /// so we use it as a backup for everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:95,Integrability,depend,dependence,95,"/// gcdMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Can sometimes disprove the equal direction for 1 or more loops.; // Can handle some symbolics that even the SIV tests don't get,; /// so we use it as a backup for everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:17,Testability,Test,Tests,17,"/// gcdMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Can sometimes disprove the equal direction for 1 or more loops.; // Can handle some symbolics that even the SIV tests don't get,; /// so we use it as a backup for everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:276,Testability,test,tests,276,"/// gcdMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Can sometimes disprove the equal direction for 1 or more loops.; // Can handle some symbolics that even the SIV tests don't get,; /// so we use it as a backup for everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:54,Integrability,depend,dependence,54,/// banerjeeMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Computes directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:100,Integrability,depend,dependence,100,/// banerjeeMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Computes directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:22,Testability,Test,Tests,22,/// banerjeeMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Computes directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:126,Integrability,depend,dependences,126,"/// exploreDirections - Hierarchically expands the direction vector; /// search space, combining the directions of discovered dependences; /// in the DirSet field of Bound. Returns the number of distinct; /// dependences discovered. If the dependence is disproved,; /// it will return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:209,Integrability,depend,dependences,209,"/// exploreDirections - Hierarchically expands the direction vector; /// search space, combining the directions of discovered dependences; /// in the DirSet field of Bound. Returns the number of distinct; /// dependences discovered. If the dependence is disproved,; /// it will return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:240,Integrability,depend,dependence,240,"/// exploreDirections - Hierarchically expands the direction vector; /// search space, combining the directions of discovered dependences; /// in the DirSet field of Bound. Returns the number of distinct; /// dependences discovered. If the dependence is disproved,; /// it will return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Testability,test,testBounds,4,/// testBounds - Returns true iff the current bounds are plausible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:27,Deployability,Update,Updates,27,/// intersectConstraints - Updates X with the intersection; /// of the Constraints X and Y. Returns true if X has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:251,Integrability,depend,dependence,251,"/// propagate - Review the constraints, looking for opportunities; /// to simplify a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:74,Usability,simpl,simplify,74,"/// propagate - Review the constraints, looking for opportunities; /// to simplify a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:140,Usability,simpl,simplification,140,"/// propagate - Review the constraints, looking for opportunities; /// to simplify a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:175,Usability,simpl,simplification,175,"/// propagate - Review the constraints, looking for opportunities; /// to simplify a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:245,Integrability,depend,dependence,245,"/// propagateDistance - Attempt to propagate a distance; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:134,Usability,simpl,simplification,134,"/// propagateDistance - Attempt to propagate a distance; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:169,Usability,simpl,simplification,169,"/// propagateDistance - Attempt to propagate a distance; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:128,Usability,simpl,simplification,128,/// propagatePoint - Attempt to propagate a point; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:237,Integrability,depend,dependence,237,"/// propagateLine - Attempt to propagate a line; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:126,Usability,simpl,simplification,126,"/// propagateLine - Attempt to propagate a line; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:161,Usability,simpl,simplification,161,"/// propagateLine - Attempt to propagate a line; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Deployability,update,updateDirection,4,/// updateDirection - Update direction vector entry; /// based on the current constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:22,Deployability,Update,Update,22,/// updateDirection - Update direction vector entry; /// based on the current constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,Availability,recover,recover,45,"/// Given a linear access function, tries to recover subscripts; /// for each dimension of the array element access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,Safety,recover,recover,45,"/// Given a linear access function, tries to recover subscripts; /// for each dimension of the array element access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:19,Security,access,access,19,"/// Given a linear access function, tries to recover subscripts; /// for each dimension of the array element access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:109,Security,access,access,109,"/// Given a linear access function, tries to recover subscripts; /// for each dimension of the array element access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:43,Security,access,access,43,"/// Tries to delinearize \p Src and \p Dst access functions for a fixed size; /// multi-dimensional array. Calls tryDelinearizeFixedSizeImpl() to; /// delinearize \p Src and \p Dst separately,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:25,Security,access,access,25,/// Tries to delinearize access function for a multi-dimensional array with; /// symbolic runtime sizes.; /// Returns true upon success and false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:89,Safety,avoid,avoid,89,/// checkSubscript - Helper function for checkSrcSubscript and; /// checkDstSubscript to avoid duplicate code,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:9,Integrability,Depend,DependenceInfo,9,// class DependenceInfo; /// AnalysisPass to compute dependence information in a function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:53,Integrability,depend,dependence,53,// class DependenceInfo; /// AnalysisPass to compute dependence information in a function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:9,Integrability,Depend,DependenceAnalysis,9,// class DependenceAnalysis; /// Printer pass to dump DA results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:9,Integrability,Depend,DependenceAnalysisPrinterPass,9,// class DependenceAnalysisPrinterPass; /// Legacy pass manager pass to access dependence information,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:79,Integrability,depend,dependence,79,// class DependenceAnalysisPrinterPass; /// Legacy pass manager pass to access dependence information,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:72,Security,access,access,72,// class DependenceAnalysisPrinterPass; /// Legacy pass manager pass to access dependence information,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:9,Integrability,Depend,DependenceAnalysisWrapperPass,9,// class DependenceAnalysisWrapperPass; /// createDependenceAnalysisPass - This creates an instance of the; /// DependenceAnalysis wrapper pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:112,Integrability,Depend,DependenceAnalysis,112,// class DependenceAnalysisWrapperPass; /// createDependenceAnalysisPass - This creates an instance of the; /// DependenceAnalysis wrapper pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:131,Integrability,wrap,wrapper,131,// class DependenceAnalysisWrapperPass; /// createDependenceAnalysisPass - This creates an instance of the; /// DependenceAnalysis wrapper pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:21,Integrability,Depend,DependenceGraphBuilder,21,"//===- llvm/Analysis/DependenceGraphBuilder.h -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a builder interface that can be used to populate dependence; // graphs such as DDG and PDG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:411,Integrability,interface,interface,411,"//===- llvm/Analysis/DependenceGraphBuilder.h -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a builder interface that can be used to populate dependence; // graphs such as DDG and PDG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:450,Integrability,depend,dependence,450,"//===- llvm/Analysis/DependenceGraphBuilder.h -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a builder interface that can be used to populate dependence; // graphs such as DDG and PDG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:132,Modifiability,inherit,inherit,132,/// This abstract builder class defines a set of high-level steps for creating; /// DDG-like graphs. The client code is expected to inherit from this class and; /// define concrete implementation for each of the pure virtual functions used; /// in the high-level algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:288,Integrability,depend,dependence,288,"/// The main entry to the graph construction algorithm. It starts by; /// creating nodes in increasing order of granularity and then; /// adds def-use and memory edges. As one of the final stages, it; /// also creates pi-block nodes to facilitate codegen in transformations; /// that use dependence graphs.; ///; /// The algorithmic complexity of this implementation is O(V^2 * I^2), where V; /// is the number of vertecies (nodes) and I is the number of instructions in; /// each node. The total number of instructions, N, is equal to V * I,; /// therefore the worst-case time complexity is O(N^2). The average time; /// complexity is O((N^2)/2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:17,Integrability,depend,dependencies,17,"/// Analyze data dependencies that exist between memory loads or stores,; /// in the graph nodes and create edges between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:56,Performance,load,loads,56,"/// Analyze data dependencies that exist between memory loads or stores,; /// in the graph nodes and create edges between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:302,Integrability,depend,dependence,302,/// Apply graph abstraction to groups of nodes that belong to a strongly; /// connected component of the graph to create larger compound nodes; /// called pi-blocks. The purpose of this abstraction is to isolate sets of; /// program elements that need to stay together during codegen and turn; /// the dependence graph into an acyclic graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:391,Usability,simpl,simple,391,/// Go through all the nodes in the graph and collapse any two nodes; /// 'a' and 'b' if all of the following are true:; /// - the only edge from 'a' is a def-use edge to 'b' and; /// - the only edge to 'b' is a def-use edge from 'a' and; /// - there is no cyclic edge from 'b' to 'a' and; /// - all instructions in 'a' and 'b' belong to the same basic block and; /// - both 'a' and 'b' are simple (single or multi instruction) nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:20,Integrability,depend,dependence,20,/// Create a memory dependence edge going from \p Src to \p Tgt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:25,Usability,simpl,simplification,25,"/// Return true if graph simplification step is requested, and false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:24,Safety,safe,safe,24,/// Return true if it's safe to merge the two nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:4,Integrability,Depend,Dependence,4,/// Dependence information used to create memory dependence edges in the; /// graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:49,Integrability,depend,dependence,49,/// Dependence information used to create memory dependence edges in the; /// graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:383,Performance,Cache,Cache,383,"//===- llvm/Analysis/DomConditionCache.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Cache for branch conditions that affect a certain value for use by; // ValueTracking. Unlike AssumptionCache, this class does not perform any; // automatic analysis or invalidation. The caller is responsible for registering; // all relevant branches (and re-registering them if they change), and for; // removing invalidated values from the cache.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:513,Performance,perform,perform,513,"//===- llvm/Analysis/DomConditionCache.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Cache for branch conditions that affect a certain value for use by; // ValueTracking. Unlike AssumptionCache, this class does not perform any; // automatic analysis or invalidation. The caller is responsible for registering; // all relevant branches (and re-registering them if they change), and for; // removing invalidated values from the cache.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:724,Performance,cache,cache,724,"//===- llvm/Analysis/DomConditionCache.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Cache for branch conditions that affect a certain value for use by; // ValueTracking. Unlike AssumptionCache, this class does not perform any; // automatic analysis or invalidation. The caller is responsible for registering; // all relevant branches (and re-registering them if they change), and for; // removing invalidated values from the cache.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:34,Performance,cache,cache,34,/// Add a branch condition to the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:28,Performance,cache,cache,28,"/// Remove a value from the cache, e.g. because it will be erased.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:4,Security,Access,Access,4,/// Access the list of branches which affect this value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DominanceFrontier.h:12,Integrability,interface,interface,12,// Accessor interface:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DominanceFrontier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DominanceFrontier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DominanceFrontier.h:3,Security,Access,Accessor,3,// Accessor interface:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DominanceFrontier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DominanceFrontier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomPrinter.h:44,Integrability,interface,interface,44,"//===-- DomPrinter.h - Dom printer external interface ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines external functions that can be called to explicitly; // instantiate the dominance tree printer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:47,Deployability,Update,Updater,47,"//===- DomTreeUpdater.h - DomTree/Post DomTree Updater ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the DomTreeUpdater class, which provides a uniform way to; // update dominator tree related data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:463,Deployability,update,update,463,"//===- DomTreeUpdater.h - DomTree/Post DomTree Updater ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the DomTreeUpdater class, which provides a uniform way to; // update dominator tree related data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:127,Availability,avail,available,127,/// Returns true if there is BasicBlock awaiting deletion.; /// The deletion will only happen until a flush event and; /// all available trees are up-to-date.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:190,Deployability,Update,UpdateStrategy,190,/// Returns true if there is BasicBlock awaiting deletion.; /// The deletion will only happen until a flush event and; /// all available trees are up-to-date.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:79,Deployability,Update,UpdateStrategy,79,/// Returns true if DelBB is awaiting deletion.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:84,Deployability,update,update,84,/// Returns true if either of DT or PDT is valid and the tree has at; /// least one update pending. If DT or PDT is nullptr it is treated; /// as having no pending updates. This function does not check; /// whether there is BasicBlock awaiting deletion.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:164,Deployability,update,updates,164,/// Returns true if either of DT or PDT is valid and the tree has at; /// least one update pending. If DT or PDT is nullptr it is treated; /// as having no pending updates. This function does not check; /// whether there is BasicBlock awaiting deletion.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:285,Deployability,Update,UpdateStrategy,285,/// Returns true if either of DT or PDT is valid and the tree has at; /// least one update pending. If DT or PDT is nullptr it is treated; /// as having no pending updates. This function does not check; /// whether there is BasicBlock awaiting deletion.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:44,Deployability,update,updates,44,/// Returns true if there are DominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or DT is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:91,Deployability,Update,UpdateStrategy,91,/// Returns true if there are DominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or DT is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:52,Performance,queue,queued,52,/// Returns true if there are DominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or DT is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:48,Deployability,update,updates,48,/// Returns true if there are PostDominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or PDT is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:95,Deployability,Update,UpdateStrategy,95,/// Returns true if there are PostDominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or PDT is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:56,Performance,queue,queued,56,/// Returns true if there are PostDominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or PDT is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:979,Availability,avail,available,979,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:83,Deployability,update,updates,83,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:188,Deployability,update,update,188,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:259,Deployability,Update,UpdateStrategy,259,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:275,Deployability,Update,Updates,275,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:345,Deployability,Update,UpdateStrategy,345,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:361,Deployability,Update,Updates,361,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:472,Deployability,update,update,472,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:520,Deployability,update,updates,520,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:591,Deployability,update,updates,591,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:662,Deployability,update,updater,662,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:689,Deployability,update,updates,689,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:819,Deployability,update,updates,819,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:879,Deployability,update,update,879,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:964,Deployability,update,updates,964,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1028,Deployability,update,updates,1028,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1088,Deployability,update,updates,1088,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1204,Deployability,update,updates,1204,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1231,Deployability,update,update,1231,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1316,Deployability,update,updated,1316,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1353,Deployability,update,updates,1353,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1382,Deployability,update,update,1382,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1468,Deployability,update,update,1468,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1526,Deployability,update,update,1526,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:792,Integrability,depend,depending,792,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1389,Integrability,rout,routine,1389,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1077,Performance,queue,queues,1077,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:26,Availability,avail,available,26,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:11,Deployability,update,updates,11,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:83,Deployability,update,updates,83,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:115,Deployability,update,updates,115,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:133,Deployability,update,updates,133,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:268,Deployability,update,updates,268,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:328,Deployability,update,updates,328,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:444,Deployability,update,updates,444,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:471,Deployability,update,update,471,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:556,Deployability,update,updated,556,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:593,Deployability,update,updates,593,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:622,Deployability,update,update,622,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:708,Deployability,update,update,708,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:766,Deployability,update,update,766,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:935,Deployability,update,updates,935,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1015,Deployability,update,updates,1015,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:629,Integrability,rout,routine,629,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:317,Performance,queue,queues,317,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:71,Availability,avail,available,71,/// Notify DTU that the entry block was replaced.; /// Recalculate all available trees and flush all BasicBlocks; /// awaiting deletion immediately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:77,Availability,avail,available,77,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:287,Availability,avail,available,287,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:148,Deployability,Update,UpdateStrategy,148,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:217,Deployability,Update,UpdateStrategy,217,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:247,Performance,queue,queued,247,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:450,Performance,queue,queued,450,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:319,Testability,Assert,Assert,319,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:77,Availability,avail,available,77,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:334,Availability,avail,available,334,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:195,Deployability,Update,UpdateStrategy,195,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:264,Deployability,Update,UpdateStrategy,264,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:506,Deployability,Update,UpdateStrategy,506,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:294,Performance,queue,queued,294,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:469,Performance,queue,queued,469,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:366,Testability,Assert,Assert,366,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:182,Deployability,update,updates,182,"///@}; ///@{; /// \name Flush APIs; ///; /// CAUTION! By the moment these flush APIs are called, the current CFG needs; /// to be the same as the CFG which DTU is in sync with + all updates; /// submitted.; /// Flush DomTree updates and return DomTree.; /// It flushes Deleted BBs if both trees are up-to-date.; /// It must only be called when it has a DomTree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:225,Deployability,update,updates,225,"///@}; ///@{; /// \name Flush APIs; ///; /// CAUTION! By the moment these flush APIs are called, the current CFG needs; /// to be the same as the CFG which DTU is in sync with + all updates; /// submitted.; /// Flush DomTree updates and return DomTree.; /// It flushes Deleted BBs if both trees are up-to-date.; /// It must only be called when it has a DomTree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:22,Deployability,update,updates,22,/// Flush PostDomTree updates and return PostDomTree.; /// It flushes Deleted BBs if both trees are up-to-date.; /// It must only be called when it has a PostDomTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:33,Availability,avail,available,33,/// Apply all pending updates to available trees and flush all BasicBlocks; /// awaiting deletion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:22,Deployability,update,updates,22,/// Apply all pending updates to available trees and flush all BasicBlocks; /// awaiting deletion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:241,Deployability,Update,UpdateStrategy,241,/// First remove all the instructions of DelBB and then make sure DelBB has a; /// valid terminator instruction which is necessary to have when DelBB still; /// has to be inside of its parent Function while awaiting deletion under Lazy; /// UpdateStrategy to prevent other routines from asserting the state of the; /// IR is inconsistent. Assert if DelBB is nullptr or has predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:273,Integrability,rout,routines,273,/// First remove all the instructions of DelBB and then make sure DelBB has a; /// valid terminator instruction which is necessary to have when DelBB still; /// has to be inside of its parent Function while awaiting deletion under Lazy; /// UpdateStrategy to prevent other routines from asserting the state of the; /// IR is inconsistent. Assert if DelBB is nullptr or has predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:287,Testability,assert,asserting,287,/// First remove all the instructions of DelBB and then make sure DelBB has a; /// valid terminator instruction which is necessary to have when DelBB still; /// has to be inside of its parent Function while awaiting deletion under Lazy; /// UpdateStrategy to prevent other routines from asserting the state of the; /// IR is inconsistent. Assert if DelBB is nullptr or has predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:339,Testability,Assert,Assert,339,/// First remove all the instructions of DelBB and then make sure DelBB has a; /// valid terminator instruction which is necessary to have when DelBB still; /// has to be inside of its parent Function while awaiting deletion under Lazy; /// UpdateStrategy to prevent other routines from asserting the state of the; /// IR is inconsistent. Assert if DelBB is nullptr or has predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:49,Deployability,update,updates,49,/// Helper function to apply all pending DomTree updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:53,Deployability,update,updates,53,/// Helper function to apply all pending PostDomTree updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:56,Availability,avail,available,56,/// Helper function to flush deleted BasicBlocks if all available; /// trees are up-to-date.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:36,Availability,avail,available,36,/// Drop all updates applied by all available trees and delete BasicBlocks if; /// all available trees are up-to-date.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:87,Availability,avail,available,87,/// Drop all updates applied by all available trees and delete BasicBlocks if; /// all available trees are up-to-date.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:13,Deployability,update,updates,13,/// Drop all updates applied by all available trees and delete BasicBlocks if; /// all available trees are up-to-date.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:24,Deployability,update,update,24,/// Returns true if the update appears in the LLVM IR.; /// It is used to check whether an update is valid in; /// insertEdge/deleteEdge or is unnecessary in the batch update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:91,Deployability,update,update,91,/// Returns true if the update appears in the LLVM IR.; /// It is used to check whether an update is valid in; /// insertEdge/deleteEdge or is unnecessary in the batch update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:168,Deployability,update,update,168,/// Returns true if the update appears in the LLVM IR.; /// It is used to check whether an update is valid in; /// insertEdge/deleteEdge or is unnecessary in the batch update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:24,Deployability,update,update,24,/// Returns true if the update is self dominance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:288,Availability,down,downcasting,288,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsViewer is also used as a mixin for avoiding repeated; /// implementation of viewer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:274,Modifiability,polymorphi,polymorphisms,274,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsViewer is also used as a mixin for avoiding repeated; /// implementation of viewer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:4,Safety,Avoid,Avoid,4,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsViewer is also used as a mixin for avoiding repeated; /// implementation of viewer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:183,Safety,avoid,avoiding,183,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsViewer is also used as a mixin for avoiding repeated; /// implementation of viewer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:537,Safety,avoid,avoid,537,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsViewer is also used as a mixin for avoiding repeated; /// implementation of viewer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:290,Availability,down,downcasting,290,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsPrinter is also used as a mixin for avoiding repeated; /// implementation of printer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:276,Modifiability,polymorphi,polymorphisms,276,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsPrinter is also used as a mixin for avoiding repeated; /// implementation of printer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:4,Safety,Avoid,Avoid,4,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsPrinter is also used as a mixin for avoiding repeated; /// implementation of printer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:184,Safety,avoid,avoiding,184,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsPrinter is also used as a mixin for avoiding repeated; /// implementation of printer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:539,Safety,avoid,avoid,539,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsPrinter is also used as a mixin for avoiding repeated; /// implementation of printer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/EHUtils.h:70,Deployability,update,update,70,// If status of predecessor block has gone above current block; // we update current blocks status.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/EHUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/EHUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/EHUtils.h:50,Deployability,update,update,50,// Check on predecessors and check for; // Status update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/EHUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/EHUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/FunctionPropertiesAnalysis.h:3,Performance,Load,Load,3,// Load Instruction Count,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/FunctionPropertiesAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/FunctionPropertiesAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/FunctionPropertiesAnalysis.h:14,Deployability,update,update,14,/// Correctly update FunctionPropertiesInfo post-inlining. A; /// FunctionPropertiesUpdater keeps the state necessary for tracking the changes; /// llvm::InlineFunction makes. The idea is that inlining will at most modify; /// a few BBs of the Caller (maybe the entry BB and definitely the callsite BB); /// and potentially affect exception handling BBs in the case of invoke; /// inlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/FunctionPropertiesAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/FunctionPropertiesAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:403,Integrability,interface,interface,403,"//===- GlobalsModRef.h - Simple Mod/Ref AA for Globals ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This is the interface for a simple mod/ref and alias analysis over globals.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:25,Usability,Simpl,Simple,25,"//===- GlobalsModRef.h - Simple Mod/Ref AA for Globals ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This is the interface for a simple mod/ref and alias analysis over globals.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:419,Usability,simpl,simple,419,"//===- GlobalsModRef.h - Simple Mod/Ref AA for Globals ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This is the interface for a simple mod/ref and alias analysis over globals.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:49,Energy Efficiency,allocate,allocates,49,"/// AllocsForIndirectGlobals - If an instruction allocates memory for an; /// indirect global, this map indicates which one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:59,Usability,simpl,simple,59,/// A map of functions to SCC. The SCCs are described by a simple integer; /// ID that is only useful for comparing for equality (are two functions; /// in the same SCC or not?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:14,Usability,clear,clear,14,/// Handle to clear this analysis on deletion of values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:207,Performance,optimiz,optimizations,207,"/// List of callbacks for globals being tracked by this analysis. Note that; /// these objects are quite large, but we only anticipate having one per; /// global tracked by this analysis. There are numerous optimizations we; /// could perform to the memory utilization here if this becomes a problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:235,Performance,perform,perform,235,"/// List of callbacks for globals being tracked by this analysis. Note that; /// these objects are quite large, but we only anticipate having one per; /// global tracked by this analysis. There are numerous optimizations we; /// could perform to the memory utilization here if this becomes a problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the GlobalsAAResult object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GuardUtils.h:402,Performance,perform,perform,402,"//===-- GuardUtils.h - Utils for work with guards ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Utils that are used to perform analyzes related to guards and their; // conditions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GuardUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GuardUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h:391,Integrability,Interface,Interface,391,"//===- IndirectCallPromotionAnalysis.h - Indirect call analysis -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Interface to identify indirect call promotion candidates.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h:124,Availability,avail,available,124,// Class for identifying profitable indirect call promotion candidates when; // the indirect-call value profile metadata is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space to read the profile annotation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:108,Deployability,Release,Release,108,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:167,Deployability,deploy,deployments,167,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:370,Integrability,depend,dependencies,370,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:733,Modifiability,plugin,plugin,733,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:741,Modifiability,Plugin,PluginInlineAdvisorAnalysis,741,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:504,Performance,perform,performance,504,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:711,Performance,load,load,711,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:659,Testability,log,logs,659,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:69,Deployability,pipeline,pipeline,69,"/// Provides context on when an inline advisor is constructed in the pipeline; /// (e.g., link phase, inline driver).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:357,Integrability,contract,contractual,357,"/// Capture state between an inlining decision having had been made, and; /// its impact being observable. When collecting model training data, this; /// allows recording features/decisions/partial reward data sets.; ///; /// Derivations of this type are expected to be tightly coupled with their; /// InliningAdvisors. The base type implements the minimal contractual; /// obligations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:69,Modifiability,extend,extend,69,"/// Exactly one of the record* APIs must be called. Implementers may extend; /// behavior by implementing the corresponding record*Impl.; ///; /// Call after inlining succeeded, and did not result in deleting the callee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:133,Availability,failure,failure,133,"// Capture the context of CB before inlining, as a successful inlining may; // change that context, and we want to report success or failure in the; // original context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:4,Integrability,Interface,Interface,4,/// Interface for deciding whether to inline a call site or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:90,Deployability,update,update,90,"/// This must be called when the Inliner pass is entered, to allow the; /// InlineAdvisor update internal state, as result of function passes run; /// between Inliner pass runs (for the same module).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:183,Deployability,update,update,183,"/// This must be called when the Inliner pass is exited, as function passes; /// may be run subsequently. This allows an implementation of InlineAdvisor; /// to prepare for a partial update, based on the optional SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:197,Testability,test,test,197,"/// The default (manual heuristics) implementation of the InlineAdvisor. This; /// implementation does not need to keep state between inliner pass runs, and is; /// reusable as-is for inliner pass test scenarios, as well as for regular use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:55,Modifiability,plugin,plugins,55,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:84,Modifiability,plugin,plugin,84,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:156,Modifiability,Plugin,PluginInlineAdvisorAnalysis,156,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:693,Modifiability,Plugin,PluginInlineAdvisorAnalysis,693,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:1267,Modifiability,plugin,plugin,1267,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:1335,Modifiability,Plugin,PluginInlineAdvisorAnlysis,1335,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:1421,Modifiability,plugin,plugin,1421,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:1160,Performance,Optimiz,OptimizationLevel,1160,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:1522,Performance,load,loaded,1522,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:13,Integrability,message,message,13,/// Emit ORE message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:13,Integrability,message,message,13,/// Emit ORE message based in cost (default heuristic).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:29,Integrability,message,message,29,/// Add location info to ORE message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:43,Integrability,message,message,43,/// Utility for extracting the inline cost message to a string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:34,Energy Efficiency,allocate,allocate,34,/// Do not inline functions which allocate this many bytes on the stack; /// when the caller is recursive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:386,Availability,avail,available,386,"/// Represents the cost of inlining a function.; ///; /// This supports special values for functions which should ""always"" or; /// ""never"" be inlined. Otherwise, the cost represents a unitless amount;; /// smaller values increase the likelihood of the function being inlined.; ///; /// Objects of this type also provide the adjusted threshold for inlining; /// based on the information available for a particular callsite. They can be; /// directly tested to determine if inlining should occur given the cost and; /// threshold for this cost metric.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:449,Testability,test,tested,449,"/// Represents the cost of inlining a function.; ///; /// This supports special values for functions which should ""always"" or; /// ""never"" be inlined. Otherwise, the cost represents a unitless amount;; /// smaller values increase the likelihood of the function being inlined.; ///; /// Objects of this type also provide the adjusted threshold for inlining; /// based on the information available for a particular callsite. They can be; /// directly tested to determine if inlining should occur given the cost and; /// threshold for this cost metric.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:36,Testability,log,logic,36,"// Trivial constructor, interesting logic in the factory functions below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:4,Testability,Test,Test,4,/// Test whether the inline cost is low enough for inlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:48,Availability,error,error,48,"/// Get the inline cost estimate.; /// It is an error to call this on an ""always"" or ""never"" InlineCost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:94,Modifiability,variab,variable,94,/// Get the cost delta from the threshold for inlining.; /// Only valid if the cost is of the variable kind. Returns a negative; /// value if the cost is too high to inline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:67,Integrability,message,message,67,/// InlineResult is basically true or false. For false results the message; /// describes a reason.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:18,Performance,tune,tune,18,"/// Thresholds to tune inline cost analysis. The inline cost analysis decides; /// the condition to apply a threshold and applies it. Otherwise,; /// DefaultThreshold is used. If a threshold is Optional, it is applied only; /// when it has a valid value. Typically, users of inline cost analysis; /// obtain an InlineParams object through one of the \c getInlineParams methods; /// and pass it to \c getInlineCost. Some specialized versions of inliner; /// (such as the pre-inliner) might have custom logic to compute \c InlineParams; /// object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:501,Testability,log,logic,501,"/// Thresholds to tune inline cost analysis. The inline cost analysis decides; /// the condition to apply a threshold and applies it. Otherwise,; /// DefaultThreshold is used. If a threshold is Optional, it is applied only; /// when it has a valid value. Typically, users of inline cost analysis; /// obtain an InlineParams object through one of the \c getInlineParams methods; /// and pass it to \c getInlineCost. Some specialized versions of inliner; /// (such as the pre-inliner) might have custom logic to compute \c InlineParams; /// object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:40,Performance,optimiz,optimized,40,/// Threshold to use when the caller is optimized for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:40,Performance,optimiz,optimized,40,/// Threshold to use when the caller is optimized for minsize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:31,Performance,tune,tune,31,/// Generate the parameters to tune the inline cost analysis based only on the; /// commandline options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:31,Performance,tune,tune,31,"/// Generate the parameters to tune the inline cost analysis based on command; /// line options. If -inline-threshold option is not explicitly passed,; /// \p Threshold is used as the default threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:31,Performance,tune,tune,31,"/// Generate the parameters to tune the inline cost analysis based on command; /// line options. If -inline-threshold option is not explicitly passed,; /// the default threshold is computed from \p OptLevel and \p SizeOptLevel.; /// An \p OptLevel value above 3 is considered an aggressive optimization mode.; /// \p SizeOptLevel of 1 corresponds to the -Os flag and 2 corresponds to; /// the -Oz flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:290,Performance,optimiz,optimization,290,"/// Generate the parameters to tune the inline cost analysis based on command; /// line options. If -inline-threshold option is not explicitly passed,; /// the default threshold is computed from \p OptLevel and \p SizeOptLevel.; /// An \p OptLevel value above 3 is considered an aggressive optimization mode.; /// \p SizeOptLevel of 1 corresponds to the -Os flag and 2 corresponds to; /// the -Oz flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:166,Availability,failure,failure,166,"/// Returns InlineResult::success() if the call site should be always inlined; /// because of user directives, and the inlining is viable. Returns; /// InlineResult::failure() if the inlining may never happen because of user; /// directives or incompatibilities detectable without needing callee traversal.; /// Otherwise returns std::nullopt, meaning that inlining should be decided; /// based on other criteria (e.g. cost modeling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:262,Safety,detect,detectable,262,"/// Returns InlineResult::success() if the call site should be always inlined; /// because of user directives, and the inlining is viable. Returns; /// InlineResult::failure() if the inlining may never happen because of user; /// directives or incompatibilities detectable without needing callee traversal.; /// Otherwise returns std::nullopt, meaning that inlining should be decided; /// based on other criteria (e.g. cost modeling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:22,Safety,detect,detect,22,/// Minimal filter to detect invalid constructs for inlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:194,Performance,optimiz,optimizations,194,// This pass is used to annotate instructions during the inline process for; // debugging and analysis. The main purpose of the pass is to see and test; // inliner's decisions when creating new optimizations to InlineCost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:147,Testability,test,test,147,// This pass is used to annotate instructions during the inline process for; // debugging and analysis. The main purpose of the pass is to see and test; // inliner's decisions when creating new optimizations to InlineCost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h:61,Modifiability,plugin,plugins,61,"/// Used for dynamically loading instances of InlineOrder as plugins; ///; /// Plugins must implement an InlineOrderFactory, for an example refer to:; /// llvm/unittests/Analysis/InlineOrderPlugin/InlineOrderPlugin.cpp; ///; /// If a PluginInlineOrderAnalysis has been registered with the; /// current ModuleAnalysisManager, llvm::getInlineOrder returns an; /// InlineOrder created by the PluginInlineOrderAnalysis' Factory.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h:79,Modifiability,Plugin,Plugins,79,"/// Used for dynamically loading instances of InlineOrder as plugins; ///; /// Plugins must implement an InlineOrderFactory, for an example refer to:; /// llvm/unittests/Analysis/InlineOrderPlugin/InlineOrderPlugin.cpp; ///; /// If a PluginInlineOrderAnalysis has been registered with the; /// current ModuleAnalysisManager, llvm::getInlineOrder returns an; /// InlineOrder created by the PluginInlineOrderAnalysis' Factory.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h:234,Modifiability,Plugin,PluginInlineOrderAnalysis,234,"/// Used for dynamically loading instances of InlineOrder as plugins; ///; /// Plugins must implement an InlineOrderFactory, for an example refer to:; /// llvm/unittests/Analysis/InlineOrderPlugin/InlineOrderPlugin.cpp; ///; /// If a PluginInlineOrderAnalysis has been registered with the; /// current ModuleAnalysisManager, llvm::getInlineOrder returns an; /// InlineOrder created by the PluginInlineOrderAnalysis' Factory.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h:389,Modifiability,Plugin,PluginInlineOrderAnalysis,389,"/// Used for dynamically loading instances of InlineOrder as plugins; ///; /// Plugins must implement an InlineOrderFactory, for an example refer to:; /// llvm/unittests/Analysis/InlineOrderPlugin/InlineOrderPlugin.cpp; ///; /// If a PluginInlineOrderAnalysis has been registered with the; /// current ModuleAnalysisManager, llvm::getInlineOrder returns an; /// InlineOrder created by the PluginInlineOrderAnalysis' Factory.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h:25,Performance,load,loading,25,"/// Used for dynamically loading instances of InlineOrder as plugins; ///; /// Plugins must implement an InlineOrderFactory, for an example refer to:; /// llvm/unittests/Analysis/InlineOrderPlugin/InlineOrderPlugin.cpp; ///; /// If a PluginInlineOrderAnalysis has been registered with the; /// current ModuleAnalysisManager, llvm::getInlineOrder returns an; /// InlineOrder created by the PluginInlineOrderAnalysis' Factory.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:567,Energy Efficiency,efficient,efficiently,567,"//===-- InstructionPrecedenceTracking.h -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Implements a class that is able to define some instructions as ""special""; // (e.g. as having implicit control flow, or writing memory, or having another; // interesting property) and then efficiently answers queries of the types:; // 1. Are there any special instructions in the block of interest?; // 2. Return first of the special instructions in the given block;; // 3. Check if the given instruction is preceeded by the first special; // instruction in the same block.; // The class provides caching that allows to answer these queries quickly. The; // user must make sure that the cached data is invalidated properly whenever; // a content of some tracked block is changed.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:965,Performance,cache,cached,965,"//===-- InstructionPrecedenceTracking.h -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Implements a class that is able to define some instructions as ""special""; // (e.g. as having implicit control flow, or writing memory, or having another; // interesting property) and then efficiently answers queries of the types:; // 1. Are there any special instructions in the block of interest?; // 2. Return first of the special instructions in the given block;; // 3. Check if the given instruction is preceeded by the first special; // instruction in the same block.; // The class provides caching that allows to answer these queries quickly. The; // user must make sure that the cached data is invalidated properly whenever; // a content of some tracked block is changed.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:93,Availability,error,error,93,/// Asserts that the cached info for \p BB is up-to-date. This helps to catch; /// the usage error of accessing a block without properly invalidating after a; /// previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:21,Performance,cache,cached,21,/// Asserts that the cached info for \p BB is up-to-date. This helps to catch; /// the usage error of accessing a block without properly invalidating after a; /// previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:102,Security,access,accessing,102,/// Asserts that the cached info for \p BB is up-to-date. This helps to catch; /// the usage error of accessing a block without properly invalidating after a; /// previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:4,Testability,Assert,Asserts,4,/// Asserts that the cached info for \p BB is up-to-date. This helps to catch; /// the usage error of accessing a block without properly invalidating after a; /// previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:107,Availability,error,error,107,/// Asserts whether or not the contents of this tracking is up-to-date. This; /// helps to catch the usage error of accessing a block without properly; /// invalidating after a previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:116,Security,access,accessing,116,/// Asserts whether or not the contents of this tracking is up-to-date. This; /// helps to catch the usage error of accessing a block without properly; /// invalidating after a previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:4,Testability,Assert,Asserts,4,/// Asserts whether or not the contents of this tracking is up-to-date. This; /// helps to catch the usage error of accessing a block without properly; /// invalidating after a previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:135,Deployability,update,updates,135,/// Notifies this tracking that we are going to insert a new instruction \p; /// Inst to the basic block \p BB. It makes all necessary updates to internal; /// caches to keep them consistent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:160,Performance,cache,caches,160,/// Notifies this tracking that we are going to insert a new instruction \p; /// Inst to the basic block \p BB. It makes all necessary updates to internal; /// caches to keep them consistent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:107,Deployability,update,updates,107,/// Notifies this tracking that we are going to remove the instruction \p Inst; /// It makes all necessary updates to internal caches to keep them consistent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:127,Performance,cache,caches,127,/// Notifies this tracking that we are going to remove the instruction \p Inst; /// It makes all necessary updates to internal caches to keep them consistent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:105,Deployability,update,updates,105,/// Notifies this tracking that we are going to replace all uses of \p Inst.; /// It makes all necessary updates to internal caches to keep them consistent.; /// Should typically be called before a RAUW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:125,Performance,cache,caches,125,/// Notifies this tracking that we are going to replace all uses of \p Inst.; /// It makes all necessary updates to internal caches to keep them consistent.; /// Should typically be called before a RAUW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:490,Performance,perform,perform,490,"/// This class allows to keep track on instructions with implicit control flow.; /// These are instructions that may not pass execution to their successors. For; /// example, throwing calls and guards do not always do this. If we need to know; /// for sure that some instruction is guaranteed to execute if the given block; /// is reached, then we need to make sure that there is no implicit control flow; /// instruction (ICFI) preceding it. For example, this check is required if we; /// perform PRE moving non-speculable instruction to other place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:402,Integrability,rout,routines,402,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:829,Integrability,rout,routines,829,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:917,Integrability,rout,routines,917,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:1316,Integrability,rout,routines,1316,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:891,Safety,safe,safe,891,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:49,Usability,simpl,simpler,49,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:441,Usability,simpl,simpler,441,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:729,Usability,simpl,simplification,729,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:936,Usability,simpl,simplified,936,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:1053,Usability,simpl,simplified,1053,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:1331,Usability,simpl,simplify,1331,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:1459,Usability,simpl,simplify,1459,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:107,Usability,Simpl,SimplifyQuery,107,"// NOTE: the explicit multiple argument versions of these functions are; // deprecated.; // Please use the SimplifyQuery versions in new code.; /// Given operands for an Add, fold the result or return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:145,Performance,perform,perform,145,"/// Given operands for the multiplication of a FMA, fold the result or return; /// null. In contrast to simplifyFMulInst, this function will not perform; /// simplifications whose unrounded results differ when rounded to the argument; /// type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:104,Usability,simpl,simplifyFMulInst,104,"/// Given operands for the multiplication of a FMA, fold the result or return; /// null. In contrast to simplifyFMulInst, this function will not perform; /// simplifications whose unrounded results differ when rounded to the argument; /// type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:158,Usability,simpl,simplifications,158,"/// Given operands for the multiplication of a FMA, fold the result or return; /// null. In contrast to simplifyFMulInst, this function will not perform; /// simplifications whose unrounded results differ when rounded to the argument; /// type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:134,Availability,mask,mask,134,"/// Given operands for a ShuffleVectorInst, fold the result or return null.; /// See class ShuffleVectorInst for a description of the mask representation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:173,Integrability,contract,contract,173,"/// Given a constrained FP intrinsic call, tries to compute its simplified; /// version. Returns a simplified result or null.; ///; /// This function provides an additional contract: it guarantees that if; /// simplification succeeds that the intrinsic is side effect free. As a result,; /// successful simplification can be used to delete the intrinsic not just; /// replace its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:64,Usability,simpl,simplified,64,"/// Given a constrained FP intrinsic call, tries to compute its simplified; /// version. Returns a simplified result or null.; ///; /// This function provides an additional contract: it guarantees that if; /// simplification succeeds that the intrinsic is side effect free. As a result,; /// successful simplification can be used to delete the intrinsic not just; /// replace its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:99,Usability,simpl,simplified,99,"/// Given a constrained FP intrinsic call, tries to compute its simplified; /// version. Returns a simplified result or null.; ///; /// This function provides an additional contract: it guarantees that if; /// simplification succeeds that the intrinsic is side effect free. As a result,; /// successful simplification can be used to delete the intrinsic not just; /// replace its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:210,Usability,simpl,simplification,210,"/// Given a constrained FP intrinsic call, tries to compute its simplified; /// version. Returns a simplified result or null.; ///; /// This function provides an additional contract: it guarantees that if; /// simplification succeeds that the intrinsic is side effect free. As a result,; /// successful simplification can be used to delete the intrinsic not just; /// replace its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:303,Usability,simpl,simplification,303,"/// Given a constrained FP intrinsic call, tries to compute its simplified; /// version. Returns a simplified result or null.; ///; /// This function provides an additional contract: it guarantees that if; /// simplification succeeds that the intrinsic is side effect free. As a result,; /// successful simplification can be used to delete the intrinsic not just; /// replace its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:12,Performance,load,load,12,"/// Given a load instruction and its pointer operand, fold the result or return; /// null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:28,Usability,simpl,simplified,28,"/// See if we can compute a simplified version of this instruction. If not,; /// return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:12,Usability,simpl,simplifyInstruction,12,"/// Like \p simplifyInstruction but the operands of \p I are replaced with; /// \p NewOps. Returns a simplified value, or null if none was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:101,Usability,simpl,simplified,101,"/// Like \p simplifyInstruction but the operands of \p I are replaced with; /// \p NewOps. Returns a simplified value, or null if none was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:13,Usability,simpl,simplifies,13,"/// See if V simplifies when its operand Op is replaced with RepOp. If not,; /// return null.; /// AllowRefinement specifies whether the simplification can be a refinement; /// (e.g. 0 instead of poison), or whether it needs to be strictly identical.; /// Op and RepOp can be assumed to not be poison when determining refinement.; ///; /// If DropFlags is passed, then the replacement result is only valid if; /// poison-generating flags/metadata on those instructions are dropped. This; /// is only useful in conjunction with AllowRefinement=false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:137,Usability,simpl,simplification,137,"/// See if V simplifies when its operand Op is replaced with RepOp. If not,; /// return null.; /// AllowRefinement specifies whether the simplification can be a refinement; /// (e.g. 0 instead of poison), or whether it needs to be strictly identical.; /// Op and RepOp can be assumed to not be poison when determining refinement.; ///; /// If DropFlags is passed, then the replacement result is only valid if; /// poison-generating flags/metadata on those instructions are dropped. This; /// is only useful in conjunction with AllowRefinement=false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:199,Deployability,update,updated,199,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:99,Performance,perform,performs,99,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:470,Performance,perform,performed,470,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:34,Usability,Simpl,SimpleV,34,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:47,Usability,simpl,simplify,47,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:132,Usability,Simpl,SimpleV,132,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:178,Usability,simpl,simplify,178,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:275,Usability,simpl,simplified,275,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:293,Usability,Simpl,SimpleV,293,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:373,Usability,simpl,simplified,373,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:449,Usability,simpl,simplifications,449,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:35,Usability,Simpl,SimplifyQuery,35,// These helper functions return a SimplifyQuery structure that contains as; // many of the optional analysis we use as are currently valid. This is the; // strongly preferred way of constructing SimplifyQuery in passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:196,Usability,Simpl,SimplifyQuery,196,// These helper functions return a SimplifyQuery structure that contains as; // many of the optional analysis we use as are currently valid. This is the; // strongly preferred way of constructing SimplifyQuery in passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h:175,Usability,simpl,simplified,175,//===--------------------------------------------------------------------===//; // Value-based folders.; //; // Return an existing value or a constant if the operation can be simplified.; // Otherwise return nullptr.; //===--------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h:3,Safety,avoid,avoid,3,// avoid calling Fold,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h:3,Safety,avoid,avoid,3,// avoid calling Fold,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h:984,Safety,avoid,avoid,984,"/// A MLModelRunner that asks for advice from an external agent, or host. It; /// uses 2 files - ideally named pipes - one to send data to that agent, and; /// one to receive advice.; /// The data exchange uses the training logger (Utils/TrainingLogger.h) format.; /// Specifically, the compiler will send the log header, set the context, and; /// send observations; the host is expected to reply with a tensor value after; /// each observation as a binary buffer that's conforming to the shape of the; /// advice. Interleaved, the data closely resembles the training log for a; /// log where we don't capture the reward signal.; ///; /// Note that the correctness of the received data is the responsibility of the; /// host. In particular, if insufficient data were sent, the compiler will block; /// when waiting for an advice.; ///; /// Note that the host can either open the pipes RW, or open first the pipe to; /// the compiler - i.e. the ""Inbound"" - and then the ""Outbound"", to avoid; /// deadlock. This is because the compiler first tries to open the inbound; /// (which will hang until there's a writer on the other end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h:224,Testability,log,logger,224,"/// A MLModelRunner that asks for advice from an external agent, or host. It; /// uses 2 files - ideally named pipes - one to send data to that agent, and; /// one to receive advice.; /// The data exchange uses the training logger (Utils/TrainingLogger.h) format.; /// Specifically, the compiler will send the log header, set the context, and; /// send observations; the host is expected to reply with a tensor value after; /// each observation as a binary buffer that's conforming to the shape of the; /// advice. Interleaved, the data closely resembles the training log for a; /// log where we don't capture the reward signal.; ///; /// Note that the correctness of the received data is the responsibility of the; /// host. In particular, if insufficient data were sent, the compiler will block; /// when waiting for an advice.; ///; /// Note that the host can either open the pipes RW, or open first the pipe to; /// the compiler - i.e. the ""Inbound"" - and then the ""Outbound"", to avoid; /// deadlock. This is because the compiler first tries to open the inbound; /// (which will hang until there's a writer on the other end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h:310,Testability,log,log,310,"/// A MLModelRunner that asks for advice from an external agent, or host. It; /// uses 2 files - ideally named pipes - one to send data to that agent, and; /// one to receive advice.; /// The data exchange uses the training logger (Utils/TrainingLogger.h) format.; /// Specifically, the compiler will send the log header, set the context, and; /// send observations; the host is expected to reply with a tensor value after; /// each observation as a binary buffer that's conforming to the shape of the; /// advice. Interleaved, the data closely resembles the training log for a; /// log where we don't capture the reward signal.; ///; /// Note that the correctness of the received data is the responsibility of the; /// host. In particular, if insufficient data were sent, the compiler will block; /// when waiting for an advice.; ///; /// Note that the host can either open the pipes RW, or open first the pipe to; /// the compiler - i.e. the ""Inbound"" - and then the ""Outbound"", to avoid; /// deadlock. This is because the compiler first tries to open the inbound; /// (which will hang until there's a writer on the other end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h:568,Testability,log,log,568,"/// A MLModelRunner that asks for advice from an external agent, or host. It; /// uses 2 files - ideally named pipes - one to send data to that agent, and; /// one to receive advice.; /// The data exchange uses the training logger (Utils/TrainingLogger.h) format.; /// Specifically, the compiler will send the log header, set the context, and; /// send observations; the host is expected to reply with a tensor value after; /// each observation as a binary buffer that's conforming to the shape of the; /// advice. Interleaved, the data closely resembles the training log for a; /// log where we don't capture the reward signal.; ///; /// Note that the correctness of the received data is the responsibility of the; /// host. In particular, if insufficient data were sent, the compiler will block; /// when waiting for an advice.; ///; /// Note that the host can either open the pipes RW, or open first the pipe to; /// the compiler - i.e. the ""Inbound"" - and then the ""Outbound"", to avoid; /// deadlock. This is because the compiler first tries to open the inbound; /// (which will hang until there's a writer on the other end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h:583,Testability,log,log,583,"/// A MLModelRunner that asks for advice from an external agent, or host. It; /// uses 2 files - ideally named pipes - one to send data to that agent, and; /// one to receive advice.; /// The data exchange uses the training logger (Utils/TrainingLogger.h) format.; /// Specifically, the compiler will send the log header, set the context, and; /// send observations; the host is expected to reply with a tensor value after; /// each observation as a binary buffer that's conforming to the shape of the; /// advice. Interleaved, the data closely resembles the training log for a; /// log where we don't capture the reward signal.; ///; /// Note that the correctness of the received data is the responsibility of the; /// host. In particular, if insufficient data were sent, the compiler will block; /// when waiting for an advice.; ///; /// Note that the host can either open the pipes RW, or open first the pipe to; /// the compiler - i.e. the ""Inbound"" - and then the ""Outbound"", to avoid; /// deadlock. This is because the compiler first tries to open the inbound; /// (which will hang until there's a writer on the other end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h:20,Integrability,depend,dependency,20,"// I don't want the dependency on <algorithm>; //return find(Nodes.begin(), Nodes.end(), BB) != Nodes.end();",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h:20,Integrability,depend,dependency,20,"// I don't want the dependency on <algorithm>; //return find(Successors.begin(), Successors.end(), BB) != Successors.end();",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h:1260,Safety,safe,safe,1260,"//===- IntervalIterator.h - Interval Iterator Declaration -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an iterator that enumerates the intervals in a control flow; // graph of some sort. This iterator is parametric, allowing iterator over the; // following types of graphs:; //; // 1. A Function* object, composed of BasicBlock nodes.; // 2. An IntervalPartition& object, composed of Interval nodes.; //; // This iterator is defined to walk the control flow graph, returning intervals; // in depth first order. These intervals are completely filled in except for; // the predecessor fields (the successor information is filled in however).; //; // By default, the intervals created by this iterator are deleted after they; // are no longer any use to the iterator. This behavior can be changed by; // passing a false value into the intervals_begin() function. This causes the; // IOwnMem member to be set, and the intervals to not be deleted.; //; // It is only safe to use this if all of the intervals are deleted by the caller; // and all of the intervals are processed. However, the user of the iterator is; // not allowed to modify or delete the intervals until after the iterator has; // been used completely. The IntervalPartition class uses this functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h:132,Integrability,depend,depending,132,"// addNodeToInterval - This method exists to assist the generic ProcessNode; // with the task of adding a node to the new interval, depending on the; // type of the source node. In the case of a CFG source graph (BasicBlock; // case), the BasicBlock itself is added to the interval.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h:132,Integrability,depend,depending,132,"// addNodeToInterval - This method exists to assist the generic ProcessNode; // with the task of adding a node to the new interval, depending on the; // type of the source node. In the case of a CFG source graph (BasicBlock; // case), the BasicBlock itself is added to the interval. In the case of; // an IntervalPartition source graph (Interval case), all of the member; // BasicBlocks are added to the interval.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:644,Availability,down,down,644,"//===- IntervalPartition.h - Interval partition Calculation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the declaration of the IntervalPartition class, which; // calculates and represents the interval partition of a function, or a; // preexisting interval partition.; //; // In this way, the interval partition may be used to reduce a flow graph down; // to its degenerate single node interval partition (unless it is irreducible).; //; // TODO: The IntervalPartition class should take a bool parameter that tells; // whether it should add the ""tails"" of an interval to an interval itself or if; // they should be represented as distinct intervals.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:624,Energy Efficiency,reduce,reduce,624,"//===- IntervalPartition.h - Interval partition Calculation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the declaration of the IntervalPartition class, which; // calculates and represents the interval partition of a function, or a; // preexisting interval partition.; //; // In this way, the interval partition may be used to reduce a flow graph down; // to its degenerate single node interval partition (unless it is irreducible).; //; // TODO: The IntervalPartition class should take a bool parameter that tells; // whether it should add the ""tails"" of an interval to an interval itself or if; // they should be represented as distinct intervals.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:302,Usability,Intuit,Intuitively,302,"//===----------------------------------------------------------------------===//; //; // IntervalPartition - This class builds and holds an ""interval partition"" for; // a function. This partition divides the control flow graph into a set of; // maximal intervals, as defined with the properties above. Intuitively, an; // interval is a (possibly nonexistent) loop with a ""tail"" of non-looping; // nodes following it.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:36,Energy Efficiency,reduce,reduced,36,// IntervalPartition ctor - Build a reduced interval partition from an; // existing interval graph. This takes an additional boolean parameter to; // distinguish it from a copy constructor. Always pass in false for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:119,Usability,simpl,simplified,119,"// isDegeneratePartition() - Returns true if the interval partition contains; // a single interval, and thus cannot be simplified anymore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:3,Integrability,Interface,Interface,3,// Interface to Intervals vector...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:3,Deployability,release,releaseMemory,3,// releaseMemory - Reset state back to before function was analyzed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:3,Deployability,update,updatePredecessors,3,"// updatePredecessors - Interval generation only sets the successor fields of; // the interval data structures. After interval generation is complete,; // run through all of the intervals and propagate successor info as; // predecessor info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:393,Integrability,Interface,Interface,393,"//===- IRSimilarityIdentifier.h - Find similarity in a module --------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // Interface file for the IRSimilarityIdentifier for identifying similarities in; // IR including the IRInstructionMapper, which maps an Instruction to unsigned; // integers.; //; // Two sequences of instructions are called ""similar"" if they perform the same; // series of operations for all inputs.; //; // \code; // %1 = add i32 %a, 10; // %2 = add i32 %a, %1; // %3 = icmp slt icmp %1, %2; // \endcode; //; // and; //; // \code; // %1 = add i32 11, %a; // %2 = sub i32 %a, %1; // %3 = icmp sgt icmp %2, %1; // \endcode; //; // ultimately have the same result, even if the inputs, and structure are; // slightly different.; //; // For instructions, we do not worry about operands that do not have fixed; // semantic meaning to the program. We consider the opcode that the instruction; // has, the types, parameters, and extra information such as the function name,; // or comparison predicate. These are used to create a hash to map instructions; // to integers to be used in similarity matching in sequences of instructions; //; // Terminology:; // An IRSimilarityCandidate is a region of IRInstructionData (wrapped; // Instructions), usually used to denote a region of similarity has been found.; //; // A SimilarityGroup is a set of IRSimilarityCandidates that are structurally; // similar to one another.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1501,Integrability,wrap,wrapped,1501,"//===- IRSimilarityIdentifier.h - Find similarity in a module --------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // Interface file for the IRSimilarityIdentifier for identifying similarities in; // IR including the IRInstructionMapper, which maps an Instruction to unsigned; // integers.; //; // Two sequences of instructions are called ""similar"" if they perform the same; // series of operations for all inputs.; //; // \code; // %1 = add i32 %a, 10; // %2 = add i32 %a, %1; // %3 = icmp slt icmp %1, %2; // \endcode; //; // and; //; // \code; // %1 = add i32 11, %a; // %2 = sub i32 %a, %1; // %3 = icmp sgt icmp %2, %1; // \endcode; //; // ultimately have the same result, even if the inputs, and structure are; // slightly different.; //; // For instructions, we do not worry about operands that do not have fixed; // semantic meaning to the program. We consider the opcode that the instruction; // has, the types, parameters, and extra information such as the function name,; // or comparison predicate. These are used to create a hash to map instructions; // to integers to be used in similarity matching in sequences of instructions; //; // Terminology:; // An IRSimilarityCandidate is a region of IRInstructionData (wrapped; // Instructions), usually used to denote a region of similarity has been found.; //; // A SimilarityGroup is a set of IRSimilarityCandidates that are structurally; // similar to one another.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:632,Performance,perform,perform,632,"//===- IRSimilarityIdentifier.h - Find similarity in a module --------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // Interface file for the IRSimilarityIdentifier for identifying similarities in; // IR including the IRInstructionMapper, which maps an Instruction to unsigned; // integers.; //; // Two sequences of instructions are called ""similar"" if they perform the same; // series of operations for all inputs.; //; // \code; // %1 = add i32 %a, 10; // %2 = add i32 %a, %1; // %3 = icmp slt icmp %1, %2; // \endcode; //; // and; //; // \code; // %1 = add i32 11, %a; // %2 = sub i32 %a, %1; // %3 = icmp sgt icmp %2, %1; // \endcode; //; // ultimately have the same result, even if the inputs, and structure are; // slightly different.; //; // For instructions, we do not worry about operands that do not have fixed; // semantic meaning to the program. We consider the opcode that the instruction; // has, the types, parameters, and extra information such as the function name,; // or comparison predicate. These are used to create a hash to map instructions; // to integers to be used in similarity matching in sequences of instructions; //; // Terminology:; // An IRSimilarityCandidate is a region of IRInstructionData (wrapped; // Instructions), usually used to denote a region of similarity has been found.; //; // A SimilarityGroup is a set of IRSimilarityCandidates that are structurally; // similar to one another.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1313,Security,hash,hash,1313,"//===- IRSimilarityIdentifier.h - Find similarity in a module --------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // Interface file for the IRSimilarityIdentifier for identifying similarities in; // IR including the IRInstructionMapper, which maps an Instruction to unsigned; // integers.; //; // Two sequences of instructions are called ""similar"" if they perform the same; // series of operations for all inputs.; //; // \code; // %1 = add i32 %a, 10; // %2 = add i32 %a, %1; // %3 = icmp slt icmp %1, %2; // \endcode; //; // and; //; // \code; // %1 = add i32 11, %a; // %2 = sub i32 %a, %1; // %3 = icmp sgt icmp %2, %1; // \endcode; //; // ultimately have the same result, even if the inputs, and structure are; // slightly different.; //; // For instructions, we do not worry about operands that do not have fixed; // semantic meaning to the program. We consider the opcode that the instruction; // has, the types, parameters, and extra information such as the function name,; // or comparison predicate. These are used to create a hash to map instructions; // to integers to be used in similarity matching in sequences of instructions; //; // Terminology:; // An IRSimilarityCandidate is a region of IRInstructionData (wrapped; // Instructions), usually used to denote a region of similarity has been found.; //; // A SimilarityGroup is a set of IRSimilarityCandidates that are structurally; // similar to one another.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:469,Integrability,wrap,wrappers,469,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:179,Performance,perform,perform,179,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:36,Security,hash,hashing,36,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:128,Security,hash,hash,128,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:508,Security,hash,hashed,508,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:614,Security,hash,hash,614,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:676,Security,Hash,Hash,676,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:714,Security,Hash,Hash,714,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:814,Security,hash,hashes,814,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:873,Security,Hash,Hash,873,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:915,Security,hash,hashing,915,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:41,Integrability,wrap,wrapped,41,/// The source Instruction that is being wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:24,Integrability,wrap,wrapped,24,"/// The legality of the wrapped instruction. This is informed by InstrType,; /// and is used when checking when two instructions are considered similar.; /// If either instruction is not legal, the instructions are automatically not; /// considered similar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:36,Integrability,wrap,wrapping,36,/// This is only relevant if we are wrapping a CmpInst where we needed to; /// change the predicate of a compare instruction from a greater than form; /// to a less than form. It is std::nullopt otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:36,Integrability,wrap,wrapping,36,"/// This is only relevant if we are wrapping a CallInst. If we are requiring; /// that the function calls have matching names as well as types, and the; /// call is not an indirect call, this will hold the name of the function. If; /// it is an indirect string, it will be the empty string. However, if this; /// requirement is not in place it will be the empty string regardless of the; /// function call type. The value held here is used to create the hash of the; /// instruction, and check to make sure two instructions are close to one; /// another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:454,Security,hash,hash,454,"/// This is only relevant if we are wrapping a CallInst. If we are requiring; /// that the function calls have matching names as well as types, and the; /// call is not an indirect call, this will hold the name of the function. If; /// it is an indirect string, it will be the empty string. However, if this; /// requirement is not in place it will be the empty string regardless of the; /// function call type. The value held here is used to create the hash of the; /// instruction, and check to make sure two instructions are close to one; /// another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:325,Performance,perform,performs,325,"/// Gather the information that is difficult to gather for an Instruction, or; /// is changed. i.e. the operands of an Instruction and the Types of those; /// operands. This extra information allows for similarity matching to make; /// assertions that allow for more flexibility when checking for whether an; /// Instruction performs the same operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:236,Testability,assert,assertions,236,"/// Gather the information that is difficult to gather for an Instruction, or; /// is changed. i.e. the operands of an Instruction and the Types of those; /// operands. This extra information allows for similarity matching to make; /// assertions that allow for more flexibility when checking for whether an; /// Instruction performs the same operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:124,Integrability,wrap,wrapping,124,/// Get the predicate that the compare instruction is using for hashing the; /// instruction. the IRInstructionData must be wrapping a CmpInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:64,Security,hash,hashing,64,/// Get the predicate that the compare instruction is using for hashing the; /// instruction. the IRInstructionData must be wrapping a CmpInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:123,Integrability,wrap,wrapping,123,/// Get the callee name that the call instruction is using for hashing the; /// instruction. The IRInstructionData must be wrapping a CallInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:63,Security,hash,hashing,63,/// Get the callee name that the call instruction is using for hashing the; /// instruction. The IRInstructionData must be wrapping a CallInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:136,Performance,perform,perform,136,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:468,Performance,perform,performing,468,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:4,Security,Hash,Hashes,4,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:121,Security,hash,hash,121,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:514,Security,hash,hashed,514,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:636,Security,hash,hashed,636,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:786,Security,hash,hashed,786,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:922,Security,hash,hashed,922,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:184,Usability,simpl,simple,184,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:6,Security,hash,hash,6,"// To hash intrinsics, we use the opcode, and types like the other; // instructions, but also, the Intrinsic ID, and the Name of the; // intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:101,Performance,perform,performing,101,"/// Compare one IRInstructionData class to another IRInstructionData class for; /// whether they are performing a the same operation, and can mapped to the; /// same value. For regular instructions if the hash value is the same, then; /// they will also be close.; ///; /// \param A - The first IRInstructionData class to compare; /// \param B - The second IRInstructionData class to compare; /// \returns true if \p A and \p B are similar enough to be mapped to the same; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:205,Security,hash,hash,205,"/// Compare one IRInstructionData class to another IRInstructionData class for; /// whether they are performing a the same operation, and can mapped to the; /// same value. For regular instructions if the hash value is the same, then; /// they will also be close.; ///; /// \param A - The first IRInstructionData class to compare; /// \param B - The second IRInstructionData class to compare; /// \returns true if \p A and \p B are similar enough to be mapped to the same; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:429,Integrability,wrap,wrapped,429,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:525,Integrability,depend,depends,525,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1759,Integrability,interface,interface,1759,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:306,Security,hash,hashing,306,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:355,Security,hash,hash,355,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:548,Security,hash,hash,548,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1249,Security,hash,hash,1249,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1357,Security,Hash,Hash,1357,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1394,Security,Hash,Hash,1394,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1431,Security,Hash,Hash,1431,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1477,Security,Hash,Hash,1477,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1515,Security,Hash,Hash,1515,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:13,Availability,avail,available,13,/// The next available integer to assign to a legal Instruction to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:33,Energy Efficiency,charge,charge,33,/// This allocator pointer is in charge of holding on to the IRInstructionData; /// so it is not deallocated until whatever external tool is using it is done; /// with the information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:33,Energy Efficiency,charge,charge,33,/// This allocator pointer is in charge of creating the IRInstructionDataList; /// so it is not deallocated until whatever external tool is using it is done; /// with the information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:11,Energy Efficiency,allocate,allocated,11,"/// Get an allocated IRInstructionData struct using the InstDataAllocator.; ///; /// \param I - The Instruction to wrap with IRInstructionData.; /// \param Legality - A boolean value that is true if the instruction is to; /// be considered for similarity, and false if not.; /// \param IDL - The InstructionDataList that the IRInstructionData is; /// inserted into.; /// \returns An allocated IRInstructionData struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:383,Energy Efficiency,allocate,allocated,383,"/// Get an allocated IRInstructionData struct using the InstDataAllocator.; ///; /// \param I - The Instruction to wrap with IRInstructionData.; /// \param Legality - A boolean value that is true if the instruction is to; /// be considered for similarity, and false if not.; /// \param IDL - The InstructionDataList that the IRInstructionData is; /// inserted into.; /// \returns An allocated IRInstructionData struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:115,Integrability,wrap,wrap,115,"/// Get an allocated IRInstructionData struct using the InstDataAllocator.; ///; /// \param I - The Instruction to wrap with IRInstructionData.; /// \param Legality - A boolean value that is true if the instruction is to; /// be considered for similarity, and false if not.; /// \param IDL - The InstructionDataList that the IRInstructionData is; /// inserted into.; /// \returns An allocated IRInstructionData struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:17,Energy Efficiency,allocate,allocated,17,/// Get an empty allocated IRInstructionData struct using the; /// InstDataAllocator.; ///; /// \param IDL - The InstructionDataList that the IRInstructionData is; /// inserted into.; /// \returns An allocated IRInstructionData struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:200,Energy Efficiency,allocate,allocated,200,/// Get an empty allocated IRInstructionData struct using the; /// InstDataAllocator.; ///; /// \param IDL - The InstructionDataList that the IRInstructionData is; /// inserted into.; /// \returns An allocated IRInstructionData struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:11,Energy Efficiency,allocate,allocated,11,/// Get an allocated IRInstructionDataList object using the IDLAllocator.; ///; /// \returns An allocated IRInstructionDataList object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:96,Energy Efficiency,allocate,allocated,96,/// Get an allocated IRInstructionDataList object using the IDLAllocator.; ///; /// \returns An allocated IRInstructionDataList object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:14,Modifiability,variab,variable,14,// We exclude variable argument instructions since variable arguments; // requires extra checking of the argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:51,Modifiability,variab,variable,51,// We exclude variable argument instructions since variable arguments; // requires extra checking of the argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:73,Integrability,depend,dependent,73,// We exclude all exception handling cases since they are so context; // dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:178,Availability,down,down,178,"// Functions marked with the swifttailcc and tailcc calling conventions; // require special handling when outlining musttail functions. The; // calling convention must be passed down to the outlined function as; // well. Further, there is special handling for musttail calls as well,; // requiring a return call directly after. For now, the outliner does not; // support this, so we do not handle matching this case either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:12,Modifiability,variab,variable,12,// The flag variable that lets the classifier know whether we should; // allow branches to be checked for similarity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:12,Modifiability,variab,variable,12,// The flag variable that lets the classifier know whether we should; // allow indirect calls to be considered legal instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:25,Integrability,wrap,wraps,25,"/// This is a class that wraps a range of IRInstructionData from one point to; /// another in the vector of IRInstructionData, which is a region of the; /// program. It is also responsible for defining the structure within this; /// region of instructions.; ///; /// The structure of a region is defined through a value numbering system; /// assigned to each unique value in a region at the creation of the; /// IRSimilarityCandidate.; ///; /// For example, for each Instruction we add a mapping for each new; /// value seen in that Instruction.; /// IR: Mapping Added:; /// %add1 = add i32 %a, c1 %add1 -> 3, %a -> 1, c1 -> 2; /// %add2 = add i32 %a, %1 %add2 -> 4; /// %add3 = add i32 c2, c1 %add3 -> 6, c2 -> 5; ///; /// We can compare IRSimilarityCandidates against one another.; /// The \ref isSimilar function compares each IRInstructionData against one; /// another and if we have the same sequences of IRInstructionData that would; /// create the same hash, we have similar IRSimilarityCandidates.; ///; /// We can also compare the structure of IRSimilarityCandidates. If we can; /// create a mapping of registers in the region contained by one; /// IRSimilarityCandidate to the region contained by different; /// IRSimilarityCandidate, they can be considered structurally similar.; ///; /// IRSimilarityCandidate1: IRSimilarityCandidate2:; /// %add1 = add i32 %a, %b %add1 = add i32 %d, %e; /// %add2 = add i32 %a, %c %add2 = add i32 %d, %f; /// %add3 = add i32 c1, c2 %add3 = add i32 c3, c4; ///; /// Can have the following mapping from candidate to candidate of:; /// %a -> %d, %b -> %e, %c -> %f, c1 -> c3, c2 -> c4; /// and can be considered similar.; ///; /// IRSimilarityCandidate1: IRSimilarityCandidate2:; /// %add1 = add i32 %a, %b %add1 = add i32 %d, c4; /// %add2 = add i32 %a, %c %add2 = add i32 %d, %f; /// %add3 = add i32 c1, c2 %add3 = add i32 c3, c4; ///; /// We cannot create the same mapping since the use of c4 is not used in the; /// same way as %b or c2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:960,Security,hash,hash,960,"/// This is a class that wraps a range of IRInstructionData from one point to; /// another in the vector of IRInstructionData, which is a region of the; /// program. It is also responsible for defining the structure within this; /// region of instructions.; ///; /// The structure of a region is defined through a value numbering system; /// assigned to each unique value in a region at the creation of the; /// IRSimilarityCandidate.; ///; /// For example, for each Instruction we add a mapping for each new; /// value seen in that Instruction.; /// IR: Mapping Added:; /// %add1 = add i32 %a, c1 %add1 -> 3, %a -> 1, c1 -> 2; /// %add2 = add i32 %a, %1 %add2 -> 4; /// %add3 = add i32 c2, c1 %add3 -> 6, c2 -> 5; ///; /// We can compare IRSimilarityCandidates against one another.; /// The \ref isSimilar function compares each IRInstructionData against one; /// another and if we have the same sequences of IRInstructionData that would; /// create the same hash, we have similar IRSimilarityCandidates.; ///; /// We can also compare the structure of IRSimilarityCandidates. If we can; /// create a mapping of registers in the region contained by one; /// IRSimilarityCandidate to the region contained by different; /// IRSimilarityCandidate, they can be considered structurally similar.; ///; /// IRSimilarityCandidate1: IRSimilarityCandidate2:; /// %add1 = add i32 %a, %b %add1 = add i32 %d, %e; /// %add2 = add i32 %a, %c %add2 = add i32 %d, %f; /// %add3 = add i32 c1, c2 %add3 = add i32 c3, c4; ///; /// Can have the following mapping from candidate to candidate of:; /// %a -> %d, %b -> %e, %c -> %f, c1 -> c3, c2 -> c4; /// and can be considered similar.; ///; /// IRSimilarityCandidate1: IRSimilarityCandidate2:; /// %add1 = add i32 %a, %b %add1 = add i32 %d, c4; /// %add2 = add i32 %a, %c %add2 = add i32 %d, %f; /// %add3 = add i32 c1, c2 %add3 = add i32 c3, c4; ///; /// We cannot create the same mapping since the use of c4 is not used in the; /// same way as %b or c2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:112,Usability,guid,guide,112,"/// Create a mapping from the value numbering to a different separate set of; /// numbers. This will serve as a guide for relating one candidate to another.; /// The canonical number gives use the ability identify which global value; /// number in one candidate relates to the global value number in the other.; ///; /// \param [in, out] CurrCand - The IRSimilarityCandidate to create a; /// canonical numbering for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:456,Integrability,bridg,bridge,456,"/// Create a mapping for the value numbering of the calling; /// IRSimilarityCandidate, to a different separate set of numbers, based on; /// the canonical ordering in \p SourceCand. These are defined based on the; /// canonical mapping defined between \p SoureCandLarge and; /// \p TargetCandLarge. These IRSimilarityCandidates are already structurally; /// similar, and fully encapsulate the IRSimilarityCandidates in question.; /// These are used as a ""bridge"" from the \p SourceCand to the target.; ///; /// \param [in, out] SourceCand - The IRSimilarityCandidate to create a; /// canonical numbering from.; /// \param SoureCandLarge - The IRSimilarityCandidate fully containing; /// \p SourceCand.; /// \param TargetCandLarge - The IRSimilarityCandidate fully containing; /// this Candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:3,Usability,Clear,Clears,3,// Clears \ref SimilarityCandidates if it is already filled by a previous run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:68,Usability,clear,clear,68,"// If we've already analyzed a Module or set of Modules, so we must clear; // the SimilarityCandidates to make sure we do not have only old values; // hanging around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:46,Integrability,wrap,wraps,46,/// Map Instructions to unsigned integers and wraps the Instruction in an; /// instance of IRInstructionData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:13,Modifiability,variab,variable,13,"/// The flag variable that marks whether we should check branches for; /// similarity, or only look within basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:13,Modifiability,variab,variable,13,"/// The flag variable that marks whether we allow indirect calls to be checked; /// for similarity, or exclude them as a legal instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:13,Modifiability,variab,variable,13,"/// The flag variable that marks whether we allow calls to be marked as; /// similar if they do not have the same name, only the same calling; /// convention, attributes and type signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:13,Modifiability,variab,variable,13,/// The flag variable that marks whether we should check intrinsics for; /// similarity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:12,Modifiability,variab,variable,12,// The flag variable that marks whether we should allow tailcalls; // to be checked for similarity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:430,Modifiability,variab,variables,430,"//===- llvm/Analysis/IVDescriptors.h - IndVar Descriptors -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file ""describes"" induction and recurrence variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:16,Testability,log,logical,16,///< Bitwise or logical OR of integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:16,Testability,log,logical,16,///< Bitwise or logical AND of integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:16,Testability,log,logical,16,///< Bitwise or logical XOR of integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:61,Modifiability,variab,variables,61,"/// The RecurrenceDescriptor is used to identify recurrences variables in a; /// loop. Reduction is a special case of recurrence that has uses of the; /// recurrence variable outside the loop. The method isReductionPHI identifies; /// reductions that are basic recurrences.; ///; /// Basic recurrences are defined as the summation, product, OR, AND, XOR, min,; /// or max of a set of terms. For example: for(i=0; i<n; i++) { total +=; /// array[i]; } is a summation of array elements. Basic recurrences are a; /// special case of chains of recurrences (CR). See ScalarEvolution for CR; /// references.; /// This struct holds information about recurrence variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:166,Modifiability,variab,variable,166,"/// The RecurrenceDescriptor is used to identify recurrences variables in a; /// loop. Reduction is a special case of recurrence that has uses of the; /// recurrence variable outside the loop. The method isReductionPHI identifies; /// reductions that are basic recurrences.; ///; /// Basic recurrences are defined as the summation, product, OR, AND, XOR, min,; /// or max of a set of terms. For example: for(i=0; i<n; i++) { total +=; /// array[i]; } is a summation of array elements. Basic recurrences are a; /// special case of chains of recurrences (CR). See ScalarEvolution for CR; /// references.; /// This struct holds information about recurrence variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:654,Modifiability,variab,variables,654,"/// The RecurrenceDescriptor is used to identify recurrences variables in a; /// loop. Reduction is a special case of recurrence that has uses of the; /// recurrence variable outside the loop. The method isReductionPHI identifies; /// reductions that are basic recurrences.; ///; /// Basic recurrences are defined as the summation, product, OR, AND, XOR, min,; /// or max of a set of terms. For example: for(i=0; i<n; i++) { total +=; /// array[i]; } is a summation of array elements. Basic recurrences are a; /// special case of chains of recurrences (CR). See ScalarEvolution for CR; /// references.; /// This struct holds information about recurrence variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:80,Modifiability,variab,variable,80,/// Returns a struct describing if the instruction 'I' can be a recurrence; /// variable of type 'Kind' for a Loop \p L and reduction PHI \p Phi.; /// If the recurrence is a min/max pattern of select(icmp()) this function; /// advances the instruction pointer 'I' from the compare instruction to the; /// select instruction and stores this pointer in 'PatternLastInst' member of; /// the returned struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:613,Performance,perform,perform,613,"/// Returns true if Phi is a fixed-order recurrence. A fixed-order recurrence; /// is a non-reduction recurrence relation in which the value of the; /// recurrence in the current loop iteration equals a value defined in a; /// previous iteration (e.g. if the value is defined in the previous; /// iteration, we refer to it as first-order recurrence, if it is defined in; /// the iteration before the previous, we refer to it as second-order; /// recurrence and so on). Note that this function optimistically assumes that; /// uses of the recurrence can be re-ordered if necessary and users need to; /// check and perform the re-ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:4,Security,Expose,Expose,4,/// Expose an ordered FP reduction to the instance users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:52,Modifiability,variab,variables,52,/// A struct for saving information about induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:22,Modifiability,variab,variable,22,///< Not an induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:23,Modifiability,variab,variable,23,///< Integer induction variable. Step = C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:30,Modifiability,variab,variable,30,///< Floating point induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:262,Testability,assert,assert,262,"/// Returns true if \p Phi is an induction in the loop \p L. If \p Phi is an; /// induction, the induction descriptor \p D will contain the data describing; /// this induction. Since Induction Phis can only be present inside loop; /// headers, the function will assert if it is passed a Phi whose parent is; /// not the loop header. If by some other means the caller has a better SCEV; /// expression for \p Phi than the one returned by the ScalarEvolution; /// analysis, it can be passed through \p Expr. If the def-use chain; /// associated with the phi includes casts (that we know we can ignore; /// under proper runtime checks), they are passed through \p CastsToIgnore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:99,Availability,redundant,redundant,99,"/// Returns a reference to the type cast instructions in the induction; /// update chain, that are redundant when guarded with a runtime; /// SCEV overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:76,Deployability,update,update,76,"/// Returns a reference to the type cast instructions in the induction; /// update chain, that are redundant when guarded with a runtime; /// SCEV overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:99,Safety,redund,redundant,99,"/// Returns a reference to the type cast instructions in the induction; /// update chain, that are redundant when guarded with a runtime; /// SCEV overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:39,Modifiability,variab,variable,39,// Instruction that advances induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:76,Availability,redundant,redundant,76,"// Instructions used for type-casts of the induction variable,; // that are redundant when guarded with a runtime SCEV overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:53,Modifiability,variab,variable,53,"// Instructions used for type-casts of the induction variable,; // that are redundant when guarded with a runtime SCEV overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:76,Safety,redund,redundant,76,"// Instructions used for type-casts of the induction variable,; // that are redundant when guarded with a runtime SCEV overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h:43,Modifiability,Variab,Variable,43,"//===- llvm/Analysis/IVUsers.h - Induction Variable Users -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements bookkeeping for ""interesting"" users of expressions; // computed from induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h:483,Modifiability,variab,variables,483,"//===- llvm/Analysis/IVUsers.h - Induction Variable Users -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements bookkeeping for ""interesting"" users of expressions; // computed from induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h:63,Modifiability,variab,variable,63,"/// IVStrideUse - Keep track of one use of a strided induction variable.; /// The Expr member keeps track of the expression, User is the actual user; /// instruction of the operand, and 'OperandValToReplace' is the operand of; /// the User that is the use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h:56,Modifiability,variab,variable,56,/// IVUses - A list of all tracked IV uses of induction variable expressions; /// we are interested in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h:23,Security,expose,exposes,23,/// Analysis pass that exposes the \c IVUsers for a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h:4,Integrability,Wrap,Wraps,4,/// Wraps a BFI to allow lazy computation of the block frequencies.; ///; /// A pass that only conditionally uses BFI can uncondtionally require the; /// analysis without paying for the overhead if BFI doesn't end up being used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h:429,Integrability,depend,dependent,429,"/// This is an alternative analysis pass to; /// BlockFrequencyInfoWrapperPass. The difference is that with this pass the; /// block frequencies are not computed when the analysis pass is executed but; /// rather when the BFI result is explicitly requested by the analysis client.; ///; /// There are some additional requirements for any client pass that wants to use; /// the analysis:; ///; /// 1. The pass needs to initialize dependent passes with:; ///; /// INITIALIZE_PASS_DEPENDENCY(LazyBFIPass); ///; /// 2. Similarly, getAnalysisUsage should call:; ///; /// LazyBlockFrequencyInfoPass::getLazyBFIAnalysisUsage(AU); ///; /// 3. The computed BFI should be requested with; /// getAnalysis<LazyBlockFrequencyInfoPass>().getBFI() before either LoopInfo; /// or BPI could be invalidated for example by changing the CFG.; ///; /// Note that it is expected that we wouldn't need this functionality for the; /// new PM since with the new PM, analyses are executed on demand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h:43,Integrability,depend,dependent,43,/// Helper for client passes to initialize dependent passes for LBFI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h:436,Integrability,depend,dependent,436,"/// This is an alternative analysis pass to; /// BranchProbabilityInfoWrapperPass. The difference is that with this pass the; /// branch probabilities are not computed when the analysis pass is executed but; /// rather when the BPI results is explicitly requested by the analysis client.; ///; /// There are some additional requirements for any client pass that wants to use; /// the analysis:; ///; /// 1. The pass needs to initialize dependent passes with:; ///; /// INITIALIZE_PASS_DEPENDENCY(LazyBPIPass); ///; /// 2. Similarly, getAnalysisUsage should call:; ///; /// LazyBranchProbabilityInfoPass::getLazyBPIAnalysisUsage(AU); ///; /// 3. The computed BPI should be requested with; /// getAnalysis<LazyBranchProbabilityInfoPass>().getBPI() before LoopInfo; /// could be invalidated for example by changing the CFG.; ///; /// Note that it is expected that we wouldn't need this functionality for the; /// new PM since with the new PM, analyses are executed on demand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h:4,Integrability,Wrap,Wraps,4,/// Wraps a BPI to allow lazy computation of the branch probabilities.; ///; /// A pass that only conditionally uses BPI can uncondtionally require the; /// analysis without paying for the overhead if BPI doesn't end up being used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h:43,Integrability,depend,dependent,43,/// Helper for client passes to initialize dependent passes for LBPI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h:4,Usability,Simpl,Simple,4,/// Simple trait class that provides a mapping between BPI passes and the; /// corresponding BPInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1036,Performance,optimiz,optimizations,1036,"//===- LazyCallGraph.h - Analysis of a Module's call graph ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Implements a lazy call graph analysis and related passes for the new pass; /// manager.; ///; /// NB: This is *not* a traditional call graph! It is a graph which models both; /// the current calls and potential calls. As a consequence there are many; /// edges in this call graph that do not correspond to a 'call' or 'invoke'; /// instruction.; ///; /// The primary use cases of this graph analysis is to facilitate iterating; /// across the functions of a module in ways that ensure all callees are; /// visited prior to a caller (given any SCC constraints), or vice versa. As; /// such is it particularly well suited to organizing CGSCC optimizations such; /// as inlining, outlining, argument promotion, etc. That is its primary use; /// case and motivates the design. It may not be appropriate for other; /// purposes. The use graph of functions or some other conservative analysis of; /// call instructions may be interesting for optimizations and subsequent; /// analyses which don't work in the context of an overly specified; /// potential-call-edge graph.; ///; /// To understand the specific rules and nature of this call graph analysis,; /// see the documentation of the \c LazyCallGraph below.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1332,Performance,optimiz,optimizations,1332,"//===- LazyCallGraph.h - Analysis of a Module's call graph ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Implements a lazy call graph analysis and related passes for the new pass; /// manager.; ///; /// NB: This is *not* a traditional call graph! It is a graph which models both; /// the current calls and potential calls. As a consequence there are many; /// edges in this call graph that do not correspond to a 'call' or 'invoke'; /// instruction.; ///; /// The primary use cases of this graph analysis is to facilitate iterating; /// across the functions of a module in ways that ensure all callees are; /// visited prior to a caller (given any SCC constraints), or vice versa. As; /// such is it particularly well suited to organizing CGSCC optimizations such; /// as inlining, outlining, argument promotion, etc. That is its primary use; /// case and motivates the design. It may not be appropriate for other; /// purposes. The use graph of functions or some other conservative analysis of; /// call instructions may be interesting for optimizations and subsequent; /// analyses which don't work in the context of an overly specified; /// potential-call-edge graph.; ///; /// To understand the specific rules and nature of this call graph analysis,; /// see the documentation of the \c LazyCallGraph below.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:2205,Deployability,update,updates,2205,"f the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt completely; /// invalidates the information in this analysis.; ///; /// FIXME: This class is named LazyCallGraph in a lame attempt to distinguish; /// it from the existing CallGraph. At some point, it is expected that this; /// will be the only call graph and it will be renamed accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1918,Modifiability,variab,variables,1918,"f the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt completely; /// invalidates the information in this analysis.; ///; /// FIXME: This class is named LazyCallGraph in a lame attempt to distinguish; /// it from the existing CallGraph. At some point, it is expected that this; /// will be the only call graph and it will be renamed accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:190,Performance,optimiz,optimization,190,"/// A lazily constructed view of the call graph of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unk",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:221,Performance,optimiz,optimizations,221,"/// A lazily constructed view of the call graph of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unk",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:240,Performance,optimiz,optimizations,240,"/// A lazily constructed view of the call graph of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unk",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:400,Performance,optimiz,optimizations,400,"/// A lazily constructed view of the call graph of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unk",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:919,Performance,optimiz,optimizing,919,"/// A lazily constructed view of the call graph of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unk",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1000,Performance,optimiz,optimizations,1000,"of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1420,Performance,optimiz,optimizations,1420,"om-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates und",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1632,Performance,optimiz,optimization,1632,"longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt complete",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:2135,Performance,load,load,2135,"f the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt completely; /// invalidates the information in this analysis.; ///; /// FIXME: This class is named LazyCallGraph in a lame attempt to distinguish; /// it from the existing CallGraph. At some point, it is expected that this; /// will be the only call graph and it will be renamed accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:2235,Performance,optimiz,optimizations,2235,"f the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt completely; /// invalidates the information in this analysis.; ///; /// FIXME: This class is named LazyCallGraph in a lame attempt to distinguish; /// it from the existing CallGraph. At some point, it is expected that this; /// will be the only call graph and it will be renamed accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:2477,Performance,optimiz,optimizations,2477,"f the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt completely; /// invalidates the information in this analysis.; ///; /// FIXME: This class is named LazyCallGraph in a lame attempt to distinguish; /// it from the existing CallGraph. At some point, it is expected that this; /// will be the only call graph and it will be renamed accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test whether the edge is null.; ///; /// This happens when an edge has been deleted. We leave the edge objects; /// around but clear them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:131,Usability,clear,clear,131,/// Test whether the edge is null.; ///; /// This happens when an edge has been deleted. We leave the edge objects; /// around but clear them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test whether the edge represents a direct call to a function.; ///; /// This requires that the edge is not null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:270,Performance,cache,cached,270,/// The edge sequence object.; ///; /// This typically exists entirely within the node but is exposed as; /// a separate type because a node doesn't initially have edges. An explicit; /// population step is required to produce this sequence at first and it is; /// then cached in the node. It is also used to represent edges entering the; /// graph from outside the module to model the graph's roots.; ///; /// The sequence itself both iterable and indexable. The indexes remain; /// stable even as the sequence mutates (including removal).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:94,Security,expose,exposed,94,/// The edge sequence object.; ///; /// This typically exists entirely within the node but is exposed as; /// a separate type because a node doesn't initially have edges. An explicit; /// population step is required to produce this sequence at first and it is; /// then cached in the node. It is also used to represent edges entering the; /// graph from outside the module to model the graph's roots.; ///; /// The sequence itself both iterable and indexable. The indexes remain; /// stable even as the sequence mutates (including removal).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:96,Performance,cache,cache,96,"/// A node in the call graph.; ///; /// This represents a single node. Its primary roles are to cache the list of; /// callees, de-duplicate and provide fast testing of whether a function is a; /// callee, and facilitate iteration of child nodes in the graph.; ///; /// The node works much like an optional in order to lazily populate the; /// edges of each node. Until populated, there are no edges. Once populated,; /// you can access the edges by dereferencing the node or using the `->`; /// operator as if the node was an `std::optional<EdgeSequence>`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:430,Security,access,access,430,"/// A node in the call graph.; ///; /// This represents a single node. Its primary roles are to cache the list of; /// callees, de-duplicate and provide fast testing of whether a function is a; /// callee, and facilitate iteration of child nodes in the graph.; ///; /// The node works much like an optional in order to lazily populate the; /// edges of each node. Until populated, there are no edges. Once populated,; /// you can access the edges by dereferencing the node or using the `->`; /// operator as if the node was an `std::optional<EdgeSequence>`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:158,Testability,test,testing,158,"/// A node in the call graph.; ///; /// This represents a single node. Its primary roles are to cache the list of; /// callees, de-duplicate and provide fast testing of whether a function is a; /// callee, and facilitate iteration of child nodes in the graph.; ///; /// The node works much like an optional in order to lazily populate the; /// edges of each node. Until populated, there are no edges. Once populated,; /// you can access the edges by dereferencing the node or using the `->`; /// operator as if the node was an `std::optional<EdgeSequence>`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Tests,4,/// Tests whether the node has been populated with edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Tests,4,/// Tests whether this is actually a dead node and no longer valid.; ///; /// Users rarely interact with nodes in this state and other methods are; /// invalid. This is used to model a node in an edge list where the; /// function has been completely removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:94,Integrability,wrap,wrapping,94,"// We allow accessing the edges by dereferencing or using the arrow; // operator, essentially wrapping the internal optional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:12,Security,access,accessing,12,"// We allow accessing the edges by dereferencing or using the arrow; // operator, essentially wrapping the internal optional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:293,Deployability,update,updates,293,"/// Populate the edges of this node if necessary.; ///; /// The first time this is called it will populate the edges for this node; /// in the graph. It does this by scanning the underlying function, so once; /// this is done, any changes to that function must be explicitly reflected; /// in updates to the graph.; ///; /// \returns the populated \c EdgeSequence to simplify walking it.; ///; /// This will not update or re-scan anything if called repeatedly. Instead,; /// the edge sequence is cached and returned immediately on subsequent; /// calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:412,Deployability,update,update,412,"/// Populate the edges of this node if necessary.; ///; /// The first time this is called it will populate the edges for this node; /// in the graph. It does this by scanning the underlying function, so once; /// this is done, any changes to that function must be explicitly reflected; /// in updates to the graph.; ///; /// \returns the populated \c EdgeSequence to simplify walking it.; ///; /// This will not update or re-scan anything if called repeatedly. Instead,; /// the edge sequence is cached and returned immediately on subsequent; /// calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:496,Performance,cache,cached,496,"/// Populate the edges of this node if necessary.; ///; /// The first time this is called it will populate the edges for this node; /// in the graph. It does this by scanning the underlying function, so once; /// this is done, any changes to that function must be explicitly reflected; /// in updates to the graph.; ///; /// \returns the populated \c EdgeSequence to simplify walking it.; ///; /// This will not update or re-scan anything if called repeatedly. Instead,; /// the edge sequence is cached and returned immediately on subsequent; /// calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:367,Usability,simpl,simplify,367,"/// Populate the edges of this node if necessary.; ///; /// The first time this is called it will populate the edges for this node; /// in the graph. It does this by scanning the underlying function, so once; /// this is done, any changes to that function must be explicitly reflected; /// in updates to the graph.; ///; /// \returns the populated \c EdgeSequence to simplify walking it.; ///; /// This will not update or re-scan anything if called repeatedly. Instead,; /// the edge sequence is cached and returned immediately on subsequent; /// calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:112,Integrability,wrap,wrapped,112,/// Print a short description useful for debugging or logging.; ///; /// We print the function names in the SCC wrapped in '()'s and skipping; /// the middle functions if there are a large number.; //; // Note: this is defined inline to dodge issues with GCC's interpretation; // of enclosing namespaces for friend function declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:54,Testability,log,logging,54,/// Print a short description useful for debugging or logging.; ///; /// We print the function names in the SCC wrapped in '()'s and skipping; /// the middle functions if there are a large number.; //; // Note: this is defined inline to dodge issues with GCC's interpretation; // of enclosing namespaces for friend function declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:68,Security,validat,validate,68,"/// Verify invariants about the SCC.; ///; /// This will attempt to validate all of the basic invariants within an; /// SCC, but not that it is a strongly connected component per se.; /// Primarily useful while building and updating the graph to check that; /// basic properties are in place rather than having inexplicable crashes; /// later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test if this SCC is a parent of \a C.; ///; /// Note that this is linear in the number of edges departing the current; /// SCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test if this SCC is an ancestor of \a C.; ///; /// Note that in the worst case this is linear in the number of edges; /// departing the current SCC and every SCC in the entire graph reachable; /// from this SCC. Thus this very well may walk every edge in the entire; /// call graph! Do not call this in a tight loop!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:139,Integrability,rout,routine,139,/// Test if this SCC is a child of \a C.; ///; /// See the comments for \c isParentOf for detailed notes about the; /// complexity of this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test if this SCC is a child of \a C.; ///; /// See the comments for \c isParentOf for detailed notes about the; /// complexity of this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:144,Integrability,rout,routine,144,/// Test if this SCC is a descendant of \a C.; ///; /// See the comments for \c isParentOf for detailed notes about the; /// complexity of this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test if this SCC is a descendant of \a C.; ///; /// See the comments for \c isParentOf for detailed notes about the; /// complexity of this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:200,Testability,log,logging,200,/// Provide a short name by printing this SCC to a std::string.; ///; /// This copes with the fact that we don't have a name per se for an SCC; /// while still making the use of this in debugging and logging useful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:91,Integrability,wrap,wrapped,91,/// Print a short description useful for debugging or logging.; ///; /// We print the SCCs wrapped in '[]'s and skipping the middle SCCs if; /// there are a large number.; //; // Note: this is defined inline to dodge issues with GCC's interpretation; // of enclosing namespaces for friend function declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:54,Testability,log,logging,54,/// Print a short description useful for debugging or logging.; ///; /// We print the SCCs wrapped in '[]'s and skipping the middle SCCs if; /// there are a large number.; //; // Note: this is defined inline to dodge issues with GCC's interpretation; // of enclosing namespaces for friend function declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:273,Deployability,update,update,273,"/// Verify invariants about the RefSCC and all its SCCs.; ///; /// This will attempt to validate all of the invariants *within* the; /// RefSCC, but not that it is a strongly connected component of the larger; /// graph. This makes it useful even when partially through an update.; ///; /// Invariants checked:; /// - SCCs and their indices match.; /// - The SCCs list is in fact in post-order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:88,Security,validat,validate,88,"/// Verify invariants about the RefSCC and all its SCCs.; ///; /// This will attempt to validate all of the invariants *within* the; /// RefSCC, but not that it is a strongly connected component of the larger; /// graph. This makes it useful even when partially through an update.; ///; /// Invariants checked:; /// - SCCs and their indices match.; /// - The SCCs list is in fact in post-order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,"/// Test if this RefSCC is a parent of \a RC.; ///; /// CAUTION: This method walks every edge in the \c RefSCC, it can be very; /// expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test if this RefSCC is an ancestor of \a RC.; ///; /// CAUTION: This method walks the directed graph of edges as far as; /// necessary to find a possible path to the argument. In the worst case; /// this may walk the entire graph and can be extremely expensive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,"/// Test if this RefSCC is a child of \a RC.; ///; /// CAUTION: This method walks every edge in the argument \c RefSCC, it can; /// be very expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test if this RefSCC is a descendant of \a RC.; ///; /// CAUTION: This method walks the directed graph of edges as far as; /// necessary to find a possible path from the argument. In the worst case; /// this may walk the entire graph and can be extremely expensive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:206,Testability,log,logging,206,/// Provide a short name by printing this RefSCC to a std::string.; ///; /// This copes with the fact that we don't have a name per se for an RefSCC; /// while still making the use of this in debugging and logging useful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:569,Performance,perform,performing,569,"///@{; /// \name Mutation API; ///; /// These methods provide the core API for updating the call graph in the; /// presence of (potentially still in-flight) DFS-found RefSCCs and SCCs.; ///; /// Note that these methods sometimes have complex runtimes, so be careful; /// how you call them.; /// Make an existing internal ref edge into a call edge.; ///; /// This may form a larger cycle and thus collapse SCCs into TargetN's SCC.; /// If that happens, the optional callback \p MergedCB will be invoked (if; /// provided) on the SCCs being merged away prior to actually performing; /// the merge. Note that this will never include the target SCC as that; /// will be the SCC functions are merged into to resolve the cycle. Once; /// this function returns, these merged SCCs are not in a valid state but; /// the pointers will remain valid until destruction of the parent graph; /// instance for the purpose of clearing cached information. This function; /// also returns 'true' if a cycle was formed and some SCCs merged away as; /// a convenience.; ///; /// After this operation, both SourceN's SCC and TargetN's SCC may move; /// position within this RefSCC's postorder list. Any SCCs merged are; /// merged into the TargetN's SCC in order to preserve reachability analyses; /// which took place on that SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:918,Performance,cache,cached,918,"///@{; /// \name Mutation API; ///; /// These methods provide the core API for updating the call graph in the; /// presence of (potentially still in-flight) DFS-found RefSCCs and SCCs.; ///; /// Note that these methods sometimes have complex runtimes, so be careful; /// how you call them.; /// Make an existing internal ref edge into a call edge.; ///; /// This may form a larger cycle and thus collapse SCCs into TargetN's SCC.; /// If that happens, the optional callback \p MergedCB will be invoked (if; /// provided) on the SCCs being merged away prior to actually performing; /// the merge. Note that this will never include the target SCC as that; /// will be the SCC functions are merged into to resolve the cycle. Once; /// this function returns, these merged SCCs are not in a valid state but; /// the pointers will remain valid until destruction of the parent graph; /// instance for the purpose of clearing cached information. This function; /// also returns 'true' if a cycle was formed and some SCCs merged away as; /// a convenience.; ///; /// After this operation, both SourceN's SCC and TargetN's SCC may move; /// position within this RefSCC's postorder list. Any SCCs merged are; /// merged into the TargetN's SCC in order to preserve reachability analyses; /// which took place on that SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:909,Usability,clear,clearing,909,"///@{; /// \name Mutation API; ///; /// These methods provide the core API for updating the call graph in the; /// presence of (potentially still in-flight) DFS-found RefSCCs and SCCs.; ///; /// Note that these methods sometimes have complex runtimes, so be careful; /// how you call them.; /// Make an existing internal ref edge into a call edge.; ///; /// This may form a larger cycle and thus collapse SCCs into TargetN's SCC.; /// If that happens, the optional callback \p MergedCB will be invoked (if; /// provided) on the SCCs being merged away prior to actually performing; /// the merge. Note that this will never include the target SCC as that; /// will be the SCC functions are merged into to resolve the cycle. Once; /// this function returns, these merged SCCs are not in a valid state but; /// the pointers will remain valid until destruction of the parent graph; /// instance for the purpose of clearing cached information. This function; /// also returns 'true' if a cycle was formed and some SCCs merged away as; /// a convenience.; ///; /// After this operation, both SourceN's SCC and TargetN's SCC may move; /// position within this RefSCC's postorder list. Any SCCs merged are; /// merged into the TargetN's SCC in order to preserve reachability analyses; /// which took place on that SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:264,Integrability,rout,routine,264,"/// Make an existing internal call edge within a single SCC into a ref; /// edge.; ///; /// Since SourceN and TargetN are part of a single SCC, this SCC may be; /// split up due to breaking a cycle in the call edges that formed it. If; /// that happens, then this routine will insert new SCCs into the postorder; /// list *before* the SCC of TargetN (previously the SCC of both). This; /// preserves postorder as the TargetN can reach all of the other nodes by; /// definition of previously being in a single SCC formed by the cycle from; /// SourceN to TargetN.; ///; /// The newly added SCCs are added *immediately* and contiguously; /// prior to the TargetN SCC and return the range covering the new SCCs in; /// the RefSCC's postorder sequence. You can directly iterate the returned; /// range to observe all of the new SCCs in postorder.; ///; /// Note that if SourceN and TargetN are in separate SCCs, the simpler; /// routine `switchTrivialInternalEdgeToRef` should be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:925,Integrability,rout,routine,925,"/// Make an existing internal call edge within a single SCC into a ref; /// edge.; ///; /// Since SourceN and TargetN are part of a single SCC, this SCC may be; /// split up due to breaking a cycle in the call edges that formed it. If; /// that happens, then this routine will insert new SCCs into the postorder; /// list *before* the SCC of TargetN (previously the SCC of both). This; /// preserves postorder as the TargetN can reach all of the other nodes by; /// definition of previously being in a single SCC formed by the cycle from; /// SourceN to TargetN.; ///; /// The newly added SCCs are added *immediately* and contiguously; /// prior to the TargetN SCC and return the range covering the new SCCs in; /// the RefSCC's postorder sequence. You can directly iterate the returned; /// range to observe all of the new SCCs in postorder.; ///; /// Note that if SourceN and TargetN are in separate SCCs, the simpler; /// routine `switchTrivialInternalEdgeToRef` should be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:912,Usability,simpl,simpler,912,"/// Make an existing internal call edge within a single SCC into a ref; /// edge.; ///; /// Since SourceN and TargetN are part of a single SCC, this SCC may be; /// split up due to breaking a cycle in the call edges that formed it. If; /// that happens, then this routine will insert new SCCs into the postorder; /// list *before* the SCC of TargetN (previously the SCC of both). This; /// preserves postorder as the TargetN can reach all of the other nodes by; /// definition of previously being in a single SCC formed by the cycle from; /// SourceN to TargetN.; ///; /// The newly added SCCs are added *immediately* and contiguously; /// prior to the TargetN SCC and return the range covering the new SCCs in; /// the RefSCC's postorder sequence. You can directly iterate the returned; /// range to observe all of the new SCCs in postorder.; ///; /// Note that if SourceN and TargetN are in separate SCCs, the simpler; /// routine `switchTrivialInternalEdgeToRef` should be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:636,Integrability,rout,routine,636,"/// Insert a ref edge from one node in this RefSCC to another in this; /// RefSCC.; ///; /// This is always a trivial operation as it doesn't change any part of the; /// graph structure besides connecting the two nodes.; ///; /// Note that we don't support directly inserting internal *call* edges; /// because that could change the graph structure and requires returning; /// information about what became invalid. As a consequence, the pattern; /// should be to first insert the necessary ref edge, and then to switch it; /// to a call edge if needed and handle any invalidation that results. See; /// the \c switchInternalEdgeToCall routine for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:604,Integrability,rout,routine,604,"/// Insert an edge whose source is in a descendant RefSCC and target is in; /// this RefSCC.; ///; /// There must be an existing path from the target to the source in this; /// case.; ///; /// NB! This is has the potential to be a very expensive function. It; /// inherently forms a cycle in the prior RefSCC DAG and we have to merge; /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which; /// participate in the cycle can in the worst case require traversing every; /// RefSCC in the graph. Every attempt is made to avoid that, but passes; /// must still exercise caution calling this routine repeatedly.; ///; /// Also note that this can only insert ref edges. In order to insert; /// a call edge, first insert a ref edge and then switch it to a call edge.; /// These are intentionally kept as separate interfaces because each step; /// of the operation invalidates a different set of data structures.; ///; /// This returns all the RefSCCs which were merged into the this RefSCC; /// (the target's). This allows callers to invalidate any cached; /// information.; ///; /// FIXME: We could possibly optimize this quite a bit for cases where the; /// caller and callee are very nearby in the graph. See comments in the; /// implementation for details, but that use case might impact users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:823,Integrability,interface,interfaces,823,"/// Insert an edge whose source is in a descendant RefSCC and target is in; /// this RefSCC.; ///; /// There must be an existing path from the target to the source in this; /// case.; ///; /// NB! This is has the potential to be a very expensive function. It; /// inherently forms a cycle in the prior RefSCC DAG and we have to merge; /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which; /// participate in the cycle can in the worst case require traversing every; /// RefSCC in the graph. Every attempt is made to avoid that, but passes; /// must still exercise caution calling this routine repeatedly.; ///; /// Also note that this can only insert ref edges. In order to insert; /// a call edge, first insert a ref edge and then switch it to a call edge.; /// These are intentionally kept as separate interfaces because each step; /// of the operation invalidates a different set of data structures.; ///; /// This returns all the RefSCCs which were merged into the this RefSCC; /// (the target's). This allows callers to invalidate any cached; /// information.; ///; /// FIXME: We could possibly optimize this quite a bit for cases where the; /// caller and callee are very nearby in the graph. See comments in the; /// implementation for details, but that use case might impact users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1059,Performance,cache,cached,1059,"/// Insert an edge whose source is in a descendant RefSCC and target is in; /// this RefSCC.; ///; /// There must be an existing path from the target to the source in this; /// case.; ///; /// NB! This is has the potential to be a very expensive function. It; /// inherently forms a cycle in the prior RefSCC DAG and we have to merge; /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which; /// participate in the cycle can in the worst case require traversing every; /// RefSCC in the graph. Every attempt is made to avoid that, but passes; /// must still exercise caution calling this routine repeatedly.; ///; /// Also note that this can only insert ref edges. In order to insert; /// a call edge, first insert a ref edge and then switch it to a call edge.; /// These are intentionally kept as separate interfaces because each step; /// of the operation invalidates a different set of data structures.; ///; /// This returns all the RefSCCs which were merged into the this RefSCC; /// (the target's). This allows callers to invalidate any cached; /// information.; ///; /// FIXME: We could possibly optimize this quite a bit for cases where the; /// caller and callee are very nearby in the graph. See comments in the; /// implementation for details, but that use case might impact users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1119,Performance,optimiz,optimize,1119,"/// Insert an edge whose source is in a descendant RefSCC and target is in; /// this RefSCC.; ///; /// There must be an existing path from the target to the source in this; /// case.; ///; /// NB! This is has the potential to be a very expensive function. It; /// inherently forms a cycle in the prior RefSCC DAG and we have to merge; /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which; /// participate in the cycle can in the worst case require traversing every; /// RefSCC in the graph. Every attempt is made to avoid that, but passes; /// must still exercise caution calling this routine repeatedly.; ///; /// Also note that this can only insert ref edges. In order to insert; /// a call edge, first insert a ref edge and then switch it to a call edge.; /// These are intentionally kept as separate interfaces because each step; /// of the operation invalidates a different set of data structures.; ///; /// This returns all the RefSCCs which were merged into the this RefSCC; /// (the target's). This allows callers to invalidate any cached; /// information.; ///; /// FIXME: We could possibly optimize this quite a bit for cases where the; /// caller and callee are very nearby in the graph. See comments in the; /// implementation for details, but that use case might impact users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:535,Safety,avoid,avoid,535,"/// Insert an edge whose source is in a descendant RefSCC and target is in; /// this RefSCC.; ///; /// There must be an existing path from the target to the source in this; /// case.; ///; /// NB! This is has the potential to be a very expensive function. It; /// inherently forms a cycle in the prior RefSCC DAG and we have to merge; /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which; /// participate in the cycle can in the worst case require traversing every; /// RefSCC in the graph. Every attempt is made to avoid that, but passes; /// must still exercise caution calling this routine repeatedly.; ///; /// Also note that this can only insert ref edges. In order to insert; /// a call edge, first insert a ref edge and then switch it to a call edge.; /// These are intentionally kept as separate interfaces because each step; /// of the operation invalidates a different set of data structures.; ///; /// This returns all the RefSCCs which were merged into the this RefSCC; /// (the target's). This allows callers to invalidate any cached; /// information.; ///; /// FIXME: We could possibly optimize this quite a bit for cases where the; /// caller and callee are very nearby in the graph. See comments in the; /// implementation for details, but that use case might impact users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:256,Safety,safe,safe,256,"/// Remove an edge whose source is in this RefSCC and target is *not*.; ///; /// This removes an inter-RefSCC edge. All inter-RefSCC edges originating; /// from this SCC have been fully explored by any in-flight DFS graph; /// formation, so this is always safe to call once you have the source; /// RefSCC.; ///; /// This operation does not change the cyclic structure of the graph and so; /// is very inexpensive. It may change the connectivity graph of the SCCs; /// though, so be careful calling this while iterating over them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1199,Deployability,pipeline,pipelines,1199,"Removing these edges may break cycles that form this RefSCC and; /// thus this operation may change the RefSCC graph significantly. In; /// particular, this operation will re-form new RefSCCs based on the; /// remaining connectivity of the graph. The following invariants are; /// guaranteed to hold after calling this method:; ///; /// 1) If a ref-cycle remains after removal, it leaves this RefSCC intact; /// and in the graph. No new RefSCCs are built.; /// 2) Otherwise, this RefSCC will be dead after this call and no longer in; /// the graph or the postorder traversal of the call graph. Any iterator; /// pointing at this RefSCC will become invalid.; /// 3) All newly formed RefSCCs will be returned and the order of the; /// RefSCCs returned will be a valid postorder traversal of the new; /// RefSCCs.; /// 4) No RefSCC other than this RefSCC has its member set changed (this is; /// inherent in the definition of removing such an edge).; ///; /// These invariants are very important to ensure that we can build; /// optimization pipelines on top of the CGSCC pass manager which; /// intelligently update the RefSCC graph without invalidating other parts; /// of the RefSCC graph.; ///; /// Note that we provide no routine to remove a *call* edge. Instead, you; /// must first switch it to a ref edge using \c switchInternalEdgeToRef.; /// This split API is intentional as each of these two steps can invalidate; /// a different aspect of the graph structure and needs to have the; /// invalidation handled independently.; ///; /// The runtime complexity of this method is, in the worst case, O(V+E); /// where V is the number of nodes in this RefSCC and E is the number of; /// edges leaving the nodes in this RefSCC. Note that E includes both edges; /// within this RefSCC and edges from this RefSCC to child RefSCCs. Some; /// effort has been made to minimize the overhead of common cases such as; /// self-edges and edge removals which result in a spanning tree with no; /// more cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1267,Deployability,update,update,1267,"Removing these edges may break cycles that form this RefSCC and; /// thus this operation may change the RefSCC graph significantly. In; /// particular, this operation will re-form new RefSCCs based on the; /// remaining connectivity of the graph. The following invariants are; /// guaranteed to hold after calling this method:; ///; /// 1) If a ref-cycle remains after removal, it leaves this RefSCC intact; /// and in the graph. No new RefSCCs are built.; /// 2) Otherwise, this RefSCC will be dead after this call and no longer in; /// the graph or the postorder traversal of the call graph. Any iterator; /// pointing at this RefSCC will become invalid.; /// 3) All newly formed RefSCCs will be returned and the order of the; /// RefSCCs returned will be a valid postorder traversal of the new; /// RefSCCs.; /// 4) No RefSCC other than this RefSCC has its member set changed (this is; /// inherent in the definition of removing such an edge).; ///; /// These invariants are very important to ensure that we can build; /// optimization pipelines on top of the CGSCC pass manager which; /// intelligently update the RefSCC graph without invalidating other parts; /// of the RefSCC graph.; ///; /// Note that we provide no routine to remove a *call* edge. Instead, you; /// must first switch it to a ref edge using \c switchInternalEdgeToRef.; /// This split API is intentional as each of these two steps can invalidate; /// a different aspect of the graph structure and needs to have the; /// invalidation handled independently.; ///; /// The runtime complexity of this method is, in the worst case, O(V+E); /// where V is the number of nodes in this RefSCC and E is the number of; /// edges leaving the nodes in this RefSCC. Note that E includes both edges; /// within this RefSCC and edges from this RefSCC to child RefSCCs. Some; /// effort has been made to minimize the overhead of common cases such as; /// self-edges and edge removals which result in a spanning tree with no; /// more cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1384,Integrability,rout,routine,1384,"Removing these edges may break cycles that form this RefSCC and; /// thus this operation may change the RefSCC graph significantly. In; /// particular, this operation will re-form new RefSCCs based on the; /// remaining connectivity of the graph. The following invariants are; /// guaranteed to hold after calling this method:; ///; /// 1) If a ref-cycle remains after removal, it leaves this RefSCC intact; /// and in the graph. No new RefSCCs are built.; /// 2) Otherwise, this RefSCC will be dead after this call and no longer in; /// the graph or the postorder traversal of the call graph. Any iterator; /// pointing at this RefSCC will become invalid.; /// 3) All newly formed RefSCCs will be returned and the order of the; /// RefSCCs returned will be a valid postorder traversal of the new; /// RefSCCs.; /// 4) No RefSCC other than this RefSCC has its member set changed (this is; /// inherent in the definition of removing such an edge).; ///; /// These invariants are very important to ensure that we can build; /// optimization pipelines on top of the CGSCC pass manager which; /// intelligently update the RefSCC graph without invalidating other parts; /// of the RefSCC graph.; ///; /// Note that we provide no routine to remove a *call* edge. Instead, you; /// must first switch it to a ref edge using \c switchInternalEdgeToRef.; /// This split API is intentional as each of these two steps can invalidate; /// a different aspect of the graph structure and needs to have the; /// invalidation handled independently.; ///; /// The runtime complexity of this method is, in the worst case, O(V+E); /// where V is the number of nodes in this RefSCC and E is the number of; /// edges leaving the nodes in this RefSCC. Note that E includes both edges; /// within this RefSCC and edges from this RefSCC to child RefSCCs. Some; /// effort has been made to minimize the overhead of common cases such as; /// self-edges and edge removals which result in a spanning tree with no; /// more cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1186,Performance,optimiz,optimization,1186,"Removing these edges may break cycles that form this RefSCC and; /// thus this operation may change the RefSCC graph significantly. In; /// particular, this operation will re-form new RefSCCs based on the; /// remaining connectivity of the graph. The following invariants are; /// guaranteed to hold after calling this method:; ///; /// 1) If a ref-cycle remains after removal, it leaves this RefSCC intact; /// and in the graph. No new RefSCCs are built.; /// 2) Otherwise, this RefSCC will be dead after this call and no longer in; /// the graph or the postorder traversal of the call graph. Any iterator; /// pointing at this RefSCC will become invalid.; /// 3) All newly formed RefSCCs will be returned and the order of the; /// RefSCCs returned will be a valid postorder traversal of the new; /// RefSCCs.; /// 4) No RefSCC other than this RefSCC has its member set changed (this is; /// inherent in the definition of removing such an edge).; ///; /// These invariants are very important to ensure that we can build; /// optimization pipelines on top of the CGSCC pass manager which; /// intelligently update the RefSCC graph without invalidating other parts; /// of the RefSCC graph.; ///; /// Note that we provide no routine to remove a *call* edge. Instead, you; /// must first switch it to a ref edge using \c switchInternalEdgeToRef.; /// This split API is intentional as each of these two steps can invalidate; /// a different aspect of the graph structure and needs to have the; /// invalidation handled independently.; ///; /// The runtime complexity of this method is, in the worst case, O(V+E); /// where V is the number of nodes in this RefSCC and E is the number of; /// edges leaving the nodes in this RefSCC. Note that E includes both edges; /// within this RefSCC and edges from this RefSCC to child RefSCCs. Some; /// effort has been made to minimize the overhead of common cases such as; /// self-edges and edge removals which result in a spanning tree with no; /// more cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:18,Integrability,wrap,wrapper,18,"/// A convenience wrapper around the above to handle trivial cases of; /// inserting a new call edge.; ///; /// This is trivial whenever the target is in the same SCC as the source or; /// the edge is an outgoing edge to some descendant SCC. In these cases; /// there is no change to the cyclic structure of SCCs or RefSCCs.; ///; /// To further make calling this convenient, it also handles inserting; /// already existing edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:18,Integrability,wrap,wrapper,18,"/// A convenience wrapper around the above to handle trivial cases of; /// inserting a new ref edge.; ///; /// This is trivial whenever the target is in the same RefSCC as the source; /// or the edge is an outgoing edge to some descendant RefSCC. In these; /// cases there is no change to the cyclic structure of the RefSCCs.; ///; /// To further make calling this convenient, it also handles inserting; /// already existing edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:100,Performance,cache,cached,100,"/// A post-order depth-first RefSCC iterator over the call graph.; ///; /// This iterator walks the cached post-order sequence of RefSCCs. However,; /// it trades stability for flexibility. It is restricted to a forward; /// iterator but will survive mutations which insert new RefSCCs and continue; /// to point to the same RefSCC even if it moves in the post-order sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test whether a function is a known and defined library function tracked by; /// the call graph.; ///; /// Because these functions are known to LLVM they are specially modeled in; /// the call graph and even when all IR-level references have been removed; /// remain active and reachable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:157,Deployability,update,update,157,"///@{; /// \name Pre-SCC Mutation API; ///; /// These methods are only valid to call prior to forming any SCCs for this; /// call graph. They can be used to update the core node-graph during; /// a node-based inorder traversal that precedes any SCC-based traversal.; ///; /// Once you begin manipulating a call graph's SCCs, most mutation of the; /// graph must be performed via a RefSCC method. There are some exceptions; /// below.; /// Update the call graph after inserting a new edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:439,Deployability,Update,Update,439,"///@{; /// \name Pre-SCC Mutation API; ///; /// These methods are only valid to call prior to forming any SCCs for this; /// call graph. They can be used to update the core node-graph during; /// a node-based inorder traversal that precedes any SCC-based traversal.; ///; /// Once you begin manipulating a call graph's SCCs, most mutation of the; /// graph must be performed via a RefSCC method. There are some exceptions; /// below.; /// Update the call graph after inserting a new edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:365,Performance,perform,performed,365,"///@{; /// \name Pre-SCC Mutation API; ///; /// These methods are only valid to call prior to forming any SCCs for this; /// call graph. They can be used to update the core node-graph during; /// a node-based inorder traversal that precedes any SCC-based traversal.; ///; /// Once you begin manipulating a call graph's SCCs, most mutation of the; /// graph must be performed via a RefSCC method. There are some exceptions; /// below.; /// Update the call graph after inserting a new edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Deployability,Update,Update,4,/// Update the call graph after inserting a new edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Deployability,Update,Update,4,/// Update the call graph after deleting an edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Deployability,Update,Update,4,/// Update the call graph after deleting an edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:177,Integrability,rout,routines,177,"///@}; ///@{; /// \name General Mutation API; ///; /// There are a very limited set of mutations allowed on the graph as a whole; /// once SCCs have started to be formed. These routines have strict contracts; /// but may be called at any point.; /// Remove a dead function from the call graph (typically to delete it).; ///; /// Note that the function must have an empty use list, and the call graph; /// must be up-to-date prior to calling this. That means it is by itself in; /// a maximal SCC which is by itself in a maximal RefSCC, etc. No structural; /// changes result from calling this routine other than potentially removing; /// entry points into the call graph.; ///; /// If SCC formation has begun, this function must not be part of the current; /// DFS in order to call this safely. Typically, the function will have been; /// fully visited by the DFS prior to calling this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:198,Integrability,contract,contracts,198,"///@}; ///@{; /// \name General Mutation API; ///; /// There are a very limited set of mutations allowed on the graph as a whole; /// once SCCs have started to be formed. These routines have strict contracts; /// but may be called at any point.; /// Remove a dead function from the call graph (typically to delete it).; ///; /// Note that the function must have an empty use list, and the call graph; /// must be up-to-date prior to calling this. That means it is by itself in; /// a maximal SCC which is by itself in a maximal RefSCC, etc. No structural; /// changes result from calling this routine other than potentially removing; /// entry points into the call graph.; ///; /// If SCC formation has begun, this function must not be part of the current; /// DFS in order to call this safely. Typically, the function will have been; /// fully visited by the DFS prior to calling this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:593,Integrability,rout,routine,593,"///@}; ///@{; /// \name General Mutation API; ///; /// There are a very limited set of mutations allowed on the graph as a whole; /// once SCCs have started to be formed. These routines have strict contracts; /// but may be called at any point.; /// Remove a dead function from the call graph (typically to delete it).; ///; /// Note that the function must have an empty use list, and the call graph; /// must be up-to-date prior to calling this. That means it is by itself in; /// a maximal SCC which is by itself in a maximal RefSCC, etc. No structural; /// changes result from calling this routine other than potentially removing; /// entry points into the call graph.; ///; /// If SCC formation has begun, this function must not be part of the current; /// DFS in order to call this safely. Typically, the function will have been; /// fully visited by the DFS prior to calling this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:886,Integrability,rout,routine,886,"///@}; ///@{; /// \name General Mutation API; ///; /// There are a very limited set of mutations allowed on the graph as a whole; /// once SCCs have started to be formed. These routines have strict contracts; /// but may be called at any point.; /// Remove a dead function from the call graph (typically to delete it).; ///; /// Note that the function must have an empty use list, and the call graph; /// must be up-to-date prior to calling this. That means it is by itself in; /// a maximal SCC which is by itself in a maximal RefSCC, etc. No structural; /// changes result from calling this routine other than potentially removing; /// entry points into the call graph.; ///; /// If SCC formation has begun, this function must not be part of the current; /// DFS in order to call this safely. Typically, the function will have been; /// fully visited by the DFS prior to calling this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:787,Safety,safe,safely,787,"///@}; ///@{; /// \name General Mutation API; ///; /// There are a very limited set of mutations allowed on the graph as a whole; /// once SCCs have started to be formed. These routines have strict contracts; /// but may be called at any point.; /// Remove a dead function from the call graph (typically to delete it).; ///; /// Note that the function must have an empty use list, and the call graph; /// must be up-to-date prior to calling this. That means it is by itself in; /// a maximal SCC which is by itself in a maximal RefSCC, etc. No structural; /// changes result from calling this routine other than potentially removing; /// entry points into the call graph.; ///; /// If SCC formation has begun, this function must not be part of the current; /// DFS in order to call this safely. Typically, the function will have been; /// fully visited by the DFS prior to calling this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:54,Deployability,update,updates,54,"///@}; ///@{; /// \name Static helpers for code doing updates to the call graph.; ///; /// These helpers are used to implement parts of the call graph but are also; /// useful to code doing updates or otherwise wanting to walk the IR in the; /// same patterns as when we build the call graph.; /// Recursively visits the defined functions whose address is reachable from; /// every constant in the \p Worklist.; ///; /// Doesn't recurse through any constants already in the \p Visited set, and; /// updates that set with every constant visited.; ///; /// For each defined function, calls \p Callback with that function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:190,Deployability,update,updates,190,"///@}; ///@{; /// \name Static helpers for code doing updates to the call graph.; ///; /// These helpers are used to implement parts of the call graph but are also; /// useful to code doing updates or otherwise wanting to walk the IR in the; /// same patterns as when we build the call graph.; /// Recursively visits the defined functions whose address is reachable from; /// every constant in the \p Worklist.; ///; /// Doesn't recurse through any constants already in the \p Visited set, and; /// updates that set with every constant visited.; ///; /// For each defined function, calls \p Callback with that function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:499,Deployability,update,updates,499,"///@}; ///@{; /// \name Static helpers for code doing updates to the call graph.; ///; /// These helpers are used to implement parts of the call graph but are also; /// useful to code doing updates or otherwise wanting to walk the IR in the; /// same patterns as when we build the call graph.; /// Recursively visits the defined functions whose address is reachable from; /// every constant in the \p Worklist.; ///; /// Doesn't recurse through any constants already in the \p Visited set, and; /// updates that set with every constant visited.; ///; /// For each defined function, calls \p Callback with that function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:75,Performance,optimiz,optimizer,75,/// Defined functions that are also known library functions which the; /// optimizer can reason about and therefore might introduce calls to out of; /// thin air.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:14,Deployability,update,update,14,/// Helper to update pointers back to the graph object during moves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates an SCC and constructs it using the graph allocator.; ///; /// The arguments are forwarded to the constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a RefSCC and constructs it using the graph allocator.; ///; /// The arguments are forwarded to the constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:11,Testability,log,logic,11,/// Common logic for building SCCs from a sequence of roots.; ///; /// This is a very generic implementation of the depth-first walk and SCC; /// formation algorithm. It uses a generic sequence of roots and generic; /// callbacks for each step. This is designed to be used to implement both; /// the RefSCC formation and SCC formation with shared logic.; ///; /// Currently this is a relatively naive implementation of Tarjan's DFS; /// algorithm to form the SCCs.; ///; /// FIXME: We should consider newer variants such as Nuutila.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:347,Testability,log,logic,347,/// Common logic for building SCCs from a sequence of roots.; ///; /// This is a very generic implementation of the depth-first walk and SCC; /// formation algorithm. It uses a generic sequence of roots and generic; /// callbacks for each step. This is designed to be used to implement both; /// the RefSCC formation and SCC formation with shared logic.; ///; /// Currently this is a relatively naive implementation of Tarjan's DFS; /// algorithm to form the SCCs.; ///; /// FIXME: We should consider newer variants such as Nuutila.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:99,Testability,test,testing,99,/// A pass which prints the call graph to a \c raw_ostream.; ///; /// This is primarily useful for testing the analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:405,Integrability,interface,interface,405,"//===- LazyValueInfo.h - Value constraint analysis --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface for lazy computation of value constraint; // information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:24,Performance,cache,caches,24,"/// This pass computes, caches, and vends lazy value constraint information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:16,Integrability,interface,interface,16,// Public query interface.; /// Determine whether the specified value comparison with a constant is; /// known to be true or false on the specified CFG edge. Pred is a CmpInst; /// predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:24,Performance,cache,cache,24,/// Inform the analysis cache that we have threaded an edge from; /// PredBB to OldSucc to be from PredBB to NewSucc instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:54,Performance,cache,cache,54,/// Remove information related to this value from the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:24,Performance,cache,cache,24,/// Inform the analysis cache that we have erased a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper around LazyValueInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Lint.h:406,Integrability,interface,interfaces,406,"//===-- llvm/Analysis/Lint.h - LLVM IR Lint ---------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines lint interfaces that can be used for some validation of; // input to the system, and for checking that transformations haven't done; // something bad. In contrast to the Verifier, the Lint checker checks for; // undefined behavior or constructions with likely unintended behavior.; //; // To see what specifically is checked, look at Lint.cpp; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Lint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Lint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Lint.h:443,Security,validat,validation,443,"//===-- llvm/Analysis/Lint.h - LLVM IR Lint ---------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines lint interfaces that can be used for some validation of; // input to the system, and for checking that transformations haven't done; // something bad. In contrast to the Verifier, the Lint checker checks for; // undefined behavior or constructions with likely unintended behavior.; //; // To see what specifically is checked, look at Lint.cpp; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Lint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Lint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:7,Performance,Load,Loads,7,"//===- Loads.h - Local load analysis --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:23,Performance,load,load,23,"//===- Loads.h - Local load analysis --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:428,Performance,load,load,428,"//===- Loads.h - Local load analysis --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:402,Usability,simpl,simple,402,"//===- Loads.h - Local load analysis --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:106,Performance,perform,perform,106,/// Return true if this is always a dereferenceable pointer. If the context; /// instruction is specified perform context-sensitive analysis and return true; /// if the pointer is dereferenceable at the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:156,Performance,perform,performs,156,/// Returns true if V is always a dereferenceable pointer with alignment; /// greater or equal than requested. If the context instruction is specified; /// performs context-sensitive analysis and returns true if the pointer is; /// dereferenceable at the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:160,Performance,perform,performs,160,/// Returns true if V is always dereferenceable for Size byte with alignment; /// greater or equal than requested. If the context instruction is specified; /// performs context-sensitive analysis and returns true if the pointer is; /// dereferenceable at the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:44,Performance,load,load,44,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:133,Performance,perform,performs,133,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:208,Performance,load,load,208,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:283,Performance,load,load,283,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:200,Safety,safe,safe,200,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:275,Safety,safe,safe,275,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:430,Security,access,accessed,430,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:420,Energy Efficiency,power,powerful,420,"/// Return true if we can prove that the given load (which is assumed to be; /// within the specified loop) would access only dereferenceable memory, and; /// be properly aligned on every iteration of the specified loop regardless of; /// its placement within the loop. (i.e. does not require predication beyond; /// that required by the header itself and could be hoisted into the header; /// if desired.) This is more powerful than the variants above when the; /// address loaded from is analyzeable by SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:47,Performance,load,load,47,"/// Return true if we can prove that the given load (which is assumed to be; /// within the specified loop) would access only dereferenceable memory, and; /// be properly aligned on every iteration of the specified loop regardless of; /// its placement within the loop. (i.e. does not require predication beyond; /// that required by the header itself and could be hoisted into the header; /// if desired.) This is more powerful than the variants above when the; /// address loaded from is analyzeable by SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:475,Performance,load,loaded,475,"/// Return true if we can prove that the given load (which is assumed to be; /// within the specified loop) would access only dereferenceable memory, and; /// be properly aligned on every iteration of the specified loop regardless of; /// its placement within the loop. (i.e. does not require predication beyond; /// that required by the header itself and could be hoisted into the header; /// if desired.) This is more powerful than the variants above when the; /// address loaded from is analyzeable by SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:114,Security,access,access,114,"/// Return true if we can prove that the given load (which is assumed to be; /// within the specified loop) would access only dereferenceable memory, and; /// be properly aligned on every iteration of the specified loop regardless of; /// its placement within the loop. (i.e. does not require predication beyond; /// that required by the header itself and could be hoisted into the header; /// if desired.) This is more powerful than the variants above when the; /// address loaded from is analyzeable by SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:44,Performance,load,load,44,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:133,Performance,perform,performs,133,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:208,Performance,load,load,208,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:283,Performance,load,load,283,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:200,Safety,safe,safe,200,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:275,Safety,safe,safe,275,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:430,Security,access,accessed,430,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:65,Availability,avail,available,65,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:60,Performance,load,load,60,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:354,Performance,perform,performing,354,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:365,Performance,load,load,365,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:541,Performance,load,load,541,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:588,Performance,load,load,588,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:625,Performance,Load,Load,625,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:634,Performance,load,load,634,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:1119,Performance,load,load,1119,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:285,Safety,safe,safe,285,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:192,Availability,avail,available,192,/// This overload provides a more efficient implementation of; /// FindAvailableLoadedValue() for the case where we are not interested in; /// finding the closest clobbering instruction if no available load is found.; /// This overload cannot be used to scan across multiple blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:34,Energy Efficiency,efficient,efficient,34,/// This overload provides a more efficient implementation of; /// FindAvailableLoadedValue() for the case where we are not interested in; /// finding the closest clobbering instruction if no available load is found.; /// This overload cannot be used to scan across multiple blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:202,Performance,load,load,202,/// This overload provides a more efficient implementation of; /// FindAvailableLoadedValue() for the case where we are not interested in; /// finding the closest clobbering instruction if no available load is found.; /// This overload cannot be used to scan across multiple blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:68,Availability,avail,available,68,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:383,Performance,load,load,383,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:534,Performance,load,load,534,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:611,Performance,load,load,611,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:679,Performance,load,load,679,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:1154,Performance,load,load,1154,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:288,Safety,safe,safe,288,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:429,Security,Access,AccessTy,429,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:442,Security,access,access,442,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:407,Safety,safe,safe,407,"/// Returns true if a pointer value \p A can be replace with another pointer; /// value \B if they are deemed equal through some means (e.g. information from; /// conditions).; /// NOTE: the current implementations is incomplete and unsound. It does not; /// reject all invalid cases yet, but will be made stricter in the future. In; /// particular this means returning true means unknown if replacement is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:405,Integrability,interface,interface,405,"//===- llvm/Analysis/LoopAccessAnalysis.h -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface for the loop memory dependence framework that; // was originally developed for the Loop Vectorizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:435,Integrability,depend,dependence,435,"//===- llvm/Analysis/LoopAccessAnalysis.h -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface for the loop memory dependence framework that; // was originally developed for the Loop Vectorizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:83,Security,Access,Access,83,/// Collection of parameters shared beetween the Loop Vectorizer and the; /// Loop Access Analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:10,Performance,perform,performing,10,/// \When performing memory disambiguation checks at runtime do not; /// make more than this number of comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:18,Integrability,depend,dependences,18,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:234,Integrability,depend,dependence,234,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:374,Integrability,depend,dependencies,374,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:1017,Modifiability,variab,variable,1017,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:639,Safety,safe,safety,639,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:696,Safety,safe,safe,696,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:776,Safety,Safe,Safe,776,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:871,Safety,safe,safe,871,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:1470,Safety,Safe,Safe,1470,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:36,Security,access,accesses,36,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:249,Security,access,access,249,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:488,Security,access,access,488,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:611,Security,access,accesses,611,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:684,Security,access,accesses,684,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:1389,Security,access,access,1389,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:1574,Security,access,accesses,1574,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:21,Integrability,depend,dependent,21,/// Set of potential dependent memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:38,Security,access,accesses,38,/// Set of potential dependent memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:44,Integrability,depend,dependence,44,/// Type to keep track of the status of the dependence check. The order of; /// the elements is important and has to be from most permissive to least; /// permissive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:47,Integrability,depend,dependences,47,// Can vectorize safely without RT checks. All dependences are known to be; // safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:17,Safety,safe,safely,17,// Can vectorize safely without RT checks. All dependences are known to be; // safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:79,Safety,safe,safe,79,// Can vectorize safely without RT checks. All dependences are known to be; // safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:61,Integrability,depend,dependencies,61,// Can possibly vectorize with RT checks to overcome unknown dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:40,Integrability,depend,dependencies,40,// Cannot vectorize due to known unsafe dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:33,Safety,unsafe,unsafe,33,// Cannot vectorize due to known unsafe dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:4,Integrability,Depend,Dependece,4,/// Dependece between memory access instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:29,Security,access,access,29,/// Dependece between memory access instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:20,Integrability,depend,dependence,20,/// The type of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:6,Integrability,depend,dependence,6,// No dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:129,Performance,load,loaded,129,"// At least one of the memory access instructions may access a loop; // varying object, e.g. the address of underlying object is loaded inside; // the loop, like A[B[i]]. We cannot determine direction or distance in; // those cases, and also are unable to generate any runtime checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:30,Security,access,access,30,"// At least one of the memory access instructions may access a loop; // varying object, e.g. the address of underlying object is loaded inside; // the loop, like A[B[i]]. We cannot determine direction or distance in; // those cases, and also are unable to generate any runtime checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:54,Security,access,access,54,"// At least one of the memory access instructions may access a loop; // varying object, e.g. the address of underlying object is loaded inside; // the loop, like A[B[i]]. We cannot determine direction or distance in; // those cases, and also are unable to generate any runtime checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:78,Integrability,depend,dependences,78,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:153,Integrability,depend,dependence,153,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:277,Integrability,depend,dependences,277,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:442,Integrability,depend,dependence,442,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:165,Safety,safe,safe,165,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:373,Security,access,access,373,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:61,Performance,load,load,61,"// Forward, but if vectorized, is likely to prevent store-to-load; // forwarding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:63,Integrability,depend,dependent,63,"// Backward, but the distance allows a vectorization factor of dependent; // on MinDepDistBytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:34,Performance,load,load,34,"// Same, but may prevent store-to-load forwarding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:31,Integrability,depend,dependence,31,/// Index of the source of the dependence in the InstMap vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:36,Integrability,depend,dependence,36,/// Index of the destination of the dependence in the InstMap vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:20,Integrability,depend,dependence,20,/// The type of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:41,Integrability,depend,dependence,41,/// Return the source instruction of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:46,Integrability,depend,dependence,46,/// Return the destination instruction of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:4,Integrability,Depend,Dependence,4,/// Dependence types that don't prevent vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:22,Integrability,depend,dependence,22,/// Lexically forward dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:23,Integrability,depend,dependence,23,/// Lexically backward dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:32,Integrability,depend,dependence,32,/// May be a lexically backward dependence type (includes Unknown).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:14,Integrability,depend,dependence,14,/// Print the dependence. \p Instr is used to map the instruction; /// indices to instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:86,Security,access,access,86,/// Register the location (instructions are given increasing numbers); /// of a write access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:86,Security,access,access,86,/// Register the location (instructions are given increasing numbers); /// of a write access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:22,Integrability,depend,dependencies,22,/// Check whether the dependencies between the accesses are safe.; ///; /// Only checks sets with elements in \p CheckDeps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:60,Safety,safe,safe,60,/// Check whether the dependencies between the accesses are safe.; ///; /// Only checks sets with elements in \p CheckDeps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:47,Security,access,accesses,47,/// Check whether the dependencies between the accesses are safe.; ///; /// Only checks sets with elements in \p CheckDeps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:14,Integrability,depend,dependence,14,/// No memory dependence was encountered that would inhibit; /// vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:51,Safety,safe,safe,51,/// Return true if the number of elements that are safe to operate on; /// simultaneously is not bounded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:43,Safety,safe,safe,43,"/// Return the number of elements that are safe to operate on; /// simultaneously, multiplied by the size of the element in bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:27,Integrability,depend,dependency,27,/// In same cases when the dependency check fails we can still; /// vectorize the loop with a dynamic array access check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:108,Security,access,access,108,/// In same cases when the dependency check fails we can still; /// vectorize the loop with a dynamic array access check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:135,Availability,avail,available,135,/// Returns the memory dependences. If null is returned we exceeded; /// the MaxDependences threshold and this information is not; /// available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:23,Integrability,depend,dependences,23,/// Returns the memory dependences. If null is returned we exceeded; /// the MaxDependences threshold and this information is not; /// available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:106,Integrability,Depend,Dependence,106,/// The vector of memory access instructions. The indices are used as; /// instruction identifiers in the Dependence class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:25,Security,access,access,25,/// The vector of memory access instructions. The indices are used as; /// instruction identifiers in the Dependence class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:45,Security,access,access,45,"/// Return the program order indices for the access location (Ptr, IsWrite).; /// Returns an empty ArrayRef if there are no accesses for the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:124,Security,access,accesses,124,"/// Return the program order indices for the access location (Ptr, IsWrite).; /// Returns an empty ArrayRef if there are no accesses for the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:6,Integrability,wrap,wrapper,6,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:283,Integrability,depend,dependences,283,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:424,Integrability,wrap,wrap,424,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:269,Safety,avoid,avoid,269,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:394,Security,access,access,394,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:109,Usability,simpl,simplify,109,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:167,Usability,usab,usable,167,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:9,Security,access,access,9,"/// Maps access locations (ptr, read/write) to program order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:11,Security,access,access,11,/// Memory access instructions in program order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:17,Integrability,depend,dependence,17,/// The smallest dependence distance in bytes in the loop. This may not be; /// the same as the maximum number of bytes that are safe to operate on; /// simultaneously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:129,Safety,safe,safe,129,/// The smallest dependence distance in bytes in the loop. This may not be; /// the same as the maximum number of bytes that are safe to operate on; /// simultaneously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:62,Safety,safe,safe,62,"/// Number of elements (from consecutive iterations) that are safe to; /// operate on simultaneously, multiplied by the size of the element in bits.; /// The size of the element is taken from the memory access that is most; /// restrictive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:203,Security,access,access,203,"/// Number of elements (from consecutive iterations) that are safe to; /// operate on simultaneously, multiplied by the size of the element in bits.; /// The size of the element is taken from the memory access that is most; /// restrictive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:29,Integrability,depend,dependence,29,/// If we see a non-constant dependence distance we can still try to; /// vectorize this loop with runtime checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:18,Integrability,depend,dependence,18,"/// Result of the dependence checks, indicating whether the checked; /// dependences are safe for vectorization, require RT checks or are known to; /// be unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:73,Integrability,depend,dependences,73,"/// Result of the dependence checks, indicating whether the checked; /// dependences are safe for vectorization, require RT checks or are known to; /// be unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:89,Safety,safe,safe,89,"/// Result of the dependence checks, indicating whether the checked; /// dependences are safe for vectorization, require RT checks or are known to; /// be unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:155,Safety,unsafe,unsafe,155,"/// Result of the dependence checks, indicating whether the checked; /// dependences are safe for vectorization, require RT checks or are known to; /// be unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:13,Integrability,Depend,Dependences,13,//// True if Dependences reflects the dependences in the; //// loop. If false we exceeded MaxDependences and; //// Dependences is invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:38,Integrability,depend,dependences,38,//// True if Dependences reflects the dependences in the; //// loop. If false we exceeded MaxDependences and; //// Dependences is invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:115,Integrability,Depend,Dependences,115,//// True if Dependences reflects the dependences in the; //// loop. If false we exceeded MaxDependences and; //// Dependences is invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:11,Integrability,depend,dependences,11,/// Memory dependences collected during the analysis. Only valid if; /// RecordDependences is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:39,Integrability,depend,dependence,39,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:273,Integrability,depend,dependence,273,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:385,Integrability,depend,dependence,385,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:404,Integrability,depend,dependence,404,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:653,Integrability,depend,dependence,653,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:71,Security,access,accesses,71,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:91,Security,Access,Access,91,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:346,Security,access,accesses,346,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:456,Security,access,access,456,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:27,Integrability,depend,dependence,27,/// Check whether the data dependence could prevent store-load; /// forwarding.; ///; /// \return false if we shouldn't vectorize at all or avoid larger; /// vectorization factors by limiting MinDepDistBytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:58,Performance,load,load,58,/// Check whether the data dependence could prevent store-load; /// forwarding.; ///; /// \return false if we shouldn't vectorize at all or avoid larger; /// vectorization factors by limiting MinDepDistBytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:140,Safety,avoid,avoid,140,/// Check whether the data dependence could prevent store-load; /// forwarding.; ///; /// \return false if we shouldn't vectorize at all or avoid larger; /// vectorization factors by limiting MinDepDistBytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:4,Deployability,Update,Updates,4,/// Updates the current safety status with \p S. We can go from Safe to; /// either PossiblySafeWithRtChecks or Unsafe and from; /// PossiblySafeWithRtChecks to Unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:24,Safety,safe,safety,24,/// Updates the current safety status with \p S. We can go from Safe to; /// either PossiblySafeWithRtChecks or Unsafe and from; /// PossiblySafeWithRtChecks to Unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:64,Safety,Safe,Safe,64,/// Updates the current safety status with \p S. We can go from Safe to; /// either PossiblySafeWithRtChecks or Unsafe and from; /// PossiblySafeWithRtChecks to Unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:112,Safety,Unsafe,Unsafe,112,/// Updates the current safety status with \p S. We can go from Safe to; /// either PossiblySafeWithRtChecks or Unsafe and from; /// PossiblySafeWithRtChecks to Unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:161,Safety,Unsafe,Unsafe,161,/// Updates the current safety status with \p S. We can go from Safe to; /// either PossiblySafeWithRtChecks or Unsafe and from; /// PossiblySafeWithRtChecks to Unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:36,Security,access,accessed,36,/// Holds the smallest byte address accessed by the pointer throughout all; /// iterations of the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:35,Security,access,accessed,35,"/// Holds the largest byte address accessed by the pointer throughout all; /// iterations of the loop, plus 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:54,Integrability,depend,dependent,54,/// Holds the id of the set of pointers that could be dependent because of a; /// shared underlying object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:17,Security,access,access,17,/// SCEV for the access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:90,Energy Efficiency,reduce,reduce,90,/// Generate the checks and store it. This also performs the grouping; /// of pointers to reduce the number of memchecks necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:48,Performance,perform,performs,48,/// Generate the checks and store it. This also performs the grouping; /// of pointers to reduce the number of memchecks necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:98,Security,access,accesses,98,/// Returns the checks that generateChecks created. They can be used to ensure; /// no read/write accesses overlap across all loop iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:160,Integrability,depend,dependencies,160,"// Returns an optional list of (pointer-difference expressions, access size); // pairs that can be used to prove that there are no vectorization-preventing; // dependencies at runtime. There are is a vectorization-preventing dependency; // if any pointer-difference is <u VF * InterleaveCount * access size. Returns; // std::nullopt if pointer-difference checks cannot be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:225,Integrability,depend,dependency,225,"// Returns an optional list of (pointer-difference expressions, access size); // pairs that can be used to prove that there are no vectorization-preventing; // dependencies at runtime. There are is a vectorization-preventing dependency; // if any pointer-difference is <u VF * InterleaveCount * access size. Returns; // std::nullopt if pointer-difference checks cannot be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:64,Security,access,access,64,"// Returns an optional list of (pointer-difference expressions, access size); // pairs that can be used to prove that there are no vectorization-preventing; // dependencies at runtime. There are is a vectorization-preventing dependency; // if any pointer-difference is <u VF * InterleaveCount * access size. Returns; // std::nullopt if pointer-difference checks cannot be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:295,Security,access,access,295,"// Returns an optional list of (pointer-difference expressions, access size); // pairs that can be used to prove that there are no vectorization-preventing; // dependencies at runtime. There are is a vectorization-preventing dependency; // if any pointer-difference is <u VF * InterleaveCount * access size. Returns; // std::nullopt if pointer-difference checks cannot be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:180,Integrability,depend,dependecies,180,"/// Groups pointers such that a single memcheck is required; /// between two different groups. This will clear the CheckingGroups vector; /// and re-compute it. We will only group dependecies if \p UseDependencies; /// is true, otherwise we will create a separate group for each pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:105,Usability,clear,clear,105,"/// Groups pointers such that a single memcheck is required; /// between two different groups. This will clear the CheckingGroups vector; /// and re-compute it. We will only group dependecies if \p UseDependencies; /// is true, otherwise we will create a separate group for each pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:49,Security,access,access,49,"/// Try to create add a new (pointer-difference, access size) pair to; /// DiffCheck for checking groups \p CGI and \p CGJ. If pointer-difference; /// checks cannot be used for the groups, set CanUseDiffCheck to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:128,Integrability,depend,dependencies,128,"/// A list of (pointer-difference, access size) pairs that can be used to; /// prove that there are no vectorization-preventing dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:35,Security,access,access,35,"/// A list of (pointer-difference, access size) pairs that can be used to; /// prove that there are no vectorization-preventing dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:246,Integrability,depend,dependences,246,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:303,Integrability,depend,dependences,303,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:384,Integrability,depend,dependence,384,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:518,Integrability,depend,dependences,518,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:778,Integrability,wrap,wrap,778,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:964,Integrability,depend,dependences,964,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:33,Security,access,accesses,33,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:115,Security,access,accesses,115,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:156,Security,access,accesses,156,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:194,Security,Access,AccessAnalysis,194,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:651,Security,Access,AccessAnalysis,651,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:92,Integrability,depend,dependence,92,/// Return true we can analyze the memory accesses in the loop and there are; /// no memory dependence cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:42,Security,access,accesses,42,/// Return true we can analyze the memory accesses in the loop and there are; /// no memory dependence cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:15,Integrability,Depend,Dependence,15,/// the Memory Dependence Checker which can determine the; /// loop-independent and loop-carried dependences between memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:97,Integrability,depend,dependences,97,/// the Memory Dependence Checker which can determine the; /// loop-independent and loop-carried dependences between memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:124,Security,access,accesses,124,/// the Memory Dependence Checker which can determine the; /// loop-independent and loop-carried dependences between memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:10,Security,access,access,10,"/// If an access has a symbolic strides, this maps the pointer value to; /// the stride symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:43,Security,access,accesses,43,/// Print the information about the memory accesses in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:27,Integrability,depend,dependence,27,"/// If the loop has memory dependence involving an invariant address, i.e. two; /// stores or a store and a load, then return true, else return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:108,Performance,load,load,108,"/// If the loop has memory dependence involving an invariant address, i.e. two; /// stores or a store and a load, then return true, else return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:37,Usability,Simpl,Simplifies,37,/// Used to add runtime SCEV checks. Simplifies SCEV expressions and converts; /// them to a more usable form. All SCEV expressions during the analysis; /// should be re-written (and therefore simplified) according to PSE.; /// A user of LoopAccessAnalysis will need to emit the runtime checks; /// associated with this predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:98,Usability,usab,usable,98,/// Used to add runtime SCEV checks. Simplifies SCEV expressions and converts; /// them to a more usable form. All SCEV expressions during the analysis; /// should be re-written (and therefore simplified) according to PSE.; /// A user of LoopAccessAnalysis will need to emit the runtime checks; /// associated with this predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:193,Usability,simpl,simplified,193,/// Used to add runtime SCEV checks. Simplifies SCEV expressions and converts; /// them to a more usable form. All SCEV expressions during the analysis; /// should be re-written (and therefore simplified) according to PSE.; /// A user of LoopAccessAnalysis will need to emit the runtime checks; /// associated with this predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:19,Security,access,access,19,"/// Collect memory access with loop invariant strides.; ///; /// Looks for accesses like ""a[i * StrideA]"" where ""StrideA"" is loop; /// invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:75,Security,access,accesses,75,"/// Collect memory access with loop invariant strides.; ///; /// Looks for accesses like ""a[i * StrideA]"" where ""StrideA"" is loop; /// invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:33,Integrability,depend,dependence,33,// Emits the first unsafe memory dependence in a loop.; // Emits nothing if there are no unsafe dependences; // or if the dependences were not recorded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:96,Integrability,depend,dependences,96,// Emits the first unsafe memory dependence in a loop.; // Emits nothing if there are no unsafe dependences; // or if the dependences were not recorded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:122,Integrability,depend,dependences,122,// Emits the first unsafe memory dependence in a loop.; // Emits nothing if there are no unsafe dependences; // or if the dependences were not recorded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:19,Safety,unsafe,unsafe,19,// Emits the first unsafe memory dependence in a loop.; // Emits nothing if there are no unsafe dependences; // or if the dependences were not recorded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:89,Safety,unsafe,unsafe,89,// Emits the first unsafe memory dependence in a loop.; // Emits nothing if there are no unsafe dependences; // or if the dependences were not recorded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:135,Usability,simpl,simpler,135,/// We need to check that all of the pointers in this list are disjoint; /// at runtime. Using std::unique_ptr to make using move ctor simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:15,Integrability,Depend,Dependence,15,/// the Memory Dependence Checker which can determine the; /// loop-independent and loop-carried dependences between memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:97,Integrability,depend,dependences,97,/// the Memory Dependence Checker which can determine the; /// loop-independent and loop-carried dependences between memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:124,Security,access,accesses,124,/// the Memory Dependence Checker which can determine the; /// loop-independent and loop-carried dependences between memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:4,Performance,Cache,Cache,4,/// Cache the result of analyzeLoop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:10,Security,access,access,10,"/// If an access has a symbolic strides, this maps the pointer value to; /// the stride symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:155,Integrability,wrap,wrap,155,"/// If the pointer has a constant stride return it in units of the access type; /// size. Otherwise return std::nullopt.; ///; /// Ensure that it does not wrap in the address space, assuming the predicate; /// associated with \p PSE is true.; ///; /// If necessary this method will version the stride of the pointer according; /// to \p PtrToStride and therefore add further predicates to \p PSE.; /// The \p Assume parameter indicates if we are allowed to make additional; /// run-time assumptions.; ///; /// Note that the analysis results are defined if-and-only-if the original; /// memory access was defined. If that access was dead, or UB, then the; /// result of this function is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:67,Security,access,access,67,"/// If the pointer has a constant stride return it in units of the access type; /// size. Otherwise return std::nullopt.; ///; /// Ensure that it does not wrap in the address space, assuming the predicate; /// associated with \p PSE is true.; ///; /// If necessary this method will version the stride of the pointer according; /// to \p PtrToStride and therefore add further predicates to \p PSE.; /// The \p Assume parameter indicates if we are allowed to make additional; /// run-time assumptions.; ///; /// Note that the analysis results are defined if-and-only-if the original; /// memory access was defined. If that access was dead, or UB, then the; /// result of this function is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:593,Security,access,access,593,"/// If the pointer has a constant stride return it in units of the access type; /// size. Otherwise return std::nullopt.; ///; /// Ensure that it does not wrap in the address space, assuming the predicate; /// associated with \p PSE is true.; ///; /// If necessary this method will version the stride of the pointer according; /// to \p PtrToStride and therefore add further predicates to \p PSE.; /// The \p Assume parameter indicates if we are allowed to make additional; /// run-time assumptions.; ///; /// Note that the analysis results are defined if-and-only-if the original; /// memory access was defined. If that access was dead, or UB, then the; /// result of this function is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:621,Security,access,access,621,"/// If the pointer has a constant stride return it in units of the access type; /// size. Otherwise return std::nullopt.; ///; /// Ensure that it does not wrap in the address space, assuming the predicate; /// associated with \p PSE is true.; ///; /// If necessary this method will version the stride of the pointer according; /// to \p PtrToStride and therefore add further predicates to \p PSE.; /// The \p Assume parameter indicates if we are allowed to make additional; /// run-time assumptions.; ///; /// Note that the analysis results are defined if-and-only-if the original; /// memory access was defined. If that access was dead, or UB, then the; /// result of this function is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:194,Integrability,depend,depend,194,/// Returns the distance between the pointers \p PtrA and \p PtrB iff they are; /// compatible and it is possible to calculate the distance between them. This; /// is a simple API that does not depend on the analysis pass.; /// \param StrictCheck Ensure that the calculated distance matches the; /// type-based one after all the bitcasts removal in the provided pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:169,Usability,simpl,simple,169,/// Returns the distance between the pointers \p PtrA and \p PtrB iff they are; /// compatible and it is possible to calculate the distance between them. This; /// is a simple API that does not depend on the analysis pass.; /// \param StrictCheck Ensure that the calculated distance matches the; /// type-based one after all the bitcasts removal in the provided pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:456,Availability,mask,mask,456,"/// Attempt to sort the pointers in \p VL and return the sorted indices; /// in \p SortedIndices, if reordering is required.; ///; /// Returns 'true' if sorting is legal, otherwise returns 'false'.; ///; /// For example, for a given \p VL of memory accesses in program order, a[i+4],; /// a[i+0], a[i+1] and a[i+7], this function will sort the \p VL and save the; /// sorted indices in \p SortedIndices as a[i+0], a[i+1], a[i+4], a[i+7] and; /// saves the mask for actual memory accesses in program order in; /// \p SortedIndices as <1,2,0,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:249,Security,access,accesses,249,"/// Attempt to sort the pointers in \p VL and return the sorted indices; /// in \p SortedIndices, if reordering is required.; ///; /// Returns 'true' if sorting is legal, otherwise returns 'false'.; ///; /// For example, for a given \p VL of memory accesses in program order, a[i+4],; /// a[i+0], a[i+1] and a[i+7], this function will sort the \p VL and save the; /// sorted indices in \p SortedIndices as a[i+0], a[i+1], a[i+4], a[i+7] and; /// saves the mask for actual memory accesses in program order in; /// \p SortedIndices as <1,2,0,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:479,Security,access,accesses,479,"/// Attempt to sort the pointers in \p VL and return the sorted indices; /// in \p SortedIndices, if reordering is required.; ///; /// Returns 'true' if sorting is legal, otherwise returns 'false'.; ///; /// For example, for a given \p VL of memory accesses in program order, a[i+4],; /// a[i+0], a[i+1] and a[i+7], this function will sort the \p VL and save the; /// sorted indices in \p SortedIndices as a[i+0], a[i+1], a[i+4], a[i+7] and; /// saves the mask for actual memory accesses in program order in; /// \p SortedIndices as <1,2,0,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:113,Integrability,depend,depend,113,/// Returns true if the memory operations \p A and \p B are consecutive.; /// This is a simple API that does not depend on the analysis pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:88,Usability,simpl,simple,88,/// Returns true if the memory operations \p A and \p B are consecutive.; /// This is a simple API that does not depend on the analysis pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:8,Performance,cache,cache,8,/// The cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:27,Integrability,depend,dependence,27,/// This analysis provides dependence information for the memory; /// accesses of a loop.; ///; /// It runs the analysis for a loop on demand. This can be initiated by; /// querying the loop access info via AM.getResult<LoopAccessAnalysis>.; /// getResult return a LoopAccessInfo object. See this class for the; /// specifics of what information is provided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:70,Security,access,accesses,70,/// This analysis provides dependence information for the memory; /// accesses of a loop.; ///; /// It runs the analysis for a loop on demand. This can be initiated by; /// querying the loop access info via AM.getResult<LoopAccessAnalysis>.; /// getResult return a LoopAccessInfo object. See this class for the; /// specifics of what information is provided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:191,Security,access,access,191,/// This analysis provides dependence information for the memory; /// accesses of a loop.; ///; /// It runs the analysis for a loop on demand. This can be initiated by; /// querying the loop access info via AM.getResult<LoopAccessAnalysis>.; /// getResult return a LoopAccessInfo object. See this class for the; /// specifics of what information is provided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:775,Availability,avail,available,775,"//===- LoopAnalysisManager.h - Loop analysis management ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing per-loop analyses. These are; /// typically used as part of a loop pass pipeline over the loop nests of; /// a function.; ///; /// Loop analyses are allowed to make some simplifying assumptions:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; ///; /// The primary mechanism to provide these invariants is the loop pass manager,; /// but they can also be manually provided in order to reason about a loop from; /// outside of a dedicated pass manager.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:510,Deployability,pipeline,pipeline,510,"//===- LoopAnalysisManager.h - Loop analysis management ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing per-loop analyses. These are; /// typically used as part of a loop pass pipeline over the loop nests of; /// a function.; ///; /// Loop analyses are allowed to make some simplifying assumptions:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; ///; /// The primary mechanism to provide these invariants is the loop pass manager,; /// but they can also be manually provided in order to reason about a loop from; /// outside of a dedicated pass manager.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:608,Usability,simpl,simplifying,608,"//===- LoopAnalysisManager.h - Loop analysis management ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing per-loop analyses. These are; /// typically used as part of a loop pass pipeline over the loop nests of; /// a function.; ///; /// Loop analyses are allowed to make some simplifying assumptions:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; ///; /// The primary mechanism to provide these invariants is the loop pass manager,; /// but they can also be manually provided in order to reason about a loop from; /// outside of a dedicated pass manager.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:671,Usability,simpl,simplified,671,"//===- LoopAnalysisManager.h - Loop analysis management ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing per-loop analyses. These are; /// typically used as part of a loop pass pipeline over the loop nests of; /// a function.; ///; /// Loop analyses are allowed to make some simplifying assumptions:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; ///; /// The primary mechanism to provide these invariants is the loop pass manager,; /// but they can also be manually provided in order to reason about a loop from; /// outside of a dedicated pass manager.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:96,Availability,avail,available,96,"/// The adaptor from a function pass to a loop pass computes these analyses and; /// makes them available to the loop passes ""for free"". Each loop pass is; /// expected to update these analyses if necessary to ensure they're; /// valid after it runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:172,Deployability,update,update,172,"/// The adaptor from a function pass to a loop pass computes these analyses and; /// makes them available to the loop passes ""for free"". Each loop pass is; /// expected to update these analyses if necessary to ensure they're; /// valid after it runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:8,Energy Efficiency,adapt,adaptor,8,"/// The adaptor from a function pass to a loop pass computes these analyses and; /// makes them available to the loop passes ""for free"". Each loop pass is; /// expected to update these analyses if necessary to ensure they're; /// valid after it runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:8,Modifiability,adapt,adaptor,8,"/// The adaptor from a function pass to a loop pass computes these analyses and; /// makes them available to the loop passes ""for free"". Each loop pass is; /// expected to update these analyses if necessary to ensure they're; /// valid after it runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:235,Deployability,integrat,integrate,235,/// The loop analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This typedef serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:206,Energy Efficiency,adapt,adaptors,206,/// The loop analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This typedef serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:235,Integrability,integrat,integrate,235,/// The loop analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This typedef serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:206,Modifiability,adapt,adaptors,206,/// The loop analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This typedef serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:201,Performance,cache,cached,201,/// A specialized result for the \c LoopAnalysisManagerFunctionProxy which; /// retains a \c LoopInfo reference.; ///; /// This allows it to collect loop objects for which analysis results may be; /// cached in the \c LoopAnalysisManager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:128,Usability,clear,clear,128,// We have to null out the analysis manager in the moved-from state; // because we are taking ownership of the responsibilty to clear the; // analysis state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:128,Usability,clear,clear,128,// We have to null out the analysis manager in the moved-from state; // because we are taking ownership of the responsibilty to clear the; // analysis state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:14,Usability,clear,cleared,14,// InnerAM is cleared in a moved from state where there is nothing to do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:3,Usability,Clear,Clear,3,// Clear out the analysis manager if we're being destroyed -- it means we; // didn't even see an invalidate call when we got invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:4,Security,Access,Accessor,4,/// Accessor for the analysis manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:205,Performance,cache,cached,205,"/// Handler for invalidation of the proxy for a particular function.; ///; /// If the proxy, \c LoopInfo, and associated analyses are preserved, this; /// will merely forward the invalidation event to any cached loop analysis; /// results for loops within this function.; ///; /// If the necessary loop infrastructure is not preserved, this will forcibly; /// clear all of the cached analysis results that are keyed on the \c; /// LoopInfo for this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:377,Performance,cache,cached,377,"/// Handler for invalidation of the proxy for a particular function.; ///; /// If the proxy, \c LoopInfo, and associated analyses are preserved, this; /// will merely forward the invalidation event to any cached loop analysis; /// results for loops within this function.; ///; /// If the necessary loop infrastructure is not preserved, this will forcibly; /// clear all of the cached analysis results that are keyed on the \c; /// LoopInfo for this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:360,Usability,clear,clear,360,"/// Handler for invalidation of the proxy for a particular function.; ///; /// If the proxy, \c LoopInfo, and associated analyses are preserved, this; /// will merely forward the invalidation event to any cached loop analysis; /// results for loops within this function.; ///; /// If the necessary loop infrastructure is not preserved, this will forcibly; /// clear all of the cached analysis results that are keyed on the \c; /// LoopInfo for this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:418,Integrability,interface,interface,418,"//===- llvm/Analysis/LoopCacheAnalysis.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interface for the loop cache analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:441,Performance,cache,cache,441,"//===- llvm/Analysis/LoopCacheAnalysis.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interface for the loop cache analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:107,Performance,cache,cache,107,/// Return true/false if the current object and the indexed reference \p Other; /// are/aren't in the same cache line of size \p CLS. Two references are in; /// the same chace line iff the distance between them in the innermost; /// dimension is less than the cache line size. Return std::nullopt if unsure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:260,Performance,cache,cache,260,/// Return true/false if the current object and the indexed reference \p Other; /// are/aren't in the same cache line of size \p CLS. Two references are in; /// the same chace line iff the distance between them in the innermost; /// dimension is less than the cache line size. Return std::nullopt if unsure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:395,Modifiability,variab,variable,395,"/// Compute the cost of the reference w.r.t. the given loop \p L when it is; /// considered in the innermost position in the loop nest.; /// The cost is defined as:; /// - equal to one if the reference is loop invariant, or; /// - equal to '(TripCount * stride) / cache_line_size' if:; /// + the reference stride is less than the cache line size, and; /// + the coefficient of this loop's index variable used in all other; /// subscripts is zero; /// - or otherwise equal to 'TripCount'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:330,Performance,cache,cache,330,"/// Compute the cost of the reference w.r.t. the given loop \p L when it is; /// considered in the innermost position in the loop nest.; /// The cost is defined as:; /// - equal to one if the reference is loop invariant, or; /// - equal to '(TripCount * stride) / cache_line_size' if:; /// + the reference stride is less than the cache line size, and; /// + the coefficient of this loop's index variable used in all other; /// subscripts is zero; /// - or otherwise equal to 'TripCount'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:30,Security,Access,AccessFn,30,/// Attempt to delinearize \p AccessFn for fixed-size arrays.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:173,Modifiability,variab,variable,173,"/// Return true if the indexed reference is 'consecutive' in loop \p L.; /// An indexed reference is 'consecutive' if the only coefficient that uses; /// the loop induction variable is the rightmost one, and the access stride is; /// smaller than the cache line size \p CLS. Provide a valid \p Stride value; /// if the indexed reference is 'consecutive'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:251,Performance,cache,cache,251,"/// Return true if the indexed reference is 'consecutive' in loop \p L.; /// An indexed reference is 'consecutive' if the only coefficient that uses; /// the loop induction variable is the rightmost one, and the access stride is; /// smaller than the cache line size \p CLS. Provide a valid \p Stride value; /// if the indexed reference is 'consecutive'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:212,Security,access,access,212,"/// Return true if the indexed reference is 'consecutive' in loop \p L.; /// An indexed reference is 'consecutive' if the only coefficient that uses; /// the loop induction variable is the rightmost one, and the access stride is; /// smaller than the cache line size \p CLS. Provide a valid \p Stride value; /// if the indexed reference is 'consecutive'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:62,Modifiability,variab,variable,62,/// Return true if the coefficient corresponding to induction variable of; /// loop \p L in the given \p Subscript is zero or is loop invariant in \p L.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:67,Usability,simpl,simple,67,/// Verify that the given \p Subscript is 'well formed' (must be a simple add; /// recurrence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:233,Integrability,depend,dependency,233,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:281,Integrability,depend,dependence,281,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:305,Integrability,depend,dependence,305,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:526,Performance,cache,cache,526,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:643,Performance,cache,cache,643,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:622,Security,access,access,622,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:558,Usability,Intuit,Intuitively,558,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:845,Modifiability,variab,variable,845,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:7,Performance,Cache,CacheCost,7,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:85,Performance,cache,cache,85,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:150,Performance,cache,cache,150,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:231,Performance,cache,cache,231,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:428,Performance,cache,cache,428,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:692,Performance,cache,cache,692,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:776,Performance,cache,cache,776,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:1041,Performance,cache,cache,1041,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:16,Performance,Cache,CacheCost,16,/// Construct a CacheCost object for the loop nest described by \p Loops.; /// The optional parameter \p TRT can be used to specify the max. distance; /// between array elements accessed in a loop so that the elements are; /// classified to have temporal reuse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:178,Security,access,accessed,178,/// Construct a CacheCost object for the loop nest described by \p Loops.; /// The optional parameter \p TRT can be used to specify the max. distance; /// between array elements accessed in a loop so that the elements are; /// classified to have temporal reuse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:13,Performance,Cache,CacheCost,13,/// Create a CacheCost for the loop nest rooted by \p Root.; /// The optional parameter \p TRT can be used to specify the max. distance; /// between array elements accessed in a loop so that the elements are; /// classified to have temporal reuse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:164,Security,access,accessed,164,/// Create a CacheCost for the loop nest rooted by \p Root.; /// The optional parameter \p TRT can be used to specify the max. distance; /// between array elements accessed in a loop so that the elements are; /// classified to have temporal reuse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:18,Performance,cache,cache,18,/// Calculate the cache footprint of each loop in the nest (when it is; /// considered to be in the innermost position).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:20,Performance,load,load,20,/// Partition store/load instructions in the loop nest into reference groups.; /// Two or more memory accesses belong in the same reference group if they; /// share the same cache line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:174,Performance,cache,cache,174,/// Partition store/load instructions in the loop nest into reference groups.; /// Two or more memory accesses belong in the same reference group if they; /// share the same cache line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:102,Security,access,accesses,102,/// Partition store/load instructions in the loop nest into reference groups.; /// Two or more memory accesses belong in the same reference group if they; /// share the same cache line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:456,Modifiability,variab,variable,456,"/// Compute the cost of a representative reference in reference group \p RG; /// when the given loop \p L is considered as the innermost loop in the nest.; /// The computed cost is an estimate for the number of cache lines used by the; /// reference group. The representative reference cost is defined as:; /// - equal to one if the reference is loop invariant, or; /// - equal to '(TripCount * stride) / cache_line_size' if (a) loop \p L's; /// induction variable is used only in the reference subscript associated; /// with loop \p L, and (b) the reference stride is less than the cache; /// line size, or; /// - TripCount otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:211,Performance,cache,cache,211,"/// Compute the cost of a representative reference in reference group \p RG; /// when the given loop \p L is considered as the innermost loop in the nest.; /// The computed cost is an estimate for the number of cache lines used by the; /// reference group. The representative reference cost is defined as:; /// - equal to one if the reference is loop invariant, or; /// - equal to '(TripCount * stride) / cache_line_size' if (a) loop \p L's; /// induction variable is used only in the reference subscript associated; /// with loop \p L, and (b) the reference stride is less than the cache; /// line size, or; /// - TripCount otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:583,Performance,cache,cache,583,"/// Compute the cost of a representative reference in reference group \p RG; /// when the given loop \p L is considered as the innermost loop in the nest.; /// The computed cost is an estimate for the number of cache lines used by the; /// reference group. The representative reference cost is defined as:; /// - equal to one if the reference is loop invariant, or; /// - equal to '(TripCount * stride) / cache_line_size' if (a) loop \p L's; /// induction variable is used only in the reference subscript associated; /// with loop \p L, and (b) the reference stride is less than the cache; /// line size, or; /// - TripCount otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:44,Performance,cache,cache,44,/// Sort the LoopCosts vector by decreasing cache cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:4,Performance,Cache,Cache,4,/// Cache costs for the loops in the loop nest associated with this object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:45,Security,access,accessed,45,/// The max. distance between array elements accessed in a loop so that the; /// elements are classified to have temporal reuse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:28,Performance,Cache,CacheCost,28,/// Printer pass for the \c CacheCost results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:55,Modifiability,variab,variable,55,"/// Check to see if the loop has a canonical induction variable: an integer; /// recurrence that starts at 0 and increments by one each time through the; /// loop. If so, return the phi node that corresponds to it.; ///; /// The IndVarSimplify pass transforms loops to have a canonical induction; /// variable.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:301,Modifiability,variab,variable,301,"/// Check to see if the loop has a canonical induction variable: an integer; /// recurrence that starts at 0 and increments by one each time through the; /// loop. If so, return the phi node that corresponds to it.; ///; /// The IndVarSimplify pass transforms loops to have a canonical induction; /// variable.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:83,Modifiability,variab,variable,83,"/// Below are some utilities to get the loop guard, loop bounds and induction; /// variable, and to check if a given phinode is an auxiliary induction; /// variable, if the loop is guarded, and if the loop is canonical.; ///; /// Here is an example:; /// \code; /// for (int i = lb; i < ub; i+=step); /// <loop body>; /// --- pseudo LLVMIR ---; /// beforeloop:; /// guardcmp = (lb < ub); /// if (guardcmp) goto preheader; else goto afterloop; /// preheader:; /// loop:; /// i_1 = phi[{lb, preheader}, {i_2, latch}]; /// <loop body>; /// i_2 = i_1 + step; /// latch:; /// cmp = (i_2 < ub); /// if (cmp) goto loop; /// exit:; /// afterloop:; /// \endcode; ///; /// - getBounds; /// - getInitialIVValue --> lb; /// - getStepInst --> i_2 = i_1 + step; /// - getStepValue --> step; /// - getFinalIVValue --> ub; /// - getCanonicalPredicate --> '<'; /// - getDirection --> Increasing; ///; /// - getInductionVariable --> i_1; /// - isAuxiliaryInductionVariable(x) --> true if x == i_1; /// - getLoopGuardBranch(); /// --> `if (guardcmp) goto preheader; else goto afterloop`; /// - isGuarded() --> true; /// - isCanonical --> false",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:156,Modifiability,variab,variable,156,"/// Below are some utilities to get the loop guard, loop bounds and induction; /// variable, and to check if a given phinode is an auxiliary induction; /// variable, if the loop is guarded, and if the loop is canonical.; ///; /// Here is an example:; /// \code; /// for (int i = lb; i < ub; i+=step); /// <loop body>; /// --- pseudo LLVMIR ---; /// beforeloop:; /// guardcmp = (lb < ub); /// if (guardcmp) goto preheader; else goto afterloop; /// preheader:; /// loop:; /// i_1 = phi[{lb, preheader}, {i_2, latch}]; /// <loop body>; /// i_2 = i_1 + step; /// latch:; /// cmp = (i_2 < ub); /// if (cmp) goto loop; /// exit:; /// afterloop:; /// \endcode; ///; /// - getBounds; /// - getInitialIVValue --> lb; /// - getStepInst --> i_2 = i_1 + step; /// - getStepValue --> step; /// - getFinalIVValue --> ub; /// - getCanonicalPredicate --> '<'; /// - getDirection --> Increasing; ///; /// - getInductionVariable --> i_1; /// - isAuxiliaryInductionVariable(x) --> true if x == i_1; /// - getLoopGuardBranch(); /// --> `if (guardcmp) goto preheader; else goto afterloop`; /// - isGuarded() --> true; /// - isCanonical --> false",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:79,Modifiability,variab,variable,79,/// Return the LoopBounds object if; /// - the given \p IndVar is an induction variable; /// - the initial value of the induction variable can be found; /// - the step instruction of the induction variable can be found; /// - the final value of the induction variable can be found; ///; /// Else std::nullopt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:130,Modifiability,variab,variable,130,/// Return the LoopBounds object if; /// - the given \p IndVar is an induction variable; /// - the initial value of the induction variable can be found; /// - the step instruction of the induction variable can be found; /// - the final value of the induction variable can be found; ///; /// Else std::nullopt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:197,Modifiability,variab,variable,197,/// Return the LoopBounds object if; /// - the given \p IndVar is an induction variable; /// - the initial value of the induction variable can be found; /// - the step instruction of the induction variable can be found; /// - the final value of the induction variable can be found; ///; /// Else std::nullopt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:259,Modifiability,variab,variable,259,/// Return the LoopBounds object if; /// - the given \p IndVar is an induction variable; /// - the initial value of the induction variable can be found; /// - the step instruction of the induction variable can be found; /// - the final value of the induction variable can be found; ///; /// Else std::nullopt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:48,Modifiability,variab,variable,48,/// Get the initial value of the loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:29,Deployability,update,updates,29,/// Get the instruction that updates the loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:56,Modifiability,variab,variable,56,/// Get the instruction that updates the loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:55,Deployability,update,updated,55,/// Get the step that the loop induction variable gets updated by in each; /// loop iteration. Return nullptr if not found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:41,Modifiability,variab,variable,41,/// Get the step that the loop induction variable gets updated by in each; /// loop iteration. Return nullptr if not found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:46,Modifiability,variab,variable,46,/// Get the final value of the loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:562,Safety,safe,safe,562,"/// Return the canonical predicate for the latch compare instruction, if; /// able to be calcuated. Else BAD_ICMP_PREDICATE.; ///; /// A predicate is considered as canonical if requirements below are all; /// satisfied:; /// 1. The first successor of the latch branch is the loop header; /// If not, inverse the predicate.; /// 2. One of the operands of the latch comparison is StepInst; /// If not, and; /// - if the current calcuated predicate is not ne or eq, flip the; /// predicate.; /// - else if the loop is increasing, return slt; /// (notice that it is safe to change from ne or eq to sign compare); /// - else if the loop is decreasing, return sgt; /// (notice that it is safe to change from ne or eq to sign compare); ///; /// Here is an example when both (1) and (2) are not satisfied:; /// \code; /// loop.header:; /// %iv = phi [%initialiv, %loop.preheader], [%inc, %loop.header]; /// %inc = add %iv, %step; /// %cmp = slt %iv, %finaliv; /// br %cmp, %loop.exit, %loop.header; /// loop.exit:; /// \endcode; /// - The second successor of the latch branch is the loop header instead; /// of the first successor (slt -> sge); /// - The first operand of the latch comparison (%cmp) is the IndVar (%iv); /// instead of the StepInst (%inc) (sge -> sgt); ///; /// The predicate would be sgt if both (1) and (2) are satisfied.; /// getCanonicalPredicate() returns sgt for this example.; /// Note: The IR is not changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:682,Safety,safe,safe,682,"/// Return the canonical predicate for the latch compare instruction, if; /// able to be calcuated. Else BAD_ICMP_PREDICATE.; ///; /// A predicate is considered as canonical if requirements below are all; /// satisfied:; /// 1. The first successor of the latch branch is the loop header; /// If not, inverse the predicate.; /// 2. One of the operands of the latch comparison is StepInst; /// If not, and; /// - if the current calcuated predicate is not ne or eq, flip the; /// predicate.; /// - else if the loop is increasing, return slt; /// (notice that it is safe to change from ne or eq to sign compare); /// - else if the loop is decreasing, return sgt; /// (notice that it is safe to change from ne or eq to sign compare); ///; /// Here is an example when both (1) and (2) are not satisfied:; /// \code; /// loop.header:; /// %iv = phi [%initialiv, %loop.preheader], [%inc, %loop.header]; /// %inc = add %iv, %step; /// %cmp = slt %iv, %finaliv; /// br %cmp, %loop.exit, %loop.header; /// loop.exit:; /// \endcode; /// - The second successor of the latch branch is the loop header instead; /// of the first successor (slt -> sge); /// - The first operand of the latch comparison (%cmp) is the IndVar (%iv); /// instead of the StepInst (%inc) (sge -> sgt); ///; /// The predicate would be sgt if both (1) and (2) are satisfied.; /// getCanonicalPredicate() returns sgt for this example.; /// Note: The IR is not changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:43,Modifiability,variab,variable,43,// The initial value of the loop induction variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:24,Deployability,update,updates,24,// The instruction that updates the loop induction variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:51,Modifiability,variab,variable,51,// The instruction that updates the loop induction variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:51,Deployability,update,updated,51,// The value that the loop induction variable gets updated by in each loop; // iteration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:37,Modifiability,variab,variable,37,// The value that the loop induction variable gets updated by in each loop; // iteration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:41,Modifiability,variab,variable,41,// The final value of the loop induction variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:30,Modifiability,variab,variable,30,"/// Return the loop induction variable if found, else return nullptr.; /// An instruction is considered as the loop induction variable if; /// - it is an induction variable of the loop; and; /// - it is used to determine the condition of the branch in the loop latch; ///; /// Note: the induction variable doesn't need to be canonical, i.e. starts at; /// zero and increments by one each time through the loop (but it can be).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:126,Modifiability,variab,variable,126,"/// Return the loop induction variable if found, else return nullptr.; /// An instruction is considered as the loop induction variable if; /// - it is an induction variable of the loop; and; /// - it is used to determine the condition of the branch in the loop latch; ///; /// Note: the induction variable doesn't need to be canonical, i.e. starts at; /// zero and increments by one each time through the loop (but it can be).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:164,Modifiability,variab,variable,164,"/// Return the loop induction variable if found, else return nullptr.; /// An instruction is considered as the loop induction variable if; /// - it is an induction variable of the loop; and; /// - it is used to determine the condition of the branch in the loop latch; ///; /// Note: the induction variable doesn't need to be canonical, i.e. starts at; /// zero and increments by one each time through the loop (but it can be).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:297,Modifiability,variab,variable,297,"/// Return the loop induction variable if found, else return nullptr.; /// An instruction is considered as the loop induction variable if; /// - it is an induction variable of the loop; and; /// - it is used to determine the condition of the branch in the loop latch; ///; /// Note: the induction variable doesn't need to be canonical, i.e. starts at; /// zero and increments by one each time through the loop (but it can be).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:61,Modifiability,variab,variable,61,/// Get the loop induction descriptor for the loop induction variable. Return; /// true if the loop induction variable is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:110,Modifiability,variab,variable,110,/// Get the loop induction descriptor for the loop induction variable. Return; /// true if the loop induction variable is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:266,Modifiability,variab,variable,266,/// Return true if the given PHINode \p AuxIndVar is; /// - in the loop header; /// - not used outside of the loop; /// - incremented by a loop invariant step for each loop iteration; /// - step instruction opcode should be add or sub; /// Note: auxiliary induction variable is not required to be used in the; /// conditional branch in the loop latch. (but it can be),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:87,Usability,simpl,simplified,87,"/// Return the loop guard branch, if it exists.; ///; /// This currently only works on simplified loop, as it requires a preheader; /// and a latch to identify the guard. It will work on loops of the form:; /// \code; /// GuardBB:; /// br cond1, Preheader, ExitSucc <== GuardBranch; /// Preheader:; /// br Header; /// Header:; /// ...; /// br Latch; /// Latch:; /// br cond2, Header, ExitBlock; /// ExitBlock:; /// br ExitSucc; /// ExitSucc:; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:42,Usability,simpl,simplify,42,"/// Return true iff the loop is; /// - in simplify rotated form, and; /// - guarded by a loop guard branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:38,Modifiability,variab,variable,38,/// Return true if the loop induction variable starts at zero and increments; /// by one each time through the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:36,Safety,safe,safe,36,/// Return true if the loop body is safe to clone in practice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:112,Integrability,depend,dependencies,112,"/// Returns true if the loop is annotated parallel.; ///; /// A parallel loop can be assumed to not contain any dependencies between; /// iterations by the compiler. That is, any loop-carried dependency checking; /// can be skipped completely when parallelizing the loop on the target; /// machine. Thus, if the parallel loop information originates from the; /// programmer, e.g. via the OpenMP parallel for pragma, it is the; /// programmer's responsibility to ensure there are no loop-carried; /// dependencies. The final execution order of the instructions across; /// iterations is not guaranteed, thus, the end result might or might not; /// implement actual concurrent execution of instructions across multiple; /// iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:192,Integrability,depend,dependency,192,"/// Returns true if the loop is annotated parallel.; ///; /// A parallel loop can be assumed to not contain any dependencies between; /// iterations by the compiler. That is, any loop-carried dependency checking; /// can be skipped completely when parallelizing the loop on the target; /// machine. Thus, if the parallel loop information originates from the; /// programmer, e.g. via the OpenMP parallel for pragma, it is the; /// programmer's responsibility to ensure there are no loop-carried; /// dependencies. The final execution order of the instructions across; /// iterations is not guaranteed, thus, the end result might or might not; /// implement actual concurrent execution of instructions across multiple; /// iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:500,Integrability,depend,dependencies,500,"/// Returns true if the loop is annotated parallel.; ///; /// A parallel loop can be assumed to not contain any dependencies between; /// iterations by the compiler. That is, any loop-carried dependency checking; /// can be skipped completely when parallelizing the loop on the target; /// machine. Thus, if the parallel loop information originates from the; /// programmer, e.g. via the OpenMP parallel for pragma, it is the; /// programmer's responsibility to ensure there are no loop-carried; /// dependencies. The final execution order of the instructions across; /// iterations is not guaranteed, thus, the end result might or might not; /// implement actual concurrent execution of instructions across multiple; /// iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:664,Performance,concurren,concurrent,664,"/// Returns true if the loop is annotated parallel.; ///; /// A parallel loop can be assumed to not contain any dependencies between; /// iterations by the compiler. That is, any loop-carried dependency checking; /// can be skipped completely when parallelizing the loop on the target; /// machine. Thus, if the parallel loop information originates from the; /// programmer, e.g. via the OpenMP parallel for pragma, it is the; /// programmer's responsibility to ensure there are no loop-carried; /// dependencies. The final execution order of the instructions across; /// iterations is not guaranteed, thus, the end result might or might not; /// implement actual concurrent execution of instructions across multiple; /// iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:67,Deployability,Update,Update,67,"// Most of the public interface is provided via LoopInfoBase.; /// Update LoopInfo after removing the last backedge from a loop. This updates; /// the loop forest and parent loops for each block so that \c L is no longer; /// referenced, but does not actually delete \c L immediately. The pointer; /// will remain valid until this LoopInfo's memory is released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:134,Deployability,update,updates,134,"// Most of the public interface is provided via LoopInfoBase.; /// Update LoopInfo after removing the last backedge from a loop. This updates; /// the loop forest and parent loops for each block so that \c L is no longer; /// referenced, but does not actually delete \c L immediately. The pointer; /// will remain valid until this LoopInfo's memory is released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:352,Deployability,release,released,352,"// Most of the public interface is provided via LoopInfoBase.; /// Update LoopInfo after removing the last backedge from a loop. This updates; /// the loop forest and parent loops for each block so that \c L is no longer; /// referenced, but does not actually delete \c L immediately. The pointer; /// will remain valid until this LoopInfo's memory is released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:22,Integrability,interface,interface,22,"// Most of the public interface is provided via LoopInfoBase.; /// Update LoopInfo after removing the last backedge from a loop. This updates; /// the loop forest and parent loops for each block so that \c L is no longer; /// referenced, but does not actually delete \c L immediately. The pointer; /// will remain valid until this LoopInfo's memory is released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:59,Safety,safe,safely,59,// If the instruction is not defined in a loop then it can safely replace; // anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:84,Safety,avoid,avoid,84,// Movement within the same loop does not break LCSSA (the equality check is; // to avoid doing a hashtable lookup in case of intra-block movement).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:98,Security,hash,hashtable,98,// Movement within the same loop does not break LCSSA (the equality check is; // to avoid doing a hashtable lookup in case of intra-block movement).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:95,Usability,simpl,simply,95,// This would need adjustment if we allow Inst to be a phi node -- the; // new use block won't simply be NewBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:23,Security,expose,exposes,23,/// Analysis pass that exposes the \c LoopInfo for a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:48,Security,access,access,48,/// Return whether an MDNode might represent an access group.; ///; /// Access group metadata nodes have to be distinct and empty. Being; /// always-empty ensures that it never needs to be changed (which -- because; /// MDNodes are designed immutable -- would require creating a new MDNode). Note; /// that this is not a sufficient condition: not every distinct and empty NDNode; /// is representing an access group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:72,Security,Access,Access,72,/// Return whether an MDNode might represent an access group.; ///; /// Access group metadata nodes have to be distinct and empty. Being; /// always-empty ensures that it never needs to be changed (which -- because; /// MDNodes are designed immutable -- would require creating a new MDNode). Note; /// that this is not a sufficient condition: not every distinct and empty NDNode; /// is representing an access group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:403,Security,access,access,403,/// Return whether an MDNode might represent an access group.; ///; /// Access group metadata nodes have to be distinct and empty. Being; /// always-empty ensures that it never needs to be changed (which -- because; /// MDNodes are designed immutable -- would require creating a new MDNode). Note; /// that this is not a sufficient condition: not every distinct and empty NDNode; /// is representing an access group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:549,Energy Efficiency,efficient,efficient,549,"//===--------- LoopIterator.h - Iterate over loop blocks --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file defines iterators to visit the basic blocks within a loop.; //; // These iterators currently visit blocks within subloops as well.; // Unfortunately we have no efficient way of summarizing loop exits which would; // allow skipping subloops during traversal.; //; // If you want to visit all blocks in a loop and don't need an ordered traveral,; // use Loop::block_begin() instead.; //; // This is intentionally designed to work with ill-formed loops in which the; // backedge has been deleted. The only prerequisite is that all blocks; // contained within the loop according to the most recent LoopInfo analysis are; // reachable from the loop header.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:8,Integrability,wrap,wraps,8,"// This wraps a const Loop * into the iterator, so we know which edges to; // filter out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:21,Performance,cache,cached,21,/// Iterate over the cached postorder blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:29,Performance,cache,cached,29,/// Reverse iterate over the cached postorder blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper class to LoopBlocksDFS that provides a standard begin()/end(); /// interface for the DFS reverse post-order traversal of blocks in a loop body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:79,Integrability,interface,interface,79,/// Wrapper class to LoopBlocksDFS that provides a standard begin()/end(); /// interface for the DFS reverse post-order traversal of blocks in a loop body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:29,Performance,cache,cached,29,/// Reverse iterate over the cached postorder blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:14,Integrability,interface,interface,14,"// po_ext_end interface requires a basic block, but ignores its value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h:418,Integrability,interface,interface,418,"//===- llvm/Analysis/LoopNestAnalysis.h -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interface for the loop nest analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h:53,Usability,simpl,simplify,53,/// Return true if all loops in the loop nest are in simplify form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:426,Performance,optimiz,optimization,426,"//===- LoopPass.h - LoopPass class ----------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines LoopPass class. All loop optimization; // and transformation passes are derived from LoopPass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:68,Performance,perform,perform,68,// runOnLoop - This method should be implemented by the subclass to perform; // whatever action is necessary for the specified Loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:72,Availability,avail,available,72,"// Check if this pass is suitable for the current LPPassManager, if; // available. This pass P is not suitable for a LPPassManager if P; // is not preserving higher level analysis info used by other; // LPPassManager passes. In such case, pop LPPassManager from the; // stack. This will force assignPassManager() to create new; // LPPassManger as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:122,Performance,Optimiz,OptimizeNone,122,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when Attribute::OptimizeNone is set or when; /// optimization bisect is over the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:155,Performance,optimiz,optimization,155,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when Attribute::OptimizeNone is set or when; /// optimization bisect is over the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:36,Energy Efficiency,schedul,scheduled,36,"/// run - Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the module, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:32,Performance,queue,queue,32,// Add a new loop into the loop queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:563,Performance,optimiz,optimizations,563,"//===- llvm/Analysis/LoopUnrollAnalyzer.h - Loop Unroll Analyzer-*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements UnrolledInstAnalyzer class. It's used for predicting; // potential effects that loop unrolling might have, such as enabling constant; // propagation and other optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:446,Safety,predict,predicting,446,"//===- llvm/Analysis/LoopUnrollAnalyzer.h - Loop Unroll Analyzer-*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements UnrolledInstAnalyzer class. It's used for predicting; // potential effects that loop unrolling might have, such as enabling constant; // propagation and other optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:48,Performance,optimiz,optimization,48,"// This class is used to get an estimate of the optimization effects that we; // could get from complete loop unrolling. It comes from the fact that some; // loads might be replaced with concrete constant values and that could trigger; // a chain of instruction simplifications.; //; // E.g. we might have:; // int a[] = {0, 1, 0};; // v = 0;; // for (i = 0; i < 3; i ++); // v += b[i]*a[i];; // If we completely unroll the loop, we would get:; // v = b[0]*a[0] + b[1]*a[1] + b[2]*a[2]; // Which then will be simplified to:; // v = b[0]* 0 + b[1]* 1 + b[2]* 0; // And finally:; // v = b[1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:158,Performance,load,loads,158,"// This class is used to get an estimate of the optimization effects that we; // could get from complete loop unrolling. It comes from the fact that some; // loads might be replaced with concrete constant values and that could trigger; // a chain of instruction simplifications.; //; // E.g. we might have:; // int a[] = {0, 1, 0};; // v = 0;; // for (i = 0; i < 3; i ++); // v += b[i]*a[i];; // If we completely unroll the loop, we would get:; // v = b[0]*a[0] + b[1]*a[1] + b[2]*a[2]; // Which then will be simplified to:; // v = b[0]* 0 + b[1]* 1 + b[2]* 0; // And finally:; // v = b[1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:262,Usability,simpl,simplifications,262,"// This class is used to get an estimate of the optimization effects that we; // could get from complete loop unrolling. It comes from the fact that some; // loads might be replaced with concrete constant values and that could trigger; // a chain of instruction simplifications.; //; // E.g. we might have:; // int a[] = {0, 1, 0};; // v = 0;; // for (i = 0; i < 3; i ++); // v += b[i]*a[i];; // If we completely unroll the loop, we would get:; // v = b[0]*a[0] + b[1]*a[1] + b[2]*a[2]; // Which then will be simplified to:; // v = b[0]* 0 + b[1]* 1 + b[2]* 0; // And finally:; // v = b[1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:509,Usability,simpl,simplified,509,"// This class is used to get an estimate of the optimization effects that we; // could get from complete loop unrolling. It comes from the fact that some; // loads might be replaced with concrete constant values and that could trigger; // a chain of instruction simplifications.; //; // E.g. we might have:; // int a[] = {0, 1, 0};; // v = 0;; // for (i = 0; i < 3; i ++); // v += b[i]*a[i];; // If we completely unroll the loop, we would get:; // v = b[0]*a[0] + b[1]*a[1] + b[2]*a[2]; // Which then will be simplified to:; // v = b[0]* 0 + b[1]* 1 + b[2]* 0; // And finally:; // v = b[1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:9,Security,access,access,9,// Allow access to the initial visit method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:6,Performance,cache,cache,6,"/// A cache of pointer bases and constant-folded offsets corresponding; /// to GEP (or derived from GEP) instructions.; ///; /// In order to find the base pointer one needs to perform non-trivial; /// traversal of the corresponding SCEV expression, so it's good to have the; /// results saved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:176,Performance,perform,perform,176,"/// A cache of pointer bases and constant-folded offsets corresponding; /// to GEP (or derived from GEP) instructions.; ///; /// In order to find the base pointer one needs to perform non-trivial; /// traversal of the corresponding SCEV expression, so it's good to have the; /// results saved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:198,Performance,load,loads,198,"/// While we walk the loop instructions, we build up and maintain a mapping; /// of simplified values specific to this iteration. The idea is to propagate; /// any special information we have about loads that can be replaced with; /// constants after complete unrolling, and account for likely simplifications; /// post-unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:84,Usability,simpl,simplified,84,"/// While we walk the loop instructions, we build up and maintain a mapping; /// of simplified values specific to this iteration. The idea is to propagate; /// any special information we have about loads that can be replaced with; /// constants after complete unrolling, and account for likely simplifications; /// post-unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:294,Usability,simpl,simplifications,294,"/// While we walk the loop instructions, we build up and maintain a mapping; /// of simplified values specific to this iteration. The idea is to propagate; /// any special information we have about loads that can be replaced with; /// constants after complete unrolling, and account for likely simplifications; /// post-unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:451,Energy Efficiency,allocate,allocate,451,"//==- llvm/Analysis/MemoryBuiltins.h - Calls to memory builtins --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions identifies calls to builtin functions that allocate; // or free memory.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:73,Energy Efficiency,allocate,allocates,73,"/// Tests if a value is a call or invoke to a library function that; /// allocates or reallocates memory (either malloc, calloc, realloc, or strdup; /// like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:4,Testability,Test,Tests,4,"/// Tests if a value is a call or invoke to a library function that; /// allocates or reallocates memory (either malloc, calloc, realloc, or strdup; /// like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:73,Energy Efficiency,allocate,allocates,73,/// Tests if a value is a call or invoke to a library function that; /// allocates memory via new.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:4,Testability,Test,Tests,4,/// Tests if a value is a call or invoke to a library function that; /// allocates memory via new.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:73,Energy Efficiency,allocate,allocates,73,/// Tests if a value is a call or invoke to a library function that; /// allocates memory similar to malloc or calloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:4,Testability,Test,Tests,4,/// Tests if a value is a call or invoke to a library function that; /// allocates memory similar to malloc or calloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:73,Energy Efficiency,allocate,allocates,73,"/// Tests if a value is a call or invoke to a library function that; /// allocates memory (either malloc, calloc, or strdup like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:4,Testability,Test,Tests,4,"/// Tests if a value is a call or invoke to a library function that; /// allocates memory (either malloc, calloc, or strdup like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:4,Testability,Test,Tests,4,"/// Tests if a function is a call or invoke to a library function that; /// reallocates memory (e.g., realloc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:386,Energy Efficiency,allocate,allocated,386,"//===----------------------------------------------------------------------===//; // Properties of allocation functions; //; /// Return true if this is a call to an allocation function that does not have; /// side effects that we are required to preserve beyond the effect of; /// allocating a new object.; /// Ex: If our allocation routine has a counter for the number of objects; /// allocated, and the program prints it on exit, can the value change due; /// to optimization? Answer is highly language dependent.; /// Note: *Removable* really does mean removable; it does not mean observable.; /// A language (e.g. C++) can allow removing allocations without allowing; /// insertion or speculative execution of allocation routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:333,Integrability,rout,routine,333,"//===----------------------------------------------------------------------===//; // Properties of allocation functions; //; /// Return true if this is a call to an allocation function that does not have; /// side effects that we are required to preserve beyond the effect of; /// allocating a new object.; /// Ex: If our allocation routine has a counter for the number of objects; /// allocated, and the program prints it on exit, can the value change due; /// to optimization? Answer is highly language dependent.; /// Note: *Removable* really does mean removable; it does not mean observable.; /// A language (e.g. C++) can allow removing allocations without allowing; /// insertion or speculative execution of allocation routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:505,Integrability,depend,dependent,505,"//===----------------------------------------------------------------------===//; // Properties of allocation functions; //; /// Return true if this is a call to an allocation function that does not have; /// side effects that we are required to preserve beyond the effect of; /// allocating a new object.; /// Ex: If our allocation routine has a counter for the number of objects; /// allocated, and the program prints it on exit, can the value change due; /// to optimization? Answer is highly language dependent.; /// Note: *Removable* really does mean removable; it does not mean observable.; /// A language (e.g. C++) can allow removing allocations without allowing; /// insertion or speculative execution of allocation routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:725,Integrability,rout,routines,725,"//===----------------------------------------------------------------------===//; // Properties of allocation functions; //; /// Return true if this is a call to an allocation function that does not have; /// side effects that we are required to preserve beyond the effect of; /// allocating a new object.; /// Ex: If our allocation routine has a counter for the number of objects; /// allocated, and the program prints it on exit, can the value change due; /// to optimization? Answer is highly language dependent.; /// Note: *Removable* really does mean removable; it does not mean observable.; /// A language (e.g. C++) can allow removing allocations without allowing; /// insertion or speculative execution of allocation routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:465,Performance,optimiz,optimization,465,"//===----------------------------------------------------------------------===//; // Properties of allocation functions; //; /// Return true if this is a call to an allocation function that does not have; /// side effects that we are required to preserve beyond the effect of; /// allocating a new object.; /// Ex: If our allocation routine has a counter for the number of objects; /// allocated, and the program prints it on exit, can the value change due; /// to optimization? Answer is highly language dependent.; /// Note: *Removable* really does mean removable; it does not mean observable.; /// A language (e.g. C++) can allow removing allocations without allowing; /// insertion or speculative execution of allocation routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:97,Modifiability,variab,variables,97,"/// Whether to round the result up to the alignment of allocas, byval; /// arguments, and global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:106,Availability,failure,failure,106,"/// Try to turn a call to \@llvm.objectsize into an integer value of the given; /// Type. Returns null on failure. If MustSucceed is true, this function will; /// not return null, and may return conservative values governed by the second; /// argument of the call to objectsize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:13,Integrability,depend,dependence,13,/// A memory dependence query can return one of three different answers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:14,Integrability,depend,dependence,14,"/// This is a dependence on the specified instruction which clobbers the; /// desired value. The pointer member of the MemDepResult pair holds the; /// instruction that clobbers the memory. For example, this occurs when we; /// see a may-aliased store to the memory location we care about.; ///; /// There are several cases that may be interesting here:; /// 1. Loads are clobbered by may-alias stores.; /// 2. Loads are considered clobbered by partially-aliased loads. The; /// client may choose to analyze deeper into these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:362,Performance,Load,Loads,362,"/// This is a dependence on the specified instruction which clobbers the; /// desired value. The pointer member of the MemDepResult pair holds the; /// instruction that clobbers the memory. For example, this occurs when we; /// see a may-aliased store to the memory location we care about.; ///; /// There are several cases that may be interesting here:; /// 1. Loads are clobbered by may-alias stores.; /// 2. Loads are considered clobbered by partially-aliased loads. The; /// client may choose to analyze deeper into these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:411,Performance,Load,Loads,411,"/// This is a dependence on the specified instruction which clobbers the; /// desired value. The pointer member of the MemDepResult pair holds the; /// instruction that clobbers the memory. For example, this occurs when we; /// see a may-aliased store to the memory location we care about.; ///; /// There are several cases that may be interesting here:; /// 1. Loads are clobbered by may-alias stores.; /// 2. Loads are considered clobbered by partially-aliased loads. The; /// client may choose to analyze deeper into these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:463,Performance,load,loads,463,"/// This is a dependence on the specified instruction which clobbers the; /// desired value. The pointer member of the MemDepResult pair holds the; /// instruction that clobbers the memory. For example, this occurs when we; /// see a may-aliased store to the memory location we care about.; ///; /// There are several cases that may be interesting here:; /// 1. Loads are clobbered by may-alias stores.; /// 2. Loads are considered clobbered by partially-aliased loads. The; /// client may choose to analyze deeper into these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:14,Integrability,depend,dependence,14,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:281,Integrability,depend,dependence,281,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:809,Integrability,Depend,Dependence,809,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:263,Performance,load,load,263,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:308,Performance,load,load,308,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:330,Performance,load,loaded,330,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:619,Performance,load,loads,619,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:701,Performance,load,load,701,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:709,Performance,load,loading,709,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:1053,Performance,load,loads,1053,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:972,Security,validat,validation,972,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:54,Integrability,depend,dependency,54,/// This marker indicates that the query has no known dependency in the; /// specified block.; ///; /// More detailed state info is encoded in the upper part of the pair (i.e.; /// the Instruction*),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:48,Integrability,depend,dependency,48,"/// This marker indicates that the query has no dependency in the specified; /// block.; ///; /// To find out more, the client should query other predecessor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:48,Integrability,depend,dependency,48,/// This marker indicates that the query has no dependency in the specified; /// function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:41,Integrability,depend,dependency,41,/// This marker indicates that the query dependency is unknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:86,Integrability,depend,dependency,86,/// Tests if this MemDepResult represents a query that is an instruction; /// clobber dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,/// Tests if this MemDepResult represents a query that is an instruction; /// clobber dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:89,Integrability,depend,dependency,89,/// Tests if this MemDepResult represents a query that is an instruction; /// definition dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,/// Tests if this MemDepResult represents a query that is an instruction; /// definition dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,/// Tests if this MemDepResult represents a valid local query (Clobber/Def).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,"/// Tests if this MemDepResult represents a query that is transparent to the; /// start of the block, but where a non-local hasn't been done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,/// Tests if this MemDepResult represents a query that is transparent to the; /// start of the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,/// Tests if this MemDepResult represents a query which cannot and/or will; /// not be computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:24,Integrability,depend,dependency,24,"/// If this is a normal dependency, returns the instruction that is depended; /// on. Otherwise, returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:68,Integrability,depend,depended,68,"/// If this is a normal dependency, returns the instruction that is depended; /// on. Otherwise, returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,/// Tests if this is a MemDepResult in its dirty/invalid. state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:44,Performance,cache,cache,44,/// This is an entry in the NonLocalDepInfo cache.; ///; /// For each BasicBlock (the BB entry) it keeps a MemDepResult.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:37,Integrability,depend,dependence,37,/// This is a result from a NonLocal dependence query.; ///; /// For each BasicBlock (the BB entry) it keeps a MemDepResult and the; /// (potentially phi translated) address that was live in the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:216,Availability,avail,available,216,/// Returns the address of this pointer in this block.; ///; /// This can be different than the address queried for the non-local result; /// because of phi translation. This returns null if the address was not; /// available in a block (i.e. because phi translation failed) or if this is; /// a cached result and that address was deleted.; ///; /// The address is always null for a non-local 'call' dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:400,Integrability,depend,dependence,400,/// Returns the address of this pointer in this block.; ///; /// This can be different than the address queried for the non-local result; /// because of phi translation. This returns null if the address was not; /// available in a block (i.e. because phi translation failed) or if this is; /// a cached result and that address was deleted.; ///; /// The address is always null for a non-local 'call' dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:296,Performance,cache,cached,296,/// Returns the address of this pointer in this block.; ///; /// This can be different than the address queried for the non-local result; /// because of phi translation. This returns null if the address was not; /// available in a block (i.e. because phi translation failed) or if this is; /// a cached result and that address was deleted.; ///; /// The address is always null for a non-local 'call' dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:29,Integrability,interface,interface,29,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:153,Integrability,depend,dependency,153,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:668,Integrability,depend,dependence,668,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:353,Performance,load,load,353,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:414,Performance,load,load,414,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:570,Performance,load,loads,570,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:621,Performance,load,load,621,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:36,Integrability,depend,dependency,36,// A map from instructions to their dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:55,Integrability,depend,dependence,55,"/// A pair<Value*, bool> where the bool is true if the dependence is a read; /// only dependence, false if read/write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:86,Integrability,depend,dependence,86,"/// A pair<Value*, bool> where the bool is true if the dependence is a read; /// only dependence, false if read/write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:98,Performance,cache,cache,98,"/// This pair is used when caching information for a block.; ///; /// If the pointer is null, the cache value is not a full query that starts; /// at the specified block. If non-null, the bool indicates whether or not; /// the contents of the block was skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:60,Performance,load,load,60,"/// This record is the information kept for each (value, is load) pair.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:145,Integrability,depend,dependencies,145,/// Cache storing single nonlocal def for the instruction.; /// It is set when nonlocal def would be found in function returning only; /// local dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Performance,Cache,Cache,4,/// Cache storing single nonlocal def for the instruction.; /// It is set when nonlocal def would be found in function returning only; /// local dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:24,Performance,cache,cached,24,"/// This map stores the cached results of doing a pointer lookup at the; /// bottom of a block.; ///; /// The key of this map is the pointer+isload bit, the value is a list of; /// <bb->result> mappings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:54,Integrability,depend,dependencies,54,// A map from instructions to their non-local pointer dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:45,Performance,cache,cached,45,/// This is the instruction we keep for each cached access that we have for; /// an instruction.; ///; /// The pointer is an owning pointer and the bool indicates whether we have; /// any dirty bits in the set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:52,Security,access,access,52,/// This is the instruction we keep for each cached access that we have for; /// an instruction.; ///; /// The pointer is an owning pointer and the bool indicates whether we have; /// any dirty bits in the set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:46,Integrability,depend,dependencies,46,// A map from instructions to their non-local dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:26,Integrability,depend,dependencies,26,// A reverse mapping from dependencies to the dependees. This is; // used when removing instructions to keep the cache coherent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:46,Integrability,depend,dependees,46,// A reverse mapping from dependencies to the dependees. This is; // used when removing instructions to keep the cache coherent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:113,Performance,cache,cache,113,// A reverse mapping from dependencies to the dependees. This is; // used when removing instructions to keep the cache coherent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:26,Integrability,depend,dependencies,26,// A reverse mapping from dependencies to the non-local dependees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:56,Integrability,depend,dependees,56,// A reverse mapping from dependencies to the non-local dependees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:38,Performance,cache,cache,38,"/// Current AA implementation, just a cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:15,Integrability,depend,dependant,15,/// Offsets to dependant clobber loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:33,Performance,load,loads,33,/// Offsets to dependant clobber loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:56,Integrability,depend,depends,56,/// Returns the instruction on which a memory operation depends.; ///; /// See the class comment for more details. It is illegal to call this on; /// non-memory instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:19,Integrability,depend,dependency,19,"/// Perform a full dependency query for the specified call, returning the set; /// of blocks that the value is potentially live across.; ///; /// The returned set of results will include a ""NonLocal"" result for all; /// blocks where the value is live across.; ///; /// This method assumes the instruction returns a ""NonLocal"" dependency; /// within its own block.; ///; /// This returns a reference to an internal data structure that may be; /// invalidated on the next non-local query or when an instruction is; /// removed. Clients must copy this data if they want it around longer than; /// that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:326,Integrability,depend,dependency,326,"/// Perform a full dependency query for the specified call, returning the set; /// of blocks that the value is potentially live across.; ///; /// The returned set of results will include a ""NonLocal"" result for all; /// blocks where the value is live across.; ///; /// This method assumes the instruction returns a ""NonLocal"" dependency; /// within its own block.; ///; /// This returns a reference to an internal data structure that may be; /// invalidated on the next non-local query or when an instruction is; /// removed. Clients must copy this data if they want it around longer than; /// that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Performance,Perform,Perform,4,"/// Perform a full dependency query for the specified call, returning the set; /// of blocks that the value is potentially live across.; ///; /// The returned set of results will include a ""NonLocal"" result for all; /// blocks where the value is live across.; ///; /// This method assumes the instruction returns a ""NonLocal"" dependency; /// within its own block.; ///; /// This returns a reference to an internal data structure that may be; /// invalidated on the next non-local query or when an instruction is; /// removed. Clients must copy this data if they want it around longer than; /// that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:19,Integrability,depend,dependency,19,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:238,Integrability,depend,dependencies,238,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:425,Integrability,depend,dependency,425,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Performance,Perform,Perform,4,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:43,Security,access,access,43,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:283,Usability,usab,usable,283,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:36,Integrability,depend,dependence,36,"/// Removes an instruction from the dependence analysis, updating the; /// dependence of instructions that previously depended on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:75,Integrability,depend,dependence,75,"/// Removes an instruction from the dependence analysis, updating the; /// dependence of instructions that previously depended on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:118,Integrability,depend,depended,118,"/// Removes an instruction from the dependence analysis, updating the; /// dependence of instructions that previously depended on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:314,Availability,avail,available,314,"/// Invalidates cached information about the specified pointer, because it; /// may be too conservative in memdep.; ///; /// This is an optional call that can be used when the client detects an; /// equivalence between the pointer and some other value and replaces the; /// other value with ptr. This can make Ptr available in more places that; /// cached info does not necessarily keep.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:16,Performance,cache,cached,16,"/// Invalidates cached information about the specified pointer, because it; /// may be too conservative in memdep.; ///; /// This is an optional call that can be used when the client detects an; /// equivalence between the pointer and some other value and replaces the; /// other value with ptr. This can make Ptr available in more places that; /// cached info does not necessarily keep.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:349,Performance,cache,cached,349,"/// Invalidates cached information about the specified pointer, because it; /// may be too conservative in memdep.; ///; /// This is an optional call that can be used when the client detects an; /// equivalence between the pointer and some other value and replaces the; /// other value with ptr. This can make Ptr available in more places that; /// cached info does not necessarily keep.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:183,Safety,detect,detects,183,"/// Invalidates cached information about the specified pointer, because it; /// may be too conservative in memdep.; ///; /// This is an optional call that can be used when the client detects an; /// equivalence between the pointer and some other value and replaces the; /// other value with ptr. This can make Ptr available in more places that; /// cached info does not necessarily keep.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Usability,Clear,Clears,4,"/// Clears the PredIteratorCache info.; ///; /// This needs to be done when the CFG changes, e.g., due to splitting; /// critical edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:55,Integrability,depend,depends,55,"/// Returns the instruction on which a memory location depends.; ///; /// If isLoad is true, this routine ignores may-aliases with read-only; /// operations. If isLoad is false, this routine ignores may-aliases; /// with reads from read-only locations. If possible, pass the query; /// instruction as well; this function may take advantage of the metadata; /// annotated to the query instruction to refine the result. \p Limit; /// can be used to set the maximum number of instructions that will be; /// examined to find the pointer dependency. On return, it will be set to; /// the number of instructions left to examine. If a null pointer is passed; /// in, the limit will default to the value of -memdep-block-scan-limit.; ///; /// Note that this is an uncached query, and thus may be inefficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:98,Integrability,rout,routine,98,"/// Returns the instruction on which a memory location depends.; ///; /// If isLoad is true, this routine ignores may-aliases with read-only; /// operations. If isLoad is false, this routine ignores may-aliases; /// with reads from read-only locations. If possible, pass the query; /// instruction as well; this function may take advantage of the metadata; /// annotated to the query instruction to refine the result. \p Limit; /// can be used to set the maximum number of instructions that will be; /// examined to find the pointer dependency. On return, it will be set to; /// the number of instructions left to examine. If a null pointer is passed; /// in, the limit will default to the value of -memdep-block-scan-limit.; ///; /// Note that this is an uncached query, and thus may be inefficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:183,Integrability,rout,routine,183,"/// Returns the instruction on which a memory location depends.; ///; /// If isLoad is true, this routine ignores may-aliases with read-only; /// operations. If isLoad is false, this routine ignores may-aliases; /// with reads from read-only locations. If possible, pass the query; /// instruction as well; this function may take advantage of the metadata; /// annotated to the query instruction to refine the result. \p Limit; /// can be used to set the maximum number of instructions that will be; /// examined to find the pointer dependency. On return, it will be set to; /// the number of instructions left to examine. If a null pointer is passed; /// in, the limit will default to the value of -memdep-block-scan-limit.; ///; /// Note that this is an uncached query, and thus may be inefficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:533,Integrability,depend,dependency,533,"/// Returns the instruction on which a memory location depends.; ///; /// If isLoad is true, this routine ignores may-aliases with read-only; /// operations. If isLoad is false, this routine ignores may-aliases; /// with reads from read-only locations. If possible, pass the query; /// instruction as well; this function may take advantage of the metadata; /// annotated to the query instruction to refine the result. \p Limit; /// can be used to set the maximum number of instructions that will be; /// examined to find the pointer dependency. On return, it will be set to; /// the number of instructions left to examine. If a null pointer is passed; /// in, the limit will default to the value of -memdep-block-scan-limit.; ///; /// Note that this is an uncached query, and thus may be inefficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:34,Performance,load,loads,34,"/// This analysis looks for other loads and stores with invariant.group; /// metadata and the same pointer operand. Returns Unknown if it does not; /// find anything, and Def if it can be assumed that 2 instructions load or; /// store the same value and NonLocal which indicate that non-local Def was; /// found, which can be retrieved by calling getNonLocalPointerDependency; /// with the same queried instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:216,Performance,load,load,216,"/// This analysis looks for other loads and stores with invariant.group; /// metadata and the same pointer operand. Returns Unknown if it does not; /// find anything, and Def if it can be assumed that 2 instructions load or; /// store the same value and NonLocal which indicate that non-local Def was; /// found, which can be retrieved by calling getNonLocalPointerDependency; /// with the same queried instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Deployability,Release,Release,4,/// Release memory in caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:22,Performance,cache,caches,22,/// Release memory in caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:33,Integrability,depend,dependent,33,/// Return the clobber offset to dependent instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:6,Integrability,wrap,wrapper,6,/// A wrapper analysis pass for the legacy pass manager that exposes a \c; /// MemoryDepnedenceResults instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:61,Security,expose,exposes,61,/// A wrapper analysis pass for the legacy pass manager that exposes a \c; /// MemoryDepnedenceResults instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:568,Modifiability,layers,layers,568,"//===- MemoryLocation.h - Memory location descriptions ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides utility analysis objects describing memory locations.; /// These are used both by the Alias Analysis infrastructure and more; /// specialized memory analysis layers.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:1175,Performance,Scalab,Scalable,1175,"// Represents the size of a MemoryLocation. Logically, it's an; // std::optional<uint63_t> that also carries a bit to represent whether the; // integer it contains, N, is 'precise'. Precise, in this context, means that we; // know that the area of storage referenced by the given MemoryLocation must be; // precisely N bytes. An imprecise value is formed as the union of two or more; // precise values, and can conservatively represent all of the values unioned; // into it. Importantly, imprecise values are an *upper-bound* on the size of a; // MemoryLocation.; //; // Concretely, a precise MemoryLocation is (%p, 4) in; // store i32 0, i32* %p; //; // Since we know that %p must be at least 4 bytes large at this point.; // Otherwise, we have UB. An example of an imprecise MemoryLocation is (%p, 4); // at the memcpy in; //; // %n = select i1 %foo, i64 1, i64 4; // call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %baz, i64 %n, i32 1,; // i1 false); //; // ...Since we'll copy *up to* 4 bytes into %p, but we can't guarantee that; // we'll ever actually do so.; //; // If asked to represent a pathologically large value, this will degrade to; // std::nullopt.; // Store Scalable information in bit 62 of Value. Scalable information is; // required to do Alias Analysis on Scalable quantities",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:1216,Performance,Scalab,Scalable,1216,"// Represents the size of a MemoryLocation. Logically, it's an; // std::optional<uint63_t> that also carries a bit to represent whether the; // integer it contains, N, is 'precise'. Precise, in this context, means that we; // know that the area of storage referenced by the given MemoryLocation must be; // precisely N bytes. An imprecise value is formed as the union of two or more; // precise values, and can conservatively represent all of the values unioned; // into it. Importantly, imprecise values are an *upper-bound* on the size of a; // MemoryLocation.; //; // Concretely, a precise MemoryLocation is (%p, 4) in; // store i32 0, i32* %p; //; // Since we know that %p must be at least 4 bytes large at this point.; // Otherwise, we have UB. An example of an imprecise MemoryLocation is (%p, 4); // at the memcpy in; //; // %n = select i1 %foo, i64 1, i64 4; // call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %baz, i64 %n, i32 1,; // i1 false); //; // ...Since we'll copy *up to* 4 bytes into %p, but we can't guarantee that; // we'll ever actually do so.; //; // If asked to represent a pathologically large value, this will degrade to; // std::nullopt.; // Store Scalable information in bit 62 of Value. Scalable information is; // required to do Alias Analysis on Scalable quantities",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:1277,Performance,Scalab,Scalable,1277,"// Represents the size of a MemoryLocation. Logically, it's an; // std::optional<uint63_t> that also carries a bit to represent whether the; // integer it contains, N, is 'precise'. Precise, in this context, means that we; // know that the area of storage referenced by the given MemoryLocation must be; // precisely N bytes. An imprecise value is formed as the union of two or more; // precise values, and can conservatively represent all of the values unioned; // into it. Importantly, imprecise values are an *upper-bound* on the size of a; // MemoryLocation.; //; // Concretely, a precise MemoryLocation is (%p, 4) in; // store i32 0, i32* %p; //; // Since we know that %p must be at least 4 bytes large at this point.; // Otherwise, we have UB. An example of an imprecise MemoryLocation is (%p, 4); // at the memcpy in; //; // %n = select i1 %foo, i64 1, i64 4; // call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %baz, i64 %n, i32 1,; // i1 false); //; // ...Since we'll copy *up to* 4 bytes into %p, but we can't guarantee that; // we'll ever actually do so.; //; // If asked to represent a pathologically large value, this will degrade to; // std::nullopt.; // Store Scalable information in bit 62 of Value. Scalable information is; // required to do Alias Analysis on Scalable quantities",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:44,Testability,Log,Logically,44,"// Represents the size of a MemoryLocation. Logically, it's an; // std::optional<uint63_t> that also carries a bit to represent whether the; // integer it contains, N, is 'precise'. Precise, in this context, means that we; // know that the area of storage referenced by the given MemoryLocation must be; // precisely N bytes. An imprecise value is formed as the union of two or more; // precise values, and can conservatively represent all of the values unioned; // into it. Importantly, imprecise values are an *upper-bound* on the size of a; // MemoryLocation.; //; // Concretely, a precise MemoryLocation is (%p, 4) in; // store i32 0, i32* %p; //; // Since we know that %p must be at least 4 bytes large at this point.; // Otherwise, we have UB. An example of an imprecise MemoryLocation is (%p, 4); // at the memcpy in; //; // %n = select i1 %foo, i64 1, i64 4; // call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %baz, i64 %n, i32 1,; // i1 false); //; // ...Since we'll copy *up to* 4 bytes into %p, but we can't guarantee that; // we'll ever actually do so.; //; // If asked to represent a pathologically large value, this will degrade to; // std::nullopt.; // Store Scalable information in bit 62 of Value. Scalable information is; // required to do Alias Analysis on Scalable quantities",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:14,Performance,scalab,scalable,14,// Create non-scalable LocationSize,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:2,Performance,Scalab,Scalable,2,/*Scalable*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:12,Security,access,accesses,12,/// Whether accesses before the base pointer are possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:76,Availability,reliab,reliably,76,// Returns an opaque value that represents this LocationSize. Cannot be; // reliably converted back into a LocationSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:383,Integrability,interface,interface,383,"/// Representation for a specific memory location.; ///; /// This abstraction can be used to represent a specific location in memory.; /// The goal of the location is to represent enough information to describe; /// abstract aliasing, modification, and reference behaviors of whatever; /// value(s) are stored in memory at the particular location.; ///; /// The primary user of this interface is LLVM's Alias Analysis, but other; /// memory analyses such as MemoryDependence can use it as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:31,Security,access,access,31,"/// Return a location that may access any location after Ptr, while remaining; /// within the underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:31,Security,access,access,31,"/// Return a location that may access any location before or after Ptr, while; /// remaining within the underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h:243,Availability,down,down,243,"/// Add a call stack context with the given allocation type to the Trie.; /// The context is represented by the list of stack ids (computed during; /// matching via a debug location hash), expected to be in order from the; /// allocation call down to the bottom of the call stack (i.e. callee to; /// caller order).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h:182,Security,hash,hash,182,"/// Add a call stack context with the given allocation type to the Trie.; /// The context is represented by the list of stack ids (computed during; /// matching via a debug location hash), expected to be in order from the; /// allocation call down to the bottom of the call stack (i.e. callee to; /// caller order).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h:332,Performance,optimiz,optimization,332,"/// Build and attach the minimal necessary MIB metadata. If the alloc has a; /// single allocation type, add a function attribute instead. The reason for; /// adding an attribute in this case is that it matches how the behavior for; /// allocation calls will be communicated to lib call simplification after; /// cloning or another optimization to distinguish the allocation types,; /// which is lower overhead and more direct than maintaining this metadata.; /// Returns true if memprof metadata attached, false if not (attribute added).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h:287,Usability,simpl,simplification,287,"/// Build and attach the minimal necessary MIB metadata. If the alloc has a; /// single allocation type, add a function attribute instead. The reason for; /// adding an attribute in this case is that it matches how the behavior for; /// allocation calls will be communicated to lib call simplification after; /// cloning or another optimization to distinguish the allocation types,; /// which is lower overhead and more direct than maintaining this metadata.; /// Returns true if memprof metadata attached, false if not (attribute added).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h:187,Usability,simpl,simplifies,187,"/// Helper class to iterate through stack ids in both metadata (memprof MIB and; /// callsite) and the corresponding ThinLTO summary data structures; /// (CallsiteInfo and MIBInfo). This simplifies implementation of client code; /// which doesn't need to worry about whether we are operating with IR (Regular; /// LTO), or summary (ThinLTO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:416,Integrability,interface,interface,416,"//===- MemorySSA.h - Build Memory SSA ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file exposes an interface to building/using memory SSA to; /// walk memory instructions using a use/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the Mem",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:617,Performance,load,loads,617,"//===- MemorySSA.h - Build Memory SSA ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file exposes an interface to building/using memory SSA to; /// walk memory instructions using a use/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the Mem",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:1219,Performance,load,load,1219,"e/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:1251,Performance,load,load,1251,"e/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:1756,Performance,load,load,1756,"e/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:1808,Performance,load,load,1808,"e/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:1955,Performance,load,load,1955,"e/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:2835,Performance,optimiz,optimized,2835," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:2867,Performance,optimiz,optimized,2867," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:2950,Performance,optimiz,optimized,2950," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3127,Performance,optimiz,optimized,3127," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3207,Performance,optimiz,optimized,3207," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3379,Performance,optimiz,optimized,3379," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:405,Security,expose,exposes,405,"//===- MemorySSA.h - Build Memory SSA ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file exposes an interface to building/using memory SSA to; /// walk memory instructions using a use/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the Mem",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:584,Security,access,access,584,"//===- MemorySSA.h - Build Memory SSA ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file exposes an interface to building/using memory SSA to; /// walk memory instructions using a use/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the Mem",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3287,Security,access,access,3287," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:27,Security,access,accesses,27,// The base for all memory accesses. All memory accesses in a block are; // linked together using an intrusive list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:48,Security,access,accesses,48,// The base for all memory accesses. All memory accesses in a block are; // linked together using an intrusive list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:36,Security,access,access,36,/// The user iterators for a memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:172,Security,access,access,172,"/// This iterator walks over all of the defs in a given; /// MemoryAccess. For MemoryPhi nodes, this walks arguments. For; /// MemoryUse/MemoryDef, this walks the defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:34,Security,access,access,34,/// Get the iterators for the all access list and the defs only list; /// We default to the all access list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:96,Security,access,access,96,/// Get the iterators for the all access list and the defs only list; /// We default to the all access list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:12,Security,access,access,12,/// Get the access that produces the memory state used by this Use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:18,Performance,optimiz,optimized,18,/// Do we have an optimized use?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:48,Performance,optimiz,optimized,48,"/// Return the MemoryAccess associated with the optimized use, or nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:13,Performance,optimiz,optimized,13,/// Sets the optimized use for a MemoryDef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:44,Performance,optimiz,optimized,44,"/// Reset the ID of what this MemoryUse was optimized to, causing it to; /// be rewalked by the walker if necessary.; /// This really should only be called by tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:159,Testability,test,tests,159,"/// Reset the ID of what this MemoryUse was optimized to, causing it to; /// be rewalked by the walker if necessary.; /// This really should only be called by tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:25,Security,access,accesses,25,"/// Represents read-only accesses to memory; ///; /// In particular, the set of Instructions that will be represented by; /// MemoryUse's is exactly the set of Instructions for which; /// AliasAnalysis::getModRefInfo returns ""Ref"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3,Energy Efficiency,allocate,allocate,3,// allocate space for exactly one operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:29,Performance,optimiz,optimized,29,"/// Whether the MemoryUse is optimized. If ensureOptimizedUses() was called,; /// uses will usually be optimized, but this is not guaranteed (e.g. due to; /// invalidation and optimization limits.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:103,Performance,optimiz,optimized,103,"/// Whether the MemoryUse is optimized. If ensureOptimizedUses() was called,; /// uses will usually be optimized, but this is not guaranteed (e.g. due to; /// invalidation and optimization limits.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:176,Performance,optimiz,optimization,176,"/// Whether the MemoryUse is optimized. If ensureOptimizedUses() was called,; /// uses will usually be optimized, but this is not guaranteed (e.g. due to; /// invalidation and optimization limits.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:28,Security,access,access,28,"/// Represents a read-write access to memory, whether it is a must-alias,; /// or a may-alias.; ///; /// In particular, the set of Instructions that will be represented by; /// MemoryDef's is exactly the set of Instructions for which; /// AliasAnalysis::getModRefInfo returns ""Mod"" or ""ModRef"".; /// Note that, in order to provide def-def chains, all defs also have a use; /// associated with them. This use points to the nearest reaching; /// MemoryDef/MemoryPhi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3,Energy Efficiency,allocate,allocate,3,// allocate space for exactly two operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:36,Security,access,accesses,36,"/// Represents phi nodes for memory accesses.; ///; /// These have the same semantic as regular phi nodes, with the exception that; /// only one phi will ever exist in a given basic block.; /// Guaranteeing one phi per block means guaranteeing there is only ever one; /// valid reaching MemoryDef/MemoryPHI along each path to the phi node.; /// This is ensured by not allowing disambiguation of the RHS of a MemoryDef or; /// a MemoryPhi's operands.; /// That is, given; /// if (a) {; /// store %a; /// store %b; /// }; /// it *must* be transformed into; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// 2 = MemoryDef(1); /// store %b; /// }; /// and *not*; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// even if the two stores do not conflict. Otherwise, both 1 and 2 reach the; /// end of the branch, and if there are not two phi nodes, one will be; /// disconnected completely from the SSA graph below that point.; /// Because MemoryUse's do not generate new definitions, they do not have this; /// issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3,Energy Efficiency,allocate,allocate,3,// allocate space for exactly zero operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:25,Security,access,accessors,25,/// Provide fast operand accessors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:18,Integrability,interface,interface,18,"// Block iterator interface. This provides access to the list of incoming; // basic blocks, which parallels the list of incoming values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:43,Security,access,access,43,"// Block iterator interface. This provides access to the list of incoming; // basic blocks, which parallels the list of incoming values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:34,Security,access,access,34,"// After deleting incoming memory access MA, the incoming accesses order may; // be changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:58,Security,access,accesses,58,"// After deleting incoming memory access MA, the incoming accesses order may; // be changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:94,Energy Efficiency,allocate,allocate,94,"/// this is more complicated than the generic; /// User::allocHungoffUses, because we have to allocate Uses for the incoming; /// values and pointers to the incoming blocks, all in one allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:75,Security,access,accesses,75,"/// Encapsulates MemorySSA, including all data associated with memory; /// accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:67,Security,access,access,67,"/// Given a memory Mod/Ref'ing instruction, get the MemorySSA; /// access associated with it. If passed a basic block gets the memory phi; /// node that exists for that block, if there is one. Otherwise, this will get; /// a MemoryUseOrDef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:70,Performance,Load,Loads,70,"/// Return true if \p MA represents the live on entry value; ///; /// Loads and stores from pointer arguments and other global values may be; /// defined by memory operations that do not occur in the current function, so; /// they may be live on entry to the function. MemorySSA represents such; /// memory state by the live on entry definition, which is guaranteed to occur; /// before any other memory access in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:404,Security,access,access,404,"/// Return true if \p MA represents the live on entry value; ///; /// Loads and stores from pointer arguments and other global values may be; /// defined by memory operations that do not occur in the current function, so; /// they may be live on entry to the function. MemorySSA represents such; /// memory state by the live on entry definition, which is guaranteed to occur; /// before any other memory access in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:21,Security,access,accesses,21,"/// Given two memory accesses in the same basic block, determine; /// whether MemoryAccess \p A dominates MemoryAccess \p B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:21,Security,access,accesses,21,"/// Given two memory accesses in potentially different blocks,; /// determine whether MemoryAccess \p A dominates MemoryAccess \p B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:140,Testability,test,tests,140,"/// Verify that MemorySSA is self consistent (IE definitions dominate; /// all uses, uses appear in the right places). This is used by unit tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:31,Performance,optimiz,optimized,31,"/// By default, uses are *not* optimized during MemorySSA construction.; /// Calling this method will attempt to optimize all MemoryUses, if this has; /// not happened yet for this MemorySSA instance. This should be done if you; /// plan to query the clobbering access for most uses, or if you walk the; /// def-use chain of uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:113,Performance,optimiz,optimize,113,"/// By default, uses are *not* optimized during MemorySSA construction.; /// Calling this method will attempt to optimize all MemoryUses, if this has; /// not happened yet for this MemorySSA instance. This should be done if you; /// plan to query the clobbering access for most uses, or if you walk the; /// def-use chain of uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:262,Security,access,access,262,"/// By default, uses are *not* optimized during MemorySSA construction.; /// Calling this method will attempt to optimize all MemoryUses, if this has; /// not happened yet for this MemorySSA instance. This should be done if you; /// plan to query the clobbering access for most uses, or if you walk the; /// def-use chain of uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:34,Integrability,wrap,wrapper,34,// Used by Memory SSA dumpers and wrapper pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:41,Deployability,update,updater,41,// This is used by the use optimizer and updater.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:27,Performance,optimiz,optimizer,27,// This is used by the use optimizer and updater.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:41,Deployability,update,updater,41,// This is used by the use optimizer and updater.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:27,Performance,optimiz,optimizer,27,// This is used by the use optimizer and updater.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:24,Deployability,update,updater,24,"// These is used by the updater to perform various internal MemorySSA; // machinsations. They do not always leave the IR in a correct state, and; // relies on the updater to fixup what it breaks, so it is not public.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:163,Deployability,update,updater,163,"// These is used by the updater to perform various internal MemorySSA; // machinsations. They do not always leave the IR in a correct state, and; // relies on the updater to fixup what it breaks, so it is not public.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:35,Performance,perform,perform,35,"// These is used by the updater to perform various internal MemorySSA; // machinsations. They do not always leave the IR in a correct state, and; // relies on the updater to fixup what it breaks, so it is not public.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:48,Security,access,access,48,"// These two mappings contain the main block to access/def mappings for; // MemorySSA. The list contained in PerBlockAccesses really owns all the; // MemoryAccesses.; // Both maps maintain the invariant that if a block is found in them, the; // corresponding list is not empty, and if a block is not found in them, the; // corresponding list is empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3,Integrability,Wrap,Wrap,3,// Wrap MemorySSA result to ensure address stability of internal MemorySSA; // pointers after construction. Use a wrapper class instead of plain; // unique_ptr<MemorySSA> to avoid build breakage on MSVC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:114,Integrability,wrap,wrapper,114,// Wrap MemorySSA result to ensure address stability of internal MemorySSA; // pointers after construction. Use a wrapper class instead of plain; // unique_ptr<MemorySSA> to avoid build breakage on MSVC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:174,Safety,avoid,avoid,174,// Wrap MemorySSA result to ensure address stability of internal MemorySSA; // pointers after construction. Use a wrapper class instead of plain; // unique_ptr<MemorySSA> to avoid build breakage on MSVC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:31,Integrability,interface,interface,31,"/// This is the generic walker interface for walkers of MemorySSA.; /// Walkers are used to be able to further disambiguate the def-use chains; /// MemorySSA gives you, or otherwise produce better info than MemorySSA gives; /// you.; /// In particular, while the def-use chains provide basic information, and are; /// guaranteed to give, for example, the nearest may-aliasing MemoryDef for a; /// MemoryUse as AliasAnalysis considers it, a user mant want better or other; /// information. In particular, they may want to use SCEV info to further; /// disambiguate memory accesses, or they may want the nearest dominating; /// may-aliasing MemoryDef for a call or a store. This API enables a; /// standardized interface to getting and using that info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:709,Integrability,interface,interface,709,"/// This is the generic walker interface for walkers of MemorySSA.; /// Walkers are used to be able to further disambiguate the def-use chains; /// MemorySSA gives you, or otherwise produce better info than MemorySSA gives; /// you.; /// In particular, while the def-use chains provide basic information, and are; /// guaranteed to give, for example, the nearest may-aliasing MemoryDef for a; /// MemoryUse as AliasAnalysis considers it, a user mant want better or other; /// information. In particular, they may want to use SCEV info to further; /// disambiguate memory accesses, or they may want the nearest dominating; /// may-aliasing MemoryDef for a call or a store. This API enables a; /// standardized interface to getting and using that info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:571,Security,access,accesses,571,"/// This is the generic walker interface for walkers of MemorySSA.; /// Walkers are used to be able to further disambiguate the def-use chains; /// MemorySSA gives you, or otherwise produce better info than MemorySSA gives; /// you.; /// In particular, while the def-use chains provide basic information, and are; /// guaranteed to give, for example, the nearest may-aliasing MemoryDef for a; /// MemoryUse as AliasAnalysis considers it, a user mant want better or other; /// information. In particular, they may want to use SCEV info to further; /// disambiguate memory accesses, or they may want the nearest dominating; /// may-aliasing MemoryDef for a call or a store. This API enables a; /// standardized interface to getting and using that info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:699,Performance,load,load,699,"/// Given a memory Mod/Ref/ModRef'ing instruction, calling this; /// will give you the nearest dominating MemoryAccess that Mod's the location; /// the instruction accesses (by skipping any def which AA can prove does not; /// alias the location(s) accessed by the instruction given).; ///; /// Note that this will return a single access, and it must dominate the; /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,; /// this will return the MemoryPhi, not the operand. This means that; /// given:; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// } else {; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// 3 = MemoryPhi(2, 1); /// MemoryUse(3); /// load %a; ///; /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef; /// in the if (a) branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:737,Performance,load,load,737,"/// Given a memory Mod/Ref/ModRef'ing instruction, calling this; /// will give you the nearest dominating MemoryAccess that Mod's the location; /// the instruction accesses (by skipping any def which AA can prove does not; /// alias the location(s) accessed by the instruction given).; ///; /// Note that this will return a single access, and it must dominate the; /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,; /// this will return the MemoryPhi, not the operand. This means that; /// given:; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// } else {; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// 3 = MemoryPhi(2, 1); /// MemoryUse(3); /// load %a; ///; /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef; /// in the if (a) branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:164,Security,access,accesses,164,"/// Given a memory Mod/Ref/ModRef'ing instruction, calling this; /// will give you the nearest dominating MemoryAccess that Mod's the location; /// the instruction accesses (by skipping any def which AA can prove does not; /// alias the location(s) accessed by the instruction given).; ///; /// Note that this will return a single access, and it must dominate the; /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,; /// this will return the MemoryPhi, not the operand. This means that; /// given:; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// } else {; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// 3 = MemoryPhi(2, 1); /// MemoryUse(3); /// load %a; ///; /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef; /// in the if (a) branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:249,Security,access,accessed,249,"/// Given a memory Mod/Ref/ModRef'ing instruction, calling this; /// will give you the nearest dominating MemoryAccess that Mod's the location; /// the instruction accesses (by skipping any def which AA can prove does not; /// alias the location(s) accessed by the instruction given).; ///; /// Note that this will return a single access, and it must dominate the; /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,; /// this will return the MemoryPhi, not the operand. This means that; /// given:; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// } else {; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// 3 = MemoryPhi(2, 1); /// MemoryUse(3); /// load %a; ///; /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef; /// in the if (a) branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:331,Security,access,access,331,"/// Given a memory Mod/Ref/ModRef'ing instruction, calling this; /// will give you the nearest dominating MemoryAccess that Mod's the location; /// the instruction accesses (by skipping any def which AA can prove does not; /// alias the location(s) accessed by the instruction given).; ///; /// Note that this will return a single access, and it must dominate the; /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,; /// this will return the MemoryPhi, not the operand. This means that; /// given:; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// } else {; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// 3 = MemoryPhi(2, 1); /// MemoryUse(3); /// load %a; ///; /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef; /// in the if (a) branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:42,Security,access,access,42,"/// Given a potentially clobbering memory access and a new location,; /// calling this will give you the nearest dominating clobbering MemoryAccess; /// (by skipping non-aliasing def links).; ///; /// This version of the function is mainly used to disambiguate phi translated; /// pointers, where the value of a pointer may have changed from the initial; /// memory access. Note that this expects to be handed either a MemoryUse,; /// or an already potentially clobbering access. Unlike the above API, if; /// given a MemoryDef that clobbers the pointer as the starting access, it; /// will return that MemoryDef, whereas the above would return the clobber; /// starting from the use side of the memory def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:366,Security,access,access,366,"/// Given a potentially clobbering memory access and a new location,; /// calling this will give you the nearest dominating clobbering MemoryAccess; /// (by skipping non-aliasing def links).; ///; /// This version of the function is mainly used to disambiguate phi translated; /// pointers, where the value of a pointer may have changed from the initial; /// memory access. Note that this expects to be handed either a MemoryUse,; /// or an already potentially clobbering access. Unlike the above API, if; /// given a MemoryDef that clobbers the pointer as the starting access, it; /// will return that MemoryDef, whereas the above would return the clobber; /// starting from the use side of the memory def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:472,Security,access,access,472,"/// Given a potentially clobbering memory access and a new location,; /// calling this will give you the nearest dominating clobbering MemoryAccess; /// (by skipping non-aliasing def links).; ///; /// This version of the function is mainly used to disambiguate phi translated; /// pointers, where the value of a pointer may have changed from the initial; /// memory access. Note that this expects to be handed either a MemoryUse,; /// or an already potentially clobbering access. Unlike the above API, if; /// given a MemoryDef that clobbers the pointer as the starting access, it; /// will return that MemoryDef, whereas the above would return the clobber; /// starting from the use side of the memory def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:570,Security,access,access,570,"/// Given a potentially clobbering memory access and a new location,; /// calling this will give you the nearest dominating clobbering MemoryAccess; /// (by skipping non-aliasing def links).; ///; /// This version of the function is mainly used to disambiguate phi translated; /// pointers, where the value of a pointer may have changed from the initial; /// memory access. Note that this expects to be handed either a MemoryUse,; /// or an already potentially clobbering access. Unlike the above API, if; /// given a MemoryDef that clobbers the pointer as the starting access, it; /// will return that MemoryDef, whereas the above would return the clobber; /// starting from the use side of the memory def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:148,Performance,perform,perform,148,"/// Given a memory access, invalidate anything this walker knows about; /// that access.; /// This API is used by walkers that store information to perform basic cache; /// invalidation. This will be called by MemorySSA at appropriate times for; /// the walker it uses or returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:162,Performance,cache,cache,162,"/// Given a memory access, invalidate anything this walker knows about; /// that access.; /// This API is used by walkers that store information to perform basic cache; /// invalidation. This will be called by MemorySSA at appropriate times for; /// the walker it uses or returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:19,Security,access,access,19,"/// Given a memory access, invalidate anything this walker knows about; /// that access.; /// This API is used by walkers that store information to perform basic cache; /// invalidation. This will be called by MemorySSA at appropriate times for; /// the walker it uses or returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:81,Security,access,access,81,"/// Given a memory access, invalidate anything this walker knows about; /// that access.; /// This API is used by walkers that store information to perform basic cache; /// invalidation. This will be called by MemorySSA at appropriate times for; /// the walker it uses or returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:76,Usability,simpl,simply,76,"/// A MemorySSAWalker that does no alias queries, or anything else. It; /// simply returns the links as they were constructed by the builder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:95,Security,access,accesses,95,/// Iterator base class used to implement const and non-const iterators; /// over the defining accesses of a MemoryAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:236,Safety,avoid,avoid,236,"// This is a bit ugly, but for MemoryPHI's, unlike PHINodes, you can't get the; // block from the operand in constant time (In a PHINode, the uselist has; // both, so it's just subtraction). We provide it as part of the; // iterator to avoid callers having to linear walk to get the block.; // If the operation becomes constant time on MemoryPHI's, this bit of; // abstraction breaking should be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:55,Security,access,access,55,"// Go to the first argument for phis, and the defining access for everything; // else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:64,Security,access,access,64,"/// Provide an iterator that walks defs, giving both the memory access,; /// and the current pointer location, updating the pointer location as it; /// changes due to phi node translation.; ///; /// This iterator, while somewhat specialized, is what most clients actually; /// want when walking upwards through MemorySSA def chains. It takes a pair of; /// <MemoryAccess,MemoryLocation>, and walks defs, properly translating the; /// memory location through phi nodes for the user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:308,Integrability,depend,dependences,308,"// Mark size as unknown, if the location is not guaranteed to be; // loop-invariant for any possible loop in the function. Setting the size; // to unknown guarantees that any memory accesses that access locations; // after the pointer are considered as clobbers, which is important to; // catch loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:182,Security,access,accesses,182,"// Mark size as unknown, if the location is not guaranteed to be; // loop-invariant for any possible loop in the function. Setting the size; // to unknown guarantees that any memory accesses that access locations; // after the pointer are considered as clobbers, which is important to; // catch loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:196,Security,access,access,196,"// Mark size as unknown, if the location is not guaranteed to be; // loop-invariant for any possible loop in the function. Setting the size; // to unknown guarantees that any memory accesses that access locations; // after the pointer are considered as clobbers, which is important to; // catch loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:582,Performance,optimiz,optimized,582,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:770,Performance,optimiz,optimized,770,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:23,Security,access,accesses,23,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:360,Security,access,access,360,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:385,Security,access,accesses,385,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:619,Security,access,access,619,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:40,Security,access,access,40,// N.B. liveOnEntry has a null defining access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:39,Deployability,Update,Updater,39,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:406,Deployability,update,updater,406,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:552,Deployability,update,updates,552,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:1003,Integrability,depend,depending,1003,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:490,Performance,perform,performs,490,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:611,Performance,load,loads,611,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:803,Security,access,access,803,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:214,Performance,load,loads,214,"/// Insert a definition into the MemorySSA IR. RenameUses will rename any use; /// below the new def block (and any inserted phis). RenameUses should be set; /// to true if the definition may cause new aliases for loads below it. This; /// is not the case for hoisting or sinking or other forms of code *movement*.; /// It *is* the case for straight code insertion.; /// For example:; /// store a; /// if (foo) { }; /// load a; ///; /// Moving the store into the if block, and calling insertDef, does not; /// require RenameUses.; /// However, changing it to:; /// store a; /// if (foo) { store b }; /// load a; /// Where a mayalias b, *does* require RenameUses be set to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:420,Performance,load,load,420,"/// Insert a definition into the MemorySSA IR. RenameUses will rename any use; /// below the new def block (and any inserted phis). RenameUses should be set; /// to true if the definition may cause new aliases for loads below it. This; /// is not the case for hoisting or sinking or other forms of code *movement*.; /// It *is* the case for straight code insertion.; /// For example:; /// store a; /// if (foo) { }; /// load a; ///; /// Moving the store into the if block, and calling insertDef, does not; /// require RenameUses.; /// However, changing it to:; /// store a; /// if (foo) { store b }; /// load a; /// Where a mayalias b, *does* require RenameUses be set to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:604,Performance,load,load,604,"/// Insert a definition into the MemorySSA IR. RenameUses will rename any use; /// below the new def block (and any inserted phis). RenameUses should be set; /// to true if the definition may cause new aliases for loads below it. This; /// is not the case for hoisting or sinking or other forms of code *movement*.; /// It *is* the case for straight code insertion.; /// For example:; /// store a; /// if (foo) { }; /// load a; ///; /// Moving the store into the if block, and calling insertDef, does not; /// require RenameUses.; /// However, changing it to:; /// store a; /// if (foo) { store b }; /// load a; /// Where a mayalias b, *does* require RenameUses be set to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:4,Deployability,Update,Update,4,"/// Update the MemoryPhi in `To` following an edge deletion between `From` and; /// `To`. If `To` becomes unreachable, a call to removeBlocks should be made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:4,Deployability,Update,Update,4,"/// Update the MemoryPhi in `To` to have a single incoming edge from `From`,; /// following a CFG change that replaced multiple edges (switch) with a direct; /// branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:4,Deployability,Update,Update,4,/// Update MemorySSA when inserting a unique backedge block for a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:4,Deployability,Update,Update,4,"/// Update MemorySSA after a loop was cloned, given the blocks in RPO order,; /// the exit blocks and a 1:1 mapping of all blocks and instructions; /// cloned. This involves duplicating all defs and uses in the cloned blocks; /// Updating phi nodes in exit block successors is done separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:4,Deployability,Update,Update,4,/// Update phi nodes in exit block successors following cloning. Exit blocks; /// that were not cloned don't have additional predecessors added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:14,Deployability,update,updates,14,"/// Apply CFG updates, analogous with the DT edge updates. By default, the; /// DT is assumed to be already up to date. If UpdateDTFirst is true, first; /// update the DT with the same updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:50,Deployability,update,updates,50,"/// Apply CFG updates, analogous with the DT edge updates. By default, the; /// DT is assumed to be already up to date. If UpdateDTFirst is true, first; /// update the DT with the same updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:123,Deployability,Update,UpdateDTFirst,123,"/// Apply CFG updates, analogous with the DT edge updates. By default, the; /// DT is assumed to be already up to date. If UpdateDTFirst is true, first; /// update the DT with the same updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:157,Deployability,update,update,157,"/// Apply CFG updates, analogous with the DT edge updates. By default, the; /// DT is assumed to be already up to date. If UpdateDTFirst is true, first; /// update the DT with the same updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:185,Deployability,update,updates,185,"/// Apply CFG updates, analogous with the DT edge updates. By default, the; /// DT is assumed to be already up to date. If UpdateDTFirst is true, first; /// update the DT with the same updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:21,Deployability,update,updates,21,"/// Apply CFG insert updates, analogous with the DT edge updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:57,Deployability,update,updates,57,"/// Apply CFG insert updates, analogous with the DT edge updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:261,Deployability,update,updated,261,"/// `From` block was spliced into `From` and `To`. There is a CFG edge from; /// `From` to `To`. Move all accesses from `From` to `To` starting at; /// instruction `Start`. `To` is newly created BB, so empty of; /// MemorySSA::MemoryAccesses. Edges are already updated, so successors of; /// `To` with MPhi nodes need to update incoming block.; /// |------| |------|; /// | From | | From |; /// | | |------|; /// | | ||; /// | | => \/; /// | | |------| <- Start; /// | | | To |; /// |------| |------|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:321,Deployability,update,update,321,"/// `From` block was spliced into `From` and `To`. There is a CFG edge from; /// `From` to `To`. Move all accesses from `From` to `To` starting at; /// instruction `Start`. `To` is newly created BB, so empty of; /// MemorySSA::MemoryAccesses. Edges are already updated, so successors of; /// `To` with MPhi nodes need to update incoming block.; /// |------| |------|; /// | From | | From |; /// | | |------|; /// | | ||; /// | | => \/; /// | | |------| <- Start; /// | | | To |; /// |------| |------|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:106,Security,access,accesses,106,"/// `From` block was spliced into `From` and `To`. There is a CFG edge from; /// `From` to `To`. Move all accesses from `From` to `To` starting at; /// instruction `Start`. `To` is newly created BB, so empty of; /// MemorySSA::MemoryAccesses. Edges are already updated, so successors of; /// `To` with MPhi nodes need to update incoming block.; /// |------| |------|; /// | From | | From |; /// | | |------|; /// | | ||; /// | | => \/; /// | | |------| <- Start; /// | | | To |; /// |------| |------|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:231,Security,access,accesses,231,"/// `From` block was merged into `To`. There is a CFG edge from `To` to; /// `From`.`To` still branches to `From`, but all instructions were moved and; /// `From` is now an empty block; `From` is about to be deleted. Move all; /// accesses from `From` to `To` starting at instruction `Start`. `To` may; /// have multiple successors, `From` has a single predecessor. `From` may have; /// successors with MPhi nodes, replace their incoming block with `To`.; /// |------| |------|; /// | To | | To |; /// |------| | |; /// || => | |; /// \/ | |; /// |------| | | <- Start; /// | From | | |; /// |------| |------|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:297,Deployability,update,update,297,"/// A new empty BasicBlock (New) now branches directly to Old. Some of; /// Old's predecessors (Preds) are now branching to New instead of Old.; /// If New is the only predecessor, move Old's Phi, if present, to New.; /// Otherwise, add a new Phi in New with appropriate incoming values, and; /// update the incoming values in Old's Phi node too, if present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:171,Deployability,update,update,171,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:813,Deployability,update,updates,813,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:782,Performance,perform,perform,782,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:59,Security,access,accesses,59,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:121,Security,access,accesses,121,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:491,Security,access,access,491,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:915,Security,access,access,915,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:253,Performance,load,load,253,"/// Remove a MemoryAccess from MemorySSA, including updating all; /// definitions and uses.; /// This should be called when a memory instruction that has a MemoryAccess; /// associated with it is erased from the program. For example, if a store or; /// load is simply erased (not replaced), removeMemoryAccess should be called; /// on the MemoryAccess for that store/load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:367,Performance,load,load,367,"/// Remove a MemoryAccess from MemorySSA, including updating all; /// definitions and uses.; /// This should be called when a memory instruction that has a MemoryAccess; /// associated with it is erased from the program. For example, if a store or; /// load is simply erased (not replaced), removeMemoryAccess should be called; /// on the MemoryAccess for that store/load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:261,Usability,simpl,simply,261,"/// Remove a MemoryAccess from MemorySSA, including updating all; /// definitions and uses.; /// This should be called when a memory instruction that has a MemoryAccess; /// associated with it is erased from the program. For example, if a store or; /// load is simply erased (not replaced), removeMemoryAccess should be called; /// on the MemoryAccess for that store/load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:123,Performance,load,load,123,"/// Remove MemoryAccess for a given instruction, if a MemoryAccess exists.; /// This should be called when an instruction (load/store) is deleted from; /// the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:399,Deployability,update,updated,399,"/// Remove all MemoryAcceses in a set of BasicBlocks about to be deleted.; /// Assumption we make here: all uses of deleted defs and phi must either; /// occur in blocks about to be deleted (thus will be deleted as well), or; /// they occur in phis that will simply lose an incoming value.; /// Deleted blocks still have successor info, but their predecessor edges and; /// Phi nodes may already be updated. Instructions in DeadBlocks should be; /// deleted after this call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:259,Usability,simpl,simply,259,"/// Remove all MemoryAcceses in a set of BasicBlocks about to be deleted.; /// Assumption we make here: all uses of deleted defs and phi must either; /// occur in blocks about to be deleted (thus will be deleted as well), or; /// they occur in phis that will simply lose an incoming value.; /// Deleted blocks still have successor info, but their predecessor edges and; /// Phi nodes may already be updated. Instructions in DeadBlocks should be; /// deleted after this call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:122,Deployability,update,update,122,"/// Instruction I will be changed to an unreachable. Remove all accesses in; /// I's block that follow I (inclusive), and update the Phis in the blocks'; /// successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:64,Security,access,accesses,64,"/// Instruction I will be changed to an unreachable. Remove all accesses in; /// I's block that follow I (inclusive), and update the Phis in the blocks'; /// successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:104,Integrability,wrap,wrappers,104,"// Move all memory accesses from `From` to `To` starting at `Start`.; // Restrictions apply, see public wrappers of this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:19,Security,access,accesses,19,"// Move all memory accesses from `From` to `To` starting at `Start`.; // Restrictions apply, see public wrappers of this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:747,Usability,simpl,simplifications,747,"// Clone all uses and defs from BB to NewBB given a 1:1 map of all; // instructions and blocks cloned, and a map of MemoryPhi : Definition; // (MemoryAccess Phi or Def). VMap maps old instructions to cloned; // instructions and old blocks to cloned blocks. MPhiMap, is created in the; // caller of this private method, and maps existing MemoryPhis to new; // definitions that new MemoryAccesses must point to. These definitions may; // not necessarily be MemoryPhis themselves, they may be MemoryDefs. As such,; // the map is between MemoryPhis and MemoryAccesses, where the MemoryAccesses; // may be MemoryPhis or MemoryDefs and not MemoryUses.; // If CloneWasSimplified = true, the clone was exact. Otherwise, assume that; // the clone involved simplifications that may have: (1) turned a MemoryUse; // into an instruction that MemorySSA has no representation for, or (2) turned; // a MemoryDef into a MemoryUse or an instruction that MemorySSA has no; // representation for. No other cases are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h:131,Deployability,update,updated,131,"// Get the initial 'level' of the function, or 0 if the function has been; // introduced afterwards.; // TODO: should we keep this updated?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h:191,Safety,avoid,avoid,191,"// Using std::map to benefit from its iterator / reference non-invalidating; // semantics, which make it easy to use `getCachedFPI` results from multiple; // calls without needing to copy to avoid invalidation effects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h:98,Deployability,update,update,98,"// Make a copy of the FPI of the caller right before inlining. If inlining; // fails, we can just update the cache with that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h:109,Performance,cache,cache,109,"// Make a copy of the FPI of the caller right before inlining. If inlining; // fails, we can just update the cache with that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h:44,Integrability,interface,interface,44,"//===- MLModelRunner.h ---- ML model runner interface -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h:18,Integrability,interface,interface,18,"/// MLModelRunner interface: abstraction of a mechanism for evaluating a; /// ML model. More abstractly, evaluating a function that has as tensors as; /// arguments, described via TensorSpecs, and returns a tensor. Currently, the; /// latter is assumed to be a scalar, in absence of more elaborate scenarios.; /// NOTE: feature indices are expected to be consistent all accross; /// MLModelRunners (pertaining to the same model), and also Loggers (see; /// TFUtils.h)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h:439,Testability,Log,Loggers,439,"/// MLModelRunner interface: abstraction of a mechanism for evaluating a; /// ML model. More abstractly, evaluating a function that has as tensors as; /// arguments, described via TensorSpecs, and returns a tensor. Currently, the; /// latter is assumed to be a scalar, in absence of more elaborate scenarios.; /// NOTE: feature indices are expected to be consistent all accross; /// MLModelRunners (pertaining to the same model), and also Loggers (see; /// TFUtils.h)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h:96,Performance,load,load,96,/// ModelUnderTrainingRunner - training mode implementation. It uses TFLite; /// to dynamically load and evaluate a TF SavedModel; /// (https://www.tensorflow.org/guide/saved_model) converted to TFLite. see; /// lib/Analysis/models/saved-model-to-tflite.py. Runtime performance is; /// sacrificed for ease of use while training.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h:266,Performance,perform,performance,266,/// ModelUnderTrainingRunner - training mode implementation. It uses TFLite; /// to dynamically load and evaluate a TF SavedModel; /// (https://www.tensorflow.org/guide/saved_model) converted to TFLite. see; /// lib/Analysis/models/saved-model-to-tflite.py. Runtime performance is; /// sacrificed for ease of use while training.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h:163,Usability,guid,guide,163,/// ModelUnderTrainingRunner - training mode implementation. It uses TFLite; /// to dynamically load and evaluate a TF SavedModel; /// (https://www.tensorflow.org/guide/saved_model) converted to TFLite. see; /// lib/Analysis/models/saved-model-to-tflite.py. Runtime performance is; /// sacrificed for ease of use while training.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h:403,Integrability,interface,interface,403,"//===- ModuleSummaryAnalysis.h - Module summary index builder ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This is the interface to build a ModuleSummaryIndex for a module.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h:280,Integrability,rout,routine,280,"/// Direct function to compute a \c ModuleSummaryIndex from a given module.; ///; /// If operating within a pass manager which has defined ways to compute the \c; /// BlockFrequencyInfo for a given function, that can be provided via; /// a std::function callback. Otherwise, this routine will manually construct; /// that information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the ModuleSummaryIndex object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the ModuleSummaryIndex object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h:138,Integrability,wrap,wrap,138,"//===--------------------------------------------------------------------===//; //; // ImmutableModuleSummaryIndexWrapperPass - This pass wrap provided; // ModuleSummaryIndex object for the module, to be used by other passes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:716,Availability,avail,available,716,"//===- MustExecute.h - Is an instruction known to execute--------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Contains a collection of routines for determining if a given instruction is; /// guaranteed to execute if a given point in control flow is reached. The most; /// common example is an instruction within a loop being provably executed if we; /// branch to the header of it's containing loop.; ///; /// There are two interfaces available to determine if an instruction is; /// executed once a given point in the control flow is reached:; /// 1) A loop-centric one derived from LoopSafetyInfo.; /// 2) A ""must be executed context""-based one implemented in the; /// MustBeExecutedContextExplorer.; /// Please refer to the class comments for more information.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:416,Integrability,rout,routines,416,"//===- MustExecute.h - Is an instruction known to execute--------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Contains a collection of routines for determining if a given instruction is; /// guaranteed to execute if a given point in control flow is reached. The most; /// common example is an instruction within a loop being provably executed if we; /// branch to the header of it's containing loop.; ///; /// There are two interfaces available to determine if an instruction is; /// executed once a given point in the control flow is reached:; /// 1) A loop-centric one derived from LoopSafetyInfo.; /// 2) A ""must be executed context""-based one implemented in the; /// MustBeExecutedContextExplorer.; /// Please refer to the class comments for more information.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:705,Integrability,interface,interfaces,705,"//===- MustExecute.h - Is an instruction known to execute--------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Contains a collection of routines for determining if a given instruction is; /// guaranteed to execute if a given point in control flow is reached. The most; /// common example is an instruction within a loop being provably executed if we; /// branch to the header of it's containing loop.; ///; /// There are two interfaces available to determine if an instruction is; /// executed once a given point in the control flow is reached:; /// 1) A loop-centric one derived from LoopSafetyInfo.; /// 2) A ""must be executed context""-based one implemented in the; /// MustBeExecutedContextExplorer.; /// Please refer to the class comments for more information.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:439,Performance,cache,cached,439,"/// Captures loop safety information.; /// It keep information for loop blocks may throw exception or otherwise; /// exit abnormally on any iteration of the loop which might actually execute; /// at runtime. The primary way to consume this information is via; /// isGuaranteedToExecute below, but some callers bailout or fallback to; /// alternate reasoning if a loop contains any implicit control flow.; /// NOTE: LoopSafetyInfo contains cached information regarding loops and their; /// particular blocks. This information is only dropped on invocation of; /// computeLoopSafetyInfo. If the loop or any of its block is deleted, or if; /// any thrower instructions have been added or removed from them, or if the; /// control flow has changed, or in case of other meaningful modifications, the; /// LoopSafetyInfo needs to be recomputed. If a meaningful modifications to the; /// loop were made and the info wasn't recomputed properly, the behavior of all; /// methods except for computeLoopSafetyInfo is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:18,Safety,safe,safety,18,"/// Captures loop safety information.; /// It keep information for loop blocks may throw exception or otherwise; /// exit abnormally on any iteration of the loop which might actually execute; /// at runtime. The primary way to consume this information is via; /// isGuaranteedToExecute below, but some callers bailout or fallback to; /// alternate reasoning if a loop contains any implicit control flow.; /// NOTE: LoopSafetyInfo contains cached information regarding loops and their; /// particular blocks. This information is only dropped on invocation of; /// computeLoopSafetyInfo. If the loop or any of its block is deleted, or if; /// any thrower instructions have been added or removed from them, or if the; /// control flow has changed, or in case of other meaningful modifications, the; /// LoopSafetyInfo needs to be recomputed. If a meaningful modifications to the; /// loop were made and the info wasn't recomputed properly, the behavior of all; /// methods except for computeLoopSafetyInfo is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:11,Deployability,update,update,11,// Used to update funclet bundle operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:45,Deployability,update,update,45,/// Returns block colors map that is used to update funclet operand bundles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:125,Safety,avoid,avoid,125,/// Returns true iff the block \p BB potentially may throw exception. It can; /// be false-positive in cases when we want to avoid complex analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:169,Deployability,Update,Updates,169,"/// Computes safety information for a loop checks loop body & header for; /// the possibility of may throw exception, it takes LoopSafetyInfo and loop; /// as argument. Updates safety information in LoopSafetyInfo argument.; /// Note: This is defined to clear and reinitialize an already initialized; /// LoopSafetyInfo. Some callers rely on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:13,Safety,safe,safety,13,"/// Computes safety information for a loop checks loop body & header for; /// the possibility of may throw exception, it takes LoopSafetyInfo and loop; /// as argument. Updates safety information in LoopSafetyInfo argument.; /// Note: This is defined to clear and reinitialize an already initialized; /// LoopSafetyInfo. Some callers rely on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:177,Safety,safe,safety,177,"/// Computes safety information for a loop checks loop body & header for; /// the possibility of may throw exception, it takes LoopSafetyInfo and loop; /// as argument. Updates safety information in LoopSafetyInfo argument.; /// Note: This is defined to clear and reinitialize an already initialized; /// LoopSafetyInfo. Some callers rely on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:254,Usability,clear,clear,254,"/// Computes safety information for a loop checks loop body & header for; /// the possibility of may throw exception, it takes LoopSafetyInfo and loop; /// as argument. Updates safety information in LoopSafetyInfo argument.; /// Note: This is defined to clear and reinitialize an already initialized; /// LoopSafetyInfo. Some callers rely on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:130,Safety,avoid,avoid,130,/// Simple and conservative implementation of LoopSafetyInfo that can give; /// false-positive answers to its queries in order to avoid complicated; /// analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:4,Usability,Simpl,Simple,4,/// Simple and conservative implementation of LoopSafetyInfo that can give; /// false-positive answers to its queries in order to avoid complicated; /// analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:152,Performance,cache,cache,152,"/// This implementation of LoopSafetyInfo use ImplicitControlFlowTracking to; /// give precise answers on ""may throw"" queries. This implementation uses cache; /// that should be invalidated by calling the methods insertInstructionTo and; /// removeInstruction whenever we modify a basic block's contents by adding or; /// removing instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:140,Deployability,update,updates,140,/// Inform the safety info that we are planning to insert a new instruction; /// \p Inst into the basic block \p BB. It will make all cache updates to keep; /// it correct after this insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:134,Performance,cache,cache,134,/// Inform the safety info that we are planning to insert a new instruction; /// \p Inst into the basic block \p BB. It will make all cache updates to keep; /// it correct after this insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:15,Safety,safe,safety,15,/// Inform the safety info that we are planning to insert a new instruction; /// \p Inst into the basic block \p BB. It will make all cache updates to keep; /// it correct after this insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:122,Deployability,update,updates,122,/// Inform safety info that we are planning to remove the instruction \p Inst; /// from its block. It will make all cache updates to keep it correct after; /// this removal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:116,Performance,cache,cache,116,/// Inform safety info that we are planning to remove the instruction \p Inst; /// from its block. It will make all cache updates to keep it correct after; /// this removal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:11,Safety,safe,safety,11,/// Inform safety info that we are planning to remove the instruction \p Inst; /// from its block. It will make all cache updates to keep it correct after; /// this removal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:2184,Availability,avail,available,2184,"or), there are two possible; /// outcomes. If we start the iterator at A, B, or E, we will visit only A, B,; /// and E. If we start at C or D, we will visit all instructions A-E.; ///; /// \code; /// A;; /// B;; /// if (...) {; /// C;; /// D;; /// }; /// E;; /// \endcode; ///; ///; /// Below is the example extneded with instructions F and G. Now we assume F; /// might not transfer execution to it's successor G. As a result we get the; /// following visit sets:; ///; /// Start Instruction | Visit Set; /// A | A, B, E, F; /// B | A, B, E, F; /// C | A, B, C, D, E, F; /// D | A, B, C, D, E, F; /// E | A, B, E, F; /// F | A, B, E, F; /// G | A, B, E, F, G; ///; ///; /// \code; /// A;; /// B;; /// if (...) {; /// C;; /// D;; /// }; /// E;; /// F; // Might not transfer execution to its successor G.; /// G;; /// \endcode; ///; ///; /// A more complex example involving conditionals, loops, break, and continue; /// is shown below. We again assume all instructions will transmit control to; /// the successor and we assume we can prove the inner loop to be finite. We; /// omit non-trivial branch conditions as the exploration is oblivious to them.; /// Constant branches are assumed to be unconditional in the CFG. The resulting; /// visist sets are shown in the table below.; ///; /// \code; /// A;; /// while (true) {; /// B;; /// if (...); /// C;; /// if (...); /// continue;; /// D;; /// if (...); /// break;; /// do {; /// if (...); /// continue;; /// E;; /// } while (...);; /// F;; /// }; /// G;; /// \endcode; ///; /// Start Instruction | Visit Set; /// A | A, B; /// B | A, B; /// C | A, B, C; /// D | A, B, D; /// E | A, B, D, E, F; /// F | A, B, D, F; /// G | A, B, D, G; ///; ///; /// Note that the examples show optimal visist sets but not necessarily the ones; /// derived by the explorer depending on the available CFG analyses (see; /// MustBeExecutedContextExplorer). Also note that we, depending on the options,; /// the visit set can contain instructions from other functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:2167,Integrability,depend,depending,2167,"or), there are two possible; /// outcomes. If we start the iterator at A, B, or E, we will visit only A, B,; /// and E. If we start at C or D, we will visit all instructions A-E.; ///; /// \code; /// A;; /// B;; /// if (...) {; /// C;; /// D;; /// }; /// E;; /// \endcode; ///; ///; /// Below is the example extneded with instructions F and G. Now we assume F; /// might not transfer execution to it's successor G. As a result we get the; /// following visit sets:; ///; /// Start Instruction | Visit Set; /// A | A, B, E, F; /// B | A, B, E, F; /// C | A, B, C, D, E, F; /// D | A, B, C, D, E, F; /// E | A, B, E, F; /// F | A, B, E, F; /// G | A, B, E, F, G; ///; ///; /// \code; /// A;; /// B;; /// if (...) {; /// C;; /// D;; /// }; /// E;; /// F; // Might not transfer execution to its successor G.; /// G;; /// \endcode; ///; ///; /// A more complex example involving conditionals, loops, break, and continue; /// is shown below. We again assume all instructions will transmit control to; /// the successor and we assume we can prove the inner loop to be finite. We; /// omit non-trivial branch conditions as the exploration is oblivious to them.; /// Constant branches are assumed to be unconditional in the CFG. The resulting; /// visist sets are shown in the table below.; ///; /// \code; /// A;; /// while (true) {; /// B;; /// if (...); /// C;; /// if (...); /// continue;; /// D;; /// if (...); /// break;; /// do {; /// if (...); /// continue;; /// E;; /// } while (...);; /// F;; /// }; /// G;; /// \endcode; ///; /// Start Instruction | Visit Set; /// A | A, B; /// B | A, B; /// C | A, B, C; /// D | A, B, D; /// E | A, B, D, E, F; /// F | A, B, D, F; /// G | A, B, D, G; ///; ///; /// Note that the examples show optimal visist sets but not necessarily the ones; /// derived by the explorer depending on the available CFG analyses (see; /// MustBeExecutedContextExplorer). Also note that we, depending on the options,; /// the visit set can contain instructions from other functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:2268,Integrability,depend,depending,2268,"or), there are two possible; /// outcomes. If we start the iterator at A, B, or E, we will visit only A, B,; /// and E. If we start at C or D, we will visit all instructions A-E.; ///; /// \code; /// A;; /// B;; /// if (...) {; /// C;; /// D;; /// }; /// E;; /// \endcode; ///; ///; /// Below is the example extneded with instructions F and G. Now we assume F; /// might not transfer execution to it's successor G. As a result we get the; /// following visit sets:; ///; /// Start Instruction | Visit Set; /// A | A, B, E, F; /// B | A, B, E, F; /// C | A, B, C, D, E, F; /// D | A, B, C, D, E, F; /// E | A, B, E, F; /// F | A, B, E, F; /// G | A, B, E, F, G; ///; ///; /// \code; /// A;; /// B;; /// if (...) {; /// C;; /// D;; /// }; /// E;; /// F; // Might not transfer execution to its successor G.; /// G;; /// \endcode; ///; ///; /// A more complex example involving conditionals, loops, break, and continue; /// is shown below. We again assume all instructions will transmit control to; /// the successor and we assume we can prove the inner loop to be finite. We; /// omit non-trivial branch conditions as the exploration is oblivious to them.; /// Constant branches are assumed to be unconditional in the CFG. The resulting; /// visist sets are shown in the table below.; ///; /// \code; /// A;; /// while (true) {; /// B;; /// if (...); /// C;; /// if (...); /// continue;; /// D;; /// if (...); /// break;; /// do {; /// if (...); /// continue;; /// E;; /// } while (...);; /// F;; /// }; /// G;; /// \endcode; ///; /// Start Instruction | Visit Set; /// A | A, B; /// B | A, B; /// C | A, B, C; /// D | A, B, D; /// E | A, B, D, E, F; /// F | A, B, D, F; /// G | A, B, D, G; ///; ///; /// Note that the examples show optimal visist sets but not necessarily the ones; /// derived by the explorer depending on the available CFG analyses (see; /// MustBeExecutedContextExplorer). Also note that we, depending on the options,; /// the visit set can contain instructions from other functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:46,Performance,cache,cached,46,"/// Reset the iterator to point at \p I, keep cached state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:215,Integrability,interface,interface,215,"/// A ""must be executed context"" for a given program point PP is the set of; /// instructions, potentially before and after PP, that are executed always when; /// PP is reached. The MustBeExecutedContextExplorer an interface to explore; /// ""must be executed contexts"" in a module through the use of; /// MustBeExecutedIterator.; ///; /// The explorer exposes ""must be executed iterators"" that traverse the must be; /// executed context. There is little information sharing between iterators as; /// the expected use case involves few iterators for ""far apart"" instructions.; /// If that changes, we should consider caching more intermediate results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:352,Security,expose,exposes,352,"/// A ""must be executed context"" for a given program point PP is the set of; /// instructions, potentially before and after PP, that are executed always when; /// PP is reached. The MustBeExecutedContextExplorer an interface to explore; /// ""must be executed contexts"" in a module through the use of; /// MustBeExecutedIterator.; ///; /// The explorer exposes ""must be executed iterators"" that traverse the must be; /// executed context. There is little information sharing between iterators as; /// the expected use case involves few iterators for ""far apart"" instructions.; /// If that changes, we should consider caching more intermediate results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:19,Integrability,interface,interface,19,/// Iterator-based interface. \see MustBeExecutedIterator.; ///{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:38,Performance,cache,cached,38,/// Return an iterator to explore the cached context around \p PP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:44,Performance,cache,cached,44,/// Return an iterator range to explore the cached context around \p PP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:29,Performance,perform,performed,29,/// Parameter that limit the performed exploration. See the constructor for; /// their meaning.; ///{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:17,Performance,cache,cache,17,///}; /// Map to cache isGuaranteedToTransferExecutionToSuccessor results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:11,Performance,cache,cache,11,/// Map to cache containsIrreducibleCFG results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/NoInferenceModelRunner.h:82,Testability,log,logs,82,"/// A pseudo model runner. We use it to store feature values when collecting; /// logs for the default policy, in 'development' mode, but never ask it to; /// 'run'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/NoInferenceModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/NoInferenceModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h:490,Modifiability,enhance,enhance,490,"//===- ObjCARCAliasAnalysis.h - ObjC ARC Alias Analysis ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h:504,Performance,optimiz,optimization,504,"//===- ObjCARCAliasAnalysis.h - ObjC ARC Alias Analysis ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h:412,Usability,simpl,simple,412,"//===- ObjCARCAliasAnalysis.h - ObjC ARC Alias Analysis ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h:14,Usability,simpl,simple,14,/// This is a simple alias analysis implementation that uses knowledge; /// of ARC constructs to answer queries.; ///; /// TODO: This class could be generalized to know about other ObjC-specific; /// tricks. Such as knowing that ivars in the non-fragile ABI are non-aliasing; /// even though their offsets are dynamic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:456,Performance,Optimiz,Optimizer,456,"//===- ObjCARCAnalysisUtils.h - ObjC ARC Analysis Utilities -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines common analysis utilities used by the ObjC ARC Optimizer.; /// ARC stands for Automatic Reference Counting and is a system for managing; /// reference counts for objects in Objective C.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:45,Performance,Optimiz,Optimizations,45,/// A handy option to enable/disable all ARC Optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:58,Performance,optimiz,optimization,58,/// Test if the given module looks interesting to run ARC optimization; /// on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:4,Testability,Test,Test,4,/// Test if the given module looks interesting to run ARC optimization; /// on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:14,Integrability,wrap,wrapper,14,"/// This is a wrapper around getUnderlyingObject which also knows how to; /// look through objc_retain and objc_autorelease calls, which we know to return; /// their argument verbatim.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:6,Integrability,wrap,wrapper,6,/// A wrapper for GetUnderlyingObjCPtr used for results memoization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:266,Performance,optimiz,optimizer,266,"/// The RCIdentity root of a value \p V is a dominating value U for which; /// retaining or releasing U is equivalent to retaining or releasing V. In other; /// words, ARC operations on \p V are equivalent to ARC operations on \p U.; ///; /// We use this in the ARC optimizer to make it easier to match up ARC; /// operations by always mapping ARC operations to RCIdentityRoots instead of; /// pointers themselves.; ///; /// The two ways that we see RCIdentical values in ObjC are via:; ///; /// 1. PointerCasts; /// 2. Forwarding Calls that return their argument verbatim.; ///; /// Thus this function strips off pointer casts and forwarding calls. *NOTE*; /// This implies that two RCIdentical values must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:4,Testability,Test,Test,4,/// Test whether the given value is possible a retainable object pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:62,Usability,intuit,intuitive,62,"// Only consider values with pointer types.; //; // It seemes intuitive to exclude function pointer types as well, since; // functions are never retainable object pointers, however clang occasionally; // bitcasts retainable object pointers to function-pointer type temporarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:17,Modifiability,variab,variables,17,// These special variables are known to hold values which are not; // reference-counted pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:6,Performance,cache,cache,6,/// A cache of MDKinds used by various ARC optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:43,Performance,optimiz,optimizations,43,/// A cache of MDKinds used by various ARC optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class is a kind of user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class is objc_retain or equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class is objc_autorelease or equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class represents instructions which return their; /// argument verbatim.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class represents instructions which do nothing if; /// passed a null pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:93,Modifiability,variab,variable,93,/// Test if the given class represents instructions which do nothing if; /// passed a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class represents instructions which do nothing if; /// passed a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:69,Safety,safe,safe,69,"/// Test if the given class represents instructions which are always safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,"/// Test if the given class represents instructions which are always safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:68,Safety,safe,safe,68,"/// Test if the given class represents instructions which are never safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,"/// Test if the given class represents instructions which are never safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:69,Safety,safe,safe,69,/// Test if the given class represents instructions which are always safe; /// to mark with the nounwind attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class represents instructions which are always safe; /// to mark with the nounwind attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test whether the given instruction can autorelease any pointer or cause an; /// autoreleasepool pop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:134,Safety,detect,detects,134,/// Determine which objc runtime call instruction class V belongs to.; ///; /// This is similar to GetARCInstKind except that it only detects objc; /// runtime calls. This allows it to be faster.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h:56,Performance,optimiz,optimization,56,"// Ignore the bundle if the return type is void. Global optimization passes; // can turn the called function's return type to void. That should happen only; // if the call doesn't return and the call to @llvm.objc.clang.arc.noop.use; // no longer consumes the function return or is deleted. In that case, it's; // not necessary to emit the marker instruction or calls to the ARC runtime; // functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h:43,Safety,unsafe,unsafeClaimRV,43,/// Check whether the function is retainRV/unsafeClaimRV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h:256,Safety,Unsafe,UnsafeClaimRV,256,/// This function returns the ARCInstKind of the function attached to operand; /// bundle clang_arc_attachedcall. It returns std::nullopt if the call doesn't; /// have the operand bundle or the operand is null. Otherwise it returns either; /// RetainRV or UnsafeClaimRV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:407,Integrability,interface,interfaces,407,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:501,Integrability,depend,dependent,501,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:586,Integrability,message,message,586,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:7,Performance,Optimiz,OptimizationRemarkEmitter,7,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:37,Performance,Optimiz,Optimization,37,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:383,Performance,Optimiz,Optimization,383,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:32,Integrability,interface,interface,32,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:8,Performance,optimiz,optimization,8,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:78,Performance,optimiz,optimizations,78,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:96,Performance,perform,performed,96,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:145,Integrability,depend,depending,145,"/// This variant can be used to generate ORE on demand (without the; /// analysis pass).; ///; /// Note that this ctor has a very different cost depending on whether; /// F->getContext().getDiagnosticsHotnessRequested() is on or not. If it's off; /// the operation is free.; ///; /// Whereas if DiagnosticsHotnessRequested is on, it is fairly expensive; /// operation since BFI and all its required analyses are computed. This is; /// for example useful for CGSCC passes that can't use function analyses; /// passes in the old PM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:65,Performance,optimiz,optimization,65,/// Output the remark via the diagnostic handler and to the; /// optimization record file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:3,Safety,Avoid,Avoid,3,// Avoid building the remark unless we know there are at least *some*; // remarks enabled. We can't currently check whether remarks are requested; // for the calling pass since that requires actually building the remark.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:54,Performance,perform,perform,54,/// Whether we allow for extra compile-time budget to perform more; /// analysis to produce fewer false positives.; ///; /// This is useful when reporting missed optimizations. In this case we can; /// use the extra analysis (1) to filter trivial false positives or (2) to; /// provide more context so that non-trivial false positives can be quickly; /// detected by the user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:162,Performance,optimiz,optimizations,162,/// Whether we allow for extra compile-time budget to perform more; /// analysis to produce fewer false positives.; ///; /// This is useful when reporting missed optimizations. In this case we can; /// use the extra analysis (1) to filter trivial false positives or (2) to; /// provide more context so that non-trivial false positives can be quickly; /// detected by the user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:355,Safety,detect,detected,355,/// Whether we allow for extra compile-time budget to perform more; /// analysis to produce fewer false positives.; ///; /// This is useful when reporting missed optimizations. In this case we can; /// use the extra analysis (1) to filter trivial false positives or (2) to; /// provide more context so that non-trivial false positives can be quickly; /// detected by the user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:83,Availability,avail,available,83,/// Compute hotness from IR value (currently assumed to be a block) if PGO is; /// available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:46,Deployability,update,update,46,/// Similar but use value from \p OptDiag and update hotness there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:23,Integrability,message,messages,23,/// Only allow verbose messages if we know we're filtering by hotness; /// (BFI is only set in this case).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:92,Integrability,interface,interface,92,/// Add a small namespace to avoid name clashes with the classes used in; /// the streaming interface. We want these to be short for better; /// write/readability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:29,Safety,avoid,avoid,29,/// Add a small namespace to avoid name clashes with the classes used in; /// the streaming interface. We want these to be short for better; /// write/readability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:4,Performance,Optimiz,OptimizationRemarkEmitter,4,"/// OptimizationRemarkEmitter legacy analysis pass; ///; /// Note that this pass shouldn't generally be marked as preserved by other; /// passes. It's holding onto BFI, so if the pass does not preserve BFI, BFI; /// could be freed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h:399,Integrability,rout,routines,399,"//===-- OverflowInstAnalysis.h - Utils to fold overflow insts ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file holds routines to help analyse overflow instructions; // and fold them into constants or other overflow instructions; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h:47,Testability,log,logic,47,"/// Match one of the patterns up to the select/logic op:; /// %Op0 = icmp ne i4 %X, 0; /// %Agg = call { i4, i1 } @llvm.[us]mul.with.overflow.i4(i4 %X, i4 %Y); /// %Op1 = extractvalue { i4, i1 } %Agg, 1; /// %ret = select i1 %Op0, i1 %Op1, i1 false / %ret = and i1 %Op0, %Op1; ///; /// %Op0 = icmp eq i4 %X, 0; /// %Agg = call { i4, i1 } @llvm.[us]mul.with.overflow.i4(i4 %X, i4 %Y); /// %NotOp1 = extractvalue { i4, i1 } %Agg, 1; /// %Op1 = xor i1 %NotOp1, true; /// %ret = select i1 %Op0, i1 true, i1 %Op1 / %ret = or i1 %Op0, %Op1; ///; /// Callers are expected to align that with the operands of the select/logic.; /// IsAnd is set to true if the Op0 and Op1 are used as the first pattern.; /// If Op0 and Op1 match one of the patterns above, return true and fill Y's; /// use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h:611,Testability,log,logic,611,"/// Match one of the patterns up to the select/logic op:; /// %Op0 = icmp ne i4 %X, 0; /// %Agg = call { i4, i1 } @llvm.[us]mul.with.overflow.i4(i4 %X, i4 %Y); /// %Op1 = extractvalue { i4, i1 } %Agg, 1; /// %ret = select i1 %Op0, i1 %Op1, i1 false / %ret = and i1 %Op0, %Op1; ///; /// %Op0 = icmp eq i4 %X, 0; /// %Agg = call { i4, i1 } @llvm.[us]mul.with.overflow.i4(i4 %X, i4 %Y); /// %NotOp1 = extractvalue { i4, i1 } %Agg, 1; /// %Op1 = xor i1 %NotOp1, true; /// %ret = select i1 %Op0, i1 true, i1 %Op1 / %ret = or i1 %Op0, %Op1; ///; /// Callers are expected to align that with the operands of the select/logic.; /// IsAnd is set to true if the Op0 and Op1 are used as the first pattern.; /// If Op0 and Op1 match one of the patterns above, return true and fill Y's; /// use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h:423,Security,access,accessor,423,"//===-- llvm/Analysis/Passes.h - Constructors for analyses ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header file defines prototypes for accessor functions that expose passes; // in the analysis libraries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h:447,Security,expose,expose,447,"//===-- llvm/Analysis/Passes.h - Constructors for analyses ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header file defines prototypes for accessor functions that expose passes; // in the analysis libraries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h:161,Integrability,Depend,DependenceAnalysisWrapper,161,//===--------------------------------------------------------------------===//; //; // createDependenceAnalysisWrapperPass - This creates an instance of the; // DependenceAnalysisWrapper pass.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:6,Performance,cache,cache,6,/// A cache of \@llvm.assume calls used by SimplifyInstruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:43,Usability,Simpl,SimplifyInstruction,43,/// A cache of \@llvm.assume calls used by SimplifyInstruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:157,Safety,avoid,avoid,157,"/// isPotentiallyPHITranslatable - If this needs PHI translation, return true; /// if we have some hope of doing it. This should be used as a filter to; /// avoid calling PHITranslateValue in hopeless situations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:260,Availability,failure,failure,260,"/// translateWithInsertion - PHI translate this value into the specified; /// predecessor block, inserting a computation of the value if it is; /// unavailable.; ///; /// All newly created instructions are added to the NewInsts list. This; /// returns null on failure.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:135,Availability,error,errors,135,"/// verify - Check internal consistency of this data structure. If the; /// structure is valid, it returns true. If invalid, it prints errors and; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:248,Availability,failure,failure,248,/// insertTranslatedSubExpr - Insert a computation of the PHI translated; /// version of 'V' for the edge PredBB->CurBB into the end of the PredBB; /// block. All newly created instructions are added to the NewInsts list.; /// This returns null on failure.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:647,Performance,cache,cached,647,"//===- PhiValues.h - Phi Value Analysis -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PhiValues class, and associated passes, which can be; // used to find the underlying values of the phis in a function, i.e. the; // non-phi values that can be found by traversing the phi graph.; //; // This information is computed lazily and cached. If new phis are added to the; // function they are handled correctly, but if an existing phi has its operands; // modified PhiValues has to be notified by calling invalidateValue.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:67,Performance,cache,cached,67,"/// Get the underlying values of a phi.; ///; /// This returns the cached value if PN has previously been processed,; /// otherwise it processes it first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:30,Performance,cache,cached,30,"/// Notify PhiValues that the cached information using V is no longer valid; ///; /// Whenever a phi has its operands modified the cached values for that phi; /// (and the phis that use that phi) become invalid. A user of PhiValues has; /// to notify it of this by calling invalidateValue on either the operand or; /// the phi, which will then clear the relevant cached information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:131,Performance,cache,cached,131,"/// Notify PhiValues that the cached information using V is no longer valid; ///; /// Whenever a phi has its operands modified the cached values for that phi; /// (and the phis that use that phi) become invalid. A user of PhiValues has; /// to notify it of this by calling invalidateValue on either the operand or; /// the phi, which will then clear the relevant cached information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:363,Performance,cache,cached,363,"/// Notify PhiValues that the cached information using V is no longer valid; ///; /// Whenever a phi has its operands modified the cached values for that phi; /// (and the phis that use that phi) become invalid. A user of PhiValues has; /// to notify it of this by calling invalidateValue on either the operand or; /// the phi, which will then clear the relevant cached information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:344,Usability,clear,clear,344,"/// Notify PhiValues that the cached information using V is no longer valid; ///; /// Whenever a phi has its operands modified the cached values for that phi; /// (and the phis that use that phi) become invalid. A user of PhiValues has; /// to notify it of this by calling invalidateValue on either the operand or; /// the phi, which will then clear the relevant cached information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:42,Performance,cache,cache,42,/// Print out the values currently in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:91,Performance,cache,cached,91,"/// A CallbackVH to notify PhiValues when a value is deleted or replaced, so; /// that the cached information for that value can be cleared to avoid; /// dangling pointers to invalid values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:143,Safety,avoid,avoid,143,"/// A CallbackVH to notify PhiValues when a value is deleted or replaced, so; /// that the cached information for that value can be cleared to avoid; /// dangling pointers to invalid values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:132,Usability,clear,cleared,132,"/// A CallbackVH to notify PhiValues when a value is deleted or replaced, so; /// that the cached information for that value can be cleared to avoid; /// dangling pointers to invalid values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper pass for the legacy pass manager,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PostDominators.h:401,Integrability,interface,interfaces,401,"//=- llvm/Analysis/PostDominators.h - Post Dominator Calculation --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes interfaces to post dominance information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PostDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PostDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PostDominators.h:393,Security,expose,exposes,393,"//=- llvm/Analysis/PostDominators.h - Post Dominator Calculation --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes interfaces to post dominance information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PostDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PostDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:421,Security,access,access,421,"//===- llvm/Analysis/ProfileSummaryInfo.h - profile summary ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that provides access to profile summary; // information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:529,Integrability,depend,depend,529,/// Analysis providing profile information.; ///; /// This is an immutable analysis pass that provides ability to query global; /// (program-level) profile information. The main APIs are isHotCount and; /// isColdCount that tells whether a given profile count is considered hot/cold; /// based on the profile summary. This also provides convenience methods to; /// check whether a function is hot or cold.; // FIXME: Provide convenience methods to determine hotness/coldness of other IR; // units. This would require making this depend on BFI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:16,Performance,cache,caches,16,// The map that caches the threshold values. The keys are the percentile; // cutoff values and the values are the corresponding threshold values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:39,Availability,avail,available,39,/// Returns true if profile summary is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:185,Availability,avail,available,185,"/// Returns true if \p F has hot function entry. If it returns false, it; /// either means it is not hot or it is unknown whether it is hot or not (for; /// example, no profile data is available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:165,Integrability,depend,dependency,165,"// Declare template specialization for llvm::MachineFunction. Do not implement; // here, because we cannot include MachineFunction header here, that would break; // dependency rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:742,Modifiability,variab,variable,742,"//===- PtrUseVisitor.h - InstVisitors over a pointers uses ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides a collection of visitors which walk the (instruction); /// uses of a pointer. These visitors all provide the same essential behavior; /// as an InstVisitor with similar template-based flexibility and; /// implementation strategies.; ///; /// These can be used, for example, to quickly analyze the uses of an alloca,; /// global variable, or function argument.; ///; /// FIXME: Provide a variant which doesn't track offsets and is cheaper.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:26,Integrability,depend,dependent,26,/// Implementation of non-dependent functionality for \c PtrUseVisitor.; ///; /// See \c PtrUseVisitor for the public interface and detailed comments about; /// usage. This class is just a helper base class which is not templated and; /// contains all common code to be shared between different instantiations of; /// PtrUseVisitor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:118,Integrability,interface,interface,118,/// Implementation of non-dependent functionality for \c PtrUseVisitor.; ///; /// See \c PtrUseVisitor for the public interface and detailed comments about; /// usage. This class is just a helper base class which is not templated and; /// contains all common code to be shared between different instantiations of; /// PtrUseVisitor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:266,Safety,abort,aborted,266,"/// This class provides information about the result of a visit.; ///; /// After walking all the users (recursively) of a pointer, the basic; /// infrastructure records some commonly useful information such as escape; /// analysis and whether the visit completed or aborted early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:28,Usability,clear,clearing,28,"/// Reset the pointer info, clearing all state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:11,Safety,abort,abort,11,/// Did we abort the visit early?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:128,Availability,avail,available,128,/// Get the instruction causing the visit to abort.; /// \returns a pointer to the instruction causing the abort if one is; /// available; otherwise returns null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:45,Safety,abort,abort,45,/// Get the instruction causing the visit to abort.; /// \returns a pointer to the instruction causing the abort if one is; /// available; otherwise returns null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:107,Safety,abort,abort,107,/// Get the instruction causing the visit to abort.; /// \returns a pointer to the instruction causing the abort if one is; /// available; otherwise returns null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:139,Availability,avail,available,139,/// Get the instruction causing the pointer to escape.; /// \returns a pointer to the instruction which escapes the pointer if one; /// is available; otherwise returns null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:132,Availability,avail,available,132,"/// Mark the visit as aborted. Intended for use in a void return.; /// \param I The instruction which caused the visit to abort, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:22,Safety,abort,aborted,22,"/// Mark the visit as aborted. Intended for use in a void return.; /// \param I The instruction which caused the visit to abort, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:122,Safety,abort,abort,122,"/// Mark the visit as aborted. Intended for use in a void return.; /// \param I The instruction which caused the visit to abort, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:128,Availability,avail,available,128,"/// Mark the pointer as escaped. Intended for use in a void return.; /// \param I The instruction which escapes the pointer, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:190,Availability,avail,available,190,"/// Mark the pointer as escaped, and the visit as aborted. Intended; /// for use in a void return.; /// \param I The instruction which both escapes the pointer and aborts the; /// visit, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:50,Safety,abort,aborted,50,"/// Mark the pointer as escaped, and the visit as aborted. Intended; /// for use in a void return.; /// \param I The instruction which both escapes the pointer and aborts the; /// visit, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:164,Safety,abort,aborts,164,"/// Mark the pointer as escaped, and the visit as aborted. Intended; /// for use in a void return.; /// \param I The instruction which both escapes the pointer and aborts the; /// visit, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:84,Integrability,rout,routine,84,/// Walk the operands of a GEP and adjust the offset as appropriate.; ///; /// This routine does the heavy lifting of the pointer walk by computing; /// offsets and looking through GEPs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:440,Availability,avail,available,440,"// end namespace detail; /// A base class for visitors over the uses of a pointer value.; ///; /// Once constructed, a user can call \c visit on a pointer value, and this; /// will walk its uses and visit each instruction using an InstVisitor. It also; /// provides visit methods which will recurse through any pointer-to-pointer; /// transformations such as GEPs and bitcasts.; ///; /// During the visit, the current Use* being visited is available to the; /// subclass, as well as the current offset from the original base pointer if; /// known.; ///; /// The recursive visit of uses is accomplished with a worklist, so the only; /// ordering guarantee is that an instruction is visited before any uses of it; /// are visited. Note that this does *not* mean before any of its users are; /// visited! This is because users can be visited multiple times due to; /// multiple, different uses of pointers derived from the same base.; ///; /// A particular Use will only be visited once, but a User may be visited; /// multiple times, once per Use. This visits may notably have different; /// offsets.; ///; /// All visit methods on the underlying InstVisitor return a boolean. This; /// return short-circuits the visit, stopping it immediately.; ///; /// FIXME: Generalize this for all values rather than just instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:29,Usability,clear,clear,29,"// If we can't walk the GEP, clear the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:62,Testability,log,logic,62,// No-op intrinsics which we know don't escape the pointer to logic in; // some other function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:577,Availability,Ping,Pingali,577,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:871,Availability,avail,available,871,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:1784,Availability,avail,available,1784,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:1000,Performance,perform,performing,1000,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:1454,Performance,optimiz,optimization,1454,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:1479,Safety,avoid,avoided,1479,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:955,Usability,simpl,simpler,955,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:123,Safety,avoid,avoid,123,// Class to be specialized for different users of RegionInfo; // (i.e. BasicBlocks or MachineBasicBlocks). This is only to avoid needing to; // pass around an unreasonable number of template parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:506,Modifiability,extend,extended,506,"//===----------------------------------------------------------------------===//; /// A single entry single exit Region.; ///; /// A Region is a connected subgraph of a control flow graph that has exactly; /// two connections to the remaining graph. It can be used to analyze or; /// optimize parts of the control flow graph.; ///; /// A <em> simple Region </em> is connected to the remaining graph by just two; /// edges. One edge entering the Region and another one leaving the Region.; ///; /// An <em> extended Region </em> (or just Region) is a subgraph that can be; /// transform into a simple Region. The transformation is done by adding; /// BasicBlocks that merge several entry or exit edges so that after the merge; /// just one entry and one exit edge exists.; ///; /// The \e Entry of a Region is the first BasicBlock that is passed after; /// entering the Region. It is an element of the Region. The entry BasicBlock; /// dominates all BasicBlocks in the Region.; ///; /// The \e Exit of a Region is the first BasicBlock that is passed after; /// leaving the Region. It is not an element of the Region. The exit BasicBlock,; /// postdominates all BasicBlocks in the Region.; ///; /// A <em> canonical Region </em> cannot be constructed by combining smaller; /// Regions.; ///; /// Region A is the \e parent of Region B, if B is completely contained in A.; ///; /// Two canonical Regions either do not intersect at all or one is; /// the parent of the other.; ///; /// The <em> Program Structure Tree</em> is a graph (V, E) where V is the set of; /// Regions in the control flow graph and E is the \e parent relation of these; /// Regions.; ///; /// Example:; ///; /// \verbatim; /// A simple control flow graph, that contains two regions.; ///; /// 1; /// / |; /// 2 |; /// / \ 3; /// 4 5 |; /// | | |; /// 6 7 8; /// \ | /; /// \ |/ Region A: 1 -> 9 {1,2,3,4,5,6,7,8}; /// 9 Region B: 2 -> 9 {2,4,5,6,7}; /// \endverbatim; ///; /// You can obtain more examples by either calling; ///; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:284,Performance,optimiz,optimize,284,"//===----------------------------------------------------------------------===//; /// A single entry single exit Region.; ///; /// A Region is a connected subgraph of a control flow graph that has exactly; /// two connections to the remaining graph. It can be used to analyze or; /// optimize parts of the control flow graph.; ///; /// A <em> simple Region </em> is connected to the remaining graph by just two; /// edges. One edge entering the Region and another one leaving the Region.; ///; /// An <em> extended Region </em> (or just Region) is a subgraph that can be; /// transform into a simple Region. The transformation is done by adding; /// BasicBlocks that merge several entry or exit edges so that after the merge; /// just one entry and one exit edge exists.; ///; /// The \e Entry of a Region is the first BasicBlock that is passed after; /// entering the Region. It is an element of the Region. The entry BasicBlock; /// dominates all BasicBlocks in the Region.; ///; /// The \e Exit of a Region is the first BasicBlock that is passed after; /// leaving the Region. It is not an element of the Region. The exit BasicBlock,; /// postdominates all BasicBlocks in the Region.; ///; /// A <em> canonical Region </em> cannot be constructed by combining smaller; /// Regions.; ///; /// Region A is the \e parent of Region B, if B is completely contained in A.; ///; /// Two canonical Regions either do not intersect at all or one is; /// the parent of the other.; ///; /// The <em> Program Structure Tree</em> is a graph (V, E) where V is the set of; /// Regions in the control flow graph and E is the \e parent relation of these; /// Regions.; ///; /// Example:; ///; /// \verbatim; /// A simple control flow graph, that contains two regions.; ///; /// 1; /// / |; /// 2 |; /// / \ 3; /// 4 5 |; /// | | |; /// 6 7 8; /// \ | /; /// \ |/ Region A: 1 -> 9 {1,2,3,4,5,6,7,8}; /// 9 Region B: 2 -> 9 {2,4,5,6,7}; /// \endverbatim; ///; /// You can obtain more examples by either calling; ///; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:343,Usability,simpl,simple,343,"//===----------------------------------------------------------------------===//; /// A single entry single exit Region.; ///; /// A Region is a connected subgraph of a control flow graph that has exactly; /// two connections to the remaining graph. It can be used to analyze or; /// optimize parts of the control flow graph.; ///; /// A <em> simple Region </em> is connected to the remaining graph by just two; /// edges. One edge entering the Region and another one leaving the Region.; ///; /// An <em> extended Region </em> (or just Region) is a subgraph that can be; /// transform into a simple Region. The transformation is done by adding; /// BasicBlocks that merge several entry or exit edges so that after the merge; /// just one entry and one exit edge exists.; ///; /// The \e Entry of a Region is the first BasicBlock that is passed after; /// entering the Region. It is an element of the Region. The entry BasicBlock; /// dominates all BasicBlocks in the Region.; ///; /// The \e Exit of a Region is the first BasicBlock that is passed after; /// leaving the Region. It is not an element of the Region. The exit BasicBlock,; /// postdominates all BasicBlocks in the Region.; ///; /// A <em> canonical Region </em> cannot be constructed by combining smaller; /// Regions.; ///; /// Region A is the \e parent of Region B, if B is completely contained in A.; ///; /// Two canonical Regions either do not intersect at all or one is; /// the parent of the other.; ///; /// The <em> Program Structure Tree</em> is a graph (V, E) where V is the set of; /// Regions in the control flow graph and E is the \e parent relation of these; /// Regions.; ///; /// Example:; ///; /// \verbatim; /// A simple control flow graph, that contains two regions.; ///; /// 1; /// / |; /// 2 |; /// / \ 3; /// 4 5 |; /// | | |; /// 6 7 8; /// \ | /; /// \ |/ Region A: 1 -> 9 {1,2,3,4,5,6,7,8}; /// 9 Region B: 2 -> 9 {2,4,5,6,7}; /// \endverbatim; ///; /// You can obtain more examples by either calling; ///; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:593,Usability,simpl,simple,593,"//===----------------------------------------------------------------------===//; /// A single entry single exit Region.; ///; /// A Region is a connected subgraph of a control flow graph that has exactly; /// two connections to the remaining graph. It can be used to analyze or; /// optimize parts of the control flow graph.; ///; /// A <em> simple Region </em> is connected to the remaining graph by just two; /// edges. One edge entering the Region and another one leaving the Region.; ///; /// An <em> extended Region </em> (or just Region) is a subgraph that can be; /// transform into a simple Region. The transformation is done by adding; /// BasicBlocks that merge several entry or exit edges so that after the merge; /// just one entry and one exit edge exists.; ///; /// The \e Entry of a Region is the first BasicBlock that is passed after; /// entering the Region. It is an element of the Region. The entry BasicBlock; /// dominates all BasicBlocks in the Region.; ///; /// The \e Exit of a Region is the first BasicBlock that is passed after; /// leaving the Region. It is not an element of the Region. The exit BasicBlock,; /// postdominates all BasicBlocks in the Region.; ///; /// A <em> canonical Region </em> cannot be constructed by combining smaller; /// Regions.; ///; /// Region A is the \e parent of Region B, if B is completely contained in A.; ///; /// Two canonical Regions either do not intersect at all or one is; /// the parent of the other.; ///; /// The <em> Program Structure Tree</em> is a graph (V, E) where V is the set of; /// Regions in the control flow graph and E is the \e parent relation of these; /// Regions.; ///; /// Example:; ///; /// \verbatim; /// A simple control flow graph, that contains two regions.; ///; /// 1; /// / |; /// 2 |; /// / \ 3; /// 4 5 |; /// | | |; /// 6 7 8; /// \ | /; /// \ |/ Region A: 1 -> 9 {1,2,3,4,5,6,7,8}; /// 9 Region B: 2 -> 9 {2,4,5,6,7}; /// \endverbatim; ///; /// You can obtain more examples by either calling; ///; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:1698,Usability,simpl,simple,1698," /// A <em> simple Region </em> is connected to the remaining graph by just two; /// edges. One edge entering the Region and another one leaving the Region.; ///; /// An <em> extended Region </em> (or just Region) is a subgraph that can be; /// transform into a simple Region. The transformation is done by adding; /// BasicBlocks that merge several entry or exit edges so that after the merge; /// just one entry and one exit edge exists.; ///; /// The \e Entry of a Region is the first BasicBlock that is passed after; /// entering the Region. It is an element of the Region. The entry BasicBlock; /// dominates all BasicBlocks in the Region.; ///; /// The \e Exit of a Region is the first BasicBlock that is passed after; /// leaving the Region. It is not an element of the Region. The exit BasicBlock,; /// postdominates all BasicBlocks in the Region.; ///; /// A <em> canonical Region </em> cannot be constructed by combining smaller; /// Regions.; ///; /// Region A is the \e parent of Region B, if B is completely contained in A.; ///; /// Two canonical Regions either do not intersect at all or one is; /// the parent of the other.; ///; /// The <em> Program Structure Tree</em> is a graph (V, E) where V is the set of; /// Regions in the control flow graph and E is the \e parent relation of these; /// Regions.; ///; /// Example:; ///; /// \verbatim; /// A simple control flow graph, that contains two regions.; ///; /// 1; /// / |; /// 2 |; /// / \ 3; /// 4 5 |; /// | | |; /// 6 7 8; /// \ | /; /// \ |/ Region A: 1 -> 9 {1,2,3,4,5,6,7,8}; /// 9 Region B: 2 -> 9 {2,4,5,6,7}; /// \endverbatim; ///; /// You can obtain more examples by either calling; ///; /// <tt> ""opt -passes='print<regions>' anyprogram.ll"" </tt>; /// or; /// <tt> ""opt -view-regions-only anyprogram.ll"" </tt>; ///; /// on any LLVM file you are interested in.; ///; /// The first call returns a textual representation of the program structure; /// tree, the second one creates a graphical representation using graphviz.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:153,Deployability,update,updates,153,/// Recursively replace the entry basic block of the region.; ///; /// This function replaces the entry basic block with a new basic block. It; /// also updates all child regions that have the same entry basic block as; /// this region.; ///; /// @param NewEntry The new entry basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:151,Deployability,update,updates,151,/// Recursively replace the exit basic block of the region.; ///; /// This function replaces the exit basic block with a new basic block. It; /// also updates all child regions that have the same exit basic block as; /// this region.; ///; /// @param NewExit The new exit basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:14,Usability,simpl,simple,14,/// Is this a simple region?; ///; /// A region is simple if it has exactly one exit and one entry edge.; ///; /// @return True if the Region is simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:51,Usability,simpl,simple,51,/// Is this a simple region?; ///; /// A region is simple if it has exactly one exit and one entry edge.; ///; /// @return True if the Region is simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:145,Usability,simpl,simple,145,/// Is this a simple region?; ///; /// A region is simple if it has exactly one exit and one entry edge.; ///; /// @return True if the Region is simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:143,Availability,avail,available,143,"/// Get the subregion that starts at a BasicBlock; ///; /// @param BB The BasicBlock the subregion should start.; /// @return The Subregion if available, otherwise NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:129,Availability,avail,available,129,"/// Get the RegionNode for a BasicBlock; ///; /// @param BB The BasicBlock at which the RegionNode should start.; /// @return If available, the RegionNode that represents the subregion; /// starting at BB. If no subregion starts at BB, the RegionNode; /// representing BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:14,Performance,cache,cache,14,/// Clear the cache for BB RegionNodes.; ///; /// After calling this function the BasicBlock RegionNodes will be stored at; /// different memory locations. RegionNodes obtained before this function is; /// called are therefore not comparable to RegionNodes abtained afterwords.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:4,Usability,Clear,Clear,4,/// Clear the cache for BB RegionNodes.; ///; /// After calling this function the BasicBlock RegionNodes will be stored at; /// different memory locations. RegionNodes obtained before this function is; /// called are therefore not comparable to RegionNodes abtained afterwords.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:100,Safety,detect,detects,100,//===----------------------------------------------------------------------===//; /// Analysis that detects all canonical Regions.; ///; /// The RegionInfo pass detects all canonical regions in a function. The Regions; /// are connected using the parent relation. This builds a Program Structure; /// Tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:161,Safety,detect,detects,161,//===----------------------------------------------------------------------===//; /// Analysis that detects all canonical Regions.; ///; /// The RegionInfo pass detects all canonical regions in a function. The Regions; /// are connected using the parent relation. This builds a Program Structure; /// Tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:4,Deployability,Update,Update,4,/// Update refences to a RegionInfoT held by the RegionT managed here; ///; /// This is a post-move helper. Regions hold references to the owning; /// RegionInfo object. After a move these need to be fixed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:97,Testability,assert,assertion,97,// Check whether the entries of BBtoRegion for the BBs of region; // SR are correct. Triggers an assertion if not. Calls itself recursively for; // subregions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:80,Modifiability,inherit,inherited,80,"// Returns true if BB is in the dominance frontier of; // entry, because it was inherited from exit. In the other case there is an; // edge going from entry to BB without passing exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:71,Modifiability,extend,extend,71,// Saves a shortcut pointing from entry to exit.; // This function may extend this shortcut if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Safety,Detect,Detect,3,// Detect all regions starting with bb 'entry'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Safety,Detect,Detects,3,// Detects regions in F.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:47,Safety,detect,detected,47,// Build the region hierarchy after all region detected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Deployability,Update,Update,3,// Update statistic about created regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Safety,Detect,Detect,3,// Detect all regions in function and build the region tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:19,Performance,Cache,Cache,19,/// Clear the Node Cache for all Regions.; ///; /// @see Region::clearNodeCache(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:4,Usability,Clear,Clear,4,/// Clear the Node Cache for all Regions.; ///; /// @see Region::clearNodeCache(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:65,Usability,clear,clearNodeCache,65,/// Clear the Node Cache for all Regions.; ///; /// @see Region::clearNodeCache(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Deployability,update,updateStatistics,3,// updateStatistics - Update statistic about created regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:22,Deployability,Update,Update,22,// updateStatistics - Update statistic about created regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:23,Integrability,interface,interface,23,/// @name FunctionPass interface; //@{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:23,Security,expose,exposes,23,/// Analysis pass that exposes the \c RegionInfo for a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:38,Safety,detect,detection,38,"//===- RegionInfoImpl.h - SESE region detection analysis --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Detects single entry single exit regions in the control flow graph.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:379,Safety,Detect,Detects,379,"//===- RegionInfoImpl.h - SESE region detection analysis --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Detects single entry single exit regions in the control flow graph.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:18,Performance,cache,cache,18,// Only clean the cache for this Region. Caches of child Regions will be; // cleaned when the child Regions are deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:41,Performance,Cache,Caches,41,// Only clean the cache for this Region. Caches of child Regions will be; // cleaned when the child Regions are deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:29,Availability,avail,available,29,// No further region at exit available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:153,Safety,detect,detected,153,"// Iterate over the dominance tree in post order to start with the small; // regions from the bottom of the dominance tree. If the small regions are; // detected first, detection of bigger regions is faster, as we can jump; // over the small regions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:169,Safety,detect,detection,169,"// Iterate over the dominance tree in post order to start with the small; // regions from the bottom of the dominance tree. If the small regions are; // detected first, detection of bigger regions is faster, as we can jump; // over the small regions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:135,Deployability,update,updated,135,// This basic block is a start block of a region. It is already in the; // BBtoRegion relation. Only the child basic blocks have to be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:168,Performance,perform,performance,168,// ShortCut a function where for every BB the exit of the largest region; // starting with BB is stored. These regions can be threated as single BBS.; // This improves performance on linear CFGs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:126,Security,threat,threated,126,// ShortCut a function where for every BB the exit of the largest region; // starting with BB is stored. These regions can be threated as single BBS.; // This improves performance on linear CFGs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionIterator.h:134,Testability,assert,assertion,134,"/// Create the iterator from a RegionNode.; ///; /// Note that the incoming node must be a bb node, otherwise it will trigger; /// an assertion when we try to get a BasicBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h:454,Performance,optimiz,optimization,454,"//===- RegionPass.h - RegionPass class --------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegionPass class. All region based analysis,; // optimization and transformation passes are derived from RegionPass.; // This class is implemented following the some ideas of the LoopPass.h class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h:188,Security,Access,Accessing,188,//===--------------------------------------------------------------------===//; /// @name To be implemented by every RegionPass; ///; //@{; /// Run the pass on a specific Region; ///; /// Accessing regions not contained in the current region is not allowed.; ///; /// @param R The region this pass is run on.; /// @param RGM The RegionPassManager that manages this Pass.; ///; /// @return True if the pass modifies this Region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h:111,Performance,optimiz,optimization,111,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when optimization bisect is over the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h:24,Energy Efficiency,schedul,schedule,24,/// The pass manager to schedule RegionPasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h:30,Energy Efficiency,schedul,scheduled,30,/// Execute all of the passes scheduled for execution.; ///; /// @return True if any of the passes modifies the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPrinter.h:50,Integrability,interface,interface,50,"//===-- RegionPrinter.h - Region printer external interface -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines external functions that can be called to explicitly; // instantiate the region printer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:7,Deployability,Release,ReleaseModeModelRunner,7,"//===- ReleaseModeModelRunner.h - Fast, precompiled model runner ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a model runner wrapping an AOT compiled ML model.; // Only inference is supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:418,Integrability,wrap,wrapping,418,"//===- ReleaseModeModelRunner.h - Fast, precompiled model runner ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a model runner wrapping an AOT compiled ML model.; // Only inference is supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:4,Deployability,Release,ReleaseModeModelRunner,4,/// ReleaseModeModelRunner - production mode implementation of the; /// MLModelRunner. It uses an AOT-compiled SavedModel for efficient execution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:126,Energy Efficiency,efficient,efficient,126,/// ReleaseModeModelRunner - production mode implementation of the; /// MLModelRunner. It uses an AOT-compiled SavedModel for efficient execution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:54,Deployability,Release,ReleaseModeModelRunner,54,"/// A mock class satisfying the interface expected by ReleaseModeModelRunner for; /// its `TGen` parameter. Useful to avoid conditional compilation complexity, as; /// a compile-time replacement for a real AOT-ed model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:32,Integrability,interface,interface,32,"/// A mock class satisfying the interface expected by ReleaseModeModelRunner for; /// its `TGen` parameter. Useful to avoid conditional compilation complexity, as; /// a compile-time replacement for a real AOT-ed model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:118,Safety,avoid,avoid,118,"/// A mock class satisfying the interface expected by ReleaseModeModelRunner for; /// its `TGen` parameter. Useful to avoid conditional compilation complexity, as; /// a compile-time replacement for a real AOT-ed model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:6,Testability,mock,mock,6,"/// A mock class satisfying the interface expected by ReleaseModeModelRunner for; /// its `TGen` parameter. Useful to avoid conditional compilation complexity, as; /// a compile-time replacement for a real AOT-ed model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h:53,Integrability,interface,interface,53,"//===- ReplayInlineAdvisor.h - Replay Inline Advisor interface -*- C++ --*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h:36,Performance,optimiz,optimization,36,/// Replay inline advisor that uses optimization remarks from inlining of; /// previous build to guide current inlining. This is useful for inliner tuning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h:97,Usability,guid,guide,97,/// Replay inline advisor that uses optimization remarks from inlining of; /// previous build to guide current inlining. This is useful for inliner tuning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:554,Modifiability,variab,variables,554,"//===- llvm/Analysis/ScalarEvolution.h - Scalar Evolution -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The ScalarEvolution class is an LLVM pass which can be used to analyze and; // categorize scalar expressions in loops. It specializes in recognizing; // general induction variables, representing them with the abstract and opaque; // SCEV class. Given this analysis, trip counts of loops and other important; // properties can be obtained.; //; // This analysis is primarily useful for induction variable substitution and; // strength reduction.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:778,Modifiability,variab,variable,778,"//===- llvm/Analysis/ScalarEvolution.h - Scalar Evolution -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The ScalarEvolution class is an LLVM pass which can be used to analyze and; // categorize scalar expressions in loops. It specializes in recognizing; // general induction variables, representing them with the abstract and opaque; // SCEV class. Given this analysis, trip counts of loops and other important; // properties can be obtained.; //; // This analysis is primarily useful for induction variable substitution and; // strength reduction.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:111,Integrability,wrap,wrap,111,"/// NoWrapFlags are bitfield indices into SubclassData.; ///; /// Add and Mul expressions may have no-unsigned-wrap <NUW> or; /// no-signed-wrap <NSW> properties, which are derived from the IR; /// operator. NSW is a misnomer that we use to mean no signed overflow or; /// underflow.; ///; /// AddRec expressions may have a no-self-wraparound <NW> property if, in; /// the integer domain, abs(step) * max-iteration(loop) <=; /// unsigned-max(bitwidth). This means that the recurrence will never reach; /// its start value if the step is non-zero. Computing the same value on; /// each iteration is not considered wrapping, and recurrences with step = 0; /// are trivially <NW>. <NW> is independent of the sign of step and the; /// value the add recurrence starts with.; ///; /// Note that NUW and NSW are also valid properties of a recurrence, and; /// either implies NW. For convenience, NW will be set for a recurrence; /// whenever either NUW or NSW are set.; ///; /// We require that the flag on a SCEV apply to the entire scope in which; /// that SCEV is defined. A SCEV's scope is set of locations dominated by; /// a defining location, which is in turn described by the following rules:; /// * A SCEVUnknown is at the point of definition of the Value.; /// * A SCEVConstant is defined at all points.; /// * A SCEVAddRec is defined starting with the header of the associated; /// loop.; /// * All other SCEVs are defined at the earlest point all operands are; /// defined.; ///; /// The above rules describe a maximally hoisted form (without regards to; /// potential control dependence). A SCEV is defined anywhere a; /// corresponding instruction could be defined in said maximally hoisted; /// form. Note that SCEVUDivExpr (currently the only expression type which; /// can trap) can be defined per these rules in regions where it would trap; /// at runtime. A SCEV being defined does not require the existence of any; /// instruction within the defined scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:140,Integrability,wrap,wrap,140,"/// NoWrapFlags are bitfield indices into SubclassData.; ///; /// Add and Mul expressions may have no-unsigned-wrap <NUW> or; /// no-signed-wrap <NSW> properties, which are derived from the IR; /// operator. NSW is a misnomer that we use to mean no signed overflow or; /// underflow.; ///; /// AddRec expressions may have a no-self-wraparound <NW> property if, in; /// the integer domain, abs(step) * max-iteration(loop) <=; /// unsigned-max(bitwidth). This means that the recurrence will never reach; /// its start value if the step is non-zero. Computing the same value on; /// each iteration is not considered wrapping, and recurrences with step = 0; /// are trivially <NW>. <NW> is independent of the sign of step and the; /// value the add recurrence starts with.; ///; /// Note that NUW and NSW are also valid properties of a recurrence, and; /// either implies NW. For convenience, NW will be set for a recurrence; /// whenever either NUW or NSW are set.; ///; /// We require that the flag on a SCEV apply to the entire scope in which; /// that SCEV is defined. A SCEV's scope is set of locations dominated by; /// a defining location, which is in turn described by the following rules:; /// * A SCEVUnknown is at the point of definition of the Value.; /// * A SCEVConstant is defined at all points.; /// * A SCEVAddRec is defined starting with the header of the associated; /// loop.; /// * All other SCEVs are defined at the earlest point all operands are; /// defined.; ///; /// The above rules describe a maximally hoisted form (without regards to; /// potential control dependence). A SCEV is defined anywhere a; /// corresponding instruction could be defined in said maximally hoisted; /// form. Note that SCEVUDivExpr (currently the only expression type which; /// can trap) can be defined per these rules in regions where it would trap; /// at runtime. A SCEV being defined does not require the existence of any; /// instruction within the defined scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:332,Integrability,wrap,wraparound,332,"/// NoWrapFlags are bitfield indices into SubclassData.; ///; /// Add and Mul expressions may have no-unsigned-wrap <NUW> or; /// no-signed-wrap <NSW> properties, which are derived from the IR; /// operator. NSW is a misnomer that we use to mean no signed overflow or; /// underflow.; ///; /// AddRec expressions may have a no-self-wraparound <NW> property if, in; /// the integer domain, abs(step) * max-iteration(loop) <=; /// unsigned-max(bitwidth). This means that the recurrence will never reach; /// its start value if the step is non-zero. Computing the same value on; /// each iteration is not considered wrapping, and recurrences with step = 0; /// are trivially <NW>. <NW> is independent of the sign of step and the; /// value the add recurrence starts with.; ///; /// Note that NUW and NSW are also valid properties of a recurrence, and; /// either implies NW. For convenience, NW will be set for a recurrence; /// whenever either NUW or NSW are set.; ///; /// We require that the flag on a SCEV apply to the entire scope in which; /// that SCEV is defined. A SCEV's scope is set of locations dominated by; /// a defining location, which is in turn described by the following rules:; /// * A SCEVUnknown is at the point of definition of the Value.; /// * A SCEVConstant is defined at all points.; /// * A SCEVAddRec is defined starting with the header of the associated; /// loop.; /// * All other SCEVs are defined at the earlest point all operands are; /// defined.; ///; /// The above rules describe a maximally hoisted form (without regards to; /// potential control dependence). A SCEV is defined anywhere a; /// corresponding instruction could be defined in said maximally hoisted; /// form. Note that SCEVUDivExpr (currently the only expression type which; /// can trap) can be defined per these rules in regions where it would trap; /// at runtime. A SCEV being defined does not require the existence of any; /// instruction within the defined scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:613,Integrability,wrap,wrapping,613,"/// NoWrapFlags are bitfield indices into SubclassData.; ///; /// Add and Mul expressions may have no-unsigned-wrap <NUW> or; /// no-signed-wrap <NSW> properties, which are derived from the IR; /// operator. NSW is a misnomer that we use to mean no signed overflow or; /// underflow.; ///; /// AddRec expressions may have a no-self-wraparound <NW> property if, in; /// the integer domain, abs(step) * max-iteration(loop) <=; /// unsigned-max(bitwidth). This means that the recurrence will never reach; /// its start value if the step is non-zero. Computing the same value on; /// each iteration is not considered wrapping, and recurrences with step = 0; /// are trivially <NW>. <NW> is independent of the sign of step and the; /// value the add recurrence starts with.; ///; /// Note that NUW and NSW are also valid properties of a recurrence, and; /// either implies NW. For convenience, NW will be set for a recurrence; /// whenever either NUW or NSW are set.; ///; /// We require that the flag on a SCEV apply to the entire scope in which; /// that SCEV is defined. A SCEV's scope is set of locations dominated by; /// a defining location, which is in turn described by the following rules:; /// * A SCEVUnknown is at the point of definition of the Value.; /// * A SCEVConstant is defined at all points.; /// * A SCEVAddRec is defined starting with the header of the associated; /// loop.; /// * All other SCEVs are defined at the earlest point all operands are; /// defined.; ///; /// The above rules describe a maximally hoisted form (without regards to; /// potential control dependence). A SCEV is defined anywhere a; /// corresponding instruction could be defined in said maximally hoisted; /// form. Note that SCEVUDivExpr (currently the only expression type which; /// can trap) can be defined per these rules in regions where it would trap; /// at runtime. A SCEV being defined does not require the existence of any; /// instruction within the defined scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:1582,Integrability,depend,dependence,1582,"/// NoWrapFlags are bitfield indices into SubclassData.; ///; /// Add and Mul expressions may have no-unsigned-wrap <NUW> or; /// no-signed-wrap <NSW> properties, which are derived from the IR; /// operator. NSW is a misnomer that we use to mean no signed overflow or; /// underflow.; ///; /// AddRec expressions may have a no-self-wraparound <NW> property if, in; /// the integer domain, abs(step) * max-iteration(loop) <=; /// unsigned-max(bitwidth). This means that the recurrence will never reach; /// its start value if the step is non-zero. Computing the same value on; /// each iteration is not considered wrapping, and recurrences with step = 0; /// are trivially <NW>. <NW> is independent of the sign of step and the; /// value the add recurrence starts with.; ///; /// Note that NUW and NSW are also valid properties of a recurrence, and; /// either implies NW. For convenience, NW will be set for a recurrence; /// whenever either NUW or NSW are set.; ///; /// We require that the flag on a SCEV apply to the entire scope in which; /// that SCEV is defined. A SCEV's scope is set of locations dominated by; /// a defining location, which is in turn described by the following rules:; /// * A SCEVUnknown is at the point of definition of the Value.; /// * A SCEVConstant is defined at all points.; /// * A SCEVAddRec is defined starting with the header of the associated; /// loop.; /// * All other SCEVs are defined at the earlest point all operands are; /// defined.; ///; /// The above rules describe a maximally hoisted form (without regards to; /// potential control dependence). A SCEV is defined anywhere a; /// corresponding instruction could be defined in said maximally hoisted; /// form. Note that SCEVUDivExpr (currently the only expression type which; /// can trap) can be defined per these rules in regions where it would trap; /// at runtime. A SCEV being defined does not require the existence of any; /// instruction within the defined scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:11,Integrability,wrap,wrap,11,// No self-wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:15,Integrability,wrap,wrap,15,// No unsigned wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:13,Integrability,wrap,wrap,13,// No signed wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:469,Performance,perform,performing,469,"// Returns estimated size of the mathematical expression represented by this; // SCEV. The rules of its calculation are following:; // 1) Size of a SCEV without operands (like constants and SCEVUnknown) is 1;; // 2) Size SCEV with operands Op1, Op2, ..., OpN is calculated by formula:; // (1 + Size(Op1) + ... + Size(OpN)).; // This value gives us an estimation of time we need to traverse through this; // SCEV and all its operands recursively. We may use it to avoid performing; // heavy transformations on SCEVs of excessive size for sake of saving the; // compilation time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:463,Safety,avoid,avoid,463,"// Returns estimated size of the mathematical expression represented by this; // SCEV. The rules of its calculation are following:; // 1) Size of a SCEV without operands (like constants and SCEVUnknown) is 1;; // 2) Size SCEV with operands Op1, Op2, ..., OpN is calculated by formula:; // (1 + Size(Op1) + ... + Size(OpN)).; // This value gives us an estimation of time we need to traverse through this; // SCEV and all its operands recursively. We may use it to avoid performing; // heavy transformations on SCEVs of excessive size for sake of saving the; // compilation time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:42,Safety,avoid,avoid,42,// Specialize FoldingSetTrait for SCEV to avoid needing to compute; // temporary FoldingSetNodeID values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:51,Safety,avoid,avoid,51,// Specialize FoldingSetTrait for SCEVPredicate to avoid needing to compute; // temporary FoldingSetNodeID values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:40,Integrability,interface,interface,40,/// Implementation of the SCEVPredicate interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:593,Integrability,wrap,wrap,593,"/// This class represents an assumption made on an AddRec expression. Given an; /// affine AddRec expression {a,+,b}, we assume that it has the nssw or nusw; /// flags (defined below) in the first X iterations of the loop, where X is a; /// SCEV expression returned by getPredicatedBackedgeTakenCount).; ///; /// Note that this does not imply that X is equal to the backedge taken; /// count. This means that if we have a nusw predicate for i32 {0,+,1} with a; /// predicated backedge taken count of X, we only guarantee that {0,+,1} has; /// nusw in the first X iterations. {0,+,1} may still wrap in the loop if we; /// have more than X iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:192,Integrability,wrap,wrap,192,"/// Similar to SCEV::NoWrapFlags, but with slightly different semantics; /// for FlagNUSW. The increment is considered to be signed, and a + b; /// (where b is the increment) is considered to wrap if:; /// zext(a + b) != zext(a) + sext(b); ///; /// If Signed is a function that takes an n-bit tuple and maps to the; /// integer domain as the tuples value interpreted as twos complement,; /// and Unsigned a function that takes an n-bit tuple and maps to the; /// integer domain as the base two value of input tuple, then a + b; /// has IncrementNUSW iff:; ///; /// 0 <= Unsigned(a) + Signed(b) < 2^n; ///; /// The IncrementNSSW flag has identical semantics with SCEV::FlagNSW.; ///; /// Note that the IncrementNUSW flag is not commutative: if base + inc; /// has IncrementNUSW, then inc + base doesn't neccessarily have this; /// property. The reason for this is that this is used for sign/zero; /// extending affine AddRec SCEV expressions when a SCEVWrapPredicate is; /// assumed. A {base,+,inc} expression is already non-commutative with; /// regards to base and inc, since it is interpreted as:; /// (((base + inc) + inc) + inc) ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:900,Modifiability,extend,extending,900,"/// Similar to SCEV::NoWrapFlags, but with slightly different semantics; /// for FlagNUSW. The increment is considered to be signed, and a + b; /// (where b is the increment) is considered to wrap if:; /// zext(a + b) != zext(a) + sext(b); ///; /// If Signed is a function that takes an n-bit tuple and maps to the; /// integer domain as the tuples value interpreted as twos complement,; /// and Unsigned a function that takes an n-bit tuple and maps to the; /// integer domain as the base two value of input tuple, then a + b; /// has IncrementNUSW iff:; ///; /// 0 <= Unsigned(a) + Signed(b) < 2^n; ///; /// The IncrementNSSW flag has identical semantics with SCEV::FlagNSW.; ///; /// Note that the IncrementNUSW flag is not commutative: if base + inc; /// has IncrementNUSW, then inc + base doesn't neccessarily have this; /// property. The reason for this is that this is used for sign/zero; /// extending affine AddRec SCEV expressions when a SCEVWrapPredicate is; /// assumed. A {base,+,inc} expression is already non-commutative with; /// regards to base and inc, since it is interpreted as:; /// (((base + inc) + inc) + inc) ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:37,Integrability,wrap,wrap,37,// No unsigned with signed increment wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:35,Integrability,wrap,wrap,35,// No signed with signed increment wrap; // (equivalent with SCEV::NSW),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:44,Integrability,wrap,wrap,44,/// Returns the set of SCEVWrapPredicate no wrap flags implied by a; /// SCEVAddRecExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:40,Integrability,interface,interface,40,/// Implementation of the SCEVPredicate interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:155,Testability,log,logical,155,"/// This class represents a composition of other SCEV predicates, and is the; /// class that most clients will interact with. This is equivalent to a; /// logical ""AND"" of all the predicates in the union.; ///; /// NB! Unlike other SCEVPredicate sub-classes this class does not live in the; /// ScalarEvolution::Preds folding set. This is why the \c add function is sound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:40,Integrability,interface,interface,40,/// Implementation of the SCEVPredicate interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:21,Safety,predict,predictably,21,///< The SCEV varies predictably with the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:205,Security,access,access,205,"/// Test if values of the given type are analyzable within the SCEV; /// framework. This primarily includes integer types, and it can optionally; /// include pointer types if the ScalarEvolution class has access to; /// target-specific information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test if values of the given type are analyzable within the SCEV; /// framework. This primarily includes integer types, and it can optionally; /// include pointer types if the ScalarEvolution class has access to; /// target-specific information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:399,Performance,load,load,399,"/// Return true if there exists a point in the program at which both; /// A and B could be operands to the same instruction.; /// SCEV expressions are generally assumed to correspond to instructions; /// which could exists in IR. In general, this requires that there exists; /// a use point in the program where all operands dominate the use.; ///; /// Example:; /// loop {; /// if; /// loop { v1 = load @global1; }; /// else; /// loop { v2 = load @global2; }; /// }; /// No SCEV with operand V1, and v2 can exist in this program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:443,Performance,load,load,443,"/// Return true if there exists a point in the program at which both; /// A and B could be operands to the same instruction.; /// SCEV expressions are generally assumed to correspond to instructions; /// which could exists in IR. In general, this requires that there exists; /// a use point in the program where all operands dominate the use.; ///; /// Example:; /// loop {; /// if; /// loop { v1 = load @global1; }; /// else; /// loop { v2 = load @global2; }; /// }; /// No SCEV with operand V1, and v2 can exist in this program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:99,Performance,cache,cached,99,/// Return true if the SCEV is a scAddRecExpr or it contains; /// scAddRecExpr. The result will be cached in HasRecMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:85,Integrability,wrap,wrap,85,"/// Parse NSW/NUW flags from add/sub/mul IR binary operation \p Op into; /// SCEV no-wrap flags, and deduce flag[s] that aren't known yet.; /// Does not mutate the original instruction. Returns std::nullopt if it could; /// not deduce more precise flags than the instruction already has, otherwise; /// returns proven flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:284,Modifiability,rewrite,rewrites,284,"/// Checks if \p SymbolicPHI can be rewritten as an AddRecExpr under some; /// Predicates. If successful return these <AddRecExpr, Predicates>;; /// The function is intended to be called from PSCEV (the caller will decide; /// whether to actually add the predicates and carry out the rewrites).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:38,Energy Efficiency,Power,Power,38,/// Return a SCEV for the constant \p Power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:115,Modifiability,extend,extended,115,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:136,Modifiability,extend,extended,136,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:115,Modifiability,extend,extended,115,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:136,Modifiability,extend,extended,136,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:115,Modifiability,extend,extended,115,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is zero extended. The; /// conversion must not be narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:136,Modifiability,extend,extended,136,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is zero extended. The; /// conversion must not be narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:115,Modifiability,extend,extended,115,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is sign extended. The; /// conversion must not be narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:136,Modifiability,extend,extended,136,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is sign extended. The; /// conversion must not be narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:115,Modifiability,extend,extended,115,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is extended with; /// unspecified bits. The conversion must not be narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:131,Modifiability,extend,extended,131,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is extended with; /// unspecified bits. The conversion must not be narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:87,Performance,perform,perform,87,"/// Promote the operands to the wider of the types using zero-extension, and; /// then perform a umax operation with them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:87,Performance,perform,perform,87,"/// Promote the operands to the wider of the types using zero-extension, and; /// then perform a umin operation with them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:87,Performance,perform,perform,87,"/// Promote the operands to the wider of the types using zero-extension, and; /// then perform a umin operation with them. N-ary function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:321,Modifiability,variab,variable,321,"/// Return a SCEV expression for the specified value at the specified scope; /// in the program. The L value specifies a loop nest to evaluate the; /// expression at, where null is the top-level or a specified loop is; /// immediately inside of the loop.; ///; /// This method can be used to compute the exit value for a variable defined; /// in a loop by querying what the value will hold in the parent loop.; ///; /// In the case that a relevant loop exit value cannot be computed, the; /// original value V is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:112,Safety,avoid,avoid,112,"/// Test whether entry to the loop is protected by a conditional between LHS; /// and RHS. This is used to help avoid max expressions in loop trip; /// counts, and to eliminate casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether entry to the loop is protected by a conditional between LHS; /// and RHS. This is used to help avoid max expressions in loop trip; /// counts, and to eliminate casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test whether entry to the basic block is protected by a conditional; /// between LHS and RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test whether the backedge of the loop is protected by a conditional; /// between LHS and RHS. This is used to eliminate casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:437,Integrability,wrap,wraps,437,"/// Convert from an ""exit count"" (i.e. ""backedge taken count"") to a ""trip; /// count"". A ""trip count"" is the number of times the header of the loop; /// will execute if an exit is taken after the specified number of backedges; /// have been taken. (e.g. TripCount = ExitCount + 1). Note that the; /// expression can overflow if ExitCount = UINT_MAX. If EvalTy is not wide; /// enough to hold the result without overflow, result unsigned wraps with; /// 2s-complement semantics. ex: EC = 255 (i8), TC = 0 (i8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:203,Usability,simpl,simply,203,"/// Returns the exact trip count of the loop if we can compute it, and; /// the result is a small constant. '0' is used to represent an unknown; /// or non-constant trip count. Note that a trip count is simply one more; /// than the backedge taken count for the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:179,Usability,simpl,simply,179,"/// Return the exact trip count for this loop if we exit through ExitingBlock.; /// '0' is used to represent an unknown or non-constant trip count. Note; /// that a trip count is simply one more than the backedge taken count for; /// the same exit.; /// This ""trip count"" assumes that control exits via ExitingBlock. More; /// precisely, it is the number of times that control will reach ExitingBlock; /// before taking the branch. For loops with multiple exits, it may not be; /// the number times that the loop header executes if the loop exits; /// prematurely via another branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:32,Safety,predict,predictable,32,"/// If the specified loop has a predictable backedge-taken count, return it,; /// otherwise return a SCEVCouldNotCompute object. The backedge-taken count is; /// the number of times the loop header will be branched to from within the; /// loop, assuming there are no abnormal exists like exception throws. This is; /// one less than the trip count of the loop, since it doesn't count the first; /// iteration, when the header is branched to from outside the loop.; ///; /// Note that it is not valid to call this method on a loop without a; /// loop-invariant backedge-taken count (see; /// hasLoopInvariantBackedgeTakenCount).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:245,Performance,perform,perform,245,"/// Similar to getBackedgeTakenCount, except it will add a set of; /// SCEV predicates to Predicates that are required to be true in order for; /// the answer to be correct. Predicates can be checked with run-time; /// checks and can be used to perform loop versioning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:151,Usability,Clear,Clear,151,/// Called when the client has changed the disposition of values in; /// this loop.; ///; /// We don't have a way to invalidate per-loop dispositions. Clear and; /// recompute is simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:179,Usability,simpl,simpler,179,/// Called when the client has changed the disposition of values in; /// this loop.; ///; /// We don't have a way to invalidate per-loop dispositions. Clear and; /// recompute is simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:167,Usability,Clear,Clear,167,/// Called when the client has changed the disposition of values in; /// a loop or block.; ///; /// We don't have a way to invalidate per-loop/per-block dispositions. Clear; /// and recompute is simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:195,Usability,simpl,simpler,195,/// Called when the client has changed the disposition of values in; /// a loop or block.; ///; /// We don't have a way to invalidate per-loop/per-block dispositions. Clear; /// and recompute is simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test if the given expression is known to be negative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test if the given expression is known to be positive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test if the given expression is known to be non-negative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test if the given expression is known to be non-positive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test if the given expression is known to be non-zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:827,Availability,avail,available,827,"/// We'd like to check the predicate on every iteration of the most dominated; /// loop between loops used in LHS and RHS.; /// To do this we use the following list of steps:; /// 1. Collect set S all loops on which either LHS or RHS depend.; /// 2. If S is non-empty; /// a. Let PD be the element of S which is dominated by all other elements.; /// b. Let E(LHS) be value of LHS on entry of PD.; /// To get E(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their entry values.; /// Define E(RHS) in the same way.; /// c. Let B(LHS) be value of L on backedge of PD.; /// To get B(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their backedge values.; /// Define B(RHS) in the same way.; /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,; /// so we can assert on that.; /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&; /// isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:234,Integrability,depend,depend,234,"/// We'd like to check the predicate on every iteration of the most dominated; /// loop between loops used in LHS and RHS.; /// To do this we use the following list of steps:; /// 1. Collect set S all loops on which either LHS or RHS depend.; /// 2. If S is non-empty; /// a. Let PD be the element of S which is dominated by all other elements.; /// b. Let E(LHS) be value of LHS on entry of PD.; /// To get E(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their entry values.; /// Define E(RHS) in the same way.; /// c. Let B(LHS) be value of L on backedge of PD.; /// To get B(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their backedge values.; /// Define B(RHS) in the same way.; /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,; /// so we can assert on that.; /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&; /// isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:868,Testability,assert,assert,868,"/// We'd like to check the predicate on every iteration of the most dominated; /// loop between loops used in LHS and RHS.; /// To do this we use the following list of steps:; /// 1. Collect set S all loops on which either LHS or RHS depend.; /// 2. If S is non-empty; /// a. Let PD be the element of S which is dominated by all other elements.; /// b. Let E(LHS) be value of LHS on entry of PD.; /// To get E(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their entry values.; /// Define E(RHS) in the same way.; /// c. Let B(LHS) be value of L on backedge of PD.; /// To get B(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their backedge values.; /// Define B(RHS) in the same way.; /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,; /// so we can assert on that.; /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&; /// isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test if the given expression is known to satisfy the condition described; /// by Pred, LHS, and RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test if the given expression is known to satisfy the condition described; /// by Pred, LHS, and RHS in the given Context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test if the condition described by Pred, LHS, RHS is known to be true on; /// every iteration of the loop of the recurrency LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:167,Testability,assert,asserts,167,"/// Construct either an exact exit limit from a constant, or an unknown; /// one from a SCEVCouldNotCompute. No other types of SCEVs are allowed; /// as arguments and asserts enforce that internally.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether this ExitLimit contains any computed information, or; /// whether it's all SCEVCouldNotCompute values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test whether this ExitLimit contains all information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:395,Integrability,wrap,wraparound,395,"/// Compute the number of times the backedge of the specified loop will; /// execute if its exit condition were a conditional branch of ExitCond.; ///; /// \p ControlsOnlyExit is true if ExitCond directly controls the only exit; /// branch. In this case, we can assume that the loop exits only if the; /// condition is true and can infer that failing to meet the condition prior; /// to integer wraparound results in undefined behavior.; ///; /// If \p AllowPredicates is set, this call will try to use a minimal set of; /// SCEV predicates in order to return an exact answer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:164,Availability,avail,available,164,"/// If the result of the predicate LHS `Pred` RHS is loop invariant with; /// respect to L, return a LoopInvariantPredicate with LHS and RHS being; /// invariants, available at L's entry. Otherwise, return std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:227,Availability,avail,available,227,"/// If the result of the predicate LHS `Pred` RHS is loop invariant with; /// respect to L at given Context during at least first MaxIter iterations,; /// return a LoopInvariantPredicate with LHS and RHS being invariants,; /// available at L's entry. Otherwise, return std::nullopt. The predicate; /// should be the loop's exit condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Usability,Simpl,Simplify,4,"/// Simplify LHS and RHS in a comparison with predicate Pred. Return true; /// iff any changes were made. If the operands are provably equal or; /// unequal, LHS and RHS are set to the same value and Pred is set to either; /// ICMP_EQ or ICMP_NE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:90,Integrability,depend,depend,90,/// Determine if the SCEV can be evaluated at loop's entry. It is true if it; /// doesn't depend on a SCEVUnknown of an instruction which is dominated by; /// the header of loop L.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test whether the given SCEV has Op as a direct or indirect operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Deployability,Update,Update,4,/// Update no-wrap flags of an AddRec. This may drop the cached info about; /// this AddRec (such as range info) in case if new flags may potentially; /// sharpen it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:14,Integrability,wrap,wrap,14,/// Update no-wrap flags of an AddRec. This may drop the cached info about; /// this AddRec (such as range info) in case if new flags may potentially; /// sharpen it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:57,Performance,cache,cached,57,/// Update no-wrap flags of an AddRec. This may drop the cached info about; /// this AddRec (such as range info) in case if new flags may potentially; /// sharpen it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:121,Performance,perform,performed,121,"/// Check whether it is poison-safe to represent the expression S using the; /// instruction I. If such a replacement is performed, the poison flags of; /// instructions in DropPoisonGeneratingInsts must be dropped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:31,Safety,safe,safe,31,"/// Check whether it is poison-safe to represent the expression S using the; /// instruction I. If such a replacement is performed, the poison flags of; /// instructions in DropPoisonGeneratingInsts must be dropped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:110,Safety,avoid,avoid,110,"/// Does the module have any calls to the llvm.experimental.guard intrinsic; /// at all? If this is false, we avoid doing work that will only help if; /// thare are guards present in the IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:14,Performance,cache,cache,14,/// This is a cache to record whether a SCEV contains any scAddRecExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:14,Performance,cache,cache,14,/// This is a cache of the values we have analyzed so far.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:14,Performance,cache,cache,14,/// This is a cache for expressions that got folded to a different existing; /// SCEV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether this BackedgeTakenInfo contains any computed information,; /// or whether it's all SCEVCouldNotCompute values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test whether this BackedgeTakenInfo contains complete information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Performance,Cache,Cache,4,/// Cache the backedge-taken count of the loops for this function as they; /// are computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Performance,Cache,Cache,4,/// Cache the predicated backedge-taken count of the loops for this; /// function as they are computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:137,Safety,avoid,avoid,137,/// This map contains entries for all of the PHI instructions that we; /// attempt to compute constant evolutions for. This allows us to avoid; /// potentially expensive recomputation of these properties. An instruction; /// maps to null if we are unable to compute its exit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:136,Security,access,access,136,"/// Set to true if the loop contains no instruction that can have side; /// effects (i.e. via throwing an exception, volatile or atomic access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Performance,Cache,Cache,4,/// Cache for \c getLoopProperties.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:12,Modifiability,parameteriz,parameterize,12,/// Used to parameterize getRange,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:100,Performance,cache,cache,100,/// Determine the range for a particular SCEV.; /// NOTE: This returns a reference to an entry in a cache. It must be; /// copied if its needed for longer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:49,Integrability,wrap,wrapping,49,"/// Determines the range for the affine non-self-wrapping SCEVAddRecExpr {\p; /// Start,+,\p Step}<nw>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:49,Usability,simpl,simple,49,"/// If the unknown expression U corresponds to a simple recurrence, return; /// a constant range which represents the entire recurrence. Note that; /// *add* recurrences with loop invariant steps aren't represented by; /// SCEVUnknowns and thus don't use this mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:56,Usability,simpl,simple,56,/// A helper function for createAddRecFromPHI to handle simple cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:52,Safety,avoid,avoid,52,// Helper functions for computeExitLimitFromCond to avoid exponential time; // complexity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:326,Testability,assert,assert,326,"// It may look like we need key on the whole (L, ExitIfTrue,; // ControlsOnlyExit, AllowPredicates) tuple, but recursive calls to; // computeExitLimitFromCondCached from computeExitLimitFromCondImpl only; // vary the in \c ExitCond and \c ControlsOnlyExit parameters. We remember; // the initial values of the other values to assert our assumption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:83,Modifiability,evolve,evolves,83,"/// If the loop is known to execute a constant number of times (the; /// condition evolves only from constants), try to evaluate a few iterations; /// of the loop until we get the exit condition gets a value of ExitWhen; /// (true or false). If we cannot evaluate the exit count of the loop,; /// return CouldNotCompute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the given FoundCondValue value evaluates to true in given; /// Context. If Context is nullptr, then the found predicate is true; /// everywhere. LHS and FoundLHS may have different type width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the given FoundCondValue value evaluates to true in given; /// Context. If Context is nullptr, then the found predicate is true; /// everywhere. LHS and FoundLHS must have same type width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by FoundPred, FoundLHS, FoundRHS is; /// true in given Context. If Context is nullptr, then the found predicate is; /// true everywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true in given Context. If Context is nullptr, then the found predicate is; /// true everywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true. Here LHS is an operation that includes FoundLHS as one of its; /// arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true.; /// Use only simple non-recursive types of checks, such as range analysis etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:86,Usability,simpl,simple,86,"/// Test whether the condition described by Pred, LHS, and RHS is true.; /// Use only simple non-recursive types of checks, such as range analysis etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true. Utility function used by isImpliedCondOperands. Tries to get; /// cases like ""X `sgt` 0 => X - 1 `sgt` -1"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:170,Integrability,rout,routine,170,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to rule out certain kinds of integer overflow, and; /// then tries to reason about arithmetic properties of the predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to rule out certain kinds of integer overflow, and; /// then tries to reason about arithmetic properties of the predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:170,Integrability,rout,routine,170,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to weaken the known condition basing on fact that; /// FoundLHS is an AddRec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to weaken the known condition basing on fact that; /// FoundLHS is an AddRec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:170,Integrability,rout,routine,170,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to figure out predicate for Phis which are SCEVUnknown; /// if it is true for every possible incoming value from their respective; /// basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to figure out predicate for Phis which are SCEVUnknown; /// if it is true for every possible incoming value from their respective; /// basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:170,Integrability,rout,routine,170,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to reason about shifts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to reason about shifts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test if the given expression is known to satisfy the condition described; /// by Pred and the known constant ranges of LHS and RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:35,Testability,log,logical,35,/// Try to split Pred LHS RHS into logical conjunctions (and's) and try to; /// prove them individually.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:196,Integrability,wrap,wrap,196,"/// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be; /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}. This is; /// equivalent to proving no signed (resp. unsigned) wrap in; /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`; /// (resp. `SCEVZeroExtendExpr`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:20,Modifiability,Extend,ExtendOpTy,20,"/// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be; /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}. This is; /// equivalent to proving no signed (resp. unsigned) wrap in; /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`; /// (resp. `SCEVZeroExtendExpr`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:88,Modifiability,Extend,ExtendOpTy,88,"/// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be; /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}. This is; /// equivalent to proving no signed (resp. unsigned) wrap in; /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`; /// (resp. `SCEVZeroExtendExpr`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:112,Modifiability,Extend,ExtendOpTy,112,"/// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be; /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}. This is; /// equivalent to proving no signed (resp. unsigned) wrap in; /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`; /// (resp. `SCEVZeroExtendExpr`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:232,Modifiability,Extend,ExtendOpTy,232,"/// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be; /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}. This is; /// equivalent to proving no signed (resp. unsigned) wrap in; /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`; /// (resp. `SCEVZeroExtendExpr`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:19,Integrability,wrap,wrap,19,/// Return SCEV no-wrap flags that can be proven based on reasoning about; /// how poison produced from no-wrap flags on this value (e.g. a nuw add); /// would trigger undefined behavior on overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:107,Integrability,wrap,wrap,107,/// Return SCEV no-wrap flags that can be proven based on reasoning about; /// how poison produced from no-wrap flags on this value (e.g. a nuw add); /// would trigger undefined behavior on overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper around the above for cases which don't care if the bound; /// is precise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:425,Performance,cache,caches,425,"/// Similar to createAddRecFromPHI, but with the additional flexibility of; /// suggesting runtime overflow checks in case casts are encountered.; /// If successful, the analysis records that for this loop, \p SymbolicPHI,; /// which is the UnknownSCEV currently representing the PHI, can be rewritten; /// into an AddRec, assuming some predicates; The function then returns the; /// AddRec and the predicates as a pair, and caches this pair in; /// PredicatedSCEVRewrites.; /// If the analysis is not successful, a mapping from the \p SymbolicPHI to; /// itself (with no predicates) is recorded, and a nullptr with an empty; /// predicates vector is returned as a pair.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:218,Modifiability,variab,variable,218,"/// Compute the maximum backedge count based on the range of values; /// permitted by Start, End, and Stride. This is for loops of the form; /// {Start, +, Stride} LT End.; ///; /// Preconditions:; /// * the induction variable is known to be positive.; /// * the induction variable is assumed not to overflow (i.e. either it; /// actually doesn't, or we'd have to immediately execute UB); /// We *don't* assert these preconditions so please be careful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:273,Modifiability,variab,variable,273,"/// Compute the maximum backedge count based on the range of values; /// permitted by Start, End, and Stride. This is for loops of the form; /// {Start, +, Stride} LT End.; ///; /// Preconditions:; /// * the induction variable is known to be positive.; /// * the induction variable is assumed not to overflow (i.e. either it; /// actually doesn't, or we'd have to immediately execute UB); /// We *don't* assert these preconditions so please be careful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:404,Testability,assert,assert,404,"/// Compute the maximum backedge count based on the range of values; /// permitted by Start, End, and Stride. This is for loops of the form; /// {Start, +, Stride} LT End.; ///; /// Preconditions:; /// * the induction variable is known to be positive.; /// * the induction variable is assumed not to overflow (i.e. either it; /// actually doesn't, or we'd have to immediately execute UB); /// We *don't* assert these preconditions so please be careful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Performance,Cache,Cache,4,"/// Cache tentative mappings from UnknownSCEVs in a Loop, to a SCEV expression; /// they can be rewritten into under certain predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:103,Deployability,release,releaseMemory,103,/// The head of a linked list of all SCEVUnknown values that have been; /// allocated. This is used by releaseMemory to locate them all and call; /// their destructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:76,Energy Efficiency,allocate,allocated,76,/// The head of a linked list of all SCEVUnknown values that have been; /// allocated. This is used by releaseMemory to locate them all and call; /// their destructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:23,Security,expose,exposes,23,/// Analysis pass that exposes the \c ScalarEvolution for a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:7,Integrability,interface,interface,7,"/// An interface layer with SCEV used to manage how we see SCEV expressions; /// for values in the context of existing predicates. We can add new; /// predicates, but we cannot remove them.; ///; /// This layer has multiple purposes:; /// - provides a simple interface for SCEV versioning.; /// - guarantees that the order of transformations applied on a SCEV; /// expression for a single Value is consistent across two different; /// getSCEV calls. This means that, for example, once we've obtained; /// an AddRec expression for a certain value through expression; /// rewriting, we will continue to get an AddRec expression for that; /// Value.; /// - lowers the number of expression rewrites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:259,Integrability,interface,interface,259,"/// An interface layer with SCEV used to manage how we see SCEV expressions; /// for values in the context of existing predicates. We can add new; /// predicates, but we cannot remove them.; ///; /// This layer has multiple purposes:; /// - provides a simple interface for SCEV versioning.; /// - guarantees that the order of transformations applied on a SCEV; /// expression for a single Value is consistent across two different; /// getSCEV calls. This means that, for example, once we've obtained; /// an AddRec expression for a certain value through expression; /// rewriting, we will continue to get an AddRec expression for that; /// Value.; /// - lowers the number of expression rewrites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:686,Modifiability,rewrite,rewrites,686,"/// An interface layer with SCEV used to manage how we see SCEV expressions; /// for values in the context of existing predicates. We can add new; /// predicates, but we cannot remove them.; ///; /// This layer has multiple purposes:; /// - provides a simple interface for SCEV versioning.; /// - guarantees that the order of transformations applied on a SCEV; /// expression for a single Value is consistent across two different; /// getSCEV calls. This means that, for example, once we've obtained; /// an AddRec expression for a certain value through expression; /// rewriting, we will continue to get an AddRec expression for that; /// Value.; /// - lowers the number of expression rewrites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:252,Usability,simpl,simple,252,"/// An interface layer with SCEV used to manage how we see SCEV expressions; /// for values in the context of existing predicates. We can add new; /// predicates, but we cannot remove them.; ///; /// This layer has multiple purposes:; /// - provides a simple interface for SCEV versioning.; /// - guarantees that the order of transformations applied on a SCEV; /// expression for a single Value is consistent across two different; /// getSCEV calls. This means that, for example, once we've obtained; /// an AddRec expression for a certain value through expression; /// rewriting, we will continue to get an AddRec expression for that; /// Value.; /// - lowers the number of expression rewrites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:48,Integrability,wrap,wrap,48,/// Returns true if we've proved that V doesn't wrap by means of a SCEV; /// predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:87,Modifiability,rewrite,rewrite,87,/// Holds a SCEV and the version number of the SCEV predicate used to; /// perform the rewrite of the expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:75,Performance,perform,perform,75,/// Holds a SCEV and the version number of the SCEV predicate used to; /// perform the rewrite of the expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:23,Modifiability,rewrite,rewrite,23,"/// Maps a SCEV to the rewrite result of that SCEV at a certain version; /// number. If this number doesn't match the current Generation, we will; /// need to do a rewrite. To preserve the transformation order of previous; /// rewrites, we will rewrite the previous result instead of the original; /// SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:164,Modifiability,rewrite,rewrite,164,"/// Maps a SCEV to the rewrite result of that SCEV at a certain version; /// number. If this number doesn't match the current Generation, we will; /// need to do a rewrite. To preserve the transformation order of previous; /// rewrites, we will rewrite the previous result instead of the original; /// SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:227,Modifiability,rewrite,rewrites,227,"/// Maps a SCEV to the rewrite result of that SCEV at a certain version; /// number. If this number doesn't match the current Generation, we will; /// need to do a rewrite. To preserve the transformation order of previous; /// rewrites, we will rewrite the previous result instead of the original; /// SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:245,Modifiability,rewrite,rewrite,245,"/// Maps a SCEV to the rewrite result of that SCEV at a certain version; /// number. If this number doesn't match the current Generation, we will; /// need to do a rewrite. To preserve the transformation order of previous; /// rewrites, we will rewrite the previous result instead of the original; /// SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:54,Modifiability,rewrite,rewrite,54,/// The SCEVPredicate that forms our context. We will rewrite all; /// expressions assuming that this predicate true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:208,Modifiability,rewrite,rewrite,208,"/// Marks the version of the SCEV predicate used. When rewriting a SCEV; /// expression we mark it with the version of the predicate. We use this to; /// figure out if the predicate has changed from the last rewrite of the; /// SCEV. If so, we need to perform a new rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:266,Modifiability,rewrite,rewrite,266,"/// Marks the version of the SCEV predicate used. When rewriting a SCEV; /// expression we mark it with the version of the predicate. We use this to; /// figure out if the predicate has changed from the last rewrite of the; /// SCEV. If so, we need to perform a new rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:252,Performance,perform,perform,252,"/// Marks the version of the SCEV predicate used. When rewriting a SCEV; /// expression we mark it with the version of the predicate. We use this to; /// figure out if the predicate has changed from the last rewrite of the; /// SCEV. If so, we need to perform a new rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h:403,Integrability,interface,interface,403,"//===- ScalarEvolutionAliasAnalysis.h - SCEV-based AA -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This is the interface for a SCEV-based alias analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h:6,Usability,simpl,simple,6,/// A simple alias analysis implementation that uses ScalarEvolution to answer; /// queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the SCEVAAResult object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:85,Usability,simpl,simpler,85,// These should be ordered in terms of increasing complexity to make the; // folders simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:90,Performance,scalab,scalable,90,"/// This class represents the value of vscale, as used when defining the length; /// of a scalable vector or returned by the llvm.vscale() intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:46,Energy Efficiency,allocate,allocates,46,"// Since SCEVs are immutable, ScalarEvolution allocates operand; // arrays with its SCEVAllocator, so this class just needs a simple; // pointer rather than a more elaborate vector-like data structure.; // This also avoids the need for a non-trivial destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:216,Safety,avoid,avoids,216,"// Since SCEVs are immutable, ScalarEvolution allocates operand; // arrays with its SCEVAllocator, so this class just needs a simple; // pointer rather than a more elaborate vector-like data structure.; // This also avoids the need for a non-trivial destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:126,Usability,simpl,simple,126,"// Since SCEVs are immutable, ScalarEvolution allocates operand; // arrays with its SCEVAllocator, so this class just needs a simple; // pointer rather than a more elaborate vector-like data structure.; // This also avoids the need for a non-trivial destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:43,Usability,clear,clearing,43,/// Set flags for a non-recurrence without clearing previously set flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:151,Integrability,depend,depend,151,"// In most cases the types of LHS and RHS will be the same, but in some; // crazy cases one or the other may be a pointer. ScalarEvolution doesn't; // depend on the type for correctness, but handling types carefully can; // avoid extra casts in the SCEVExpander. The LHS is more likely to be; // a pointer type than the RHS, so use the RHS' type here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:224,Safety,avoid,avoid,224,"// In most cases the types of LHS and RHS will be the same, but in some; // crazy cases one or the other may be a pointer. ScalarEvolution doesn't; // depend on the type for correctness, but handling types carefully can; // avoid extra casts in the SCEVExpander. The LHS is more likely to be; // a pointer type than the RHS, so use the RHS' type here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:231,Integrability,wrap,wraparound,231,"/// Constructs and returns the recurrence indicating how much this; /// expression steps by. If this is a polynomial of degree N, it; /// returns a chrec of degree N-1. We cannot determine whether; /// the step recurrence has self-wraparound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:39,Usability,clear,clearing,39,"/// Set flags for a recurrence without clearing any previously set flags.; /// For AddRec, either NUW or NSW implies NW. Keep track of this fact here; /// to make it easier to propagate flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:43,Usability,clear,clearing,43,/// Set flags for a non-recurrence without clearing previously set flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:54,Deployability,update,update,54,/// The parent ScalarEvolution value. This is used to update the; /// parent's maps when the value associated with a SCEVUnknown is; /// deleted or RAUW'd.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:25,Usability,simpl,simple,25,/// This class defines a simple visitor class that may be used for; /// various SCEV analysis purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:107,Performance,cache,cached,107,"/// This visitor recursively visits a SCEV expression and re-writes it.; /// The result from each visit is cached, so it will return the same; /// SCEV for the same input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:111,Availability,redundant,redundant,111,"// Memoize the result of each visit so that we only compute once for; // the same input SCEV. This is to avoid redundant computations when; // a SCEV is referenced by multiple SCEVs. Without memoization, this; // visit algorithm would have exponential time complexity in the worst; // case, causing the compiler to hang on certain tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:105,Safety,avoid,avoid,105,"// Memoize the result of each visit so that we only compute once for; // the same input SCEV. This is to avoid redundant computations when; // a SCEV is referenced by multiple SCEVs. Without memoization, this; // visit algorithm would have exponential time complexity in the worst; // case, causing the compiler to hang on certain tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:111,Safety,redund,redundant,111,"// Memoize the result of each visit so that we only compute once for; // the same input SCEV. This is to avoid redundant computations when; // a SCEV is referenced by multiple SCEVs. Without memoization, this; // visit algorithm would have exponential time complexity in the worst; // case, causing the compiler to hang on certain tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:331,Testability,test,tests,331,"// Memoize the result of each visit so that we only compute once for; // the same input SCEV. This is to avoid redundant computations when; // a SCEV is referenced by multiple SCEVs. Without memoization, this; // visit algorithm would have exponential time complexity in the worst; // case, causing the compiler to hang on certain tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:70,Deployability,update,updates,70,/// The SCEVParameterRewriter takes a scalar evolution expression and updates; /// the SCEVUnknown components following the Map (Value -> SCEV).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionNormalization.h:919,Modifiability,variab,variables,919,"//===- llvm/Analysis/ScalarEvolutionNormalization.h - See below -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines utilities for working with ""normalized"" ScalarEvolution; // expressions.; //; // The following example illustrates post-increment uses and how normalized; // expressions help.; //; // for (i=0; i!=n; ++i) {; // ...; // }; // use(i);; //; // While the expression for most uses of i inside the loop is {0,+,1}<%L>, the; // expression for the use of i outside the loop is {1,+,1}<%L>, since i is; // incremented at the end of the loop body. This is inconveient, since it; // suggests that we need two different induction variables, one that starts; // at 0 and one that starts at 1. We'd prefer to be able to think of these as; // the same induction variable, with uses inside the loop using the; // ""pre-incremented"" value, and uses after the loop using the; // ""post-incremented"" value.; //; // Expressions for post-incremented uses are represented as an expression; // paired with a set of loops for which the expression is in ""post-increment""; // mode (there may be multiple loops).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionNormalization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionNormalization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionNormalization.h:1048,Modifiability,variab,variable,1048,"//===- llvm/Analysis/ScalarEvolutionNormalization.h - See below -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines utilities for working with ""normalized"" ScalarEvolution; // expressions.; //; // The following example illustrates post-increment uses and how normalized; // expressions help.; //; // for (i=0; i!=n; ++i) {; // ...; // }; // use(i);; //; // While the expression for most uses of i inside the loop is {0,+,1}<%L>, the; // expression for the use of i outside the loop is {1,+,1}<%L>, since i is; // incremented at the end of the loop body. This is inconveient, since it; // suggests that we need two different induction variables, one that starts; // at 0 and one that starts at 1. We'd prefer to be able to think of these as; // the same induction variable, with uses inside the loop using the; // ""pre-incremented"" value, and uses after the loop using the; // ""post-incremented"" value.; //; // Expressions for post-incremented uses are represented as an expression; // paired with a set of loops for which the expression is in ""post-increment""; // mode (there may be multiple loops).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionNormalization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionNormalization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h:407,Integrability,interface,interface,407,"//===- ScopedNoAliasAA.h - Scoped No-Alias Alias Analysis -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This is the interface for a metadata-based scoped no-alias analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h:6,Usability,simpl,simple,6,/// A simple AA result which uses scoped-noalias metadata to answer queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the ScopedNoAliasAAResult object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:8,Usability,Simpl,SimplifyQuery,8,"//===-- SimplifyQuery.h - Context for simplifications -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:38,Usability,simpl,simplifications,38,"//===-- SimplifyQuery.h - Context for simplifications -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:31,Integrability,interface,interface,31,"/// InstrInfoQuery provides an interface to query additional information for; /// instructions like metadata or keywords like nsw, which provides conservative; /// results if the users specified it is safe to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:201,Safety,safe,safe,201,"/// InstrInfoQuery provides an interface to query additional information for; /// instructions like metadata or keywords like nsw, which provides conservative; /// results if the users specified it is safe to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:3,Integrability,Wrap,Wrapper,3,"// Wrapper to query additional information for instructions like metadata or; // keywords like nsw, which provides conservative results if those cannot; // be safely used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:159,Safety,safe,safely,159,"// Wrapper to query additional information for instructions like metadata or; // keywords like nsw, which provides conservative results if those cannot; // be safely used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:21,Usability,simpl,simplifications,21,"/// Controls whether simplifications are allowed to constrain the range of; /// possible values for uses of undef. If it is false, simplifications are not; /// allowed to assume a particular value for a use of undef for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:131,Usability,simpl,simplifications,131,"/// Controls whether simplifications are allowed to constrain the range of; /// possible values for uses of undef. If it is false, simplifications are not; /// allowed to assume a particular value for a use of undef for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:188,Energy Efficiency,power,power,188,"/// AbstractLatticeFunction - This class is implemented by the dataflow instance; /// to specify what the lattice values are and how they handle merges etc. This; /// gives the client the power to compute lattice values from instructions,; /// constants, etc. The current requirement is that lattice values must be; /// copyable. At the moment, nothing tries to avoid copying. Additionally,; /// lattice keys must be able to be used as keys of a mapping data structure.; /// Internally, the generic solver currently uses a DenseMap to map lattice keys; /// to lattice values. If the lattice key is a non-standard type, a; /// specialization of DenseMapInfo must be provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:362,Safety,avoid,avoid,362,"/// AbstractLatticeFunction - This class is implemented by the dataflow instance; /// to specify what the lattice values are and how they handle merges etc. This; /// gives the client the power to compute lattice values from instructions,; /// constants, etc. The current requirement is that lattice values must be; /// copyable. At the moment, nothing tries to avoid copying. Additionally,; /// lattice keys must be able to be used as keys of a mapping data structure.; /// Internally, the generic solver currently uses a DenseMap to map lattice keys; /// to lattice values. If the lattice key is a non-standard type, a; /// specialization of DenseMapInfo must be provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:182,Safety,avoid,avoid,182,"/// IsUntrackedValue - If the specified LatticeKey is obviously uninteresting; /// to the analysis (i.e., it would always return UntrackedVal), this; /// function can return true to avoid pointless work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:128,Availability,down,down,128,/// MergeValues - Compute and return the merge of the two specified lattice; /// values. Merging should only move one direction down the lattice to; /// guarantee convergence (toward overdefined).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:10,Safety,safe,safe,10,"// always safe, never useful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:4,Deployability,Update,UpdateState,4,"/// UpdateState - When the state of some LatticeKey is potentially updated to; /// the given LatticeVal, this function notices and adds the LLVM value; /// corresponding the key to the work list, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:67,Deployability,update,updated,67,"/// UpdateState - When the state of some LatticeKey is potentially updated to; /// the given LatticeVal, this function notices and adds the LLVM value; /// corresponding the key to the work list, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:18,Deployability,Update,Update,18,// No change.; // Update the state of the given LatticeKey and add its corresponding LLVM; // value to the work list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:25,Modifiability,variab,variables,25,// Overdefined condition variables can branch either way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:22,Modifiability,variab,variables,22,// Constant condition variables mean the branch can only go a single way,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:105,Availability,down,down,105,"// Quick exit; // Super-extra-high-degree PHI nodes are unlikely to ever be interesting,; // and slow us down a lot. Just mark them overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:3,Deployability,Update,Update,3,"// Update the PHI with the compute value, which is the merge of the inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:39,Testability,log,logic,39,"// PHIs are handled by the propagation logic, they are never passed into the; // transfer functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:21,Availability,alive,alive,21,"// Controls what is ""alive"" if control flow may reach the instruction; // with a different liveness of the alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:10,Availability,alive,alive,10,// May be alive on some path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:11,Availability,alive,alive,11,// Must be alive on every path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:34,Availability,alive,alive,34,/// Returns true if the alloca is alive after the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:21,Testability,test,testing,21,/// Printer pass for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:44,Safety,safe,safety,44,"//===- StackSafetyAnalysis.h - Stack memory safety analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stack Safety Analysis detects allocas and arguments with safe access.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:389,Safety,Safe,Safety,389,"//===- StackSafetyAnalysis.h - Stack memory safety analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stack Safety Analysis detects allocas and arguments with safe access.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:405,Safety,detect,detects,405,"//===- StackSafetyAnalysis.h - Stack memory safety analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stack Safety Analysis detects allocas and arguments with safe access.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:440,Safety,safe,safe,440,"//===- StackSafetyAnalysis.h - Stack memory safety analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stack Safety Analysis detects allocas and arguments with safe access.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:445,Security,access,access,445,"//===- StackSafetyAnalysis.h - Stack memory safety analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stack Safety Analysis detects allocas and arguments with safe access.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:4,Integrability,Interface,Interface,4,/// Interface to access stack safety analysis results for single function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:30,Safety,safe,safety,30,/// Interface to access stack safety analysis results for single function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:17,Security,access,access,17,/// Interface to access stack safety analysis results for single function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:65,Security,access,access,65,"/// Parameters use for a FunctionSummary.; /// Function collects access information of all pointer parameters.; /// Information includes a range of direct access of parameters by the; /// functions and all call sites accepting the parameter.; /// StackSafety assumes that missing parameter information means possibility; /// of access to the parameter with any offset, so we can correctly link; /// code without StackSafety information, e.g. non-ThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:155,Security,access,access,155,"/// Parameters use for a FunctionSummary.; /// Function collects access information of all pointer parameters.; /// Information includes a range of direct access of parameters by the; /// functions and all call sites accepting the parameter.; /// StackSafety assumes that missing parameter information means possibility; /// of access to the parameter with any offset, so we can correctly link; /// code without StackSafety information, e.g. non-ThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:328,Security,access,access,328,"/// Parameters use for a FunctionSummary.; /// Function collects access information of all pointer parameters.; /// Information includes a range of direct access of parameters by the; /// functions and all call sites accepting the parameter.; /// StackSafety assumes that missing parameter information means possibility; /// of access to the parameter with any offset, so we can correctly link; /// code without StackSafety information, e.g. non-ThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:33,Security,access,accesses,33,// Whether we can prove that all accesses to this Alloca are in-range and; // during its lifetime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:84,Security,access,accesses,84,// Returns true if the instruction can be proven to do only two types of; // memory accesses:; // (1) live stack locations in-bounds or; // (2) non-stack locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:20,Integrability,wrap,wrapper,20,/// StackSafetyInfo wrapper for the new pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:20,Integrability,wrap,wrapper,20,/// StackSafetyInfo wrapper for the legacy pass manager,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:14,Performance,perform,performs,14,/// This pass performs the global (interprocedural) stack safety analysis (new; /// pass manager).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:58,Safety,safe,safety,58,/// This pass performs the global (interprocedural) stack safety analysis (new; /// pass manager).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:14,Performance,perform,performs,14,/// This pass performs the global (interprocedural) stack safety analysis; /// (legacy pass manager).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:58,Safety,safe,safety,58,/// This pass performs the global (interprocedural) stack safety analysis; /// (legacy pass manager).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StructuralHash.h:35,Security,Hash,Hash,35,"//=- StructuralHash.h - Structural Hash Printing --*- C++ -*-----------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StructuralHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StructuralHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h:536,Integrability,depend,dependent,536,"//====- TargetFolder.h - Constant folding helper ---------------*- C++ -*-====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TargetFolder class, a helper for IRBuilder.; // It provides IRBuilder with a set of methods for creating constants with; // target dependent folding, in addition to the same target-independent; // folding that the ConstantFolder class provides. For general constant; // creation and folding, use ConstantExpr and the routines in; // llvm/Analysis/ConstantFolding.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h:722,Integrability,rout,routines,722,"//====- TargetFolder.h - Constant folding helper ---------------*- C++ -*-====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TargetFolder class, a helper for IRBuilder.; // It provides IRBuilder with a set of methods for creating constants with; // target dependent folding, in addition to the same target-independent; // folding that the ConstantFolder class provides. For general constant; // creation and folding, use ConstantExpr and the routines in; // llvm/Analysis/ConstantFolding.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h:48,Integrability,depend,dependent,48,/// TargetFolder - Create constants with target dependent folding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h:175,Usability,simpl,simplified,175,//===--------------------------------------------------------------------===//; // Value-based folders.; //; // Return an existing value or a constant if the operation can be simplified.; // Otherwise return nullptr.; //===--------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h:3,Safety,avoid,avoid,3,// avoid calling Fold,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h:3,Safety,avoid,avoid,3,// avoid calling Fold,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:245,Availability,mask,mask,245,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:332,Availability,mask,mask,332,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:444,Availability,mask,mask,444,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:459,Availability,mask,masked,459,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:477,Availability,mask,mask,477,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:507,Performance,concurren,concurrent,507,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:623,Performance,scalab,scalable,623,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:77,Availability,mask,mask,77,/// Returns a vector function ABI variant string on the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:151,Availability,avail,available,151,"/// Implementation of the target library information.; ///; /// This class constructs tables that hold the target library information and; /// make it available. However, it is somewhat expensive to compute and only; /// depends on the triple. So users typically interact with the \c; /// TargetLibraryInfo wrapper below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:221,Integrability,depend,depends,221,"/// Implementation of the target library information.; ///; /// This class constructs tables that hold the target library information and; /// make it available. However, it is somewhat expensive to compute and only; /// depends on the triple. So users typically interact with the \c; /// TargetLibraryInfo wrapper below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:307,Integrability,wrap,wrapper,307,"/// Implementation of the target library information.; ///; /// This class constructs tables that hold the target library information and; /// make it available. However, it is somewhat expensive to compute and only; /// depends on the triple. So users typically interact with the \c; /// TargetLibraryInfo wrapper below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:121,Availability,avail,available,121,"/// Return true if the function type FTy is valid for the library function; /// F, regardless of whether the function is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:7,Performance,Perform,Performance,7,// Arm Performance Libraries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:38,Availability,avail,available,38,/// Forces a function to be marked as available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:38,Availability,avail,available,38,/// Forces a function to be marked as available and provide an alternate name; /// that must be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:58,Availability,avail,available,58,/// Provides information about what library functions are available for; /// the current target.; ///; /// This both allows optimizations to handle them specially and frontends to; /// disable such optimizations through -fno-builtin etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:124,Performance,optimiz,optimizations,124,/// Provides information about what library functions are available for; /// the current target.; ///; /// This both allows optimizations to handle them specially and frontends to; /// disable such optimizations through -fno-builtin etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:198,Performance,optimiz,optimizations,198,/// Provides information about what library functions are available for; /// the current target.; ///; /// This both allows optimizations to handle them specially and frontends to; /// disable such optimizations through -fno-builtin etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:121,Availability,avail,available,121,"/// Return true if the function type FTy is valid for the library function; /// F, regardless of whether the function is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:40,Availability,avail,available,40,/// Tests whether a library function is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:4,Testability,Test,Tests,4,/// Tests whether a library function is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:34,Availability,avail,available,34,/// Tests if the function is both available and a candidate for optimized code; /// generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:64,Performance,optimiz,optimized,64,/// Tests if the function is both available and a candidate for optimized code; /// generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:4,Testability,Test,Tests,4,/// Tests if the function is both available and a candidate for optimized code; /// generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:605,Integrability,interface,interface,605,"//===- TargetTransformInfo.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This pass exposes codegen information to IR-level passes. Every; /// transformation that uses codegen information is broken into three parts:; /// 1. The IR-level analysis pass.; /// 2. The IR-level transformation interface which provides the needed; /// information.; /// 3. Codegen-level implementation which uses target-specific hooks.; ///; /// This file defines #2, which is the interface that IR-level transformations; /// use for querying the codegen.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:775,Integrability,interface,interface,775,"//===- TargetTransformInfo.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This pass exposes codegen information to IR-level passes. Every; /// transformation that uses codegen information is broken into three parts:; /// 1. The IR-level analysis pass.; /// 2. The IR-level transformation interface which provides the needed; /// information.; /// 3. Codegen-level implementation which uses target-specific hooks.; ///; /// This file defines #2, which is the interface that IR-level transformations; /// use for querying the codegen.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:401,Security,expose,exposes,401,"//===- TargetTransformInfo.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This pass exposes codegen information to IR-level passes. Every; /// transformation that uses codegen information is broken into three parts:; /// 1. The IR-level analysis pass.; /// 2. The IR-level transformation interface which provides the needed; /// information.; /// 3. Codegen-level implementation which uses target-specific hooks.; ///; /// This file defines #2, which is the interface that IR-level transformations; /// use for querying the codegen.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:24,Performance,load,load,24,/// Information about a load/store intrinsic defined by the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:46,Performance,load,loading,46,"/// This is the pointer that the intrinsic is loading from or storing to.; /// If this is non-null, then analysis/optimization passes can assume that; /// this intrinsic is functionally equivalent to a load/store from this; /// pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:114,Performance,optimiz,optimization,114,"/// This is the pointer that the intrinsic is loading from or storing to.; /// If this is non-null, then analysis/optimization passes can assume that; /// this intrinsic is functionally equivalent to a load/store from this; /// pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:202,Performance,load,load,202,"/// This is the pointer that the intrinsic is loading from or storing to.; /// If this is non-null, then analysis/optimization passes can assume that; /// this intrinsic is functionally equivalent to a load/store from this; /// pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:50,Performance,load,load,50,// Same Id is set by the target for corresponding load/store intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:27,Integrability,depend,dependent,27,/// Attributes of a target dependent hardware loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:26,Deployability,update,updated,26,// Should loop counter be updated in; // the loop via a phi?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:37,Performance,perform,performs,37,// Generate the intrinsic which also performs; // icmp ne zero on the loop counter value and; // produces an i1 to guard the loop entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:26,Availability,mask,mask,26,"/// Use predicate only to mask operations on data in the loop.; /// When the VL is not known to be a power-of-2, this method requires a; /// runtime overflow check for the i + VL in the loop because it compares the; /// scalar induction variable against the tripcount rounded up by VL which may; /// overflow. When the VL is a power-of-2, both the increment and uprounded; /// tripcount will overflow to 0, which does not require a runtime check; /// since the loop is exited when the loop induction variable equals the; /// uprounded trip-count, which are both 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:101,Energy Efficiency,power,power-of-,101,"/// Use predicate only to mask operations on data in the loop.; /// When the VL is not known to be a power-of-2, this method requires a; /// runtime overflow check for the i + VL in the loop because it compares the; /// scalar induction variable against the tripcount rounded up by VL which may; /// overflow. When the VL is a power-of-2, both the increment and uprounded; /// tripcount will overflow to 0, which does not require a runtime check; /// since the loop is exited when the loop induction variable equals the; /// uprounded trip-count, which are both 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:327,Energy Efficiency,power,power-of-,327,"/// Use predicate only to mask operations on data in the loop.; /// When the VL is not known to be a power-of-2, this method requires a; /// runtime overflow check for the i + VL in the loop because it compares the; /// scalar induction variable against the tripcount rounded up by VL which may; /// overflow. When the VL is a power-of-2, both the increment and uprounded; /// tripcount will overflow to 0, which does not require a runtime check; /// since the loop is exited when the loop induction variable equals the; /// uprounded trip-count, which are both 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:237,Modifiability,variab,variable,237,"/// Use predicate only to mask operations on data in the loop.; /// When the VL is not known to be a power-of-2, this method requires a; /// runtime overflow check for the i + VL in the loop because it compares the; /// scalar induction variable against the tripcount rounded up by VL which may; /// overflow. When the VL is a power-of-2, both the increment and uprounded; /// tripcount will overflow to 0, which does not require a runtime check; /// since the loop is exited when the loop induction variable equals the; /// uprounded trip-count, which are both 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:500,Modifiability,variab,variable,500,"/// Use predicate only to mask operations on data in the loop.; /// When the VL is not known to be a power-of-2, this method requires a; /// runtime overflow check for the i + VL in the loop because it compares the; /// scalar induction variable against the tripcount rounded up by VL which may; /// overflow. When the VL is a power-of-2, both the increment and uprounded; /// tripcount will overflow to 0, which does not require a runtime check; /// since the loop is exited when the loop induction variable equals the; /// uprounded trip-count, which are both 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:55,Availability,mask,mask,55,"/// Same as Data, but avoids using the get.active.lane.mask intrinsic to; /// calculate the mask and instead implements this with a; /// splat/stepvector/cmp.; /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the; /// active.lane.mask intrinsic when it is not natively supported?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:92,Availability,mask,mask,92,"/// Same as Data, but avoids using the get.active.lane.mask intrinsic to; /// calculate the mask and instead implements this with a; /// splat/stepvector/cmp.; /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the; /// active.lane.mask intrinsic when it is not natively supported?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:254,Availability,mask,mask,254,"/// Same as Data, but avoids using the get.active.lane.mask intrinsic to; /// calculate the mask and instead implements this with a; /// splat/stepvector/cmp.; /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the; /// active.lane.mask intrinsic when it is not natively supported?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:22,Safety,avoid,avoids,22,"/// Same as Data, but avoids using the get.active.lane.mask intrinsic to; /// calculate the mask and instead implements this with a; /// splat/stepvector/cmp.; /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the; /// active.lane.mask intrinsic when it is not natively supported?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:222,Availability,mask,mask,222,"/// Use predicate to control both data and control flow.; /// This method always requires a runtime overflow check for the i + VL; /// increment inside the loop, because it uses the result direclty in the; /// active.lane.mask to calculate the mask for the next iteration. If the; /// increment overflows, the mask is no longer correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:244,Availability,mask,mask,244,"/// Use predicate to control both data and control flow.; /// This method always requires a runtime overflow check for the i + VL; /// increment inside the loop, because it uses the result direclty in the; /// active.lane.mask to calculate the mask for the next iteration. If the; /// increment overflows, the mask is no longer correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:310,Availability,mask,mask,310,"/// Use predicate to control both data and control flow.; /// This method always requires a runtime overflow check for the i + VL; /// increment inside the loop, because it uses the result direclty in the; /// active.lane.mask to calculate the mask for the next iteration. If the; /// increment overflows, the mask is no longer correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:128,Safety,avoid,avoided,128,"/// Use predicate to control both data and control flow, but modify; /// the trip count so that a runtime overflow check can be avoided; /// and such that the scalar epilogue loop can always be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:45,Integrability,interface,interfaces,45,/// This pass provides access to the codegen interfaces that are needed; /// for IR-level transformations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:23,Security,access,access,23,/// This pass provides access to the codegen interfaces that are needed; /// for IR-level transformations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:137,Integrability,wrap,wrapping,137,/// Construct a TTI object using a type implementing the \c Concept; /// API below.; ///; /// This is used by targets to construct a TTI wrapping their target-specific; /// implementation that encodes appropriate costs for their target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:16,Performance,throughput,throughput,16,///< Reciprocal throughput.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:9,Performance,latency,latency,9,///< The latency of instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:34,Performance,latency,latency,34,///< The weighted sum of size and latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:51,Integrability,interface,interface,51,"/// Underlying constants for 'cost' values in this interface.; ///; /// Many APIs in this interface return a cost. This enum defines the; /// fundamental values that should be used to interpret (and produce) those; /// costs. The costs are returned as an int rather than a member of this; /// enumeration because it is expected that the cost of one IR instruction; /// may have a multiplicative factor to it or otherwise won't fit directly; /// into the enum. Moreover, it is common to sum or average costs which works; /// better as simple integral values. Thus this enum only provides constants.; /// Also note that the returned costs are signed integers to make it natural; /// to add, subtract, and test with zero (a common boundary condition). It is; /// not expected that 2^32 is a realistic cost to be modeling at any point.; ///; /// Note that these costs should usually reflect the intersection of code-size; /// cost and execution cost. A free instruction is typically one that folds; /// into another instruction. For example, reg-to-reg moves can often be; /// skipped by renaming the registers in the CPU, but they still are encoded; /// and thus wouldn't be considered 'free' here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:90,Integrability,interface,interface,90,"/// Underlying constants for 'cost' values in this interface.; ///; /// Many APIs in this interface return a cost. This enum defines the; /// fundamental values that should be used to interpret (and produce) those; /// costs. The costs are returned as an int rather than a member of this; /// enumeration because it is expected that the cost of one IR instruction; /// may have a multiplicative factor to it or otherwise won't fit directly; /// into the enum. Moreover, it is common to sum or average costs which works; /// better as simple integral values. Thus this enum only provides constants.; /// Also note that the returned costs are signed integers to make it natural; /// to add, subtract, and test with zero (a common boundary condition). It is; /// not expected that 2^32 is a realistic cost to be modeling at any point.; ///; /// Note that these costs should usually reflect the intersection of code-size; /// cost and execution cost. A free instruction is typically one that folds; /// into another instruction. For example, reg-to-reg moves can often be; /// skipped by renaming the registers in the CPU, but they still are encoded; /// and thus wouldn't be considered 'free' here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:703,Testability,test,test,703,"/// Underlying constants for 'cost' values in this interface.; ///; /// Many APIs in this interface return a cost. This enum defines the; /// fundamental values that should be used to interpret (and produce) those; /// costs. The costs are returned as an int rather than a member of this; /// enumeration because it is expected that the cost of one IR instruction; /// may have a multiplicative factor to it or otherwise won't fit directly; /// into the enum. Moreover, it is common to sum or average costs which works; /// better as simple integral values. Thus this enum only provides constants.; /// Also note that the returned costs are signed integers to make it natural; /// to add, subtract, and test with zero (a common boundary condition). It is; /// not expected that 2^32 is a realistic cost to be modeling at any point.; ///; /// Note that these costs should usually reflect the intersection of code-size; /// cost and execution cost. A free instruction is typically one that folds; /// into another instruction. For example, reg-to-reg moves can often be; /// skipped by renaming the registers in the CPU, but they still are encoded; /// and thus wouldn't be considered 'free' here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:534,Usability,simpl,simple,534,"/// Underlying constants for 'cost' values in this interface.; ///; /// Many APIs in this interface return a cost. This enum defines the; /// fundamental values that should be used to interpret (and produce) those; /// costs. The costs are returned as an int rather than a member of this; /// enumeration because it is expected that the cost of one IR instruction; /// may have a multiplicative factor to it or otherwise won't fit directly; /// into the enum. Moreover, it is common to sum or average costs which works; /// better as simple integral values. Thus this enum only provides constants.; /// Also note that the returned costs are signed integers to make it natural; /// to add, subtract, and test with zero (a common boundary condition). It is; /// not expected that 2^32 is a realistic cost to be modeling at any point.; ///; /// Note that these costs should usually reflect the intersection of code-size; /// cost and execution cost. A free instruction is typically one that folds; /// into another instruction. For example, reg-to-reg moves can often be; /// skipped by renaming the registers in the CPU, but they still are encoded; /// and thus wouldn't be considered 'free' here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:428,Performance,load,load,428,"/// Estimate the cost of a GEP operation when lowered.; ///; /// \p PointeeType is the source element type of the GEP.; /// \p Ptr is the base pointer operand.; /// \p Operands is the list of indices following the base pointer.; ///; /// \p AccessType is a hint as to what type of memory might be accessed by; /// users of the GEP. getGEPCost will use it to determine if the GEP can be; /// folded into the addressing mode of a load/store. If AccessType is null,; /// then the resulting target type based off of PointeeType will be used as an; /// approximation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:241,Security,Access,AccessType,241,"/// Estimate the cost of a GEP operation when lowered.; ///; /// \p PointeeType is the source element type of the GEP.; /// \p Ptr is the base pointer operand.; /// \p Operands is the list of indices following the base pointer.; ///; /// \p AccessType is a hint as to what type of memory might be accessed by; /// users of the GEP. getGEPCost will use it to determine if the GEP can be; /// folded into the addressing mode of a load/store. If AccessType is null,; /// then the resulting target type based off of PointeeType will be used as an; /// approximation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:297,Security,access,accessed,297,"/// Estimate the cost of a GEP operation when lowered.; ///; /// \p PointeeType is the source element type of the GEP.; /// \p Ptr is the base pointer operand.; /// \p Operands is the list of indices following the base pointer.; ///; /// \p AccessType is a hint as to what type of memory might be accessed by; /// users of the GEP. getGEPCost will use it to determine if the GEP can be; /// folded into the addressing mode of a load/store. If AccessType is null,; /// then the resulting target type based off of PointeeType will be used as an; /// approximation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:443,Security,Access,AccessType,443,"/// Estimate the cost of a GEP operation when lowered.; ///; /// \p PointeeType is the source element type of the GEP.; /// \p Ptr is the base pointer operand.; /// \p Operands is the list of indices following the base pointer.; ///; /// \p AccessType is a hint as to what type of memory might be accessed by; /// users of the GEP. getGEPCost will use it to determine if the GEP can be; /// folded into the addressing mode of a load/store. If AccessType is null,; /// then the resulting target type based off of PointeeType will be used as an; /// approximation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:92,Performance,load,loads,92,/// Estimate the cost of a chain of pointers (typically pointer operands of a; /// chain of loads or stores within same block) operations set when lowered.; /// \p AccessTy is the type of the loads/stores that will ultimately use the; /// \p Ptrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:192,Performance,load,loads,192,/// Estimate the cost of a chain of pointers (typically pointer operands of a; /// chain of loads or stores within same block) operations set when lowered.; /// \p AccessTy is the type of the loads/stores that will ultimately use the; /// \p Ptrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:164,Security,Access,AccessTy,164,/// Estimate the cost of a chain of pointers (typically pointer operands of a; /// chain of loads or stores within same block) operations set when lowered.; /// \p AccessTy is the type of the loads/stores that will ultimately use the; /// \p Ptrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:370,Modifiability,evolve,evolved,370,/// \returns Vector bonus in percent.; ///; /// Vector bonuses: We want to more aggressively inline vector-dense kernels; /// and apply this bonus based on the percentage of vector instructions. A; /// bonus is applied if the vector instructions exceed 50% and half that; /// amount is applied if it exceeds 10%. Note that these bonuses are some what; /// arbitrary and evolved over time by accident as much as because they are; /// principled bonuses.; /// FIXME: It would be nice to base the bonus values on something more; /// scientific. A target may has no bonus on vector instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:60,Integrability,depend,depend,60,"/// \return the expected cost of a memcpy, which could e.g. depend on the; /// source/destination type and alignment and the number of bytes copied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:120,Safety,predict,predicted,120,"/// If a branch or a select condition is skewed in one direction by more than; /// this factor, it is very likely to be predicted correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:116,Performance,perform,performance,116,"/// Return true if branch divergence exists.; ///; /// Branch divergence has a significantly negative impact on GPU performance; /// when threads in the same wavefront take different paths due to conditional; /// branches.; ///; /// If \p F is passed, provides a context function. If \p F is known to only; /// execute in a single threaded environment, the target may choose to skip; /// uniformity analysis and assume all values are uniform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:93,Integrability,depend,dependent,93,/// Returns whether V is a source of divergence.; ///; /// This function provides the target-dependent information for; /// the target-independent UniformityAnalysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:741,Performance,optimiz,optimizations,741,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:913,Performance,optimiz,optimize,913,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:268,Security,access,access,268,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:339,Security,Access,Access,339,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:491,Security,access,accessed,491,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:785,Security,access,access,785,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite intrinsic call \p II such that \p OldV will be replaced with \p; /// NewV, which has a different address space. This should happen for every; /// operand index that collectFlatAddressOperands returned for the intrinsic.; /// \returns nullptr if the intrinsic was not handled. Otherwise, returns the; /// new value (which may be the original \p II with modified operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:423,Integrability,interface,interface,423,"/// Test whether calls to a function lower to actual program function; /// calls.; ///; /// The idea is to test whether the program is likely to require a 'call'; /// instruction or equivalent in order to call the given function.; ///; /// FIXME: It's not clear that this is a good or useful query API. Client's; /// should probably move to simpler cost metrics using the above.; /// Alternatively, we could split the cost interface into distinct code-size; /// and execution-speed costs. This would allow modelling the core of this; /// query more accurately as a call is a single small instruction, but; /// incurs significant execution cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:4,Testability,Test,Test,4,"/// Test whether calls to a function lower to actual program function; /// calls.; ///; /// The idea is to test whether the program is likely to require a 'call'; /// instruction or equivalent in order to call the given function.; ///; /// FIXME: It's not clear that this is a good or useful query API. Client's; /// should probably move to simpler cost metrics using the above.; /// Alternatively, we could split the cost interface into distinct code-size; /// and execution-speed costs. This would allow modelling the core of this; /// query more accurately as a call is a single small instruction, but; /// incurs significant execution cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:107,Testability,test,test,107,"/// Test whether calls to a function lower to actual program function; /// calls.; ///; /// The idea is to test whether the program is likely to require a 'call'; /// instruction or equivalent in order to call the given function.; ///; /// FIXME: It's not clear that this is a good or useful query API. Client's; /// should probably move to simpler cost metrics using the above.; /// Alternatively, we could split the cost interface into distinct code-size; /// and execution-speed costs. This would allow modelling the core of this; /// query more accurately as a call is a single small instruction, but; /// incurs significant execution cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:256,Usability,clear,clear,256,"/// Test whether calls to a function lower to actual program function; /// calls.; ///; /// The idea is to test whether the program is likely to require a 'call'; /// instruction or equivalent in order to call the given function.; ///; /// FIXME: It's not clear that this is a good or useful query API. Client's; /// should probably move to simpler cost metrics using the above.; /// Alternatively, we could split the cost interface into distinct code-size; /// and execution-speed costs. This would allow modelling the core of this; /// query more accurately as a call is a single small instruction, but; /// incurs significant execution cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:341,Usability,simpl,simpler,341,"/// Test whether calls to a function lower to actual program function; /// calls.; ///; /// The idea is to test whether the program is likely to require a 'call'; /// instruction or equivalent in order to call the given function.; ///; /// FIXME: It's not clear that this is a good or useful query API. Client's; /// should probably move to simpler cost metrics using the above.; /// Alternatively, we could split the cost interface into distinct code-size; /// and execution-speed costs. This would allow modelling the core of this; /// query more accurately as a call is a single small instruction, but; /// incurs significant execution cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:213,Integrability,interface,interface,213,"/// The cost threshold for the unrolled loop. Should be relative to the; /// getInstructionCost values returned by this API, and the expectation is; /// that the unrolled loop's instructions when run through that interface; /// should not exceed this cost. However, this is only an estimate. Also,; /// specific loops may be unrolled even with a cost above this threshold if; /// deemed profitable. Set this to UINT_MAX to disable the loop body cost; /// restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:31,Energy Efficiency,reduce,reduce,31,"/// If complete unrolling will reduce the cost of the loop, we will boost; /// the Threshold by a certain percent to allow more aggressive complete; /// unrolling. This value provides the maximum boost percentage that we; /// can apply to Threshold (The value should be no less than 100).; /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,; /// MaxPercentThresholdBoost / 100); /// E.g. if complete unrolling reduces the loop execution time by 50%; /// then we boost the threshold by the factor of 2x. If unrolling is not; /// expected to reduce the running time, then we do not increase the; /// threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:425,Energy Efficiency,reduce,reduces,425,"/// If complete unrolling will reduce the cost of the loop, we will boost; /// the Threshold by a certain percent to allow more aggressive complete; /// unrolling. This value provides the maximum boost percentage that we; /// can apply to Threshold (The value should be no less than 100).; /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,; /// MaxPercentThresholdBoost / 100); /// E.g. if complete unrolling reduces the loop execution time by 50%; /// then we boost the threshold by the factor of 2x. If unrolling is not; /// expected to reduce the running time, then we do not increase the; /// threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:555,Energy Efficiency,reduce,reduce,555,"/// If complete unrolling will reduce the cost of the loop, we will boost; /// the Threshold by a certain percent to allow more aggressive complete; /// unrolling. This value provides the maximum boost percentage that we; /// can apply to Threshold (The value should be no less than 100).; /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,; /// MaxPercentThresholdBoost / 100); /// E.g. if complete unrolling reduces the loop execution time by 50%; /// then we boost the threshold by the factor of 2x. If unrolling is not; /// expected to reduce the running time, then we do not increase the; /// threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:50,Performance,optimiz,optimizing,50,/// The cost threshold for the unrolled loop when optimizing for size (set; /// to UINT_MAX to disable).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:50,Performance,optimiz,optimizing,50,"/// The cost threshold for the unrolled loop when optimizing for size, like; /// OptSizeThreshold, but used for partial/runtime unrolling (set to; /// UINT_MAX to disable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:37,Performance,optimiz,optimized,37,"// Represents number of instructions optimized when ""back edge""; // becomes ""fall through"" in unrolled loop.; // For now we count a conditional branch on a backedge and a comparison; // feeding it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:101,Safety,avoid,avoid,101,"/// Query the target whether it would be prefered to create a predicated; /// vector loop, which can avoid the need to emit a scalar epilogue loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:134,Deployability,update,update,134,"/// Query the target what the preferred style of tail folding is.; /// \param IVUpdateMayOverflow Tells whether it is known if the IV update; /// may (or will never) overflow for the suggested VF/UF in the given loop.; /// Targets can use this information to select a more optimal tail folding; /// style. The value conservatively defaults to true, such that no assumptions; /// are made on overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:216,Performance,perform,performance,216,"/// @}; /// \name Scalar Target Information; /// @{; /// Flags indicating the kind of support for population count.; ///; /// Compared to the SW implementation, HW support is supposed to; /// significantly boost the performance when the population is dense, and it; /// may or may not degrade performance if the population is sparse. A HW; /// support is considered as ""Fast"" if it can outperform, or is on a par; /// with, SW implementation when the population is sparse; otherwise, it is; /// considered as ""Slow"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:293,Performance,perform,performance,293,"/// @}; /// \name Scalar Target Information; /// @{; /// Flags indicating the kind of support for population count.; ///; /// Compared to the SW implementation, HW support is supposed to; /// significantly boost the performance when the population is dense, and it; /// may or may not degrade performance if the population is sparse. A HW; /// support is considered as ""Fast"" if it can outperform, or is on a par; /// with, SW implementation when the population is sparse; otherwise, it is; /// considered as ""Slow"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:94,Performance,load,load,94,"/// Return true if the addressing mode represented by AM is legal for; /// this target, for a load/store of the specified type.; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type.; /// If target returns true in LSRWithInstrQueries(), I may be valid.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:231,Performance,load,load,231,"/// Return true if the addressing mode represented by AM is legal for; /// this target, for a load/store of the specified type.; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type.; /// If target returns true in LSRWithInstrQueries(), I may be valid.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:132,Availability,avail,available,132,"/// Return true if LSR should attempts to replace a use of an otherwise dead; /// primary IV in the latch condition with another IV available in the loop.; /// When successful, makes the primary IV dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,Performance,optimiz,optimize,36,/// \returns true if LSR should not optimize a chain that includes \p I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,Availability,mask,masked,39,/// Return true if the target supports masked store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,Availability,mask,masked,39,/// Return true if the target supports masked load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:46,Performance,load,load,46,/// Return true if the target supports masked load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:51,Performance,load,load,51,/// Return true if the target supports nontemporal load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:56,Performance,load,load,56,/// \Returns true if the target supports broadcasting a load to a vector of; /// type <NumElements x ElementTy>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,Availability,mask,masked,39,/// Return true if the target supports masked scatter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,Availability,mask,masked,39,/// Return true if the target supports masked gather.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:57,Availability,mask,masked,57,/// Return true if the target forces scalarizing of llvm.masked.gather; /// intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:57,Availability,mask,masked,57,/// Return true if the target forces scalarizing of llvm.masked.scatter; /// intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,Availability,mask,masked,39,/// Return true if the target supports masked compress store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,Availability,mask,masked,39,/// Return true if the target supports masked expand load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:53,Performance,load,load,53,/// Return true if the target supports masked expand load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:336,Availability,mask,mask,336,/// Return true if this is an alternating opcode pattern that can be lowered; /// to a single instruction on the target. In X86 this is for the addsub; /// instruction which corrsponds to a Shuffle + Fadd + FSub pattern in IR.; /// This function expectes two opcodes: \p Opcode1 and \p Opcode2 being; /// selected by \p OpcodeMask. The mask contains one bit per lane and is a `0`; /// when \p Opcode0 is selected and `1` when Opcode1 is selected.; /// \p VecTy is the vector type of the instruction to be generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:344,Performance,throughput,throughput,344,"/// Return true if the target has a unified operation to calculate division; /// and remainder. If so, the additional implicit multiplication and; /// subtraction required to calculate a remainder from division are free. This; /// can enable more aggressive transformations for division and remainder than; /// would typically be allowed using throughput or size cost models.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:197,Performance,load,loads,197,"/// Return true if the given instruction (assumed to be a memory access; /// instruction) has a volatile variant. If that's the case then we can avoid; /// addrspacecast to generic AS for volatile loads/stores. Default; /// implementation returns false, which prevents address space inference for; /// volatile loads/stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:311,Performance,load,loads,311,"/// Return true if the given instruction (assumed to be a memory access; /// instruction) has a volatile variant. If that's the case then we can avoid; /// addrspacecast to generic AS for volatile loads/stores. Default; /// implementation returns false, which prevents address space inference for; /// volatile loads/stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:145,Safety,avoid,avoid,145,"/// Return true if the given instruction (assumed to be a memory access; /// instruction) has a volatile variant. If that's the case then we can avoid; /// addrspacecast to generic AS for volatile loads/stores. Default; /// implementation returns false, which prevents address space inference for; /// volatile loads/stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:65,Security,access,access,65,"/// Return true if the given instruction (assumed to be a memory access; /// instruction) has a volatile variant. If that's the case then we can avoid; /// addrspacecast to generic AS for volatile loads/stores. Default; /// implementation returns false, which prevents address space inference for; /// volatile loads/stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:116,Performance,load,load,116,"/// Return the cost of the scaling factor used in the addressing; /// mode represented by AM for this target, for a load/store; /// of the specified type.; /// If the AM is supported, the return value must be >= 0.; /// If the AM is not supported, it returns a negative value.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:37,Energy Efficiency,reduce,reduce,37,"/// Return true if the loop strength reduce pass should make; /// Instruction* based TTI queries to isLegalAddressingMode(). This is; /// needed on SystemZ, where e.g. a memcpy can only have a 12 bit unsigned; /// immediate offset and no index register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:18,Energy Efficiency,efficient,efficient,18,"/// If target has efficient vector element load/store instructions, it can; /// return true here so that insertion/extraction costs are not added to; /// the scalarization cost of a load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:43,Performance,load,load,43,"/// If target has efficient vector element load/store instructions, it can; /// return true here so that insertion/extraction costs are not added to; /// the scalarization cost of a load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:182,Performance,load,load,182,"/// If target has efficient vector element load/store instructions, it can; /// return true here so that insertion/extraction costs are not added to; /// the scalarization cost of a load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:21,Performance,load,load,21,// Maximum number of load operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:15,Availability,avail,available,15,"// The list of available load sizes (in bytes), sorted in decreasing order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:25,Performance,load,load,25,"// The list of available load sizes (in bytes), sorted in decreasing order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:120,Performance,load,load,120,"// For memcmp expansion when the memcmp result is only compared equal or; // not-equal to 0, allow up to this number of load pairs per block. As an; // example, this may allow 'memcmp(a, b, 3) == 0' in a single block:; // a0 = load2bytes &a[0]; // b0 = load2bytes &b[0]; // a2 = load1byte &a[2]; // b2 = load1byte &b[2]; // r = cmp eq (a0 ^ b0 | a2 ^ b2), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,Performance,load,loads,36,"// Set to true to allow overlapping loads. For example, 7-byte compares can; // be done with two 4-byte compares instead of 4+2+1-byte compares. This; // requires all loads in LoadSizes to be doable in an unaligned way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:167,Performance,load,loads,167,"// Set to true to allow overlapping loads. For example, 7-byte compares can; // be done with two 4-byte compares instead of 4+2+1-byte compares. This; // requires all loads in LoadSizes to be doable in an unaligned way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:176,Performance,Load,LoadSizes,176,"// Set to true to allow overlapping loads. For example, 7-byte compares can; // be done with two 4-byte compares instead of 4+2+1-byte compares. This; // requires all loads in LoadSizes to be doable in an unaligned way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:255,Energy Efficiency,efficient,efficiently,255,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:124,Performance,load,loaded,124,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:145,Performance,load,load,145,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:270,Performance,load,loading,270,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:431,Performance,load,loads,431,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:456,Usability,simpl,simplifies,456,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:22,Performance,Optimiz,Optimization,22,/// Should the Select Optimization pass be enabled and ran.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:22,Performance,Optimiz,Optimization,22,"/// Should the Select Optimization pass treat the given instruction like a; /// select, potentially converting it to a conditional branch. This can; /// include select-like instructions like or(zext(c), x) that can be converted; /// to selects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:35,Security,access,access,35,/// Enable matching of interleaved access groups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:126,Availability,mask,masked,126,/// Enable matching of interleaved access groups that contain predicated; /// accesses or gaps and therefore vectorized using masked; /// vector loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:145,Performance,load,loads,145,/// Enable matching of interleaved access groups that contain predicated; /// accesses or gaps and therefore vectorized using masked; /// vector loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:35,Security,access,access,35,/// Enable matching of interleaved access groups that contain predicated; /// accesses or gaps and therefore vectorized using masked; /// vector loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:78,Security,access,accesses,78,/// Enable matching of interleaved access groups that contain predicated; /// accesses or gaps and therefore vectorized using masked; /// vector loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:276,Integrability,depend,depending,276,"/// Indicate that it is potentially unsafe to automatically vectorize; /// floating-point operations because the semantics of vector and scalar; /// floating-point semantics may differ. For example, ARM NEON v7 SIMD math; /// does not support IEEE-754 denormal numbers, while depending on the; /// platform, scalar floating-point math does.; /// This applies to floating-point math operations and calls, not memory; /// operations, shuffles, or casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,Safety,unsafe,unsafe,36,"/// Indicate that it is potentially unsafe to automatically vectorize; /// floating-point operations because the semantics of vector and scalar; /// floating-point semantics may differ. For example, ARM NEON v7 SIMD math; /// does not support IEEE-754 denormal numbers, while depending on the; /// platform, scalar floating-point math does.; /// This applies to floating-point math operations and calls, not memory; /// operations, shuffles, or casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:54,Security,access,accesses,54,/// Determine if the target supports unaligned memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:149,Integrability,wrap,wraps,149,"/// Return true if the cost of the instruction is too high to speculatively; /// execute and should be kept behind a branch.; /// This normally just wraps around a getInstructionCost() call, but some; /// targets might report a low TCK_SizeAndLatency value that is incompatible; /// with the fixed TCC_Expensive value.; /// NOTE: This assumes the instruction passes isSafeToSpeculativelyExecute().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:402,Usability,simpl,simpler,402,/// It can be advantageous to detach complex constants from their uses to make; /// their generation cheaper. This hook allows targets to report when such; /// transformations might negatively effect the code generation of the; /// underlying operation. The motivating example is divides whereby hoisting; /// constants prevents the code generator's ability to transform them into; /// combinations of simpler operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:76,Availability,mask,mask,76,///< Merge elements from two source vectors into one; ///< with any shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:69,Availability,mask,mask,69,///< Shuffle elements of single source vector with any; ///< shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:572,Performance,perform,performed,572,"/// \return the target-provided register class ID for the provided type,; /// accounting for type promotion and other type-legalization techniques that; /// the target might apply. However, it specifically does not account for the; /// scalarization or splitting of vector types. Should a vector type require; /// scalarization or splitting into multiple underlying vector registers, that; /// type should be mapped to a register class containing no registers.; /// Specifically, this is designed to provide a simple, high-level view of the; /// register allocation later performed by the backend. These register classes; /// don't necessarily map onto the register classes used by the backend.; /// FIXME: It's not currently possible to determine how many registers; /// are used by the provided type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:510,Usability,simpl,simple,510,"/// \return the target-provided register class ID for the provided type,; /// accounting for type promotion and other type-legalization techniques that; /// the target might apply. However, it specifically does not account for the; /// scalarization or splitting of vector types. Should a vector type require; /// scalarization or splitting into multiple underlying vector registers, that; /// type should be mapped to a register class containing no registers.; /// Specifically, this is designed to provide a simple, high-level view of the; /// register allocation later performed by the backend. These register classes; /// don't necessarily map onto the register classes used by the backend.; /// FIXME: It's not currently possible to determine how many registers; /// are used by the provided type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:35,Performance,tune,tune,35,/// \return the value of vscale to tune the cost model for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:44,Energy Efficiency,power,power,44,/// \return true if vscale is known to be a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:270,Performance,scalab,scalable,270,"/// \return The minimum vectorization factor for types of given element; /// bit width, or 0 if there is no minimum VF. The returned value only; /// applies when shouldMaximizeVectorBandwidth returns true.; /// If IsScalable is true, the returned ElementCount must be a scalable VF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:26,Performance,cache,cache,26,/// \return The size of a cache line in bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:17,Performance,cache,cache,17,/// The possible cache levels,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:15,Performance,cache,cache,15,// The L1 data cache,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:15,Performance,cache,cache,15,"// The L2 data cache; // We currently do not model L3 caches, as their sizes differ widely between; // microarchitectures. Also, we currently do not have a use for L3 cache; // size modeling yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:54,Performance,cache,caches,54,"// The L2 data cache; // We currently do not model L3 caches, as their sizes differ widely between; // microarchitectures. Also, we currently do not have a use for L3 cache; // size modeling yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:167,Performance,cache,cache,167,"// The L2 data cache; // We currently do not model L3 caches, as their sizes differ widely between; // microarchitectures. Also, we currently do not have a use for L3 cache; // size modeling yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:53,Availability,avail,available,53,"/// \return The size of the cache level in bytes, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:28,Performance,cache,cache,28,"/// \return The size of the cache level in bytes, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:53,Availability,avail,available,53,"/// \return The associativity of the cache level, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:37,Performance,cache,cache,37,"/// \return The associativity of the cache level, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:30,Performance,load,load,30,/// \return How much before a load we should place the prefetch; /// instruction. This is currently measured in number of; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:594,Performance,cache,cache,594,"/// Some HW prefetchers can handle accesses up to a certain constant stride.; /// Sometimes prefetching is beneficial even below the HW prefetcher limit,; /// and the arguments provided are meant to serve as a basis for deciding this; /// for a particular loop.; ///; /// \param NumMemAccesses Number of memory accesses in the loop.; /// \param NumStridedMemAccesses Number of the memory accesses that; /// ScalarEvolution could find a known stride; /// for.; /// \param NumPrefetches Number of software prefetches that will be; /// emitted as determined by the addresses; /// involved and the cache line size.; /// \param HasCall True if the loop contains a call.; ///; /// \return This is the minimum stride in bytes where it makes sense to start; /// adding SW prefetches. The default is 1, i.e. prefetch with any; /// stride.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:35,Security,access,accesses,35,"/// Some HW prefetchers can handle accesses up to a certain constant stride.; /// Sometimes prefetching is beneficial even below the HW prefetcher limit,; /// and the arguments provided are meant to serve as a basis for deciding this; /// for a particular loop.; ///; /// \param NumMemAccesses Number of memory accesses in the loop.; /// \param NumStridedMemAccesses Number of the memory accesses that; /// ScalarEvolution could find a known stride; /// for.; /// \param NumPrefetches Number of software prefetches that will be; /// emitted as determined by the addresses; /// involved and the cache line size.; /// \param HasCall True if the loop contains a call.; ///; /// \return This is the minimum stride in bytes where it makes sense to start; /// adding SW prefetches. The default is 1, i.e. prefetch with any; /// stride.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:311,Security,access,accesses,311,"/// Some HW prefetchers can handle accesses up to a certain constant stride.; /// Sometimes prefetching is beneficial even below the HW prefetcher limit,; /// and the arguments provided are meant to serve as a basis for deciding this; /// for a particular loop.; ///; /// \param NumMemAccesses Number of memory accesses in the loop.; /// \param NumStridedMemAccesses Number of the memory accesses that; /// ScalarEvolution could find a known stride; /// for.; /// \param NumPrefetches Number of software prefetches that will be; /// emitted as determined by the addresses; /// involved and the cache line size.; /// \param HasCall True if the loop contains a call.; ///; /// \return This is the minimum stride in bytes where it makes sense to start; /// adding SW prefetches. The default is 1, i.e. prefetch with any; /// stride.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:388,Security,access,accesses,388,"/// Some HW prefetchers can handle accesses up to a certain constant stride.; /// Sometimes prefetching is beneficial even below the HW prefetcher limit,; /// and the arguments provided are meant to serve as a basis for deciding this; /// for a particular loop.; ///; /// \param NumMemAccesses Number of memory accesses in the loop.; /// \param NumStridedMemAccesses Number of the memory accesses that; /// ScalarEvolution could find a known stride; /// for.; /// \param NumPrefetches Number of software prefetches that will be; /// emitted as determined by the addresses; /// involved and the cache line size.; /// \param HasCall True if the loop contains a call.; ///; /// \return This is the minimum stride in bytes where it makes sense to start; /// adding SW prefetches. The default is 1, i.e. prefetch with any; /// stride.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:155,Performance,perform,performed,155,"/// \return The maximum number of iterations to prefetch ahead. If; /// the required number of iterations is more than this number, no; /// prefetching is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:117,Integrability,depend,depends,117,/// \return The maximum interleave factor that any transform should try to; /// perform for this target. This number depends on the level of parallelism; /// and the number of execution units in the CPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:80,Performance,perform,perform,80,/// \return The maximum interleave factor that any transform should try to; /// perform for this target. This number depends on the level of parallelism; /// and the number of execution units in the CPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:295,Integrability,depend,dependency,295,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:43,Performance,throughput,throughput,43,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:117,Performance,throughput,throughput,117,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:170,Performance,throughput,throughput,170,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:880,Performance,optimiz,optimizations,880,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:64,Testability,log,logic,64,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:151,Usability,guid,guides,151,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:341,Availability,mask,mask,341,/// Returns the cost estimation for alternating opcode pattern that can be; /// lowered to a single instruction on the target. In X86 this is for the; /// addsub instruction which corrsponds to a Shuffle + Fadd + FSub pattern in; /// IR. This function expects two opcodes: \p Opcode1 and \p Opcode2 being; /// selected by \p OpcodeMask. The mask contains one bit per lane and is a `0`; /// when \p Opcode0 is selected and `1` when Opcode1 is selected.; /// \p VecTy is the vector type of the instruction to be generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:90,Availability,mask,mask,90,"/// \return The cost of a shuffle instruction of kind Kind and of type Tp.; /// The exact mask may be passed as Mask, or else the array will be empty.; /// The index and subtype parameters are used by the subvector insertion and; /// extraction shuffle kinds to show the insert/extract point and the type of; /// the subvector being inserted/extracted. The operands of the shuffle can be; /// passed through \p Args, which helps improve the cost estimation in some; /// cases, like in broadcast loads.; /// NOTE: For subvector extractions Tp represents the source type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:112,Availability,Mask,Mask,112,"/// \return The cost of a shuffle instruction of kind Kind and of type Tp.; /// The exact mask may be passed as Mask, or else the array will be empty.; /// The index and subtype parameters are used by the subvector insertion and; /// extraction shuffle kinds to show the insert/extract point and the type of; /// the subvector being inserted/extracted. The operands of the shuffle can be; /// passed through \p Args, which helps improve the cost estimation in some; /// cases, like in broadcast loads.; /// NOTE: For subvector extractions Tp represents the source type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:495,Performance,load,loads,495,"/// \return The cost of a shuffle instruction of kind Kind and of type Tp.; /// The exact mask may be passed as Mask, or else the array will be empty.; /// The index and subtype parameters are used by the subvector insertion and; /// extraction shuffle kinds to show the insert/extract point and the type of; /// the subvector being inserted/extracted. The operands of the shuffle can be; /// passed through \p Args, which helps improve the cost estimation in some; /// cases, like in broadcast loads.; /// NOTE: For subvector extractions Tp represents the source type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:151,Performance,load,load,151,"/// Represents a hint about the context in which a cast is used.; ///; /// For zext/sext, the context of the cast is the operand, which must be a; /// load of some kind. For trunc, the context is of the cast is the single; /// user of the instruction, which must be a store of some kind.; ///; /// This enum allows the vectorizer to give getCastInstrCost an idea of the; /// type of cast it's dealing with, as not every cast is equal. For instance,; /// the zext of a load may be free, but the zext of an interleaving load can; //// be (very) expensive!; ///; /// See \c getCastContextHint to compute a CastContextHint from a cast; /// Instruction*. Callers can use it if they don't need to override the; /// context and just want it to be calculated from the instruction.; ///; /// FIXME: This handles the types of load/store that the vectorizer can; /// produce, which are the cases where the context instruction is most; /// likely to be incorrect. There are other situations where that can happen; /// too, which might be handled here but in the long run a more general; /// solution of costing multiple instructions at the same times may be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:468,Performance,load,load,468,"/// Represents a hint about the context in which a cast is used.; ///; /// For zext/sext, the context of the cast is the operand, which must be a; /// load of some kind. For trunc, the context is of the cast is the single; /// user of the instruction, which must be a store of some kind.; ///; /// This enum allows the vectorizer to give getCastInstrCost an idea of the; /// type of cast it's dealing with, as not every cast is equal. For instance,; /// the zext of a load may be free, but the zext of an interleaving load can; //// be (very) expensive!; ///; /// See \c getCastContextHint to compute a CastContextHint from a cast; /// Instruction*. Callers can use it if they don't need to override the; /// context and just want it to be calculated from the instruction.; ///; /// FIXME: This handles the types of load/store that the vectorizer can; /// produce, which are the cases where the context instruction is most; /// likely to be incorrect. There are other situations where that can happen; /// too, which might be handled here but in the long run a more general; /// solution of costing multiple instructions at the same times may be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:518,Performance,load,load,518,"/// Represents a hint about the context in which a cast is used.; ///; /// For zext/sext, the context of the cast is the operand, which must be a; /// load of some kind. For trunc, the context is of the cast is the single; /// user of the instruction, which must be a store of some kind.; ///; /// This enum allows the vectorizer to give getCastInstrCost an idea of the; /// type of cast it's dealing with, as not every cast is equal. For instance,; /// the zext of a load may be free, but the zext of an interleaving load can; //// be (very) expensive!; ///; /// See \c getCastContextHint to compute a CastContextHint from a cast; /// Instruction*. Callers can use it if they don't need to override the; /// context and just want it to be calculated from the instruction.; ///; /// FIXME: This handles the types of load/store that the vectorizer can; /// produce, which are the cases where the context instruction is most; /// likely to be incorrect. There are other situations where that can happen; /// too, which might be handled here but in the long run a more general; /// solution of costing multiple instructions at the same times may be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:816,Performance,load,load,816,"/// Represents a hint about the context in which a cast is used.; ///; /// For zext/sext, the context of the cast is the operand, which must be a; /// load of some kind. For trunc, the context is of the cast is the single; /// user of the instruction, which must be a store of some kind.; ///; /// This enum allows the vectorizer to give getCastInstrCost an idea of the; /// type of cast it's dealing with, as not every cast is equal. For instance,; /// the zext of a load may be free, but the zext of an interleaving load can; //// be (very) expensive!; ///; /// See \c getCastContextHint to compute a CastContextHint from a cast; /// Instruction*. Callers can use it if they don't need to override the; /// context and just want it to be calculated from the instruction.; ///; /// FIXME: This handles the types of load/store that the vectorizer can; /// produce, which are the cases where the context instruction is most; /// likely to be incorrect. There are other situations where that can happen; /// too, which might be handled here but in the long run a more general; /// solution of costing multiple instructions at the same times may be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:33,Performance,load,load,33,///< The cast is not used with a load/store of any kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,Performance,load,load,36,///< The cast is used with a normal load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:29,Availability,mask,masked,29,///< The cast is used with a masked load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,Performance,load,load,36,///< The cast is used with a masked load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:42,Performance,load,load,42,///< The cast is used with an interleaved load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:38,Performance,load,load,38,///< The cast is used with a reversed load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:49,Modifiability,extend,extended,49,/// \return The expected cost of a sign- or zero-extended vector extract. Use; /// Index = -1 to indicate that there is no information about the index value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:179,Availability,avail,available,179,/// \return The expected cost of vector Insert and Extract.; /// Use -1 to indicate that there is no information on the index value.; /// This is used when the instruction is not available; a typical use; /// case is to provision the cost of vectorization/scalarization in; /// vectorizer passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:98,Availability,avail,available,98,"/// \return The expected cost of vector Insert and Extract.; /// This is used when instruction is available, and implementation; /// asserts 'I' is not nullptr.; ///; /// A typical suitable use case is cost estimation when vector instruction; /// exists (e.g., from basic blocks during transformation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:133,Testability,assert,asserts,133,"/// \return The expected cost of vector Insert and Extract.; /// This is used when instruction is available, and implementation; /// asserts 'I' is not nullptr.; ///; /// A typical suitable use case is cost estimation when vector instruction; /// exists (e.g., from basic blocks during transformation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:137,Availability,mask,mask,137,"/// \return The cost of replication shuffle of \p VF elements typed \p EltTy; /// \p ReplicationFactor times.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:24,Performance,Load,Load,24,/// \return The cost of Load and Store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:27,Performance,Load,Load,27,/// \return The cost of VP Load and Store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:24,Availability,mask,masked,24,/// \return The cost of masked Load and Store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:31,Performance,Load,Load,31,/// \return The cost of masked Load and Store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:318,Availability,mask,mask,318,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:254,Modifiability,Variab,VariableMask,254,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:96,Performance,Load,Load,96,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:159,Performance,load,loaded,159,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:496,Performance,load,load,496,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:89,Security,access,access,89,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:290,Security,access,access,290,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:534,Availability,mask,masked,534,/// \return The cost of the interleaved memory operation.; /// \p Opcode is the memory operation code; /// \p VecTy is the vector type of the interleaved access.; /// \p Factor is the interleave factor; /// \p Indices is the indices for interleaved load members (as interleaved; /// load allows gaps); /// \p Alignment is the alignment of the memory operation; /// \p AddressSpace is address space of the pointer.; /// \p UseMaskForCond indicates if the memory access is predicated.; /// \p UseMaskForGaps indicates if gaps should be masked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:249,Performance,load,load,249,/// \return The cost of the interleaved memory operation.; /// \p Opcode is the memory operation code; /// \p VecTy is the vector type of the interleaved access.; /// \p Factor is the interleave factor; /// \p Indices is the indices for interleaved load members (as interleaved; /// load allows gaps); /// \p Alignment is the alignment of the memory operation; /// \p AddressSpace is address space of the pointer.; /// \p UseMaskForCond indicates if the memory access is predicated.; /// \p UseMaskForGaps indicates if gaps should be masked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:283,Performance,load,load,283,/// \return The cost of the interleaved memory operation.; /// \p Opcode is the memory operation code; /// \p VecTy is the vector type of the interleaved access.; /// \p Factor is the interleave factor; /// \p Indices is the indices for interleaved load members (as interleaved; /// load allows gaps); /// \p Alignment is the alignment of the memory operation; /// \p AddressSpace is address space of the pointer.; /// \p UseMaskForCond indicates if the memory access is predicated.; /// \p UseMaskForGaps indicates if gaps should be masked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:154,Security,access,access,154,/// \return The cost of the interleaved memory operation.; /// \p Opcode is the memory operation code; /// \p VecTy is the vector type of the interleaved access.; /// \p Factor is the interleave factor; /// \p Indices is the indices for interleaved load members (as interleaved; /// load allows gaps); /// \p Alignment is the alignment of the memory operation; /// \p AddressSpace is address space of the pointer.; /// \p UseMaskForCond indicates if the memory access is predicated.; /// \p UseMaskForGaps indicates if gaps should be masked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:461,Security,access,access,461,/// \return The cost of the interleaved memory operation.; /// \p Opcode is the memory operation code; /// \p VecTy is the vector type of the interleaved access.; /// \p Factor is the interleave factor; /// \p Indices is the indices for interleaved load members (as interleaved; /// load allows gaps); /// \p Alignment is the alignment of the memory operation; /// \p AddressSpace is address space of the pointer.; /// \p UseMaskForCond indicates if the memory access is predicated.; /// \p UseMaskForGaps indicates if gaps should be masked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:270,Performance,perform,performing,270,"/// Calculate the cost of vector reduction intrinsics.; ///; /// This is the cost of reducing the vector value of type \p Ty to a scalar; /// value using the operation denoted by \p Opcode. The FastMathFlags; /// parameter \p FMF indicates what type of reduction we are performing:; /// 1. Tree-wise. This is the typical 'fast' reduction performed that; /// involves successively splitting a vector into half and doing the; /// operation on the pair of halves until you have a scalar value. For; /// example:; /// (v0, v1, v2, v3); /// ((v0+v2), (v1+v3), undef, undef); /// ((v0+v2+v1+v3), undef, undef, undef); /// This is the default behaviour for integer operations, whereas for; /// floating point we only do this if \p FMF indicates that; /// reassociation is allowed.; /// 2. Ordered. For a vector with N elements this involves performing N; /// operations in lane order, starting with an initial scalar value, i.e.; /// result = InitVal + v0; /// result = result + v1; /// result = result + v2; /// result = result + v3; /// This is only the case for FP operations and when reassociation is not; /// allowed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:338,Performance,perform,performed,338,"/// Calculate the cost of vector reduction intrinsics.; ///; /// This is the cost of reducing the vector value of type \p Ty to a scalar; /// value using the operation denoted by \p Opcode. The FastMathFlags; /// parameter \p FMF indicates what type of reduction we are performing:; /// 1. Tree-wise. This is the typical 'fast' reduction performed that; /// involves successively splitting a vector into half and doing the; /// operation on the pair of halves until you have a scalar value. For; /// example:; /// (v0, v1, v2, v3); /// ((v0+v2), (v1+v3), undef, undef); /// ((v0+v2+v1+v3), undef, undef, undef); /// This is the default behaviour for integer operations, whereas for; /// floating point we only do this if \p FMF indicates that; /// reassociation is allowed.; /// 2. Ordered. For a vector with N elements this involves performing N; /// operations in lane order, starting with an initial scalar value, i.e.; /// result = InitVal + v0; /// result = result + v1; /// result = result + v2; /// result = result + v3; /// This is only the case for FP operations and when reassociation is not; /// allowed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:834,Performance,perform,performing,834,"/// Calculate the cost of vector reduction intrinsics.; ///; /// This is the cost of reducing the vector value of type \p Ty to a scalar; /// value using the operation denoted by \p Opcode. The FastMathFlags; /// parameter \p FMF indicates what type of reduction we are performing:; /// 1. Tree-wise. This is the typical 'fast' reduction performed that; /// involves successively splitting a vector into half and doing the; /// operation on the pair of halves until you have a scalar value. For; /// example:; /// (v0, v1, v2, v3); /// ((v0+v2), (v1+v3), undef, undef); /// ((v0+v2+v1+v3), undef, undef, undef); /// This is the default behaviour for integer operations, whereas for; /// floating point we only do this if \p FMF indicates that; /// reassociation is allowed.; /// 2. Ordered. For a vector with N elements this involves performing N; /// operations in lane order, starting with an initial scalar value, i.e.; /// result = InitVal + v0; /// result = result + v1; /// result = result + v2; /// result = result + v3; /// This is only the case for FP operations and when reassociation is not; /// allowed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:29,Modifiability,extend,extended,29,"/// Calculate the cost of an extended reduction pattern, similar to; /// getArithmeticReductionCost of an Add reduction with multiply and optional; /// extensions. This is the cost of as:; /// ResTy vecreduce.add(mul (A, B)).; /// ResTy vecreduce.add(mul(ext(Ty A), ext(Ty B)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:29,Modifiability,extend,extended,29,"/// Calculate the cost of an extended reduction pattern, similar to; /// getArithmeticReductionCost of a reduction with an extension.; /// This is the cost of as:; /// ResTy vecreduce.opcode(ext(Ty A)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:499,Security,access,access,499,/// \returns The cost of the address computation. For most targets this can be; /// merged into the instruction indexing mode. Some targets might want to; /// distinguish between address computation for memory operations on vector; /// types and scalar types. Such targets should override this function.; /// The 'SE' parameter holds pointer for the scalar evolution object which; /// is used in order to get the Ptr step value in case of constant stride.; /// The 'Ptr' parameter holds SCEV of the access pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:68,Availability,alive,alive,68,"/// \returns The cost, if any, of keeping values of the given types alive; /// over a callsite.; ///; /// Some types may require the use of register classes that do not have; /// any callee-saved registers, so would require a spill and fill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:16,Performance,load,load,16,/// The type of load/store indexing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:43,Performance,load,load,43,/// \returns True if the specified indexed load for the given type is legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:81,Performance,load,load,81,/// \returns The bitwidth of the largest vector type that should be used to; /// load/store in the given address space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:25,Performance,load,load,25,/// \returns True if the load instruction is legal to vectorize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:56,Performance,load,load,56,/// \returns True if it is legal to vectorize the given load chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:53,Performance,scalab,scalable,53,/// \returns True if the given type is supported for scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:91,Performance,load,loads,91,/// \returns The new vector factor value if the target doesn't support \p; /// SizeInBytes loads or has a better vector factor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:172,Availability,mask,mask,172,"/// \returns True if the target prefers reductions select kept in the loop; /// when tail folding. i.e.; /// loop:; /// p = phi (0, s); /// a = add (p, x); /// s = select (mask, a, p); /// vecreduce.add(s); ///; /// As opposed to the normal scheme of p = phi (0, a) which allows the select; /// to be pulled out of the loop. If the select(.., add, ..) can be predicated; /// by the target, this can lead to cleaner code generation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:41,Performance,scalab,scalable,41,/// \returns True if the target supports scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:22,Performance,scalab,scalable,22,/// \return true when scalable vectorization is preferred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:117,Energy Efficiency,efficient,efficiently,117,"/// \name Vector Predication Information; /// @{; /// Whether the target supports the %evl parameter of VP intrinsic efficiently; /// in hardware, for the given opcode and type/alignment. (see LLVM Language; /// Reference - ""Vector Predication Intrinsics"").; /// Use of %evl is discouraged when that is not the case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:183,Availability,mask,mask,183,// How to transform the EVL parameter.; // Legal: keep the EVL parameter as it is.; // Discard: Ignore the EVL parameter where it is safe to do so.; // Convert: Fold the EVL into the mask parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:133,Safety,safe,safe,133,// How to transform the EVL parameter.; // Legal: keep the EVL parameter as it is.; // Discard: Ignore the EVL parameter where it is safe to do so.; // Convert: Fold the EVL into the mask parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:60,Availability,avail,available,60,"/// @}; /// \returns Whether a 32-bit branch instruction is available in Arm or Thumb; /// state.; ///; /// Used by the LowerTypeTests pass, which constructs an IR inline assembler; /// node containing a jump table in a format suitable for the target, so it; /// needs to know what format of jump table it can legally use.; ///; /// For non-Arm targets, this function isn't used. It defaults to returning; /// false, but it shouldn't matter what it returns anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:48,Integrability,wrap,wraps,48,/// The template model for the base class which wraps a concrete; /// implementation in a type erased interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:102,Integrability,interface,interface,102,/// The template model for the base class which wraps a concrete; /// implementation in a type erased interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:30,Performance,load,load,30,/// \return How much before a load we should place the prefetch; /// instruction. This is currently measured in number of; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:43,Security,access,accesses,43,"/// \return Some HW prefetchers can handle accesses up to a certain; /// constant stride. This is the minimum stride in bytes where it; /// makes sense to start adding SW prefetches. The default is 1,; /// i.e. prefetch with any stride. Sometimes prefetching is beneficial; /// even below the HW prefetcher limit, and the arguments provided are; /// meant to serve as a basis for deciding this for a particular loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:155,Performance,perform,performed,155,"/// \return The maximum number of iterations to prefetch ahead. If; /// the required number of iterations is more than this number, no; /// prefetching is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:120,Integrability,interface,interface,120,/// Analysis pass providing the \c TargetTransformInfo.; ///; /// The core idea of the TargetIRAnalysis is to expose an interface through; /// which LLVM targets can analyze and provide information about the middle; /// end's target-independent IR. This supports use cases such as target-aware; /// cost modeling of IR constructs.; ///; /// This is a function analysis because much of the cost modeling for targets; /// is done in a subtarget specific way and LLVM supports compiling different; /// functions targeting different subtargets in order to support runtime; /// dispatch according to the observed subtarget.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:110,Security,expose,expose,110,/// Analysis pass providing the \c TargetTransformInfo.; ///; /// The core idea of the TargetIRAnalysis is to expose an interface through; /// which LLVM targets can analyze and provide information about the middle; /// end's target-independent IR. This supports use cases such as target-aware; /// cost modeling of IR constructs.; ///; /// This is a function analysis because much of the cost modeling for targets; /// is done in a subtarget specific way and LLVM supports compiling different; /// functions targeting different subtargets in order to support runtime; /// dispatch according to the observed subtarget.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:462,Availability,error,error,462,"/// The callback used to produce a result.; ///; /// We use a completely opaque callback so that targets can provide whatever; /// mechanism they desire for constructing the TTI for a given function.; ///; /// FIXME: Should we really use std::function? It's relatively inefficient.; /// It might be possible to arrange for even stateful callbacks to outlive; /// the analysis and thus use a function_ref which would be lighter weight.; /// This may also be less error prone as the callback is likely to reference; /// the external TargetMachine, and that reference needs to never dangle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper pass for TargetTransformInfo.; ///; /// This pass can be constructed from a TTI object which it stores internally; /// and is queried by passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:153,Integrability,rout,routines,153,/// We must provide a default constructor for the pass but it should; /// never be used.; ///; /// Use the constructor below or call one of the creation routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:127,Availability,avail,available,127,/// Create an analysis pass wrapper around a TTI object.; ///; /// This analysis pass just holds the TTI instance and makes it available to; /// clients.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:28,Integrability,wrap,wrapper,28,/// Create an analysis pass wrapper around a TTI object.; ///; /// This analysis pass just holds the TTI instance and makes it available to; /// clients.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:208,Modifiability,refactor,refactorings,208,"// FIXME: These should almost certainly not be handled here, and instead; // handled with the help of TLI or the target itself. This was largely; // ported from existing analysis heuristics here so that such refactorings; // can take place in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:30,Performance,optimiz,optimized,30,// These are all likely to be optimized into something smaller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:52,Availability,avail,available,52,"// By default, assume nontemporal memory stores are available for stores; // that are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:120,Energy Efficiency,power,power,120,"// By default, assume nontemporal memory stores are available for stores; // that are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:51,Availability,avail,available,51,"// By default, assume nontemporal memory loads are available for loads that; // are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:118,Energy Efficiency,power,power,118,"// By default, assume nontemporal memory loads are available for loads that; // are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:41,Performance,load,loads,41,"// By default, assume nontemporal memory loads are available for loads that; // are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:65,Performance,load,loads,65,"// By default, assume nontemporal memory loads are available for loads that; // are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:22,Testability,log,logical-and,22,// If the select is a logical-and/logical-or then it is better treated as a; // and/or by the backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:34,Testability,log,logical-or,34,// If the select is a logical-and/logical-or then it is better treated as a; // and/or by the backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:113,Performance,optimiz,optimized,113,"// Widenable conditions will eventually lower into constants, so some; // operations with them will be trivially optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:37,Testability,test,tests,37,// FIXME: A number of transformation tests seem to require these values; // which seems a little odd for how arbitary there are.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:16,Performance,latency,latency,16,// Assume a 3cy latency for fp arithmetic ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:49,Performance,throughput,throughput,49,"// A phi would be free, unless we're costing the throughput because it; // will require a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:103,Energy Efficiency,power,power-of-,103,"// Note for overrides: You must ensure for all element unordered-atomic; // memory intrinsics that all power-of-2 element sizes up to, and; // including, the return value of this method have a corresponding; // runtime lib call. These runtime lib call definitions can be found; // in RuntimeLibcalls.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:24,Performance,scalab,scalable,24,"// If this operand is a scalable type, bail out early.; // TODO: Make isLegalAddressingMode TypeSize aware.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:275,Performance,load,load,275,"// If we haven't been provided a hint, use the target type for now.; //; // TODO: Take a look at potentially removing this: This is *slightly* wrong; // as it's possible to have a GEP with a foldable target type but a memory; // access that isn't foldable. For example, this load isn't foldable on; // RISC-V:; //; // %p = getelementptr i32, ptr %base, i32 42; // %x = load <2 x i32>, ptr %p",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:369,Performance,load,load,369,"// If we haven't been provided a hint, use the target type for now.; //; // TODO: Take a look at potentially removing this: This is *slightly* wrong; // as it's possible to have a GEP with a foldable target type but a memory; // access that isn't foldable. For example, this load isn't foldable on; // RISC-V:; //; // %p = getelementptr i32, ptr %base, i32 42; // %x = load <2 x i32>, ptr %p",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:229,Security,access,access,229,"// If we haven't been provided a hint, use the target type for now.; //; // TODO: Take a look at potentially removing this: This is *slightly* wrong; // as it's possible to have a GEP with a foldable target type but a memory; // access that isn't foldable. For example, this load isn't foldable on; // RISC-V:; //; // %p = getelementptr i32, ptr %base, i32 42; // %x = load <2 x i32>, ptr %p",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:80,Security,access,access,80,"// If the final address of the GEP is a legal addressing mode for the given; // access type, then we can fold it into its users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:563,Integrability,depend,dependecies,563,"// In the basic model we take into account GEP instructions only; // (although here can come alloca instruction, a value, constants and/or; // constant expressions, PHIs, bitcasts ... whatever allowed to be used as a; // pointer). Typically, if Base is a not a GEP-instruction and all the; // pointers are relative to the same base address, all the rest are; // either GEP instructions, PHIs, bitcasts or constants. When we have same; // base, we just calculate cost of each non-Base GEP as an ADD operation if; // any their index is a non-const.; // If no known dependecies between the pointers cost is calculated as a sum; // of costs of GEP instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:29,Security,Access,AccessType,29,"// For now, only provide the AccessType in the simple case where the GEP; // only has one user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:47,Usability,simpl,simple,47,"// For now, only provide the AccessType in the simple case where the GEP; // only has one user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:110,Performance,load,load,110,"// If there is a non-register sized type, the cost estimation may expand; // it to be several instructions to load into multiple registers on the; // target. But, if the only use of the load is a trunc instruction to a; // register sized type, the instruction selector can combine these; // instructions to be a single load. So, in this case, we use the; // destination type of the trunc instruction rather than the load to; // accurately estimate the cost of this load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:186,Performance,load,load,186,"// If there is a non-register sized type, the cost estimation may expand; // it to be several instructions to load into multiple registers on the; // target. But, if the only use of the load is a trunc instruction to a; // register sized type, the instruction selector can combine these; // instructions to be a single load. So, in this case, we use the; // destination type of the trunc instruction rather than the load to; // accurately estimate the cost of this load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:319,Performance,load,load,319,"// If there is a non-register sized type, the cost estimation may expand; // it to be several instructions to load into multiple registers on the; // target. But, if the only use of the load is a trunc instruction to a; // register sized type, the instruction selector can combine these; // instructions to be a single load. So, in this case, we use the; // destination type of the trunc instruction rather than the load to; // accurately estimate the cost of this load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:416,Performance,load,load,416,"// If there is a non-register sized type, the cost estimation may expand; // it to be several instructions to load into multiple registers on the; // target. But, if the only use of the load is a trunc instruction to a; // register sized type, the instruction selector can combine these; // instructions to be a single load. So, in this case, we use the; // destination type of the trunc instruction rather than the load to; // accurately estimate the cost of this load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:465,Performance,load,load,465,"// If there is a non-register sized type, the cost estimation may expand; // it to be several instructions to load into multiple registers on the; // target. But, if the only use of the load is a trunc instruction to a; // register sized type, the instruction selector can combine these; // instructions to be a single load. So, in this case, we use the; // destination type of the trunc instruction rather than the load to; // accurately estimate the cost of this load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:94,Performance,throughput,throughput,94,"// By default, just classify everything as 'basic' or -1 to represent that; // don't know the throughput cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TensorSpec.h:246,Usability,Learn,Learning,246,"/// TensorSpec encapsulates the specification of a tensor: its dimensions, or; /// ""shape"" (row-major), its type (see TensorSpec::getDataType specializations; /// for supported types), its name and port (see ""TensorFlow: Large-Scale; /// Machine Learning on Heterogeneous Distributed Systems"", section 4.2, para 2:; /// https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45166.pdf); ///; /// Note that the design is motivated by Tensorflow, but it is not intended to; /// be Tensorflow-specific.; ///; /// Known tensor types. The left part is the C type, the; /// right is a name we can use to identify the type (to implement TensorSpec; /// equality checks), and to use, if needed, when mapping to an underlying; /// evaluator's type system. The main requirement is that the C type we use has; /// the same size and encoding (e.g. endian-ness) as the one used by the; /// evaluator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TensorSpec.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TensorSpec.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h:538,Performance,optimiz,optimizations,538,"//===- llvm/Analysis/Trace.h - Represent one trace of LLVM code -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class represents a single trace of LLVM basic blocks. A trace is a; // single entry, multiple exit, region of code that is often hot. Trace-based; // optimizations treat traces almost like they are a large, strange, basic; // block: because the trace path is assumed to be hot, optimizations for the; // fall-through path are made at the expense of the non-fall-through paths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h:666,Performance,optimiz,optimizations,666,"//===- llvm/Analysis/Trace.h - Represent one trace of LLVM code -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class represents a single trace of LLVM basic blocks. A trace is a; // single entry, multiple exit, region of code that is often hot. Trace-based; // optimizations treat traces almost like they are a large, strange, basic; // block: because the trace path is assumed to be hot, optimizations for the; // fall-through path are made at the expense of the non-fall-through paths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h:65,Availability,error,error,65,/// dump - Debugger convenience method; writes trace to standard error; /// output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h:407,Integrability,interface,interface,407,"//===- TypeBasedAliasAnalysis.h - Type-Based Alias Analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This is the interface for a metadata-based TBAA. See the source file for; /// details on the algorithm.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h:6,Usability,simpl,simple,6,/// A simple AA result that uses TBAA metadata to answer queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the TypeBasedAAResult object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h:46,Testability,test,test,46,"/// Given a call to the intrinsic \@llvm.type.test, find all devirtualizable; /// call sites based on the call and return them in DevirtCalls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h:54,Performance,load,load,54,"/// Given a call to the intrinsic \@llvm.type.checked.load, find all; /// devirtualizable call sites based on the call and return them in DevirtCalls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h:46,Modifiability,extend,extended,46,/// Number of times a constant range has been extended with widening enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h:22,Modifiability,extend,extending,22,/// Handle repeatedly extending a range by going to overdefined after a; /// number of steps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h:42,Modifiability,extend,extended,42,"// Simple form of widening. If a range is extended multiple times, go to; // overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h:3,Usability,Simpl,Simple,3,"// Simple form of widening. If a range is extended multiple times, go to; // overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h:4,Deployability,Update,Updates,4,/// Updates this object to approximate both this object and RHS. Returns; /// true if this object has been changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h:430,Performance,perform,performing,430,"//===-- ValueLatticeUtils.h - Utils for solving lattices --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares common functions useful for performing data-flow analyses; // that propagate values across function boundaries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h:58,Modifiability,variab,variable,58,/// Determine if the value maintained in the given global variable can be; /// tracked interprocedurally. A value can be tracked if the global variable; /// has local linkage and is only used by non-volatile loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h:143,Modifiability,variab,variable,143,/// Determine if the value maintained in the given global variable can be; /// tracked interprocedurally. A value can be tracked if the global variable; /// has local linkage and is only used by non-volatile loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h:208,Performance,load,loads,208,/// Determine if the value maintained in the given global variable can be; /// tracked interprocedurally. A value can be tracked if the global variable; /// has local linkage and is only used by non-volatile loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:402,Integrability,rout,routines,402,"//===- llvm/Analysis/ValueTracking.h - Walk computations --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains routines that help analyze properties that chains of; // computations have.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:34,Integrability,depend,dependent,34,/// Merge bits known from context-dependent facts into Known.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:55,Testability,log,logic,55,/// Using KnownBits LHS/RHS produce the known bits for logic op (and/xor/or).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:149,Energy Efficiency,power,power,149,"/// Return true if the given value is known to have exactly one bit set when; /// defined. For vectors return true if every element is known to be a power; /// of two when defined. Supports values with integer or pointer type and; /// vectors of integers. If 'OrZero' is set, then return true if the given; /// value is either a power of two or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:329,Energy Efficiency,power,power,329,"/// Return true if the given value is known to have exactly one bit set when; /// defined. For vectors return true if every element is known to be a power; /// of two when defined. Supports values with integer or pointer type and; /// vectors of integers. If 'OrZero' is set, then return true if the given; /// value is either a power of two or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:243,Performance,perform,perform,243,"/// Return true if the given value is known to be non-zero when defined. For; /// vectors, return true if every element is known to be non-zero when; /// defined. For pointers, if the context instruction and dominator tree are; /// specified, perform context-sensitive analysis and return true if the; /// pointer couldn't possibly be null at the specified instruction.; /// Supports values with integer or pointer type and vectors of integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:24,Availability,Mask,Mask,24,"/// Return true if 'V & Mask' is known to be zero. We use this predicate to; /// simplify operations downstream. Mask is known to be zero for bits that V; /// cannot have.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, the mask, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the elements in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:101,Availability,down,downstream,101,"/// Return true if 'V & Mask' is known to be zero. We use this predicate to; /// simplify operations downstream. Mask is known to be zero for bits that V; /// cannot have.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, the mask, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the elements in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:113,Availability,Mask,Mask,113,"/// Return true if 'V & Mask' is known to be zero. We use this predicate to; /// simplify operations downstream. Mask is known to be zero for bits that V; /// cannot have.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, the mask, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the elements in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:334,Availability,mask,mask,334,"/// Return true if 'V & Mask' is known to be zero. We use this predicate to; /// simplify operations downstream. Mask is known to be zero for bits that V; /// cannot have.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, the mask, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the elements in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:81,Usability,simpl,simplify,81,"/// Return true if 'V & Mask' is known to be zero. We use this predicate to; /// simplify operations downstream. Mask is known to be zero for bits that V; /// cannot have.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, the mask, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the elements in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:220,Availability,mask,mask,220,"/// Returns a pair of values, which if passed to llvm.is.fpclass, returns the; /// same result as an fcmp with the given operands.; ///; /// If \p LookThroughSrc is true, consider the input value when computing the; /// mask.; ///; /// If \p LookThroughSrc is false, ignore the source value (i.e. the first pair; /// element will always be LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:59,Availability,mask,mask,59,/// Return true if it's known this can never be one of the mask entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:80,Modifiability,extend,extends,80,/// Return true if it's know this can never be interpreted as a zero. This; /// extends isKnownNeverZero to cover the case where the assumed; /// floating-point mode for the function interprets denormals as zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:43,Availability,mask,mask,43,// Clear sign bits based on the input sign mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:3,Usability,Clear,Clear,3,// Clear sign bits based on the input sign mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:440,Availability,reliab,reliable,440,"/// Determine which floating-point classes are valid for \p V, and return them; /// in KnownFPClass bit sets.; ///; /// This function is defined on values with floating-point type, values vectors; /// of floating-point type, and arrays of floating-point type.; /// \p InterestedClasses is a compile time optimization hint for which floating; /// point classes should be queried. Queries not specified in \p; /// InterestedClasses should be reliable if they are determined during the; /// query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:304,Performance,optimiz,optimization,304,"/// Determine which floating-point classes are valid for \p V, and return them; /// in KnownFPClass bit sets.; ///; /// This function is defined on values with floating-point type, values vectors; /// of floating-point type, and arrays of floating-point type.; /// \p InterestedClasses is a compile time optimization hint for which floating; /// point classes should be queried. Queries not specified in \p; /// InterestedClasses should be reliable if they are determined during the; /// query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper to account for known fast math flags at the use instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:107,Integrability,depend,depending,107,/// Return true if we can prove that the specified FP value's sign bit is 0.; ///; /// NaN --> true/false (depending on the NaN's sign bit); /// +0 --> true; /// -0 --> false; /// x > +0 --> true; /// x < -0 --> false,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:173,Integrability,wrap,wrapper,173,/// Analyze the specified pointer to see if it can be expressed as a base; /// pointer plus a constant offset. Return the base and offset to the caller.; ///; /// This is a wrapper around Value::stripAndAccumulateConstantOffsets that; /// creates and later unpacks the required APInt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:136,Integrability,interface,interface,136,"/// ConstantDataArray pointer. nullptr indicates a zeroinitializer (a valid; /// initializer, it just doesn't fit the ConstantDataArray interface).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:16,Security,access,accessor,16,/// Convenience accessor for elements in the slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:18,Safety,avoid,avoid,18,// Force const to avoid infinite recursion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:463,Performance,Load,Load-PRE,463,"/// This method is similar to getUnderlyingObject except that it can; /// look through phi and select instructions and return multiple objects.; ///; /// If LoopInfo is passed, loop phis are further analyzed. If a pointer; /// accesses different objects in each iteration, we don't look through the; /// phi node. E.g. consider this loop nest:; ///; /// int **A;; /// for (i); /// for (j) {; /// A[i][j] = A[i-1][j] * B[j]; /// }; ///; /// This is transformed by Load-PRE to stash away A[i] for the next iteration; /// of the outer loop:; ///; /// Curr = A[0]; // Prev_0; /// for (i: 1..N) {; /// Prev = Curr; // Prev = PHI (Prev_0, Curr); /// Curr = A[i];; /// for (j: 0..N) {; /// Curr[j] = Prev[j] * B[j]; /// }; /// }; ///; /// Since A[i] and A[i-1] are independent pointers, getUnderlyingObjects; /// should not assume that Curr and Prev share the same underlying object thus; /// it shouldn't look through the phi above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:227,Security,access,accesses,227,"/// This method is similar to getUnderlyingObject except that it can; /// look through phi and select instructions and return multiple objects.; ///; /// If LoopInfo is passed, loop phis are further analyzed. If a pointer; /// accesses different objects in each iteration, we don't look through the; /// phi node. E.g. consider this loop nest:; ///; /// int **A;; /// for (i); /// for (j) {; /// A[i][j] = A[i-1][j] * B[j]; /// }; ///; /// This is transformed by Load-PRE to stash away A[i] for the next iteration; /// of the outer loop:; ///; /// Curr = A[0]; // Prev_0; /// for (i: 1..N) {; /// Prev = Curr; // Prev = PHI (Prev_0, Curr); /// Curr = A[i];; /// for (j: 0..N) {; /// Curr[j] = Prev[j] * B[j]; /// }; /// }; ///; /// Since A[i] and A[i-1] are independent pointers, getUnderlyingObjects; /// should not assume that Curr and Prev share the same underlying object thus; /// it shouldn't look through the phi above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:14,Integrability,wrap,wrapper,14,/// This is a wrapper around getUnderlyingObjects and adds support for basic; /// ptrtoint+arithmetic+inttoptr sequences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:281,Integrability,interface,interface,281,"/// Return true if speculation of the given load must be suppressed to avoid; /// ordering or interfering with an active sanitizer. If not suppressed,; /// dereferenceability and alignment must be proven separately. Note: This; /// is only needed for raw reasoning; if you use the interface below; /// (isSafeToSpeculativelyExecute), this is handled internally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:44,Performance,load,load,44,"/// Return true if speculation of the given load must be suppressed to avoid; /// ordering or interfering with an active sanitizer. If not suppressed,; /// dereferenceability and alignment must be proven separately. Note: This; /// is only needed for raw reasoning; if you use the interface below; /// (isSafeToSpeculativelyExecute), this is handled internally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:71,Safety,avoid,avoid,71,"/// Return true if speculation of the given load must be suppressed to avoid; /// ordering or interfering with an active sanitizer. If not suppressed,; /// dereferenceability and alignment must be proven separately. Note: This; /// is only needed for raw reasoning; if you use the interface below; /// (isSafeToSpeculativelyExecute), this is handled internally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:121,Security,sanitiz,sanitizer,121,"/// Return true if speculation of the given load must be suppressed to avoid; /// ordering or interfering with an active sanitizer. If not suppressed,; /// dereferenceability and alignment must be proven separately. Note: This; /// is only needed for raw reasoning; if you use the interface below; /// (isSafeToSpeculativelyExecute), this is handled internally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:373,Performance,load,loading,373,"/// Return true if the instruction does not have any effects besides; /// calculating the result and does not have undefined behavior.; ///; /// This method never returns true for an instruction that returns true for; /// mayHaveSideEffects; however, this method also does some other checks in; /// addition. It checks for undefined behavior, like dividing by zero or; /// loading from an invalid pointer (but not for undefined results, like a; /// shift with a shift amount larger than the width of the result). It checks; /// for malloc and alloca because speculatively executing them might cause a; /// memory leak. It also returns false for instructions related to control; /// flow, specifically terminators and PHI nodes.; ///; /// If the CtxI is specified this method performs context-sensitive analysis; /// and returns true if it is safe to execute the instruction immediately; /// before the CtxI.; ///; /// If the CtxI is NOT specified this method only looks at the instruction; /// itself and its operands, so if this method returns true, it is safe to; /// move the instruction as long as the correct dominance relationships for; /// the operands and users hold.; ///; /// This method can return true for instructions that read memory;; /// for such instructions, moving them may change the resulting value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:775,Performance,perform,performs,775,"/// Return true if the instruction does not have any effects besides; /// calculating the result and does not have undefined behavior.; ///; /// This method never returns true for an instruction that returns true for; /// mayHaveSideEffects; however, this method also does some other checks in; /// addition. It checks for undefined behavior, like dividing by zero or; /// loading from an invalid pointer (but not for undefined results, like a; /// shift with a shift amount larger than the width of the result). It checks; /// for malloc and alloca because speculatively executing them might cause a; /// memory leak. It also returns false for instructions related to control; /// flow, specifically terminators and PHI nodes.; ///; /// If the CtxI is specified this method performs context-sensitive analysis; /// and returns true if it is safe to execute the instruction immediately; /// before the CtxI.; ///; /// If the CtxI is NOT specified this method only looks at the instruction; /// itself and its operands, so if this method returns true, it is safe to; /// move the instruction as long as the correct dominance relationships for; /// the operands and users hold.; ///; /// This method can return true for instructions that read memory;; /// for such instructions, moving them may change the resulting value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:842,Safety,safe,safe,842,"/// Return true if the instruction does not have any effects besides; /// calculating the result and does not have undefined behavior.; ///; /// This method never returns true for an instruction that returns true for; /// mayHaveSideEffects; however, this method also does some other checks in; /// addition. It checks for undefined behavior, like dividing by zero or; /// loading from an invalid pointer (but not for undefined results, like a; /// shift with a shift amount larger than the width of the result). It checks; /// for malloc and alloca because speculatively executing them might cause a; /// memory leak. It also returns false for instructions related to control; /// flow, specifically terminators and PHI nodes.; ///; /// If the CtxI is specified this method performs context-sensitive analysis; /// and returns true if it is safe to execute the instruction immediately; /// before the CtxI.; ///; /// If the CtxI is NOT specified this method only looks at the instruction; /// itself and its operands, so if this method returns true, it is safe to; /// move the instruction as long as the correct dominance relationships for; /// the operands and users hold.; ///; /// This method can return true for instructions that read memory;; /// for such instructions, moving them may change the resulting value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:1057,Safety,safe,safe,1057,"/// Return true if the instruction does not have any effects besides; /// calculating the result and does not have undefined behavior.; ///; /// This method never returns true for an instruction that returns true for; /// mayHaveSideEffects; however, this method also does some other checks in; /// addition. It checks for undefined behavior, like dividing by zero or; /// loading from an invalid pointer (but not for undefined results, like a; /// shift with a shift amount larger than the width of the result). It checks; /// for malloc and alloca because speculatively executing them might cause a; /// memory leak. It also returns false for instructions related to control; /// flow, specifically terminators and PHI nodes.; ///; /// If the CtxI is specified this method performs context-sensitive analysis; /// and returns true if it is safe to execute the instruction immediately; /// before the CtxI.; ///; /// If the CtxI is NOT specified this method only looks at the instruction; /// itself and its operands, so if this method returns true, it is safe to; /// move the instruction as long as the correct dominance relationships for; /// the operands and users hold.; ///; /// This method can return true for instructions that read memory;; /// for such instructions, moving them may change the resulting value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:456,Availability,fault,fault,456,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:78,Integrability,depend,depend,78,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:147,Integrability,depend,dependence,147,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:273,Integrability,depend,dependent,273,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:364,Integrability,depend,dependent,364,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:403,Integrability,depend,dependence,403,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:315,Performance,optimiz,optimize,315,"/// Return true if it is valid to use the assumptions provided by an; /// assume intrinsic, I, at the point in the control-flow identified by the; /// context instruction, CxtI. By default, ephemeral values of the assumption; /// are treated as an invalid context, to prevent the assumption from being used; /// to optimize away its argument. If the caller can ensure that this won't; /// happen, it can call with AllowEphemerals set to true to get more valid; /// assumptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:105,Integrability,depend,dependent,105,"/// Returns true if the arithmetic part of the \p WO 's result is; /// used only along the paths control dependent on the computation; /// not overflowing, \p WO being an <op>.with.overflow intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:168,Safety,avoid,avoid,168,"/// Return true if every instruction in the range (Begin, End) is; /// guaranteed to transfer execution to its static successor. \p ScanLimit; /// bounds the search to avoid scanning huge blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:395,Performance,perform,performs,395,"/// Return true if this function can prove that V does not have undef bits; /// and is never poison. If V is an aggregate value or vector, check whether; /// all elements (except padding) are not undef or poison.; /// Note that this is different from canCreateUndefOrPoison because the; /// function assumes Op's operands are not poison/undef.; ///; /// If CtxI and DT are specified this method performs flow-sensitive analysis; /// and returns true if it is guaranteed to be never undef or poison; /// immediately before the CtxI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:477,Modifiability,variab,variable,477,"/// Attempt to match a simple first order recurrence cycle of the form:; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %iv, %step; /// OR; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %step, %iv; ///; /// A first order recurrence is a formula with the form: X_n = f(X_(n-1)); ///; /// A couple of notes on subtleties in that definition:; /// * The Step does not have to be loop invariant. In math terms, it can; /// be a free variable. We allow recurrences with both constant and; /// variable coefficients. Callers may wish to filter cases where Step; /// does not dominate P.; /// * For non-commutative operators, we will match both forms. This; /// results in some odd recurrence structures. Callers may wish to filter; /// out recurrences where the phi is not the LHS of the returned operator.; /// * Because of the structure matched, the caller can assume as a post; /// condition of the match the presence of a Loop with P's parent as it's; /// header *except* in unreachable code. (Dominance decays in unreachable; /// code.); ///; /// NOTE: This is intentional simple. If you want the ability to analyze; /// non-trivial loop conditons, see ScalarEvolution instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:536,Modifiability,variab,variable,536,"/// Attempt to match a simple first order recurrence cycle of the form:; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %iv, %step; /// OR; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %step, %iv; ///; /// A first order recurrence is a formula with the form: X_n = f(X_(n-1)); ///; /// A couple of notes on subtleties in that definition:; /// * The Step does not have to be loop invariant. In math terms, it can; /// be a free variable. We allow recurrences with both constant and; /// variable coefficients. Callers may wish to filter cases where Step; /// does not dominate P.; /// * For non-commutative operators, we will match both forms. This; /// results in some odd recurrence structures. Callers may wish to filter; /// out recurrences where the phi is not the LHS of the returned operator.; /// * Because of the structure matched, the caller can assume as a post; /// condition of the match the presence of a Loop with P's parent as it's; /// header *except* in unreachable code. (Dominance decays in unreachable; /// code.); ///; /// NOTE: This is intentional simple. If you want the ability to analyze; /// non-trivial loop conditons, see ScalarEvolution instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:23,Usability,simpl,simple,23,"/// Attempt to match a simple first order recurrence cycle of the form:; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %iv, %step; /// OR; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %step, %iv; ///; /// A first order recurrence is a formula with the form: X_n = f(X_(n-1)); ///; /// A couple of notes on subtleties in that definition:; /// * The Step does not have to be loop invariant. In math terms, it can; /// be a free variable. We allow recurrences with both constant and; /// variable coefficients. Callers may wish to filter cases where Step; /// does not dominate P.; /// * For non-commutative operators, we will match both forms. This; /// results in some odd recurrence structures. Callers may wish to filter; /// out recurrences where the phi is not the LHS of the returned operator.; /// * Because of the structure matched, the caller can assume as a post; /// condition of the match the presence of a Loop with P's parent as it's; /// header *except* in unreachable code. (Dominance decays in unreachable; /// code.); ///; /// NOTE: This is intentional simple. If you want the ability to analyze; /// non-trivial loop conditons, see ScalarEvolution instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:1120,Usability,simpl,simple,1120,"/// Attempt to match a simple first order recurrence cycle of the form:; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %iv, %step; /// OR; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %step, %iv; ///; /// A first order recurrence is a formula with the form: X_n = f(X_(n-1)); ///; /// A couple of notes on subtleties in that definition:; /// * The Step does not have to be loop invariant. In math terms, it can; /// be a free variable. We allow recurrences with both constant and; /// variable coefficients. Callers may wish to filter cases where Step; /// does not dominate P.; /// * For non-commutative operators, we will match both forms. This; /// results in some odd recurrence structures. Callers may wish to filter; /// out recurrences where the phi is not the LHS of the returned operator.; /// * Because of the structure matched, the caller can assume as a post; /// condition of the match the presence of a Loop with P's parent as it's; /// header *except* in unreachable code. (Dominance decays in unreachable; /// code.); ///; /// NOTE: This is intentional simple. If you want the ability to analyze; /// non-trivial loop conditons, see ScalarEvolution instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:38,Availability,mask,masked,38,"// Check whether we have at least one masked vector version of a scalar; // function. If no VF is specified then we check for any masked variant,; // otherwise we look for one that matches the supplied VF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:130,Availability,mask,masked,130,"// Check whether we have at least one masked vector version of a scalar; // function. If no VF is specified then we check for any masked variant,; // otherwise we look for one that matches the supplied VF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:31,Integrability,interface,interface,31,/// \defgroup VFDatabase query interface.; ///; /// @{; /// Retrieve the Function with VFShape \p Shape.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:27,Availability,Mask,Mask,27,"/// If all non-negative \p Mask elements are the same value, return that value.; /// If all elements are negative (undefined) or \p Mask contains different; /// non-negative values, return -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:132,Availability,Mask,Mask,132,"/// If all non-negative \p Mask elements are the same value, return that value.; /// If all elements are negative (undefined) or \p Mask contains different; /// non-negative values, return -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:325,Energy Efficiency,power,powerful,325,"/// Return true if each element of the vector value \p V is poisoned or equal to; /// every other non-poisoned element. If an index element is specified, either; /// every element of the vector is poisoned or the element at that index is not; /// poisoned and equal to every other non-poisoned element.; /// This may be more powerful than the related getSplatValue() because it is; /// not limited by finding a scalar source value to a splatted vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:24,Availability,mask,mask,24,"/// Transform a shuffle mask's output demanded element mask into demanded; /// element masks for the 2 operands, returns false if the mask isn't valid.; /// Both \p DemandedLHS and \p DemandedRHS are initialised to [SrcWidth].; /// \p AllowUndefElts permits ""-1"" indices to be treated as undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:55,Availability,mask,mask,55,"/// Transform a shuffle mask's output demanded element mask into demanded; /// element masks for the 2 operands, returns false if the mask isn't valid.; /// Both \p DemandedLHS and \p DemandedRHS are initialised to [SrcWidth].; /// \p AllowUndefElts permits ""-1"" indices to be treated as undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:87,Availability,mask,masks,87,"/// Transform a shuffle mask's output demanded element mask into demanded; /// element masks for the 2 operands, returns false if the mask isn't valid.; /// Both \p DemandedLHS and \p DemandedRHS are initialised to [SrcWidth].; /// \p AllowUndefElts permits ""-1"" indices to be treated as undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:134,Availability,mask,mask,134,"/// Transform a shuffle mask's output demanded element mask into demanded; /// element masks for the 2 operands, returns false if the mask isn't valid.; /// Both \p DemandedLHS and \p DemandedRHS are initialised to [SrcWidth].; /// \p AllowUndefElts permits ""-1"" indices to be treated as undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:25,Availability,mask,mask,25,"/// Replace each shuffle mask index with the scaled sequential indices for an; /// equivalent mask of narrowed elements. Mask elements that are less than 0; /// (sentinel values) are repeated in the output mask.; ///; /// Example with Scale = 4:; /// <4 x i32> <3, 2, 0, -1> -->; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1>; ///; /// This is the reverse process of widening shuffle mask elements, but it always; /// succeeds because the indexes can always be multiplied (scaled up) to map to; /// narrower vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:94,Availability,mask,mask,94,"/// Replace each shuffle mask index with the scaled sequential indices for an; /// equivalent mask of narrowed elements. Mask elements that are less than 0; /// (sentinel values) are repeated in the output mask.; ///; /// Example with Scale = 4:; /// <4 x i32> <3, 2, 0, -1> -->; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1>; ///; /// This is the reverse process of widening shuffle mask elements, but it always; /// succeeds because the indexes can always be multiplied (scaled up) to map to; /// narrower vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:121,Availability,Mask,Mask,121,"/// Replace each shuffle mask index with the scaled sequential indices for an; /// equivalent mask of narrowed elements. Mask elements that are less than 0; /// (sentinel values) are repeated in the output mask.; ///; /// Example with Scale = 4:; /// <4 x i32> <3, 2, 0, -1> -->; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1>; ///; /// This is the reverse process of widening shuffle mask elements, but it always; /// succeeds because the indexes can always be multiplied (scaled up) to map to; /// narrower vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:206,Availability,mask,mask,206,"/// Replace each shuffle mask index with the scaled sequential indices for an; /// equivalent mask of narrowed elements. Mask elements that are less than 0; /// (sentinel values) are repeated in the output mask.; ///; /// Example with Scale = 4:; /// <4 x i32> <3, 2, 0, -1> -->; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1>; ///; /// This is the reverse process of widening shuffle mask elements, but it always; /// succeeds because the indexes can always be multiplied (scaled up) to map to; /// narrower vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:411,Availability,mask,mask,411,"/// Replace each shuffle mask index with the scaled sequential indices for an; /// equivalent mask of narrowed elements. Mask elements that are less than 0; /// (sentinel values) are repeated in the output mask.; ///; /// Example with Scale = 4:; /// <4 x i32> <3, 2, 0, -1> -->; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1>; ///; /// This is the reverse process of widening shuffle mask elements, but it always; /// succeeds because the indexes can always be multiplied (scaled up) to map to; /// narrower vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:31,Availability,mask,mask,31,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:103,Availability,mask,mask,103,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:136,Availability,mask,mask,136,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:200,Availability,mask,mask,200,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:281,Availability,mask,mask,281,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:693,Availability,mask,mask,693,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:816,Availability,down,down,816,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:100,Availability,mask,mask,100,"/// Repetitively apply `widenShuffleMaskElts()` for as long as it succeeds,; /// to get the shuffle mask with widest possible elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:33,Availability,mask,mask,33,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:208,Availability,mask,mask,208,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:327,Availability,mask,mask,327,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:579,Availability,mask,masks,579,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:598,Availability,Mask,Mask,598,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:620,Availability,mask,mask,620,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:38,Integrability,depend,depending,38,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:342,Availability,down,down,342,"/// Compute a map of integer instructions to their minimum legal type; /// size.; ///; /// C semantics force sub-int-sized values (e.g. i8, i16) to be promoted to int; /// type (e.g. i32) whenever arithmetic is performed on them.; ///; /// For targets with native i8 or i16 operations, usually InstCombine can shrink; /// the arithmetic type down again. However InstCombine refuses to create; /// illegal types, so for targets without i8 or i16 registers, the lengthening; /// and shrinking remains.; ///; /// Most SIMD ISAs (e.g. NEON) however support vectors of i8 or i16 even when; /// their scalar equivalents do not, so during vectorization it is important to; /// remove these lengthens and truncates when deciding the profitability of; /// vectorization.; ///; /// This function analyzes the given range of instructions and determines the; /// minimum type size each can be converted to. It attempts to remove or; /// minimize type size changes across each def-use chain, so for example in the; /// following code:; ///; /// %1 = load i8, i8*; /// %2 = add i8 %1, 2; /// %3 = load i16, i16*; /// %4 = zext i8 %2 to i32; /// %5 = zext i16 %3 to i32; /// %6 = add i32 %4, %5; /// %7 = trunc i32 %6 to i16; ///; /// Instruction %6 must be done at least in i16, so computeMinimumValueSizes; /// will return: {%1: 16, %2: 16, %3: 16, %4: 16, %5: 16, %6: 16, %7: 16}.; ///; /// If the optional TargetTransformInfo is provided, this function tries harder; /// to do less work by only looking at illegal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:211,Performance,perform,performed,211,"/// Compute a map of integer instructions to their minimum legal type; /// size.; ///; /// C semantics force sub-int-sized values (e.g. i8, i16) to be promoted to int; /// type (e.g. i32) whenever arithmetic is performed on them.; ///; /// For targets with native i8 or i16 operations, usually InstCombine can shrink; /// the arithmetic type down again. However InstCombine refuses to create; /// illegal types, so for targets without i8 or i16 registers, the lengthening; /// and shrinking remains.; ///; /// Most SIMD ISAs (e.g. NEON) however support vectors of i8 or i16 even when; /// their scalar equivalents do not, so during vectorization it is important to; /// remove these lengthens and truncates when deciding the profitability of; /// vectorization.; ///; /// This function analyzes the given range of instructions and determines the; /// minimum type size each can be converted to. It attempts to remove or; /// minimize type size changes across each def-use chain, so for example in the; /// following code:; ///; /// %1 = load i8, i8*; /// %2 = add i8 %1, 2; /// %3 = load i16, i16*; /// %4 = zext i8 %2 to i32; /// %5 = zext i16 %3 to i32; /// %6 = add i32 %4, %5; /// %7 = trunc i32 %6 to i16; ///; /// Instruction %6 must be done at least in i16, so computeMinimumValueSizes; /// will return: {%1: 16, %2: 16, %3: 16, %4: 16, %5: 16, %6: 16, %7: 16}.; ///; /// If the optional TargetTransformInfo is provided, this function tries harder; /// to do less work by only looking at illegal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:1037,Performance,load,load,1037,"/// Compute a map of integer instructions to their minimum legal type; /// size.; ///; /// C semantics force sub-int-sized values (e.g. i8, i16) to be promoted to int; /// type (e.g. i32) whenever arithmetic is performed on them.; ///; /// For targets with native i8 or i16 operations, usually InstCombine can shrink; /// the arithmetic type down again. However InstCombine refuses to create; /// illegal types, so for targets without i8 or i16 registers, the lengthening; /// and shrinking remains.; ///; /// Most SIMD ISAs (e.g. NEON) however support vectors of i8 or i16 even when; /// their scalar equivalents do not, so during vectorization it is important to; /// remove these lengthens and truncates when deciding the profitability of; /// vectorization.; ///; /// This function analyzes the given range of instructions and determines the; /// minimum type size each can be converted to. It attempts to remove or; /// minimize type size changes across each def-use chain, so for example in the; /// following code:; ///; /// %1 = load i8, i8*; /// %2 = add i8 %1, 2; /// %3 = load i16, i16*; /// %4 = zext i8 %2 to i32; /// %5 = zext i16 %3 to i32; /// %6 = add i32 %4, %5; /// %7 = trunc i32 %6 to i16; ///; /// Instruction %6 must be done at least in i16, so computeMinimumValueSizes; /// will return: {%1: 16, %2: 16, %3: 16, %4: 16, %5: 16, %6: 16, %7: 16}.; ///; /// If the optional TargetTransformInfo is provided, this function tries harder; /// to do less work by only looking at illegal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:1083,Performance,load,load,1083,"/// Compute a map of integer instructions to their minimum legal type; /// size.; ///; /// C semantics force sub-int-sized values (e.g. i8, i16) to be promoted to int; /// type (e.g. i32) whenever arithmetic is performed on them.; ///; /// For targets with native i8 or i16 operations, usually InstCombine can shrink; /// the arithmetic type down again. However InstCombine refuses to create; /// illegal types, so for targets without i8 or i16 registers, the lengthening; /// and shrinking remains.; ///; /// Most SIMD ISAs (e.g. NEON) however support vectors of i8 or i16 even when; /// their scalar equivalents do not, so during vectorization it is important to; /// remove these lengthens and truncates when deciding the profitability of; /// vectorization.; ///; /// This function analyzes the given range of instructions and determines the; /// minimum type size each can be converted to. It attempts to remove or; /// minimize type size changes across each def-use chain, so for example in the; /// following code:; ///; /// %1 = load i8, i8*; /// %2 = add i8 %1, 2; /// %3 = load i16, i16*; /// %4 = zext i8 %2 to i32; /// %5 = zext i16 %3 to i32; /// %6 = add i32 %4, %5; /// %7 = trunc i32 %6 to i16; ///; /// Instruction %6 must be done at least in i16, so computeMinimumValueSizes; /// will return: {%1: 16, %2: 16, %3: 16, %4: 16, %5: 16, %6: 16, %7: 16}.; ///; /// If the optional TargetTransformInfo is provided, this function tries harder; /// to do less work by only looking at illegal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:29,Security,access,access-group,29,"/// Compute the union of two access-group lists.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:89,Security,access,access,89,"/// Compute the union of two access-group lists.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:16,Security,access,access-group,16,"/// Compute the access-group list of access groups that @p Inst1 and @p Inst2; /// are both in. If either instruction does not access memory at all, it is; /// considered to be in every list.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:37,Security,access,access,37,"/// Compute the access-group list of access groups that @p Inst1 and @p Inst2; /// are both in. If either instruction does not access memory at all, it is; /// considered to be in every list.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:127,Security,access,access,127,"/// Compute the access-group list of access groups that @p Inst1 and @p Inst2; /// are both in. If either instruction does not access memory at all, it is; /// considered to be in every list.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:232,Security,access,access,232,"/// Compute the access-group list of access groups that @p Inst1 and @p Inst2; /// are both in. If either instruction does not access memory at all, it is; /// considered to be in every list.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:13,Availability,mask,mask,13,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:120,Availability,mask,mask,120,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:292,Availability,mask,mask,292,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:351,Availability,Mask,Mask,351,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:391,Availability,mask,mask,391,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:397,Availability,mask,mask,397,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:13,Availability,mask,mask,13,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:86,Availability,mask,mask,86,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:214,Availability,mask,mask,214,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:244,Availability,mask,mask,244,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:437,Availability,mask,mask,437,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:342,Performance,load,loads,342,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:33,Availability,mask,mask,33,"/// Create an interleave shuffle mask.; ///; /// This function creates a shuffle mask for interleaving \p NumVecs vectors of; /// vectorization factor \p VF into a single wide vector. The mask is of the; /// form:; ///; /// <0, VF, VF * 2, ..., VF * (NumVecs - 1), 1, VF + 1, VF * 2 + 1, ...>; ///; /// For example, the mask for VF = 4 and NumVecs = 2 is:; ///; /// <0, 4, 1, 5, 2, 6, 3, 7>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:81,Availability,mask,mask,81,"/// Create an interleave shuffle mask.; ///; /// This function creates a shuffle mask for interleaving \p NumVecs vectors of; /// vectorization factor \p VF into a single wide vector. The mask is of the; /// form:; ///; /// <0, VF, VF * 2, ..., VF * (NumVecs - 1), 1, VF + 1, VF * 2 + 1, ...>; ///; /// For example, the mask for VF = 4 and NumVecs = 2 is:; ///; /// <0, 4, 1, 5, 2, 6, 3, 7>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:188,Availability,mask,mask,188,"/// Create an interleave shuffle mask.; ///; /// This function creates a shuffle mask for interleaving \p NumVecs vectors of; /// vectorization factor \p VF into a single wide vector. The mask is of the; /// form:; ///; /// <0, VF, VF * 2, ..., VF * (NumVecs - 1), 1, VF + 1, VF * 2 + 1, ...>; ///; /// For example, the mask for VF = 4 and NumVecs = 2 is:; ///; /// <0, 4, 1, 5, 2, 6, 3, 7>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:320,Availability,mask,mask,320,"/// Create an interleave shuffle mask.; ///; /// This function creates a shuffle mask for interleaving \p NumVecs vectors of; /// vectorization factor \p VF into a single wide vector. The mask is of the; /// form:; ///; /// <0, VF, VF * 2, ..., VF * (NumVecs - 1), 1, VF + 1, VF * 2 + 1, ...>; ///; /// For example, the mask for VF = 4 and NumVecs = 2 is:; ///; /// <0, 4, 1, 5, 2, 6, 3, 7>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:28,Availability,mask,mask,28,"/// Create a stride shuffle mask.; ///; /// This function creates a shuffle mask whose elements begin at \p Start and; /// are incremented by \p Stride. The mask can be used to deinterleave an; /// interleaved vector into separate vectors of vectorization factor \p VF. The; /// mask is of the form:; ///; /// <Start, Start + Stride, ..., Start + Stride * (VF - 1)>; ///; /// For example, the mask for Start = 0, Stride = 2, and VF = 4 is:; ///; /// <0, 2, 4, 6>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:76,Availability,mask,mask,76,"/// Create a stride shuffle mask.; ///; /// This function creates a shuffle mask whose elements begin at \p Start and; /// are incremented by \p Stride. The mask can be used to deinterleave an; /// interleaved vector into separate vectors of vectorization factor \p VF. The; /// mask is of the form:; ///; /// <Start, Start + Stride, ..., Start + Stride * (VF - 1)>; ///; /// For example, the mask for Start = 0, Stride = 2, and VF = 4 is:; ///; /// <0, 2, 4, 6>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:157,Availability,mask,mask,157,"/// Create a stride shuffle mask.; ///; /// This function creates a shuffle mask whose elements begin at \p Start and; /// are incremented by \p Stride. The mask can be used to deinterleave an; /// interleaved vector into separate vectors of vectorization factor \p VF. The; /// mask is of the form:; ///; /// <Start, Start + Stride, ..., Start + Stride * (VF - 1)>; ///; /// For example, the mask for Start = 0, Stride = 2, and VF = 4 is:; ///; /// <0, 2, 4, 6>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:279,Availability,mask,mask,279,"/// Create a stride shuffle mask.; ///; /// This function creates a shuffle mask whose elements begin at \p Start and; /// are incremented by \p Stride. The mask can be used to deinterleave an; /// interleaved vector into separate vectors of vectorization factor \p VF. The; /// mask is of the form:; ///; /// <Start, Start + Stride, ..., Start + Stride * (VF - 1)>; ///; /// For example, the mask for Start = 0, Stride = 2, and VF = 4 is:; ///; /// <0, 2, 4, 6>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:393,Availability,mask,mask,393,"/// Create a stride shuffle mask.; ///; /// This function creates a shuffle mask whose elements begin at \p Start and; /// are incremented by \p Stride. The mask can be used to deinterleave an; /// interleaved vector into separate vectors of vectorization factor \p VF. The; /// mask is of the form:; ///; /// <Start, Start + Stride, ..., Start + Stride * (VF - 1)>; ///; /// For example, the mask for Start = 0, Stride = 2, and VF = 4 is:; ///; /// <0, 2, 4, 6>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:32,Availability,mask,mask,32,"/// Create a sequential shuffle mask.; ///; /// This function creates shuffle mask whose elements are sequential and begin; /// at \p Start. The mask contains \p NumInts integers and is padded with \p; /// NumUndefs undef values. The mask is of the form:; ///; /// <Start, Start + 1, ... Start + NumInts - 1, undef_1, ... undef_NumUndefs>; ///; /// For example, the mask for Start = 0, NumInsts = 4, and NumUndefs = 4 is:; ///; /// <0, 1, 2, 3, undef, undef, undef, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:78,Availability,mask,mask,78,"/// Create a sequential shuffle mask.; ///; /// This function creates shuffle mask whose elements are sequential and begin; /// at \p Start. The mask contains \p NumInts integers and is padded with \p; /// NumUndefs undef values. The mask is of the form:; ///; /// <Start, Start + 1, ... Start + NumInts - 1, undef_1, ... undef_NumUndefs>; ///; /// For example, the mask for Start = 0, NumInsts = 4, and NumUndefs = 4 is:; ///; /// <0, 1, 2, 3, undef, undef, undef, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:145,Availability,mask,mask,145,"/// Create a sequential shuffle mask.; ///; /// This function creates shuffle mask whose elements are sequential and begin; /// at \p Start. The mask contains \p NumInts integers and is padded with \p; /// NumUndefs undef values. The mask is of the form:; ///; /// <Start, Start + 1, ... Start + NumInts - 1, undef_1, ... undef_NumUndefs>; ///; /// For example, the mask for Start = 0, NumInsts = 4, and NumUndefs = 4 is:; ///; /// <0, 1, 2, 3, undef, undef, undef, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:234,Availability,mask,mask,234,"/// Create a sequential shuffle mask.; ///; /// This function creates shuffle mask whose elements are sequential and begin; /// at \p Start. The mask contains \p NumInts integers and is padded with \p; /// NumUndefs undef values. The mask is of the form:; ///; /// <Start, Start + 1, ... Start + NumInts - 1, undef_1, ... undef_NumUndefs>; ///; /// For example, the mask for Start = 0, NumInsts = 4, and NumUndefs = 4 is:; ///; /// <0, 1, 2, 3, undef, undef, undef, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:366,Availability,mask,mask,366,"/// Create a sequential shuffle mask.; ///; /// This function creates shuffle mask whose elements are sequential and begin; /// at \p Start. The mask contains \p NumInts integers and is padded with \p; /// NumUndefs undef values. The mask is of the form:; ///; /// <Start, Start + 1, ... Start + NumInts - 1, undef_1, ... undef_NumUndefs>; ///; /// For example, the mask for Start = 0, NumInsts = 4, and NumUndefs = 4 is:; ///; /// <0, 1, 2, 3, undef, undef, undef, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:20,Availability,mask,mask,20,"/// Given a shuffle mask for a binary shuffle, create the equivalent shuffle; /// mask assuming both operands are identical. This assumes that the unary; /// shuffle will use elements from operand 0 (operand 1 will be unused).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:82,Availability,mask,mask,82,"/// Given a shuffle mask for a binary shuffle, create the equivalent shuffle; /// mask assuming both operands are identical. This assumes that the unary; /// shuffle will use elements from operand 0 (operand 1 will be unused).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:12,Availability,mask,mask,12,"/// Given a mask vector of i1, Return true if all of the elements of this; /// predicate mask are known to be false or undef. That is, return true if all; /// lanes can be assumed inactive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:89,Availability,mask,mask,89,"/// Given a mask vector of i1, Return true if all of the elements of this; /// predicate mask are known to be false or undef. That is, return true if all; /// lanes can be assumed inactive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:12,Availability,mask,mask,12,"/// Given a mask vector of i1, Return true if all of the elements of this; /// predicate mask are known to be true or undef. That is, return true if all; /// lanes can be assumed active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:89,Availability,mask,mask,89,"/// Given a mask vector of i1, Return true if all of the elements of this; /// predicate mask are known to be true or undef. That is, return true if all; /// lanes can be assumed active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:12,Availability,mask,mask,12,"/// Given a mask vector of i1, Return true if any of the elements of this; /// predicate mask are known to be true or undef. That is, return true if at; /// least one lane can be assumed active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:89,Availability,mask,mask,89,"/// Given a mask vector of i1, Return true if any of the elements of this; /// predicate mask are known to be true or undef. That is, return true if at; /// least one lane can be assumed active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:12,Availability,mask,mask,12,"/// Given a mask vector of the form <Y x i1>, return an APInt (of bitwidth Y); /// for each lane which may be active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:29,Performance,load,loads,29,"/// The group of interleaved loads/stores sharing the same stride and; /// close to each other.; ///; /// Each member in this group has an index starting from 0, and the largest; /// index should be less than interleaved factor, which is equal to the absolute; /// value of the access's stride.; ///; /// E.g. An interleaved load group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// a = A[i]; // Member of index 0; /// b = A[i+1]; // Member of index 1; /// d = A[i+3]; // Member of index 3; /// ...; /// }; ///; /// An interleaved store group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// ...; /// A[i] = a; // Member of index 0; /// A[i+1] = b; // Member of index 1; /// A[i+2] = c; // Member of index 2; /// A[i+3] = d; // Member of index 3; /// }; ///; /// Note: the interleaved load group could have gaps (missing members), but; /// the interleaved store group doesn't allow gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:325,Performance,load,load,325,"/// The group of interleaved loads/stores sharing the same stride and; /// close to each other.; ///; /// Each member in this group has an index starting from 0, and the largest; /// index should be less than interleaved factor, which is equal to the absolute; /// value of the access's stride.; ///; /// E.g. An interleaved load group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// a = A[i]; // Member of index 0; /// b = A[i+1]; // Member of index 1; /// d = A[i+3]; // Member of index 3; /// ...; /// }; ///; /// An interleaved store group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// ...; /// A[i] = a; // Member of index 0; /// A[i+1] = b; // Member of index 1; /// A[i+2] = c; // Member of index 2; /// A[i+3] = d; // Member of index 3; /// }; ///; /// Note: the interleaved load group could have gaps (missing members), but; /// the interleaved store group doesn't allow gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:813,Performance,load,load,813,"/// The group of interleaved loads/stores sharing the same stride and; /// close to each other.; ///; /// Each member in this group has an index starting from 0, and the largest; /// index should be less than interleaved factor, which is equal to the absolute; /// value of the access's stride.; ///; /// E.g. An interleaved load group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// a = A[i]; // Member of index 0; /// b = A[i+1]; // Member of index 1; /// d = A[i+3]; // Member of index 3; /// ...; /// }; ///; /// An interleaved store group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// ...; /// A[i] = a; // Member of index 0; /// A[i+1] = b; // Member of index 1; /// A[i+2] = c; // Member of index 2; /// A[i+3] = d; // Member of index 3; /// }; ///; /// Note: the interleaved load group could have gaps (missing members), but; /// the interleaved store group doesn't allow gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:278,Security,access,access,278,"/// The group of interleaved loads/stores sharing the same stride and; /// close to each other.; ///; /// Each member in this group has an index starting from 0, and the largest; /// index should be less than interleaved factor, which is equal to the absolute; /// value of the access's stride.; ///; /// E.g. An interleaved load group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// a = A[i]; // Member of index 0; /// b = A[i+1]; // Member of index 1; /// d = A[i+3]; // Member of index 3; /// ...; /// }; ///; /// An interleaved store group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// ...; /// A[i] = a; // Member of index 0; /// A[i+1] = b; // Member of index 1; /// A[i+2] = c; // Member of index 2; /// A[i+3] = d; // Member of index 3; /// }; ///; /// Note: the interleaved load group could have gaps (missing members), but; /// the interleaved store group doesn't allow gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:15,Safety,safe,safe,15,// It's always safe to select the minimum alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:63,Security,access,access,63,"// We have a group with gaps. It therefore can't be a reversed access,; // because such groups get invalidated (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:22,Performance,load,loads,22,"// This is a group of loads, with gaps, and without a last-member",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:21,Integrability,depend,dependences,21,"// To avoid breaking dependences, vectorized instructions of an interleave; // group should be inserted at either the first load or the last store in; // program order.; //; // E.g. %even = load i32 // Insert Position; // %add = add i32 %even // Use of %even; // %odd = load i32; //; // store i32 %even; // %odd = add i32 // Def of %odd; // store i32 %odd // Insert Position",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:124,Performance,load,load,124,"// To avoid breaking dependences, vectorized instructions of an interleave; // group should be inserted at either the first load or the last store in; // program order.; //; // E.g. %even = load i32 // Insert Position; // %add = add i32 %even // Use of %even; // %odd = load i32; //; // store i32 %even; // %odd = add i32 // Def of %odd; // store i32 %odd // Insert Position",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:190,Performance,load,load,190,"// To avoid breaking dependences, vectorized instructions of an interleave; // group should be inserted at either the first load or the last store in; // program order.; //; // E.g. %even = load i32 // Insert Position; // %add = add i32 %even // Use of %even; // %odd = load i32; //; // store i32 %even; // %odd = add i32 // Def of %odd; // store i32 %odd // Insert Position",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:270,Performance,load,load,270,"// To avoid breaking dependences, vectorized instructions of an interleave; // group should be inserted at either the first load or the last store in; // program order.; //; // E.g. %even = load i32 // Insert Position; // %add = add i32 %even // Use of %even; // %odd = load i32; //; // store i32 %even; // %odd = add i32 // Def of %odd; // store i32 %odd // Insert Position",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:6,Safety,avoid,avoid,6,"// To avoid breaking dependences, vectorized instructions of an interleave; // group should be inserted at either the first load or the last store in; // program order.; //; // E.g. %even = load i32 // Insert Position; // %add = add i32 %even // Use of %even; // %odd = load i32; //; // store i32 %even; // %odd = add i32 // Def of %odd; // store i32 %odd // Insert Position",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:259,Safety,unsafe,unsafe,259,/// Drive the analysis of interleaved memory accesses in the loop.; ///; /// Use this class to analyze interleaved accesses only when we can vectorize; /// a loop. Otherwise it's meaningless to do analysis as the vectorization; /// on interleaved accesses is unsafe.; ///; /// The analysis collects interleave groups and records the relationships; /// between the member and the group in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:45,Security,access,accesses,45,/// Drive the analysis of interleaved memory accesses in the loop.; ///; /// Use this class to analyze interleaved accesses only when we can vectorize; /// a loop. Otherwise it's meaningless to do analysis as the vectorization; /// on interleaved accesses is unsafe.; ///; /// The analysis collects interleave groups and records the relationships; /// between the member and the group in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:115,Security,access,accesses,115,/// Drive the analysis of interleaved memory accesses in the loop.; ///; /// Use this class to analyze interleaved accesses only when we can vectorize; /// a loop. Otherwise it's meaningless to do analysis as the vectorization; /// on interleaved accesses is unsafe.; ///; /// The analysis collects interleave groups and records the relationships; /// between the member and the group in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:247,Security,access,accesses,247,/// Drive the analysis of interleaved memory accesses in the loop.; ///; /// Use this class to analyze interleaved accesses only when we can vectorize; /// a loop. Otherwise it's meaningless to do analysis as the vectorization; /// on interleaved accesses is unsafe.; ///; /// The analysis collects interleave groups and records the relationships; /// between the member and the group in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:157,Performance,load,loads,157,/// Analyze the interleaved accesses and collect them in interleave; /// groups. Substitute symbolic strides using \p Strides.; /// Consider also predicated loads/stores in the analysis if; /// \p EnableMaskedInterleavedGroup is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:28,Security,access,accesses,28,/// Analyze the interleaved accesses and collect them in interleave; /// groups. Substitute symbolic strides using \p Strides.; /// Consider also predicated loads/stores in the analysis if; /// \p EnableMaskedInterleavedGroup is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:179,Security,access,accesses,179,"/// Invalidate groups, e.g., in case all blocks in loop will be predicated; /// contrary to original assumption. Although we currently prevent group; /// formation for predicated accesses, we may be able to relax this limitation; /// in the future once we handle more complicated blocks. Returns true if any; /// groups were invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:50,Security,access,access,50,/// Returns true if an interleaved group that may access memory; /// out-of-bounds requires a scalar epilogue iteration for correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:180,Availability,mask,masking,180,"/// Invalidate groups that require a scalar epilogue (due to gaps). This can; /// happen when optimizing for size forbids a scalar epilogue, and the gap; /// cannot be filtered by masking the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:94,Performance,optimiz,optimizing,94,"/// Invalidate groups that require a scalar epilogue (due to gaps). This can; /// happen when optimizing for size forbids a scalar epilogue, and the gap; /// cannot be filtered by masking the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:192,Performance,load,load,192,"/// Invalidate groups that require a scalar epilogue (due to gaps). This can; /// happen when optimizing for size forbids a scalar epilogue, and the gap; /// cannot be filtered by masking the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:6,Integrability,wrap,wrapper,6,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks.; /// Simplifies SCEV expressions in the context of existing SCEV assumptions.; /// The interleaved access analysis can also add new predicates (for example; /// by versioning strides of pointers).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:170,Security,access,access,170,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks.; /// Simplifies SCEV expressions in the context of existing SCEV assumptions.; /// The interleaved access analysis can also add new predicates (for example; /// by versioning strides of pointers).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:76,Usability,Simpl,Simplifies,76,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks.; /// Simplifies SCEV expressions in the context of existing SCEV assumptions.; /// The interleaved access analysis can also add new predicates (for example; /// by versioning strides of pointers).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:89,Security,access,accesses,89,/// True if the loop may contain non-reversed interleaved groups with; /// out-of-bounds accesses. We ensure we don't speculatively access memory; /// out-of-bounds by executing at least one scalar epilogue iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:132,Security,access,access,132,/// True if the loop may contain non-reversed interleaved groups with; /// out-of-bounds accesses. We ensure we don't speculatively access memory; /// out-of-bounds by executing at least one scalar epilogue iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:10,Integrability,depend,dependences,10,/// Holds dependences among the memory accesses in the loop. It maps a source; /// access to a set of dependent sink accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:102,Integrability,depend,dependent,102,/// Holds dependences among the memory accesses in the loop. It maps a source; /// access to a set of dependent sink accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:39,Security,access,accesses,39,/// Holds dependences among the memory accesses in the loop. It maps a source; /// access to a set of dependent sink accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:83,Security,access,access,83,/// Holds dependences among the memory accesses in the loop. It maps a source; /// access to a set of dependent sink accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:117,Security,access,accesses,117,/// Holds dependences among the memory accesses in the loop. It maps a source; /// access to a set of dependent sink accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:40,Security,access,access,40,/// The descriptor for a strided memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:7,Security,access,access,7,// The access's stride. It is negative for a reverse access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:53,Security,access,access,53,// The access's stride. It is negative for a reverse access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:33,Security,access,access,33,// The scalar expression of this access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:25,Security,access,access,25,// The alignment of this access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:4,Deployability,Release,Release,4,/// Release the group and remove all the relationships.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:20,Security,access,accesses,20,/// Collect all the accesses with a constant stride in program order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:51,Integrability,depend,dependence,51,/// Returns true if LoopAccessInfo can be used for dependence queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:273,Integrability,depend,dependent,273,"/// Returns true if memory accesses \p A and \p B can be reordered, if; /// necessary, when constructing interleaved groups.; ///; /// \p A must precede \p B in program order. We return false if reordering is; /// not necessary or is prevented because \p A and \p B may be dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:27,Security,access,accesses,27,"/// Returns true if memory accesses \p A and \p B can be reordered, if; /// necessary, when constructing interleaved groups.; ///; /// \p A must precede \p B in program order. We return false if reordering is; /// not necessary or is prevented because \p A and \p B may be dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:433,Integrability,depend,dependence,433,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:521,Integrability,depend,dependences,521,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:609,Integrability,depend,dependence,609,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:70,Performance,load,loads,70,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:217,Performance,load,load,217,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:331,Performance,load,load,331,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:564,Safety,safe,safely,564,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:31,Security,access,accesses,31,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:34,Integrability,depend,dependence,34,// B is potentially the sink of a dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:58,Integrability,depend,dependences,58,"// Code motion for interleaved accesses can't violate WAR dependences.; // Thus, reordering is legal if the source isn't a write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:31,Security,access,accesses,31,"// Code motion for interleaved accesses can't violate WAR dependences.; // Thus, reordering is legal if the source isn't a write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:23,Security,access,accesses,23,// At least one of the accesses must be strided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:36,Availability,avail,available,36,"// If dependence information is not available from LoopAccessInfo,; // conservatively assume the instructions can't be reordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:6,Integrability,depend,dependence,6,"// If dependence information is not available from LoopAccessInfo,; // conservatively assume the instructions can't be reordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:25,Integrability,depend,dependence,25,"// If we know there is a dependence from source to sink, assume the; // instructions can't be reordered. Otherwise, reordering is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:16,Integrability,depend,dependences,16,/// Collect the dependences from LoopAccessInfo.; ///; /// We process the dependences once during the interleaved access analysis to; /// enable constant-time dependence queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:74,Integrability,depend,dependences,74,/// Collect the dependences from LoopAccessInfo.; ///; /// We process the dependences once during the interleaved access analysis to; /// enable constant-time dependence queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:159,Integrability,depend,dependence,159,/// Collect the dependences from LoopAccessInfo.; ///; /// We process the dependences once during the interleaved access analysis to; /// enable constant-time dependence queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:114,Security,access,access,114,/// Collect the dependences from LoopAccessInfo.; ///; /// We process the dependences once during the interleaved access analysis to; /// enable constant-time dependence queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/WithCache.h:45,Performance,cache,cache,45,"//===- llvm/Analysis/WithCache.h - KnownBits cache for pointers -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Store a pointer to any type along with the KnownBits information for it; // that is computed lazily (if required).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/WithCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/WithCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h:385,Performance,perform,performed,385,"/// Calculate and dump ThinLTO specific inliner stats.; /// The main statistics are:; /// (1) Number of inlined imported functions,; /// (2) Number of imported functions inlined into importing module (indirect),; /// (3) Number of non imported functions inlined into importing module; /// (indirect).; /// The difference between first and the second is that first stat counts; /// all performed inlines on imported functions, but the second one only the; /// functions that have been eventually inlined to a function in the importing; /// module (by a chain of inlines). Because llvm uses bottom-up inliner, it is; /// possible to e.g. import function `A`, `B` and then inline `B` to `A`,; /// and after this `A` might be too big to be inlined into some other function; /// that calls it. It calculates this statistic by building graph, where; /// the nodes are functions, and edges are performed inlines and then by marking; /// the edges starting from not imported function.; ///; /// If `Verbose` is set to true, then it also dumps statistics; /// per each inlined function, sorted by the greatest inlines count like; /// - number of performed inlines; /// - number of performed inlines to importing module",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h:887,Performance,perform,performed,887,"/// Calculate and dump ThinLTO specific inliner stats.; /// The main statistics are:; /// (1) Number of inlined imported functions,; /// (2) Number of imported functions inlined into importing module (indirect),; /// (3) Number of non imported functions inlined into importing module; /// (indirect).; /// The difference between first and the second is that first stat counts; /// all performed inlines on imported functions, but the second one only the; /// functions that have been eventually inlined to a function in the importing; /// module (by a chain of inlines). Because llvm uses bottom-up inliner, it is; /// possible to e.g. import function `A`, `B` and then inline `B` to `A`,; /// and after this `A` might be too big to be inlined into some other function; /// that calls it. It calculates this statistic by building graph, where; /// the nodes are functions, and edges are performed inlines and then by marking; /// the edges starting from not imported function.; ///; /// If `Verbose` is set to true, then it also dumps statistics; /// per each inlined function, sorted by the greatest inlines count like; /// - number of performed inlines; /// - number of performed inlines to importing module",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h:1137,Performance,perform,performed,1137,"/// Calculate and dump ThinLTO specific inliner stats.; /// The main statistics are:; /// (1) Number of inlined imported functions,; /// (2) Number of imported functions inlined into importing module (indirect),; /// (3) Number of non imported functions inlined into importing module; /// (indirect).; /// The difference between first and the second is that first stat counts; /// all performed inlines on imported functions, but the second one only the; /// functions that have been eventually inlined to a function in the importing; /// module (by a chain of inlines). Because llvm uses bottom-up inliner, it is; /// possible to e.g. import function `A`, `B` and then inline `B` to `A`,; /// and after this `A` might be too big to be inlined into some other function; /// that calls it. It calculates this statistic by building graph, where; /// the nodes are functions, and edges are performed inlines and then by marking; /// the edges starting from not imported function.; ///; /// If `Verbose` is set to true, then it also dumps statistics; /// per each inlined function, sorted by the greatest inlines count like; /// - number of performed inlines; /// - number of performed inlines to importing module",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h:1172,Performance,perform,performed,1172,"/// Calculate and dump ThinLTO specific inliner stats.; /// The main statistics are:; /// (1) Number of inlined imported functions,; /// (2) Number of imported functions inlined into importing module (indirect),; /// (3) Number of non imported functions inlined into importing module; /// (indirect).; /// The difference between first and the second is that first stat counts; /// all performed inlines on imported functions, but the second one only the; /// functions that have been eventually inlined to a function in the importing; /// module (by a chain of inlines). Because llvm uses bottom-up inliner, it is; /// possible to e.g. import function `A`, `B` and then inline `B` to `A`,; /// and after this `A` might be too big to be inlined into some other function; /// that calls it. It calculates this statistic by building graph, where; /// the nodes are functions, and edges are performed inlines and then by marking; /// the edges starting from not imported function.; ///; /// If `Verbose` is set to true, then it also dumps statistics; /// per each inlined function, sorted by the greatest inlines count like; /// - number of performed inlines; /// - number of performed inlines to importing module",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h:30,Performance,perform,perform,30,"//===- Local.h - Functions to perform local transformations -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h:408,Performance,perform,perform,408,"//===- Local.h - Functions to perform local transformations -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h:4,Performance,Load,Load,4,"/// Load a SavedModel, find the given inputs and outputs, and setup storage; /// for input tensors. The user is responsible for correctly dimensioning the; /// input tensors and setting their values before calling evaluate().; /// To initialize:; /// - construct the object; /// - initialize the input tensors using initInput. Indices must correspond to; /// indices in the InputNames used at construction.; /// To use:; /// - set input values by using getInput to get each input tensor, and then; /// setting internal scalars, for all dimensions (tensors are row-major:; /// https://github.com/tensorflow/tensorflow/blob/r1.5/tensorflow/c/c_api.h#L205); /// - call evaluate. The input tensors' values are not consumed after this, and; /// may still be read.; /// - use the outputs in the output vector",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h:13,Security,access,access,13,/// Provides access to the input vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h:34,Performance,load,loaded,34,"/// Returns true if the model was loaded successfully, false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h:12,Security,access,access,12,/// Untyped access to input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:2041,Availability,avail,available,2041,"dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; // An example reader, used for test, is available at; // Analysis/models/log_reader.py; //; // Example:; // {""features"":[list of TensorSpecs], ""score"":<a tensor spec>}; // {""context"": ""aFunction""}; // {""observation"": 0}; // <bytes>; // {""outcome"": 0}; // <bytes for the tensor corresponding to the ""score"" spec in the header>; // {""observation"": 1}; // ...; // {""context"": ""anotherFunction""}; // {""observation"": 0}; // ...; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:427,Integrability,depend,dependencies,427,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:991,Performance,optimiz,optimizations,991,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:691,Safety,avoid,avoiding,691,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:46,Testability,log,logging,46,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:406,Testability,log,logger,406,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:776,Testability,log,logger,776,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:1649,Testability,log,log,1649,"dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; // An example reader, used for test, is available at; // Analysis/models/log_reader.py; //; // Example:; // {""features"":[list of TensorSpecs], ""score"":<a tensor spec>}; // {""context"": ""aFunction""}; // {""observation"": 0}; // <bytes>; // {""outcome"": 0}; // <bytes for the tensor corresponding to the ""score"" spec in the header>; // {""observation"": 1}; // ...; // {""context"": ""anotherFunction""}; // {""observation"": 0}; // ...; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:2032,Testability,test,test,2032,"dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; // An example reader, used for test, is available at; // Analysis/models/log_reader.py; //; // Example:; // {""features"":[list of TensorSpecs], ""score"":<a tensor spec>}; // {""context"": ""aFunction""}; // {""observation"": 0}; // <bytes>; // {""outcome"": 0}; // <bytes for the tensor corresponding to the ""score"" spec in the header>; // {""observation"": 1}; // ...; // {""context"": ""anotherFunction""}; // {""observation"": 0}; // ...; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:769,Usability,simpl,simple,769,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:4,Testability,Log,Logging,4,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:107,Testability,log,logging,107,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:191,Testability,log,logged,191,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:267,Testability,log,log,267,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:548,Testability,log,logFloatValue,548,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:611,Testability,log,logFloatReward,611,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:650,Testability,log,logFloatValue,650,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:713,Testability,log,logFloatReward,713,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:782,Testability,log,log,782,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:818,Testability,log,logReward,818,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:864,Testability,log,log,864,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:16,Testability,Log,Logger,16,"/// Construct a Logger. If IncludeReward is false, then logReward or; /// logFinalReward shouldn't be called, and the reward feature won't be; /// printed out.; /// NOTE: the FeatureSpecs are expected to be in the same order (i.e. have; /// corresponding indices) with any MLModelRunner implementations; /// corresponding to the model being trained/logged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:56,Testability,log,logReward,56,"/// Construct a Logger. If IncludeReward is false, then logReward or; /// logFinalReward shouldn't be called, and the reward feature won't be; /// printed out.; /// NOTE: the FeatureSpecs are expected to be in the same order (i.e. have; /// corresponding indices) with any MLModelRunner implementations; /// corresponding to the model being trained/logged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:74,Testability,log,logFinalReward,74,"/// Construct a Logger. If IncludeReward is false, then logReward or; /// logFinalReward shouldn't be called, and the reward feature won't be; /// printed out.; /// NOTE: the FeatureSpecs are expected to be in the same order (i.e. have; /// corresponding indices) with any MLModelRunner implementations; /// corresponding to the model being trained/logged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:349,Testability,log,logged,349,"/// Construct a Logger. If IncludeReward is false, then logReward or; /// logFinalReward shouldn't be called, and the reward feature won't be; /// printed out.; /// NOTE: the FeatureSpecs are expected to be in the same order (i.e. have; /// corresponding indices) with any MLModelRunner implementations; /// corresponding to the model being trained/logged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:168,Integrability,depend,depend,168,/// ValID - Represents a reference of a definition of some sort with no type.; /// There are several cases where we have to parse the value but where the; /// type can depend on later context. This may either be a numeric reference; /// or a symbolic (%var) reference. This is just a discriminated union.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:63,Deployability,Upgrade,UpgradeDebuginfo,63,/// Only the llvm-as tool may set this to false to bypass; /// UpgradeDebuginfo so it can generate broken bitcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:10,Integrability,Rout,Routines,10,// Helper Routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:94,Deployability,install,installs,94,"/// setInstName - After an instruction is parsed and inserted into its; /// basic block, this installs its name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:103,Availability,error,error,103,"/// DefineBB - Define the specified basic block, which is either named or; /// unnamed. If there is an error, this returns null otherwise it returns; /// the block being defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:97,Availability,error,error,97,"// Instruction Parsing. Each instruction parsing routine can return with a; // normal result, an error result, or return having eaten an extra comma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:49,Integrability,rout,routine,49,"// Instruction Parsing. Each instruction parsing routine can return with a; // normal result, an error result, or return having eaten an extra comma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLToken.h:122,Safety,detect,detection,122,"// GV's where the clang++ frontend (when ASan is used) notes that this is; // dynamically initialized, and thus needs ODR detection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:492,Availability,Error,Error,492,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:551,Energy Efficiency,allocate,allocate,551,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:28,Integrability,interface,interface,28,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:502,Availability,Error,Error,502,"/// The function is a secondary interface to the LLVM Assembly Parser. It parses; /// an ASCII string that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a string; /// \param AsmString The string containing assembly; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:561,Energy Efficiency,allocate,allocate,561,"/// The function is a secondary interface to the LLVM Assembly Parser. It parses; /// an ASCII string that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a string; /// \param AsmString The string containing assembly; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:32,Integrability,interface,interface,32,"/// The function is a secondary interface to the LLVM Assembly Parser. It parses; /// an ASCII string that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a string; /// \param AsmString The string containing assembly; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:60,Integrability,interface,interfaces,60,/// Holds the Module and ModuleSummaryIndex returned by the interfaces; /// that parse both.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:563,Availability,Error,Error,563,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code, including; /// a module summary. It returns a Module (intermediate representation) and; /// a ModuleSummaryIndex with the corresponding features. Note that this does; /// not verify that the generated Module or Index are valid, so you should; /// run the verifier after parsing the file to check that they are okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:622,Energy Efficiency,allocate,allocate,622,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code, including; /// a module summary. It returns a Module (intermediate representation) and; /// a ModuleSummaryIndex with the corresponding features. Note that this does; /// not verify that the generated Module or Index are valid, so you should; /// run the verifier after parsing the file to check that they are okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:28,Integrability,interface,interface,28,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code, including; /// a module summary. It returns a Module (intermediate representation) and; /// a ModuleSummaryIndex with the corresponding features. Note that this does; /// not verify that the generated Module or Index are valid, so you should; /// run the verifier after parsing the file to check that they are okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:32,Testability,test,testing,32,/// Only for use in llvm-as for testing; this does not produce a valid module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:500,Availability,Error,Error,500,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code for a module; /// summary. It returns a ModuleSummaryIndex with the corresponding features.; /// Note that this does not verify that the generated Index is valid, so you; /// should run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly Index from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:28,Integrability,interface,interface,28,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code for a module; /// summary. It returns a ModuleSummaryIndex with the corresponding features.; /// Note that this does not verify that the generated Index is valid, so you; /// should run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly Index from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:506,Availability,Error,Error,506,"/// The function is a secondary interface to the LLVM Assembly Parser. It parses; /// an ASCII string that (presumably) contains LLVM Assembly code for a module; /// summary. It returns a a ModuleSummaryIndex with the corresponding features.; /// Note that this does not verify that the generated Index is valid, so you; /// should run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a string; /// \param AsmString The string containing assembly; /// \param Err Error result info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:32,Integrability,interface,interface,32,"/// The function is a secondary interface to the LLVM Assembly Parser. It parses; /// an ASCII string that (presumably) contains LLVM Assembly code for a module; /// summary. It returns a a ModuleSummaryIndex with the corresponding features.; /// Note that this does not verify that the generated Index is valid, so you; /// should run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a string; /// \param AsmString The string containing assembly; /// \param Err Error result info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:194,Availability,Error,Error,194,/// parseAssemblyFile and parseAssemblyString are wrappers around this function.; /// Parse LLVM Assembly from a MemoryBuffer.; /// \param F The MemoryBuffer containing assembly; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:50,Integrability,wrap,wrappers,50,/// parseAssemblyFile and parseAssemblyString are wrappers around this function.; /// Parse LLVM Assembly from a MemoryBuffer.; /// \param F The MemoryBuffer containing assembly; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:158,Availability,Error,Error,158,/// Parse LLVM Assembly including the summary index from a MemoryBuffer.; ///; /// \param F The MemoryBuffer containing assembly with summary; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; ///; /// parseAssemblyFileWithIndex is a wrapper around this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:309,Integrability,wrap,wrapper,309,/// Parse LLVM Assembly including the summary index from a MemoryBuffer.; ///; /// \param F The MemoryBuffer containing assembly with summary; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; ///; /// parseAssemblyFileWithIndex is a wrapper around this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:148,Availability,Error,Error,148,/// Parse LLVM Assembly for summary index from a MemoryBuffer.; ///; /// \param F The MemoryBuffer containing assembly with summary; /// \param Err Error result info.; ///; /// parseSummaryIndexAssemblyFile is a wrapper around this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:212,Integrability,wrap,wrapper,212,/// Parse LLVM Assembly for summary index from a MemoryBuffer.; ///; /// \param F The MemoryBuffer containing assembly with summary; /// \param Err Error result info.; ///; /// parseSummaryIndexAssemblyFile is a wrapper around this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:432,Availability,Error,Error,432,/// This function is the low-level interface to the LLVM Assembly Parser.; /// This is kept as an independent function instead of being inlined into; /// parseAssembly for the convenience of interactive users that want to add; /// recently parsed bits to an existing module.; ///; /// \param F The MemoryBuffer containing assembly; /// \param M The module to add data to.; /// \param Index The index to add data to.; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \return true on error.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:562,Availability,error,error,562,/// This function is the low-level interface to the LLVM Assembly Parser.; /// This is kept as an independent function instead of being inlined into; /// parseAssembly for the convenience of interactive users that want to add; /// recently parsed bits to an existing module.; ///; /// \param F The MemoryBuffer containing assembly; /// \param M The module to add data to.; /// \param Index The index to add data to.; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \return true on error.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:35,Integrability,interface,interface,35,/// This function is the low-level interface to the LLVM Assembly Parser.; /// This is kept as an independent function instead of being inlined into; /// parseAssembly for the convenience of interactive users that want to add; /// recently parsed bits to an existing module.; ///; /// \param F The MemoryBuffer containing assembly; /// \param M The module to add data to.; /// \param Index The index to add data to.; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \return true on error.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:278,Availability,error,error,278,"/// Parse a type and a constant value in the given string.; ///; /// The constant value can be any LLVM constant, including a constant; /// expression.; ///; /// \param Slots The optional slot mapping that will restore the parsing state; /// of the module.; /// \return null on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:164,Availability,error,error,164,/// Parse a type in the given string.; ///; /// \param Slots The optional slot mapping that will restore the parsing state; /// of the module.; /// \return null on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:280,Availability,error,error,280,/// Parse a string \p Asm that starts with a type.; /// \p Read[out] gives the number of characters that have been read to parse; /// the type in \p Asm.; ///; /// \param Slots The optional slot mapping that will restore the parsing state; /// of the module.; /// \return null on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:561,Availability,avail,available,561,"//===-- llvm/BinaryFormat/COFF.h --------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an definitions used in Windows COFF Files.; //; // Structures and enums defined within this file where created using; // information from Microsoft's publicly available PE/COFF format document:; //; // Microsoft Portable Executable and Common Object File Format Specification; // Revision 8.1 - February 15, 2008; //; // As of 5/2/2010, hosted by Microsoft at:; // http://www.microsoft.com/whdc/system/platform/firmware/pecoff.mspx; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:614,Modifiability,Portab,Portable,614,"//===-- llvm/BinaryFormat/COFF.h --------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an definitions used in Windows COFF Files.; //; // Structures and enums defined within this file where created using; // information from Microsoft's publicly available PE/COFF format document:; //; // Microsoft Portable Executable and Common Object File Format Specification; // Revision 8.1 - February 15, 2008; //; // As of 5/2/2010, hosted by Microsoft at:; // http://www.microsoft.com/whdc/system/platform/firmware/pecoff.mspx; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:47,Testability,stub,stub,47,// The PE signature bytes that follows the DOS stub header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:134,Availability,error,error,134,"/// The file does not contain base relocations and must be loaded at its; /// preferred base. If this cannot be done, the loader will error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:59,Performance,load,loaded,59,"/// The file does not contain base relocations and must be loaded at its; /// preferred base. If this cannot be done, the loader will error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:122,Performance,load,loader,122,"/// The file does not contain base relocations and must be loaded at its; /// preferred base. If this cannot be done, the loader will error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:46,Performance,load,load,46,"/// If the image is on removable media, fully load it and copy it to swap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:44,Performance,load,load,44,"/// If the image is on network media, fully load it and copy it to swap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:11,Modifiability,variab,variable,11,///< Stack variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:14,Modifiability,variab,variable,14,///< Register variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:36,Modifiability,variab,variable,36,///< No complex type; simple scalar variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:22,Usability,simpl,simple,22,///< No complex type; simple scalar variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:28,Performance,load,load,28,/// DLL can be relocated at load time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:9,Security,integrity,integrity,9,/// Code integrity checks are enforced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:11,Performance,perform,performs,11,/// Module performs control flow integrity checks using system-supplied; /// support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:33,Security,integrity,integrity,33,/// Module performs control flow integrity checks using system-supplied; /// support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:11,Performance,perform,performs,11,/// Module performs control flow and write integrity checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:43,Security,integrity,integrity,43,/// Module performs control flow and write integrity checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:40,Security,secur,security,40,/// Module does not make use of the /GS security cookie.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:36,Performance,load,load,36,/// Module supports read only delay load IAT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:134,Modifiability,config,config,134,/// Module contains suppressed export information. This also infers that the; /// address taken IAT table is also present in the load config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:129,Performance,load,load,129,/// Module contains suppressed export information. This also infers that the; /// address taken IAT table is also present in the load config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:4,Availability,Mask,Mask,4,"/// Mask for the subfield that contains the stride of Control Flow Guard; /// function table entries (that is, the additional count of bytes per table; /// entry).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:30,Safety,safe,safeseh,30,// Object is compatible with /safeseh.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:667,Deployability,release,released,667,"//===-- llvm/BinaryFormat/Dwarf.h ---Dwarf Constants-------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains constants used for implementing Dwarf; /// debug support.; ///; /// For details on the Dwarf specfication see the latest DWARF Debugging; /// Information Format standard document on http://www.dwarfstd.org. This; /// file often includes support for non-released standard features.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:9,Testability,mock,mock,9,/// LLVM mock tags (see also llvm/BinaryFormat/Dwarf.def).; /// \{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:3,Security,Access,Accessibility,3,// Accessibility codes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:16,Modifiability,Extend,Extended,16,/// Line Number Extended Opcode Encodings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:22,Security,hash,hash,22,"// Dsymutil qualified hash extension.; // DW_ATOM_type_flags values.; // Always set for C++, only set for ObjC if this is the @implementation for a; // class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:3,Security,Hash,Hash,3,// Hash functions.; // Daniel J. Bernstein hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:43,Security,hash,hash,43,// Hash functions.; // Daniel J. Bernstein hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:103,Integrability,depend,depending,103,"/// A helper struct providing information about the byte size of DW_FORM; /// values that vary in size depending on the DWARF version, address byte; /// size, or DWARF32/DWARF64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:56,Integrability,depend,depends,56,"/// The definition of the size of form DW_FORM_ref_addr depends on the; /// version. In DWARF v2 it's the size of an address; after that, it's the; /// size of a reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:47,Integrability,depend,depending,47,/// Get the byte size of the unit length field depending on the DWARF format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:182,Modifiability,variab,variable,182,"/// Get the fixed byte size for a given form.; ///; /// If the form has a fixed byte size, then an Optional with a value will be; /// returned. If the form is always encoded using a variable length storage; /// format (ULEB or SLEB numbers or blocks) then std::nullopt will be returned.; ///; /// \param Form DWARF form to get the fixed byte size for.; /// \param Params DWARF parameters to help interpret forms.; /// \returns std::optional<uint8_t> value with the fixed byte size or; /// std::nullopt if \p Form doesn't have a fixed byte size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:39,Security,hash,hash,39,// This flag indicates that the shader hash was computed; // taking into account source information (-Zss),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:9,Security,Hash,HashFlags,9,// dxbc::HashFlags,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:3,Availability,Mask,Mask,3,"// Mask (column allocation); // The ExclusiveMask has a different meaning for input and output signatures.; // For an output signature, masked components of the output register are never; // written to.; // For an input signature, masked components of the input register are always; // read.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:136,Availability,mask,masked,136,"// Mask (column allocation); // The ExclusiveMask has a different meaning for input and output signatures.; // For an output signature, masked components of the output register are never; // written to.; // For an input signature, masked components of the input register are always; // read.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:231,Availability,mask,masked,231,"// Mask (column allocation); // The ExclusiveMask has a different meaning for input and output signatures.; // For an output signature, masked components of the output register are never; // written to.; // For an input signature, masked components of the input register are always; // read.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:579,Integrability,Interface,Interface,579,"//===- llvm/BinaryFormat/ELF.h - ELF constants and structures ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header contains common, non-processor-specific data structures and; // constants for the ELF file format.; //; // The details of the ELF32 bits in this file are largely based on the Tool; // Interface Standard (TIS) Executable and Linking Format (ELF) Specification; // Version 1.2, May 1995. The ELF64 stuff is based on ELF-64 Object File Format; // Version 1.5, Draft 2, May 1998 as well as OpenBSD header files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:97,Usability,ux,uxsglobal,97,// Machine architectures; // See current registered ELF machine architectures at:; // http://www.uxsglobal.com/developers/gabi/latest/ch4.eheader.html,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Modifiability,Enhance,Enhanced,3,// Enhanced instruction set SPARC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Energy Efficiency,Power,PowerPC,3,// PowerPC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:12,Testability,Log,Logic,12,// Advanced Logic Corp. TinyJ embedded processor family,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:7,Testability,Log,Logic,7,// LSI Logic 16-bit DSP Processor,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:24,Modifiability,config,configurable,24,// eXcess: 16/32/64-bit configurable embedded CPU,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:39,Modifiability,config,configurable,39,// STMicroelectronics STxP7x family of configurable; // and extensible RISC processors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:13,Modifiability,Extend,Extended,13,// Freescale Extended Time Processing Unit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:13,Performance,Optimiz,Optimized,13,// Nanoradio Optimized RISC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:6,Usability,UX,UX,6,// HP-UX operating system,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:29,Availability,mask,mask,29,// EF_AVR_ARCH_xxx selection mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:11,Modifiability,extend,extended,11,// O32 ABI extended for 64-bit architecture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Availability,Mask,Mask,3,// Mask for selecting EF_MIPS_ABI_ variant.; // MIPS machine variant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:30,Availability,mask,mask,30,// EF_MIPS_MACH_xxx selection mask; // ARCH_ASE,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Availability,Mask,Mask,3,// Mask for EF_MIPS_ARCH_ASE_xxx flags; // ARCH,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Availability,Mask,Mask,3,// Mask for applying EF_MIPS_ARCH_ variant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:40,Energy Efficiency,allocate,allocated,40,// Common symbols which are defined and allocated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:12,Deployability,patch,patches,12,// Hardware patches applied,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:16,Deployability,patch,patches,16,// Hardware AND patches applied,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:15,Deployability,patch,patches,15,// Hardware OR patches applied,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:9,Security,access,access,9,// Other access sizes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:14,Security,access,access,14,// Byte-sized access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:19,Security,access,access,19,// Half-word-sized access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:14,Security,access,access,14,// Word-sized access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:20,Security,access,access,20,// Double-word-size access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:23,Availability,mask,mask,23,// Processor selection mask for EF_AMDGPU_MACH_* values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:19,Availability,mask,mask,19,// XNACK selection mask for EF_AMDGPU_FEATURE_XNACK_* values.; //; // Only valid for ELFOSABI_AMDGPU_HSA and ELFABIVERSION_AMDGPU_HSA_V4.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:21,Availability,mask,mask,21,// SRAMECC selection mask for EF_AMDGPU_FEATURE_SRAMECC_* values.; //; // Only valid for ELFOSABI_AMDGPU_HSA and ELFABIVERSION_AMDGPU_HSA_V4.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:23,Availability,mask,mask,23,// Processor selection mask for EF_CUDA_SM* values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Usability,Undo,Undocumented,3,// Undocumented software feature.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:31,Availability,mask,mask,31,// Virtual processor selection mask for EF_CUDA_VIRTUAL_SM* values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:126,Security,hash,hash,126,// Definitions from LoongArch ELF psABI v2.01.; // Reference: https://github.com/loongson/LoongArch-Documentation; // (commit hash 296de4def055c871809068e0816325a4ac04eb12); // Base ABI Modifiers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:32,Availability,mask,mask,32,// Four-bit Xtensa machine type mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:34,Performance,load,loaded,34,// Address where section is to be loaded,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:39,Modifiability,variab,variables,39,// FORTRAN COMMON or C external global variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:10,Security,hash,hash,10,// Symbol hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:47,Safety,safe,safe,47,// List of address-significant symbols; // for safe ICF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:8,Integrability,Depend,Dependent,8,// LLVM Dependent Library Specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:18,Performance,load,loadable,18,// ELF header for loadable partition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:13,Performance,load,loadable,13,// Phdrs for loadable partition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:13,Security,hash,hash,13,// GNU-style hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:59,Safety,avoid,avoid,59,// This section requires special OS-specific processing to avoid incorrect; // behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:87,Security,access,accesses,87,// All sections with the GPREL flag are grouped into a global data area; // for faster accesses,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:64,Security,access,accessors,64,"// Which section (header table index) it's defined in; // These accessors and mutators correspond to the ELF32_ST_BIND,; // ELF32_ST_TYPE, and ELF32_ST_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:32,Security,access,accessors,32,// Size of the symbol; // These accessors and mutators are identical to those defined for ELF32; // symbol table entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:28,Modifiability,variab,variable,28,"// Symbol is a data object (variable, array, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:64,Security,access,accessors,64,"// Symbol table index and type of relocation to apply; // These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,; // and ELF32_R_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:64,Security,access,accessors,64,"// Compute value for relocatable field by adding this; // These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,; // and ELF32_R_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:65,Security,access,accessors,65,"// Symbol table index and type of relocation to apply.; // These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,; // and ELF64_R_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:65,Security,access,accessors,65,"// Compute value for relocatable field by adding this.; // These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,; // and ELF64_R_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Performance,Load,Loadable,3,// Loadable segment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:30,Performance,load,load,30,// Process all relocations on load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:22,Performance,load,load,22,// Reject attempts to load dynamically.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:18,Performance,load,loading,18,// Trigger filtee loading at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Deployability,Configurat,Configuration,3,// Configuration alternative created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Modifiability,Config,Configuration,3,// Configuration alternative created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:10,Security,audit,auditing,10,// Global auditing required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:22,Energy Efficiency,power,power,22,// Hash size is not a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Security,Hash,Hash,3,// Hash size is not a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:9,Performance,load,load,9,// Delay-load DSO by default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:24,Safety,safe,safe,24,// Symbol table is in a safe order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:17,Availability,mask,mask,17,// Version Index mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:171,Deployability,upgrade,upgrade,171,"// Enumeration to determine the tagging mode. In Android-land, 'SYNC' means; // running all threads in MTE Synchronous mode, and 'ASYNC' means to use the; // kernels auto-upgrade feature to allow for either MTE Asynchronous,; // Asymmetric, or Synchronous mode. This allows silicon vendors to specify, on; // a per-cpu basis what 'ASYNC' should mean. Generally, the expectation is; // ""pick the most precise mode that's very fast"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:31,Performance,load,loader,31,// Bits indicating whether the loader should prepare for MTE to be enabled on; // the heap and/or stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Modifiability,Variab,Variable,3,// Variable in LDS; symbol encoded like SHN_COMMON,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:22,Performance,load,loader,22,// Enums from <mach-o/loader.h>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,"// Constant masks for the ""flags"" field in llvm::MachO::section and; // llvm::MachO::section_64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,"// Constant masks for the ""flags[7:0]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_TYPE); /// S_REGULAR - Regular section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:102,Availability,mask,mask,102,"// Constant masks for the ""flags[7:0]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_TYPE); /// S_REGULAR - Regular section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:41,Testability,stub,stubs,41,"/// S_SYMBOL_STUBS - Section with symbol stubs, byte size of stub in; /// the Reserved2 field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:61,Testability,stub,stub,61,"/// S_SYMBOL_STUBS - Section with symbol stubs, byte size of stub in; /// the Reserved2 field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:82,Performance,load,loaded,82,/// S_LAZY_DYLIB_SYMBOL_POINTERS - Section with lazy symbol pointers to; /// lazy loaded dylibs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:57,Modifiability,variab,variable,57,/// S_THREAD_LOCAL_VARIABLES - Section with thread local variable; /// structure data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:75,Modifiability,variab,variable,75,/// S_THREAD_LOCAL_INIT_FUNCTION_POINTERS - Section with thread local; /// variable initialization pointers to functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,"// Constant masks for the ""flags[31:24]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_ATTRIBUTES_USR); /// S_ATTR_PURE_INSTRUCTIONS - Section contains only true machine; /// instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:104,Availability,mask,mask,104,"// Constant masks for the ""flags[31:24]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_ATTRIBUTES_USR); /// S_ATTR_PURE_INSTRUCTIONS - Section contains only true machine; /// instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:53,Testability,stub,stubs,53,/// S_ATTR_SELF_MODIFYING_CODE - Used with i386 code stubs written on by; /// dyld.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,"// Constant masks for the ""flags[23:8]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_ATTRIBUTES_SYS); /// S_ATTR_SOME_INSTRUCTIONS - Section contains some machine instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:103,Availability,mask,mask,103,"// Constant masks for the ""flags[23:8]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_ATTRIBUTES_SYS); /// S_ATTR_SOME_INSTRUCTIONS - Section contains some machine instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,// Constant masks for the value of an indirect symbol in an indirect; // symbol table,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,"// Constant masks for the ""n_type"" field in llvm::MachO::nlist and; // llvm::MachO::nlist_64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,"// Constant masks for the ""n_desc"" field in llvm::MachO::nlist and; // llvm::MachO::nlist_64; // The low 3 bits are the for the REFERENCE_TYPE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:45,Energy Efficiency,Power,PowerPC,45,// Constant values for the r_type field in a PowerPC architecture; // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info; // structure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:6,Security,authenticat,authenticated,6,// An authenticated pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:24,Performance,load,loader,24,// Structs from <mach-o/loader.h>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:123,Performance,load,load,123,/// Structs for dyld chained fixups.; /// dyld_chained_fixups_header is the data pointed to by LC_DYLD_CHAINED_FIXUPS; /// load command.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:3,Availability,Mask,Mask,3,// Mask for architecture bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:16,Energy Efficiency,Power,PowerPC,16,// Old Motorola PowerPC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:3,Availability,Mask,Mask,3,// Mask for architecture bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:25,Performance,load,load,25,// Define a union of all load command structs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:36,Modifiability,variab,variable-length,36,// getStructOrErr() cannot copy the variable-length seg_info_offset array.; // Its elements must be byte swapped manually.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:7,Deployability,install,installer,7,/* has installer entitlement */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:11,Security,Validat,Validation,11,/* Library Validation required by Hardened System Policy */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:9,Performance,load,load,9,/* don't load invalid pages */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:19,Security,validat,validation,19,/* require library validation */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:43,Modifiability,variab,variables,43,/* has com.apple.rootless.restricted-nvram-variables.heritable; entitlement */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:16,Performance,load,load,16,/* dyld used to load this is a platform binary */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:33,Performance,load,loaded,33,"/* code is dev signed, cannot be loaded into prod signed code; (will go away with rdar://problem/28322552) */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:26,Security,validat,validation,26,/* OBSOLETE: skip library validation */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:19,Security,hash,hashes,19,/* always - larger hashes are truncated */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:85,Modifiability,plugin,plugins,85,"/* max size of the hash we'll support */; /*; * Currently only to support Legacy VPN plugins, and Mac App Store; * but intended to replace all the various platform code, dev code etc. bits.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:19,Security,hash,hash,19,"/* max size of the hash we'll support */; /*; * Currently only to support Legacy VPN plugins, and Mac App Store; * but intended to replace all the various platform code, dev code etc. bits.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:13,Security,hash,hash,13,/* offset of hash slot element at index zero */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:21,Security,hash,hash,21,/* number of special hash slots */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:29,Security,hash,hash,29,/* number of ordinary (code) hash slots */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:16,Security,hash,hash,16,/* size of each hash in bytes */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:11,Security,hash,hash,11,/* type of hash (cdHashType* constants) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h:23,Testability,stub,stub,23,///< Mach-O Shared lib stub,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h:32,Testability,Stub,Stub,32,///< Text-based Dynamic Library Stub file,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Minidump.h:113,Integrability,depend,depends,113,/// Detailed information about the processor of the system that generated this; /// minidump. Its interpretation depends on the ProcessorArchitecture enum.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Minidump.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Minidump.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:20,Integrability,Message,MessagePack,20,"//===-- MsgPack.h - MessagePack Constants -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains constants used for implementing MessagePack support.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:447,Integrability,Message,MessagePack,447,"//===-- MsgPack.h - MessagePack Constants -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains constants used for implementing MessagePack support.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:55,Integrability,Message,MessagePack,55,/// The endianness of all multi-byte encoded values in MessagePack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:34,Integrability,Message,MessagePack,34,/// The first byte identifiers of MessagePack object formats.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:343,Availability,mask,mask,343,"/// Most significant bits used to identify ""Fix"" variants in MessagePack.; ///; /// For example, FixStr objects encode their size in the five least significant; /// bits of their first byte, which is identified by the bit pattern ""101"" in; /// the three most significant bits. So FixBits::String contains 0b10100000.; ///; /// A corresponding mask of the bit pattern is found in \c FixBitsMask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:61,Integrability,Message,MessagePack,61,"/// Most significant bits used to identify ""Fix"" variants in MessagePack.; ///; /// For example, FixStr objects encode their size in the five least significant; /// bits of their first byte, which is identified by the bit pattern ""101"" in; /// the three most significant bits. So FixBits::String contains 0b10100000.; ///; /// A corresponding mask of the bit pattern is found in \c FixBitsMask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:4,Availability,Mask,Mask,4,"/// Mask of bits used to identify ""Fix"" variants in MessagePack.; ///; /// For example, FixStr objects encode their size in the five least significant; /// bits of their first byte, which is identified by the bit pattern ""101"" in; /// the three most significant bits. So FixBitsMask::String contains; /// 0b11100000.; ///; /// The corresponding bit pattern to mask for is found in FixBits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:360,Availability,mask,mask,360,"/// Mask of bits used to identify ""Fix"" variants in MessagePack.; ///; /// For example, FixStr objects encode their size in the five least significant; /// bits of their first byte, which is identified by the bit pattern ""101"" in; /// the three most significant bits. So FixBitsMask::String contains; /// 0b11100000.; ///; /// The corresponding bit pattern to mask for is found in FixBits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:52,Integrability,Message,MessagePack,52,"/// Mask of bits used to identify ""Fix"" variants in MessagePack.; ///; /// For example, FixStr objects encode their size in the five least significant; /// bits of their first byte, which is identified by the bit pattern ""101"" in; /// the three most significant bits. So FixBitsMask::String contains; /// 0b11100000.; ///; /// The corresponding bit pattern to mask for is found in FixBits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:423,Security,expose,exposes,423,"//===-- MsgPackDocument.h - MsgPack Document --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares a class that exposes a simple in-memory representation; /// of a document of MsgPack objects, that can be read from MsgPack, written to; /// MsgPack, and inspected and modified in memory. This is intended to be a; /// lighter-weight (in terms of memory allocations) replacement for; /// MsgPackTypes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:433,Usability,simpl,simple,433,"//===-- MsgPackDocument.h - MsgPack Document --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares a class that exposes a simple in-memory representation; /// of a document of MsgPack objects, that can be read from MsgPack, written to; /// MsgPack, and inspected and modified in memory. This is intended to be a; /// lighter-weight (in terms of memory allocations) replacement for; /// MsgPackTypes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:44,Usability,simpl,simple,44,/// A node in a MsgPack Document. This is a simple copyable and; /// passable-by-value type that does not own any memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:3,Security,Access,Accessors,3,"// Accessors. isEmpty() returns true for both a default-constructed DocNode; // that has no associated Document, and the result of getEmptyNode(), which; // does have an associated document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:297,Safety,avoid,avoid,297,"/// Convenience assignment operators. This only works if the destination; /// DocNode has an associated Document, i.e. it was not constructed using the; /// default constructor. The string one does not copy, so the string must; /// remain valid for the lifetime of the Document. Use fromString to avoid; /// that restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:7,Security,access,access,7,// Map access methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:11,Security,access,access,11,/// Member access. The string data must remain valid for the lifetime of the; /// Document.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:11,Security,access,access,11,"/// Member access, with convenience versions for an integer key.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:9,Security,access,access,9,// Array access methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:25,Modifiability,extend,extends,25,"/// Element access. This extends the array if necessary, with empty nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:12,Security,access,access,12,"/// Element access. This extends the array if necessary, with empty nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:4,Usability,Simpl,Simple,4,/// Simple in-memory representation of a document of msgpack objects with; /// ability to find and create array and map elements. Does not currently cope; /// with any extension types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:513,Availability,error,error,513,"/// Read a document from a binary msgpack blob, merging into anything already; /// in the Document. The blob data must remain valid for the lifetime of this; /// Document (because a string object in the document contains a StringRef; /// into the original blob). If Multi, then this sets root to an array and; /// adds top-level objects to it. If !Multi, then it only reads a single; /// top-level object, even if there are more, and sets root to that. Returns; /// false if failed due to illegal format or merge error.; ///; /// The Merger arg is a callback function that is called when the merge has a; /// conflict, that is, it is trying to set an item that is already set. If the; /// conflict cannot be resolved, the callback function returns -1. If the; /// conflict can be resolved, the callback returns a non-negative number and; /// sets *DestNode to the resolved node. The returned non-negative number is; /// significant only for an array node; it is then the array index to start; /// populating at. That allows Merger to choose whether to merge array; /// elements (returns 0) or append new elements (returns existing size).; ///; /// If SrcNode is an array or map, the resolution must be that *DestNode is an; /// array or map respectively, although it could be the array or map; /// (respectively) that was already there. MapKey is the key if *DestNode is a; /// map entry, a nil node otherwise.; ///; /// The default for Merger is to disallow any conflict.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:63,Availability,failure,failure,63,/// Read YAML text into the MsgPack document. Returns false on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:768,Availability,error,error,768,"//===- MsgPackReader.h - Simple MsgPack reader ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is a MessagePack reader.; ///; /// See https://github.com/msgpack/msgpack/blob/master/spec.md for the full; /// standard.; ///; /// Typical usage:; /// \code; /// StringRef input = GetInput();; /// msgpack::Reader MPReader(input);; /// msgpack::Object Obj;; ///; /// while (true) {; /// Expected<bool> ReadObj = MPReader.read(&Obj);; /// if (!ReadObj); /// // Handle error...; /// if (!ReadObj.get()); /// break; // Reached end of input; /// switch (Obj.Kind) {; /// case msgpack::Type::Int:; // // Use Obj.Int; /// break;; /// // ...; /// }; /// }; /// \endcode; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:406,Integrability,Message,MessagePack,406,"//===- MsgPackReader.h - Simple MsgPack reader ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is a MessagePack reader.; ///; /// See https://github.com/msgpack/msgpack/blob/master/spec.md for the full; /// standard.; ///; /// Typical usage:; /// \code; /// StringRef input = GetInput();; /// msgpack::Reader MPReader(input);; /// msgpack::Object Obj;; ///; /// while (true) {; /// Expected<bool> ReadObj = MPReader.read(&Obj);; /// if (!ReadObj); /// // Handle error...; /// if (!ReadObj.get()); /// break; // Reached end of input; /// switch (Obj.Kind) {; /// case msgpack::Type::Int:; // // Use Obj.Int; /// break;; /// // ...; /// }; /// }; /// \endcode; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:25,Usability,Simpl,Simple,25,"//===- MsgPackReader.h - Simple MsgPack reader ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is a MessagePack reader.; ///; /// See https://github.com/msgpack/msgpack/blob/master/spec.md for the full; /// standard.; ///; /// Typical usage:; /// \code; /// StringRef input = GetInput();; /// msgpack::Reader MPReader(input);; /// msgpack::Object Obj;; ///; /// while (true) {; /// Expected<bool> ReadObj = MPReader.read(&Obj);; /// if (!ReadObj); /// // Handle error...; /// if (!ReadObj.get()); /// break; // Reached end of input; /// switch (Obj.Kind) {; /// case msgpack::Type::Int:; // // Use Obj.Int; /// break;; /// // ...; /// }; /// }; /// \endcode; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:4,Integrability,Message,MessagePack,4,"/// MessagePack types as defined in the standard, with the exception of Integer; /// being divided into a signed Int and unsigned UInt variant in order to map; /// directly to C++ types.; ///; /// The types map onto corresponding union members of the \c Object struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:4,Integrability,Message,MessagePack,4,"/// MessagePack object, represented as a tagged union of C++ types.; ///; /// All types except \c Type::Nil (which has only one value, and so is; /// completely represented by the \c Kind itself) map to a exactly one union; /// member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:10,Integrability,Message,MessagePack,10,"/// Reads MessagePack objects from memory, one at a time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:629,Availability,error,error,629,"/// Read one object from the input buffer, advancing past it.; ///; /// The \p Obj is updated with the kind of the object read, and the; /// corresponding union member is updated.; ///; /// For the collection objects (Array and Map), only the length is read, and; /// the caller must make and additional \c N calls (in the case of Array) or; /// \c N*2 calls (in the case of Map) to \c Read to retrieve the collection; /// elements.; ///; /// \param [out] Obj filled with next object on success.; ///; /// \returns true when object successfully read, false when at end of; /// input (and so \p Obj was not updated), otherwise an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:86,Deployability,update,updated,86,"/// Read one object from the input buffer, advancing past it.; ///; /// The \p Obj is updated with the kind of the object read, and the; /// corresponding union member is updated.; ///; /// For the collection objects (Array and Map), only the length is read, and; /// the caller must make and additional \c N calls (in the case of Array) or; /// \c N*2 calls (in the case of Map) to \c Read to retrieve the collection; /// elements.; ///; /// \param [out] Obj filled with next object on success.; ///; /// \returns true when object successfully read, false when at end of; /// input (and so \p Obj was not updated), otherwise an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:171,Deployability,update,updated,171,"/// Read one object from the input buffer, advancing past it.; ///; /// The \p Obj is updated with the kind of the object read, and the; /// corresponding union member is updated.; ///; /// For the collection objects (Array and Map), only the length is read, and; /// the caller must make and additional \c N calls (in the case of Array) or; /// \c N*2 calls (in the case of Map) to \c Read to retrieve the collection; /// elements.; ///; /// \param [out] Obj filled with next object on success.; ///; /// \returns true when object successfully read, false when at end of; /// input (and so \p Obj was not updated), otherwise an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:606,Deployability,update,updated,606,"/// Read one object from the input buffer, advancing past it.; ///; /// The \p Obj is updated with the kind of the object read, and the; /// corresponding union member is updated.; ///; /// For the collection objects (Array and Map), only the length is read, and; /// the caller must make and additional \c N calls (in the case of Array) or; /// \c N*2 calls (in the case of Map) to \c Read to retrieve the collection; /// elements.; ///; /// \param [out] Obj filled with next object on success.; ///; /// \returns true when object successfully read, false when at end of; /// input (and so \p Obj was not updated), otherwise an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h:417,Integrability,Message,MessagePack,417,"//===- MsgPackWriter.h - Simple MsgPack writer ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a MessagePack writer.; ///; /// See https://github.com/msgpack/msgpack/blob/master/spec.md for the full; /// specification.; ///; /// Typical usage:; /// \code; /// raw_ostream output = GetOutputStream();; /// msgpack::Writer MPWriter(output);; /// MPWriter.writeNil();; /// MPWriter.write(false);; /// MPWriter.write(""string"");; /// // ...; /// \endcode; ///; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h:25,Usability,Simpl,Simple,25,"//===- MsgPackWriter.h - Simple MsgPack writer ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a MessagePack writer.; ///; /// See https://github.com/msgpack/msgpack/blob/master/spec.md for the full; /// specification.; ///; /// Typical usage:; /// \code; /// raw_ostream output = GetOutputStream();; /// msgpack::Writer MPWriter(output);; /// MPWriter.writeNil();; /// MPWriter.write(false);; /// MPWriter.write(""string"");; /// // ...; /// \endcode; ///; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h:11,Integrability,Message,MessagePack,11,"/// Writes MessagePack objects to an output stream, one at a time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h:88,Integrability,Message,MessagePack,88,"/// Construct a writer, optionally enabling ""Compatibility Mode"" as defined; /// in the MessagePack specification.; ///; /// When in \p Compatible mode, the writer will write \c Str16 formats; /// instead of \c Str8 formats, and will refuse to write any \c Bin formats.; ///; /// \param OS stream to output MessagePack objects to.; /// \param Compatible when set, write in ""Compatibility Mode"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h:307,Integrability,Message,MessagePack,307,"/// Construct a writer, optionally enabling ""Compatibility Mode"" as defined; /// in the MessagePack specification.; ///; /// When in \p Compatible mode, the writer will write \c Str16 formats; /// instead of \c Str8 formats, and will refuse to write any \c Bin formats.; ///; /// \param OS stream to output MessagePack objects to.; /// \param Compatible when set, write in ""Compatibility Mode"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h:18,Integrability,depend,dependencies,18,// Shared library dependencies,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h:22,Modifiability,extend,extended,22,// Set to non-zero if extended const is used (i.e. more than; // one instruction),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:3,Availability,Mask,Masks,3,// Masks for packing/unpacking the r_rsize field of relocations.; // The msb is used to indicate if the bits being relocated are signed or; // unsigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:46,Performance,load,loader,46,"///< file is executable (i.e., it; ///< has a loader section)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:31,Modifiability,variab,variable,31,///< executable requests using variable size pages,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:25,Performance,load,loadable,25,///< file is dynamically loadable and; ///< executable (equivalent to F_EXEC on AIX),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:17,Performance,load,loaded,17,"///< file can be loaded by the system loader, but it is; ///< ignored by the linker if it is a member of an archive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:38,Performance,load,loader,38,"///< file can be loaded by the system loader, but it is; ///< ignored by the linker if it is a member of an archive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:31,Integrability,Interface,Interface,31,///< Global Linkage (Interfile Interface Code),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:5,Modifiability,Extend,Extended,5,///< Extended Operation (Pseudo Machine Instruction),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:30,Modifiability,variab,variable,30,///< Initialized thread-local variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:32,Modifiability,variab,variable,32,///< Uninitialized thread-local variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:40,Availability,Mask,Masks,40,"// Flags for defining the section type. Masks for use with the (signed, 32-bit); // s_flags field of the section header structure, selecting for values in the; // lower 16 bits. Defined in the system header `scnhdr.h`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:10,Modifiability,variab,variable,10,// Global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:14,Energy Efficiency,allocate,allocated,14,// Statically allocated symbol,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:23,Modifiability,variab,variable,23,// Global thread-local variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:23,Modifiability,variab,variable,23,// Static thread-local variable; // Storage classes used for DWARF symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:22,Energy Efficiency,allocate,allocated,22,// Automatic variable allocated on stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:13,Modifiability,variab,variable,13,// Automatic variable allocated on stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:26,Energy Efficiency,allocate,allocated,26,// Argument to subroutine allocated on stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:12,Modifiability,variab,variable,12,// Register variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:63,Usability,Undo,Undocumented,63,// Declaration of object (type); // Storage classes - Obsolete/Undocumented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:13,Modifiability,variab,variable,13,// Automatic variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:12,Modifiability,variab,variable,12,// Register variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:23,Performance,load,load,23,///< Positive indirect load relocation. Modifiable instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:14,Performance,load,load,14,///< Positive load address relocation. Modifiable instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:27,Performance,load,load,27,"///< TOC relative indirect load relocation. Similar to R_TOC,; ///< but not modifiable instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:256,Performance,load,load,256,///< Relative to the TOC or to the thread-local storage base; ///< relocation. Compilers are not permitted to generate this; ///< relocation type. It is the result of a reversible; ///< transformation by the linker of an R_TOC relation that turned a; ///< load instruction into an add-immediate instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:219,Integrability,depend,dependency,219,///< A non-relocating relocation. Used to prevent the binder; ///< from garbage collecting a csect (such as code used for; ///< dynamic initialization of non-local statics) for which; ///< another csect has an implicit dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:5,Energy Efficiency,Power,PowerPC,5,///< PowerPC common architecture 64-bit mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:5,Energy Efficiency,POWER,POWER,5,///< POWER and PowerPC architecture common.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:15,Energy Efficiency,Power,PowerPC,15,///< POWER and PowerPC architecture common.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:14,Energy Efficiency,Power,PowerPC,14,///< PPC970 - PowerPC 64-bit architecture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:3,Availability,Mask,Masks,3,// Masks to select leftmost bits for decoding parameter type information.; // Bit to use when vector info is not presented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:3,Modifiability,Extend,Extended,3,// Extended Traceback table flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:19,Deployability,canary,canary,19,///< stack smasher canary present on stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h:403,Integrability,interface,interfaces,403,"//===- llvm/Bitcode/BitcodeAnalyzer.h - Bitcode analyzer --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines interfaces to analyze LLVM bitcode files/streams.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h:56,Availability,avail,available,56,/// Don't emit numeric info in dump if symbolic info is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:55,Integrability,Wrap,Wrappers,55,"//===- llvm/Bitcode/BitcodeConvenience.h - Convenience Wrappers -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file Convenience wrappers for the LLVM bitcode format and bitstream APIs.; ///; /// This allows you to use a sort of DSL to declare and use bitcode; /// abbreviations and records. Example:; ///; /// \code; /// using Metadata = BCRecordLayout<; /// METADATA_ID, // ID; /// BCFixed<16>, // Module format major version; /// BCFixed<16>, // Module format minor version; /// BCBlob // misc. version information; /// >;; /// Metadata metadata(Out);; /// metadata.emit(ScratchRecord, VERSION_MAJOR, VERSION_MINOR, Data);; /// \endcode; ///; /// For details on the bitcode format, see; /// http://llvm.org/docs/BitCodeFormat.html; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:403,Integrability,wrap,wrappers,403,"//===- llvm/Bitcode/BitcodeConvenience.h - Convenience Wrappers -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file Convenience wrappers for the LLVM bitcode format and bitstream APIs.; ///; /// This allows you to use a sort of DSL to declare and use bitcode; /// abbreviations and records. Example:; ///; /// \code; /// using Metadata = BCRecordLayout<; /// METADATA_ID, // ID; /// BCFixed<16>, // Module format major version; /// BCFixed<16>, // Module format minor version; /// BCBlob // misc. version information; /// >;; /// Metadata metadata(Out);; /// metadata.emit(ScratchRecord, VERSION_MAJOR, VERSION_MINOR, Data);; /// \endcode; ///; /// For details on the bitcode format, see; /// http://llvm.org/docs/BitCodeFormat.html; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:4,Testability,Assert,Asserts,4,/// Asserts that the given data is a valid value for this field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:365,Availability,down,down,365,"// namespace detail; /// Represents a literal operand in a bitcode record.; ///; /// The value of a literal operand is the same for all instances of the record,; /// so it is only emitted in the abbreviation definition.; ///; /// Note that because this uses a compile-time template, you cannot have a; /// literal operand that is fixed at run-time without dropping down to the; /// raw LLVM APIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:17,Modifiability,variab,variable-width,17,/// Represents a variable-width value in a bitcode record.; ///; /// The \p Width parameter should include the continuation bit.; ///; /// Note that the LLVM bitcode format only supports unsigned values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:9,Security,validat,validate,9,// TODO: validate array data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:76,Security,access,accessor,76,/// Blob data is not stored in the buffer if you are using the correct; /// accessor; this method should not be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:403,Integrability,interface,interfaces,403,"//===- llvm/Bitcode/BitcodeReader.h - Bitcode reader ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines interfaces to read LLVM bitcode files/streams.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:47,Availability,Error,Error,47,// These functions are for converting Expected/Error values to; // ErrorOr/std::error_code for compatibility with legacy clients. FIXME:; // Remove these functions once no longer needed by the C and libLTO APIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:67,Availability,Error,ErrorOr,67,// These functions are for converting Expected/Error values to; // ErrorOr/std::error_code for compatibility with legacy clients. FIXME:; // Remove these functions once no longer needed by the C and libLTO APIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:201,Deployability,upgrade,upgrade,201,"/// The ValueType callback is called for every function definition or; /// declaration and allows accessing the type information, also behind; /// pointers. This can be useful, when the opaque pointer upgrade cleans all; /// type information behind pointers.; /// The second argument to ValueTypeCallback is the type ID of the; /// function, the two passed functions can be used to extract type; /// information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:98,Security,access,accessing,98,"/// The ValueType callback is called for every function definition or; /// declaration and allows accessing the type information, also behind; /// pointers. This can be useful, when the opaque pointer upgrade cleans all; /// type information behind pointers.; /// The second argument to ValueTypeCallback is the type ID of the; /// function, the two passed functions can be used to extract type; /// information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:132,Performance,load,load,132,"/// Read the bitcode module and prepare for lazy deserialization of function; /// bodies. If ShouldLazyLoadMetadata is true, lazily load metadata as well.; /// If IsImporting is true, this module is being parsed for ThinLTO; /// importing into another module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:161,Performance,load,load,161,"/// Read the header of the specified bitcode buffer and prepare for lazy; /// deserialization of function bodies. If ShouldLazyLoadMetadata is true,; /// lazily load metadata as well. If IsImporting is true, this module is; /// being parsed for ThinLTO importing into another module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:153,Availability,error,error,153,"/// Like getLazyBitcodeModule, except that the module takes ownership of; /// the memory buffer if successful. If successful, this moves Buffer. On; /// error, this *does not* move Buffer. If IsImporting is true, this module is; /// being parsed for ThinLTO importing into another module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:139,Availability,error,error,139,"/// Read the header of the specified bitcode buffer and extract just the; /// triple information. If successful, this returns a string. On error, this; /// returns """".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:153,Availability,error,error,153,"/// Read the header of the specified bitcode buffer and extract just the; /// producer string information. If successful, this returns a string. On; /// error, this returns """".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:102,Integrability,wrap,wrapper,102,/// isBitcodeWrapper - Return true if the given bytes are the magic bytes; /// for an LLVM IR bitcode wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:34,Integrability,message,message,34,// See if you can find the hidden message in the magic bytes :-).; // (Hint: it's a little-endian encoding.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:110,Integrability,wrap,wrapper,110,/// isRawBitcode - Return true if the given bytes are the magic bytes for; /// raw LLVM IR bitcode (without a wrapper).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:109,Availability,redundant,redundant,109,"// These bytes sort of have a hidden message, but it's not in; // little-endian this time, and it's a little redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:37,Integrability,message,message,37,"// These bytes sort of have a hidden message, but it's not in; // little-endian this time, and it's a little redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:109,Safety,redund,redundant,109,"// These bytes sort of have a hidden message, but it's not in; // little-endian this time, and it's a little redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:118,Integrability,wrap,wrapper,118,"/// isBitcode - Return true if the given bytes are the magic bytes for; /// LLVM IR bitcode, either with or without a wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:548,Availability,down,down,548,"/// SkipBitcodeWrapperHeader - Some systems wrap bc files with a special; /// header for padding or other reasons. The format of this header is:; ///; /// struct bc_header {; /// uint32_t Magic; // 0x0B17C0DE; /// uint32_t Version; // Version, currently always 0.; /// uint32_t BitcodeOffset; // Offset to traditional bitcode file.; /// uint32_t BitcodeSize; // Size of traditional bitcode file.; /// ... potentially other gunk ...; /// };; ///; /// This function is called when we find a file with a matching magic number.; /// In this case, skip down to the subsection of the file that is actually a; /// BC file.; /// If 'VerifyBufferSize' is true, check that the buffer is large enough to; /// contain the whole bitcode file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:44,Integrability,wrap,wrap,44,"/// SkipBitcodeWrapperHeader - Some systems wrap bc files with a special; /// header for padding or other reasons. The format of this header is:; ///; /// struct bc_header {; /// uint32_t Magic; // 0x0B17C0DE; /// uint32_t Version; // Version, currently always 0.; /// uint32_t BitcodeOffset; // Offset to traditional bitcode file.; /// uint32_t BitcodeSize; // Size of traditional bitcode file.; /// ... potentially other gunk ...; /// };; ///; /// This function is called when we find a file with a matching magic number.; /// In this case, skip down to the subsection of the file that is actually a; /// BC file.; /// If 'VerifyBufferSize' is true, check that the buffer is large enough to; /// contain the whole bitcode file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:403,Integrability,interface,interfaces,403,"//===- llvm/Bitcode/BitcodeWriter.h - Bitcode writers -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines interfaces to write LLVM bitcode files/streams.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:270,Performance,perform,performance,270,"/// Attempt to write a symbol table to the bitcode file. This must be called; /// at most once after all modules have been written.; ///; /// A reader does not require a symbol table to interpret a bitcode file;; /// the symbol table is needed only to improve link-time performance. So; /// this function may decide not to write a symbol table. It may so decide; /// if, for example, the target is unregistered or the IR is malformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:360,Performance,optimiz,optimization,360,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:409,Security,hash,hashing,409,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:446,Security,hash,hash,446,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:604,Security,hash,hash,604,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:693,Security,hash,hash,693,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:791,Security,hash,hash,791,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:440,Performance,optimiz,optimization,440,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:489,Security,hash,hashing,489,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:526,Security,hash,hash,526,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:684,Security,hash,hash,684,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:773,Security,hash,hash,773,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:871,Security,hash,hash,871,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:132,Availability,avail,available,132,"/// If EmbedBitcode is set, save a copy of the llvm IR as data in the; /// __LLVM,__bitcode section (.llvmbc on non-MacOS).; /// If available, pass the serialized module via the Buf parameter. If not,; /// pass an empty (default-initialized) MemoryBufferRef, and the serialization; /// will be handled by this API. The same behavior happens if the provided Buf; /// is not bitcode (i.e. if it's invalid data or even textual LLVM assembly).; /// If EmbedCmdline is set, the command line is also exported in; /// the corresponding section (__LLVM,_cmdline / .llvmcmd) - even if CmdArgs; /// were empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriterPass.h:277,Performance,optimiz,optimization,277,"/// Construct a bitcode writer pass around a particular output stream.; ///; /// If \c ShouldPreserveUseListOrder, encode use-list order so it can be; /// reproduced when deserialized.; ///; /// If \c EmitSummaryIndex, emit the summary index (currently; /// for use in ThinLTO optimization).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriterPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriterPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:103,Availability,error,error,103,// Block intended to contains information on the bitcode versioning.; // Can be used to provide better error messages when we fail to parse a; // bitcode file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:109,Integrability,message,messages,109,// Block intended to contains information on the bitcode versioning.; // Can be used to provide better error messages when we fail to parse a; // bitcode file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:120,Deployability,upgrade,upgrade,120,"/// Identification block contains a string that describes the producer details,; /// and an epoch that defines the auto-upgrade capability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:36,Deployability,upgrade,upgrade,36,"/// The epoch that defines the auto-upgrade compatibility for the bitcode.; ///; /// LLVM guarantees in a major release that a minor release can read bitcode; /// generated by previous minor releases. We translate this by making the reader; /// accepting only bitcode with the same epoch, except for the X.0 release which; /// also accepts N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:112,Deployability,release,release,112,"/// The epoch that defines the auto-upgrade compatibility for the bitcode.; ///; /// LLVM guarantees in a major release that a minor release can read bitcode; /// generated by previous minor releases. We translate this by making the reader; /// accepting only bitcode with the same epoch, except for the X.0 release which; /// also accepts N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:133,Deployability,release,release,133,"/// The epoch that defines the auto-upgrade compatibility for the bitcode.; ///; /// LLVM guarantees in a major release that a minor release can read bitcode; /// generated by previous minor releases. We translate this by making the reader; /// accepting only bitcode with the same epoch, except for the X.0 release which; /// also accepts N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:191,Deployability,release,releases,191,"/// The epoch that defines the auto-upgrade compatibility for the bitcode.; ///; /// LLVM guarantees in a major release that a minor release can read bitcode; /// generated by previous minor releases. We translate this by making the reader; /// accepting only bitcode with the same epoch, except for the X.0 release which; /// also accepts N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:308,Deployability,release,release,308,"/// The epoch that defines the auto-upgrade compatibility for the bitcode.; ///; /// LLVM guarantees in a major release that a minor release can read bitcode; /// generated by previous minor releases. We translate this by making the reader; /// accepting only bitcode with the same epoch, except for the X.0 release which; /// also accepts N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:3,Security,HASH,HASH,3,// HASH: [5*i32],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:25,Testability,test,test,25,// The list of llvm.type.test type identifiers used by the following function; // that are used other than by an llvm.assume.; // [n x typeid],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:83,Testability,test,test,83,"// The list of virtual calls made by this function using; // llvm.assume(llvm.type.test) intrinsics that do not have all constant; // integer arguments.; // [n x (typeid, offset)]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:79,Performance,load,load,79,"// The list of virtual calls made by this function using; // llvm.type.checked.load intrinsics that do not have all constant integer; // arguments.; // [n x (typeid, offset)]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:86,Testability,test,test,86,"// Identifies a virtual call made by this function using an; // llvm.assume(llvm.type.test) intrinsic with all constant integer arguments.; // [typeid, offset, n x arg]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:82,Performance,load,load,82,"// Identifies a virtual call made by this function using an; // llvm.type.checked.load intrinsic with all constant integer arguments.; // [typeid, offset, n x arg]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:13,Usability,GUID,GUID,13,"// Assigns a GUID to a value ID. This normally appears only in combined; // summaries, but it can also appear in per-module summaries for PGO data.; // [valueid, guid]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:162,Usability,guid,guid,162,"// Assigns a GUID to a value ID. This normally appears only in combined; // summaries, but it can also appear in per-module summaries for PGO data.; // [valueid, guid]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:25,Security,access,accessed,25,"// Range information for accessed offsets for every argument.; // [n x (paramno, range, numcalls, numcalls x (callee_guid, paramno, range))]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:35,Security,checksum,checksumkind,35,"// [distinct, filename, directory, checksumkind, checksum]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:49,Security,checksum,checksum,49,"// [distinct, filename, directory, checksumkind, checksum]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:27,Modifiability,variab,variable,27,"// [distinct, scope, name, variable,...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:3,Performance,LOAD,LOAD,3,"// LOAD: [opty, op, align, vol]; // 21 is unused.; // 22 is unused.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:142,Availability,avail,available,142,"// VAARG: [valistty, valist, instty]; // This store code encodes the pointer type, rather than the value type; // this is so information only available in the pointer type (e.g. address; // spaces) is retained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:3,Usability,RESUME,RESUME,3,// RESUME: [opval],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:3,Performance,LOAD,LOAD,3,"// LOAD: [opty, op, align, vol,; // ordering, synchscope]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodeEnums.h:46,Integrability,wrap,wrapper,46,/// Offsets of the 32-bit fields of bitstream wrapper header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodeEnums.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodeEnums.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodeEnums.h:111,Availability,avail,available,111,"/// BLOCKINFO_BLOCK is used to define metadata about blocks, for example,; /// standard abbrevs that should be available to all blocks of a specified; /// ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodeEnums.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodeEnums.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h:3,Security,Access,Accessors,3,// Accessors for literals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h:3,Security,Access,Accessors,3,// Accessors for encoding info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h:120,Safety,redund,redundancy,120,"/// BitCodeAbbrev - This class represents an abbreviation record. An; /// abbreviation allows a complex record that has redundancy to be stored in a; /// specialized format instead of the fully-general, fully-vbr, format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:54,Integrability,interface,interface,54,"//===- BitstreamReader.h - Low-level bitstream reader interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the BitstreamReader class. This class can be used to; // read an arbitrary bitstream, regardless of its contents.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:135,Modifiability,inherit,inherit,135,/// This contains information emitted to BLOCKINFO_BLOCK blocks. These; /// describe abbreviations that all blocks of the specified ID inherit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:9,Availability,mask,mask,9,// Use a mask to avoid undefined behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:17,Safety,avoid,avoid,17,// Use a mask to avoid undefined behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:26,Safety,abort,abort,26,"// If we run out of data, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:9,Availability,mask,mask,9,// Use a mask to avoid undefined behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:17,Safety,avoid,avoid,17,// Use a mask to avoid undefined behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:83,Usability,Simpl,SimpleBitstreamCursor,83,"/// This represents a position within a bitcode file, implemented on top of a; /// SimpleBitstreamCursor.; ///; /// Unlike iterators, BitstreamCursors are heavy-weight objects that should not; /// be passed by value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:12,Deployability,install,installed,12,/// Abbrevs installed at in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:65,Availability,error,error,65,"/// Read and return a block info block from the bitstream. If an error was; /// encountered, return std::nullopt.; ///; /// \param ReadBlockInfoNames Whether to read block/record name information in; /// the BlockInfo block. Only llvm-bcanalyzer uses this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:54,Integrability,interface,interface,54,"//===- BitstreamWriter.h - Low-level bitstream writer interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the BitstreamWriter class. This class can be used to; // write an arbitrary bitstream, regardless of its contents.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:25,Deployability,install,installed,25,/// CurAbbrevs - Abbrevs installed at in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:147,Modifiability,inherit,inherit,147,/// BlockInfo - This contains information emitted to BLOCKINFO_BLOCK blocks.; /// These describe abbreviations that all blocks of the specified ID inherit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:16,Deployability,update,update,16,// Copy data to update into Bytes from the file FS and the buffer Out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:107,Deployability,update,updated,107,"// When unaligned, copy existing data into Bytes from the file FS and the; // buffer Out so that it can be updated before writing. For debug builds; // read bytes unconditionally in order to check that the existing value is 0; // as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:3,Deployability,Update,Update,3,// Update Bytes in terms of bit offset and value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:8,Deployability,update,updated,8,// Copy updated data back to the file FS and the buffer Out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:3,Deployability,Update,Update,3,// Update the block size field in the header of this sub-block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:39,Testability,assert,assertion,39,// Know that blob data is consumed for assertion below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:245,Integrability,rout,routine,245,"/// EmitRecordWithBlob - Emit the specified record to the stream, using an; /// abbrev that includes a blob at the end. The blob data to emit is; /// specified by the pointer and length specified at the end. In contrast to; /// EmitRecord, this routine expects that the first entry in Vals is the code; /// of the record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:2338,Modifiability,parameteriz,parameterized,2338,"/ section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; /// |------------------|; /// | ENTRY POOL |; /// `------------------'; ///; /// For the full documentation please refer to the DWARF 5 standard.; ///; ///; /// This file defines the class template AccelTable, which is represents an; /// abstract view of an Accelerator table, without any notion of an on-disk; /// layout. This class is parameterized by an entry type, which should derive; /// from AccelTableData. This is the type of individual entries in the table,; /// and it should store the data necessary to emit them. AppleAccelTableData is; /// the base class for Apple Accelerator Table entries, which have a uniform; /// structure based on a sequence of Atoms. There are different sub-classes; /// derived from AppleAccelTable, which differ in the set of Atoms and how they; /// obtain their values.; ///; /// An Apple Accelerator Table can be serialized by calling emitAppleAccelTable; /// function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:81,Performance,optimiz,optimized,81,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:70,Security,hash,hash,70,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:124,Security,access,access,124,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:505,Security,HASH,HASHES,505,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:686,Security,hash,hash,686,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:745,Security,hash,hashes,745,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:884,Security,hash,hashes,884,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:902,Security,hash,hashes,902,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:949,Security,hash,hash,949,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:1061,Security,hash,hash,1061,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:1108,Security,hash,hash,1108,"to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; /// |------------------|; /// | ENTRY POOL |; /// `------------------'; ///; /// For the full documentation please refer to the DW",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:1259,Security,hash,hashes,1259,"e Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; /// |------------------|; /// | ENTRY POOL |; /// `------------------'; ///; /// For the full documentation please refer to the DWARF 5 standard.; ///; ///; /// This file defines the class template AccelTable, which is represents an; /// abstract view of an Accelerator table, without any notio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:1300,Security,hash,hash,1300,"e Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; /// |------------------|; /// | ENTRY POOL |; /// `------------------'; ///; /// For the full documentation please refer to the DWARF 5 standard.; ///; ///; /// This file defines the class template AccelTable, which is represents an; /// abstract view of an Accelerator table, without any notio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:1325,Security,hash,hash,1325,"e Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; /// |------------------|; /// | ENTRY POOL |; /// `------------------'; ///; /// For the full documentation please refer to the DWARF 5 standard.; ///; ///; /// This file defines the class template AccelTable, which is represents an; /// abstract view of an Accelerator table, without any notio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:1893,Security,HASH,HASH,1893,"/ section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; /// |------------------|; /// | ENTRY POOL |; /// `------------------'; ///; /// For the full documentation please refer to the DWARF 5 standard.; ///; ///; /// This file defines the class template AccelTable, which is represents an; /// abstract view of an Accelerator table, without any notion of an on-disk; /// layout. This class is parameterized by an entry type, which should derive; /// from AccelTableData. This is the type of individual entries in the table,; /// and it should store the data necessary to emit them. AppleAccelTableData is; /// the base class for Apple Accelerator Table entries, which have a uniform; /// structure based on a sequence of Atoms. There are different sub-classes; /// derived from AppleAccelTable, which differ in the set of Atoms and how they; /// obtain their values.; ///; /// An Apple Accelerator Table can be serialized by calling emitAppleAccelTable; /// function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:4,Integrability,Interface,Interface,4,/// Interface which the different types of accelerator table data have to; /// conform. It serves as a base class for different values of the template; /// argument of the AccelTable class template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:52,Security,hash,hash,52,// Subclasses should implement:; // static uint32_t hash(StringRef Name);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:38,Integrability,depend,dependant,38,/// A base class holding non-template-dependant functionality of the AccelTable; /// class. Clients should not use this class directly but rather instantiate; /// AccelTable with a type derived from AccelTableData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:66,Security,hash,hash,66,"/// Represents a group of entries with identical name (and hence, hash value).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:18,Security,Hash,HashData,18,/// Allocator for HashData and Values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:188,Modifiability,parameteriz,parameterized,188,"/// This class holds an abstract representation of an Accelerator Table,; /// consisting of a sequence of buckets, each bucket containint a sequence of; /// HashData entries. The class is parameterized by the type of entries it; /// holds. The type template parameter also defines the hash function to use for; /// hashing names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:157,Security,Hash,HashData,157,"/// This class holds an abstract representation of an Accelerator Table,; /// consisting of a sequence of buckets, each bucket containint a sequence of; /// HashData entries. The class is parameterized by the type of entries it; /// holds. The type template parameter also defines the hash function to use for; /// hashing names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:285,Security,hash,hash,285,"/// This class holds an abstract representation of an Accelerator Table,; /// consisting of a sequence of buckets, each bucket containint a sequence of; /// HashData entries. The class is parameterized by the type of entries it; /// holds. The type template parameter also defines the hash function to use for; /// hashing names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:315,Security,hash,hashing,315,"/// This class holds an abstract representation of an Accelerator Table,; /// consisting of a sequence of buckets, each bucket containint a sequence of; /// HashData entries. The class is parameterized by the type of entries it; /// holds. The type template parameter also defines the hash function to use for; /// hashing names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:160,Modifiability,variab,variable,160,/// A base class for different implementations of Data classes for Apple; /// Accelerator Tables. The columns in the table are defined by the static Atoms; /// variable defined on the subclasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:127,Integrability,wrap,wrapper,127,"/// The Data class implementation for DWARF v5 accelerator table. Unlike the; /// Apple Data classes, this class is just a DIE wrapper, and does not know to; /// serialize itself. The complete serialization logic is in the; /// emitDWARF5AccelTable function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:207,Testability,log,logic,207,"/// The Data class implementation for DWARF v5 accelerator table. Unlike the; /// Apple Data classes, this class is just a DIE wrapper, and does not know to; /// serialize itself. The complete serialization logic is in the; /// emitDWARF5AccelTable function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:46,Usability,simpl,simple,46,/// Accelerator table data implementation for simple Apple accelerator tables; /// with just a DIE reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:46,Usability,simpl,simple,46,/// Accelerator table data implementation for simple Apple accelerator tables; /// with a DIE offset but no actual DIE pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:186,Energy Efficiency,schedul,scheduled,186,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:57,Performance,optimiz,optimized,57,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:4,Testability,Test,Test,4,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:257,Testability,test,tests,257,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:181,Performance,optimiz,optimizations,181,"/// Test if given that the input instruction is in the tail call position, if; /// there is an attribute mismatch between the caller and the callee that will; /// inhibit tail call optimizations.; /// \p AllowDifferingSizes is an output parameter which, if forming a tail call; /// is permitted, determines whether it's permitted only if the size of the; /// caller's and callee's return types match exactly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:4,Testability,Test,Test,4,"/// Test if given that the input instruction is in the tail call position, if; /// there is an attribute mismatch between the caller and the callee that will; /// inhibit tail call optimizations.; /// \p AllowDifferingSizes is an output parameter which, if forming a tail call; /// is permitted, determines whether it's permitted only if the size of the; /// caller's and callee's return types match exactly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:160,Performance,optimiz,optimization,160,/// Test if given that the input instruction is in the tail call position if the; /// return type or any attributes of the function will inhibit tail call; /// optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:4,Testability,Test,Test,4,/// Test if given that the input instruction is in the tail call position if the; /// return type or any attributes of the function will inhibit tail call; /// optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:516,Energy Efficiency,schedul,scheduling,516,"//===- llvm/CodeGen/AntiDepBreaker.h - Anti-Dependence Breaking -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AntiDepBreaker class, which implements; // anti-dependence breaking heuristics for post-register-allocation scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:44,Integrability,Depend,Dependence,44,"//===- llvm/CodeGen/AntiDepBreaker.h - Anti-Dependence Breaking -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AntiDepBreaker class, which implements; // anti-dependence breaking heuristics for post-register-allocation scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:456,Integrability,depend,dependence,456,"//===- llvm/CodeGen/AntiDepBreaker.h - Anti-Dependence Breaking -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AntiDepBreaker class, which implements; // anti-dependence breaking heuristics for post-register-allocation scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:53,Energy Efficiency,schedul,scheduler,53,/// This class works in conjunction with the post-RA scheduler to rename; /// registers to break register anti-dependencies (WAR hazards).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:111,Integrability,depend,dependencies,111,/// This class works in conjunction with the post-RA scheduler to rename; /// registers to break register anti-dependencies (WAR hazards).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:129,Safety,hazard,hazards,129,/// This class works in conjunction with the post-RA scheduler to rename; /// registers to break register anti-dependencies (WAR hazards).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:19,Integrability,depend,dependencies,19,/// Identifiy anti-dependencies within a basic-block region and break them by; /// renaming registers. Return the number of anti-dependencies broken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:129,Integrability,depend,dependencies,129,/// Identifiy anti-dependencies within a basic-block region and break them by; /// renaming registers. Return the number of anti-dependencies broken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:4,Deployability,Update,Update,4,"/// Update liveness information to account for the current; /// instruction, which will not be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:95,Energy Efficiency,schedul,scheduled,95,"/// Update liveness information to account for the current; /// instruction, which will not be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:4,Deployability,Update,Update,4,/// Update DBG_VALUE or DBG_PHI if dependency breaker is updating; /// other machine instruction to use NewReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:35,Integrability,depend,dependency,35,/// Update DBG_VALUE or DBG_PHI if dependency breaker is updating; /// other machine instruction to use NewReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:4,Deployability,Update,Update,4,/// Update all DBG_VALUE instructions that may be affected by the dependency; /// breaker's update of ParentMI to use NewReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:92,Deployability,update,update,92,/// Update all DBG_VALUE instructions that may be affected by the dependency; /// breaker's update of ParentMI to use NewReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:66,Integrability,depend,dependency,66,/// Update all DBG_VALUE instructions that may be affected by the dependency; /// breaker's update of ParentMI to use NewReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:94,Energy Efficiency,Schedul,ScheduleDAGInstrs,94,// The following code is dependent on the order in which the DbgValues are; // constructed in ScheduleDAGInstrs::buildSchedGraph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:25,Integrability,depend,dependent,25,// The following code is dependent on the order in which the DbgValues are; // constructed in ScheduleDAGInstrs::buildSchedGraph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:4,Performance,Optimiz,Optimization,4,/// Optimization remark emitter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:59,Modifiability,extend,extended,59,/// struct HandlerInfo and Handlers permit users or target extended; /// AsmPrinter to add their own handlers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:161,Security,access,accessed,161,/// Return the symbol to be used for the specified basic block when its; /// address is taken. This cannot be its normal LBB label because the block; /// may be accessed outside its containing function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:276,Integrability,depend,depending,276,"// The table will contain these structs that point to the sled, the function; // containing the sled, and what kind of sled (and whether they should always; // be instrumented). We also use a version identifier that the runtime can use; // to decide what to do with the sled, depending on the version of the sled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:9,Availability,down,down,9,"/// Shut down the asmprinter. If you override this in your pass, you must make; /// sure to call it explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:108,Integrability,rout,routines,108,//===------------------------------------------------------------------===//; // Coarse grained IR lowering routines.; //===------------------------------------------------------------------===//; /// This should be called when a new MachineFunction is being processed from; /// runOnMachineFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:193,Security,sanitiz,sanitizers,193,"/// Since emitting CFI unwind information is entangled with supporting the; /// exceptions, this returns true for platforms which use CFI unwind; /// information for other purposes (debugging, sanitizers, ...) when; /// `MCAsmInfo::ExceptionsType == ExceptionHandling::None`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:30,Modifiability,variab,variable,30,/// Emit the specified global variable to the .s file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:49,Energy Efficiency,power,power,49,"/// Emit an alignment directive to the specified power of two boundary. If a; /// global value is specified, and if that global has an explicit alignment; /// requested, it will override the alignment request if required for; /// correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:113,Modifiability,variab,variable,113,"/// Print a general LLVM constant to the .s file.; /// On AIX, when an alias refers to a sub-element of a global variable, the; /// label of that alias needs to be emitted before the corresponding element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:28,Modifiability,variab,variables,28,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:89,Modifiability,variab,variable,89,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:116,Modifiability,variab,variable,116,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:411,Modifiability,variab,variables,411,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:224,Performance,optimiz,optimization,224,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:422,Safety,avoid,avoid,422,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:251,Security,access,accesses,251,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:520,Security,access,accesses,520,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:97,Integrability,Rout,Routines,97,//===------------------------------------------------------------------===//; // Symbol Lowering Routines.; //===------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:97,Integrability,Rout,Routines,97,//===------------------------------------------------------------------===//; // Emission Helper Routines.; //===------------------------------------------------------------------===//; /// This is just convenient handler for printing offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:175,Availability,avail,available,175,"/// Emit something like "".long Hi-Lo"" where the size in bytes of the directive; /// is specified by Size and Hi/Lo specify the labels. This implicitly uses; /// .set if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:183,Availability,avail,available,183,"/// Emit something like "".long Label+Offset"" where the size in bytes of the; /// directive is specified by Size and Label specifies the label. This; /// implicitly uses .set if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:103,Integrability,Rout,Routines,103,"//===------------------------------------------------------------------===//; // Dwarf Emission Helper Routines; //===------------------------------------------------------------------===//; /// Emit a .byte 42 directive that corresponds to an encoding. If verbose; /// assembly output is enabled, we output comments describing the encoding.; /// Desc is a string saying what the encoding is specifying (e.g. ""LSDA"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:298,Integrability,depend,depends,298,"/// Emit the 4- or 8-byte offset of a string from the start of its section.; ///; /// When possible, emit a DwarfStringPool section offset without any; /// relocations, and without using the symbol. Otherwise, defers to \a; /// emitDwarfSymbolReference().; ///; /// The length of the emitted value depends on the DWARF format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:78,Integrability,depend,depending,78,"/// Emit something like "".long Label + Offset"" or "".quad Label + Offset""; /// depending on the DWARF format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:29,Integrability,depend,depending,29,/// Emit 32- or 64-bit value depending on the DWARF format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:96,Integrability,Rout,Routines,96,//===------------------------------------------------------------------===//; // Dwarf Lowering Routines; //===------------------------------------------------------------------===//; /// Emit frame instruction to describe the layout of the frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:97,Integrability,Rout,Routines,97,"//===------------------------------------------------------------------===//; // CodeView Helper Routines; //===------------------------------------------------------------------===//; /// Gets information required to create a CodeView debug symbol for a jump; /// table.; /// Return value is <Base Address, Base Offset, Branch Address, Entry Size>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:494,Modifiability,portab,portably,494,"//===------------------------------------------------------------------===//; // Inline Asm Support; //===------------------------------------------------------------------===//; // These are hooks that targets can override to implement inline asm; // support. These should probably be moved out of AsmPrinter someday.; /// Print information related to the specified machine instr that is; /// independent of the operand, and may be independent of the instr itself.; /// This can be useful for portably encoding the comment character or other; /// bits of target-specific knowledge into the asmstrings. The syntax used is; /// ${:comment}. Targets can override this to add support for their own; /// strange codes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinterHandler.h:412,Integrability,interface,interface,412,"//===-- llvm/CodeGen/AsmPrinterHandler.h -----------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a generic interface for AsmPrinter handlers,; // like debug and EH info emitters.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinterHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinterHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:9,Integrability,wrap,wrapper,9,/// Type wrapper for integer ID for Variables. 0 is reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:36,Modifiability,Variab,Variables,36,/// Type wrapper for integer ID for Variables. 0 is reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:4,Modifiability,Variab,Variable,4,/// Variable location definition used by FunctionVarLocs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:34,Modifiability,variab,variable,34,/// Data structure describing the variable locations in a function. Used as the; /// result of the AssignmentTrackingAnalysis pass. Essentially read-only; /// outside of AssignmentTrackingAnalysis where it is built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:20,Modifiability,Variab,VariableID,20,/// Maps VarLocInfo.VariableID to a DebugVariable for VarLocRecords.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:12,Modifiability,variab,variable,12,/// List of variable location changes grouped by the instruction the; /// change occurs before (see VarLocsBeforeInst). The elements from; /// zero to SingleVarLocEnd represent variables with a single location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:177,Modifiability,variab,variables,177,/// List of variable location changes grouped by the instruction the; /// change occurs before (see VarLocsBeforeInst). The elements from; /// zero to SingleVarLocEnd represent variables with a single location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:49,Modifiability,variab,variables,49,/// End of range of VarLocRecords that represent variables with a single; /// location that is valid for the entire scope. Range starts at 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:38,Modifiability,variab,variable,38,/// Return the DILocalVariable of the variable represented by \p ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:53,Modifiability,variab,variable,53,///@name iterators; ///@{; /// First single-location variable location definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:38,Modifiability,variab,variable,38,/// One past the last single-location variable location definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:10,Modifiability,variab,variable,10,/// First variable location definition that comes before \p Before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:22,Modifiability,variab,variable,22,/// One past the last variable location definition that comes before \p; /// Before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:77,Performance,load,loaded,77,"/// Parameters (see the expansion example below):; /// (the builder, %addr, %loaded, %new_val, ordering,; /// /* OUT */ %success, /* OUT */ %new_loaded)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:227,Availability,avail,available,227,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:333,Modifiability,rewrite,rewrite,333,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:714,Modifiability,Rewrite,RewriteAtomics,714,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:278,Performance,load,loads,278,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:879,Performance,load,load,879,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:938,Performance,load,loaded,938,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:1027,Performance,load,loaded,1027,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:1167,Performance,load,loaded,1167,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:587,Safety,avoid,avoid,587,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:623,Safety,avoid,avoiding,623,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h:29,Availability,error,error,29,// Returns a profile parsing error for the current line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h:113,Availability,avail,available,113,// Map from every function name in the module to its debug info filename or; // empty string if no debug info is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h:339,Performance,optimiz,optimized,339,"/// This checks if the source of this function has drifted since this binary was; /// profiled previously.; /// For now, we are piggy backing on what PGO does to; /// detect this with instrumented profiles. PGO emits an hash of the IR and; /// checks if the hash has changed. Advanced basic block layout is usually done; /// on top of PGO optimized binaries and hence this check works well in; /// practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h:167,Safety,detect,detect,167,"/// This checks if the source of this function has drifted since this binary was; /// profiled previously.; /// For now, we are piggy backing on what PGO does to; /// detect this with instrumented profiles. PGO emits an hash of the IR and; /// checks if the hash has changed. Advanced basic block layout is usually done; /// on top of PGO optimized binaries and hence this check works well in; /// practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h:220,Security,hash,hash,220,"/// This checks if the source of this function has drifted since this binary was; /// profiled previously.; /// For now, we are piggy backing on what PGO does to; /// detect this with instrumented profiles. PGO emits an hash of the IR and; /// checks if the hash has changed. Advanced basic block layout is usually done; /// on top of PGO optimized binaries and hence this check works well in; /// practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h:258,Security,hash,hash,258,"/// This checks if the source of this function has drifted since this binary was; /// profiled previously.; /// For now, we are piggy backing on what PGO does to; /// detect this with instrumented profiles. PGO emits an hash of the IR and; /// checks if the hash has changed. Advanced basic block layout is usually done; /// on top of PGO optimized binaries and hence this check works well in; /// practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:455,Integrability,interface,interface,455,"//===- BasicTTIImpl.h -------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides a helper that implements much of the TTI interface in; /// terms of the target-independent code generator and TargetLowering; /// interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:544,Integrability,interface,interfaces,544,"//===- BasicTTIImpl.h -------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides a helper that implements much of the TTI interface in; /// terms of the target-independent code generator and TargetLowering; /// interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:133,Integrability,interface,interface,133,"/// Base class which can be used to help build a TTI implementation.; ///; /// This class provides as much implementation of the TTI interface as is; /// possible using the target independent parts of the code generator.; ///; /// In order to subclass it, your class must implement a getST() method to; /// return the subtarget, and a getTLI() method to return the target lowering.; /// We need these methods implemented in the derived class so that this class; /// doesn't have to duplicate storage for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:23,Security,access,access,23,/// Helper function to access this as a T.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:164,Availability,mask,mask,164,"// Shuffle cost is equal to the cost of extracting element from its argument; // plus the cost of inserting them onto the result vector.; // e.g. <4 x float> has a mask of <0,5,2,7> i.e we need to extract from; // index 0 of first vector, index 1 of second vector,index 2 of first; // vector and finally index 3 of second vector and insert them at index; // <0,1,2,3> of result vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:23,Performance,scalab,scalable,23,"// We cannot scalarize scalable vectors, so return Invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:87,Availability,mask,masks,87,"// Compute the cost of conditionally executing the memory operations with; // variable masks. This includes extracting the individual conditions, a; // branches and PHIs to combine the results.; // NOTE: Estimating the cost of conditionally executing the memory; // operations accurately is quite difficult and the current solution; // provides a very rough estimate only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:78,Modifiability,variab,variable,78,"// Compute the cost of conditionally executing the memory operations with; // variable masks. This includes extracting the individual conditions, a; // branches and PHIs to combine the results.; // NOTE: Estimating the cost of conditionally executing the memory; // operations accurately is quite difficult and the current solution; // provides a very rough estimate only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:266,Testability,test,test,266,"/// Try to find the estimated number of clusters. Note that the number of; /// clusters identified in this function could be different from the actual; /// numbers found in lowering. This function ignore switches that are; /// lowered with a mix of jump table / bit test / BTree. This function was; /// initially intended to be used when estimating the cost of switch in; /// inline cost heuristic, but it's a generic cost model to be used in other; /// places (e.g., in loop unrolling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:43,Testability,test,test,43,// Early exit if both a jump table and bit test are not allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:31,Testability,test,test,31,// Check if suitable for a bit test,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:25,Availability,avail,available,25,"// Check whether FADD is available, as a proxy for floating-point in; // general.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:175,Performance,Optimiz,Optimization,175,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:290,Performance,queue,queue,290,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:593,Performance,Optimiz,Optimization,593,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:257,Safety,detect,detector,257,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:698,Safety,predict,predictor,698,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:1003,Testability,benchmark,benchmarking,1003,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:606,Usability,Guid,Guide,606,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:24,Performance,optimiz,optimizing,24,// Avoid unrolling when optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:3,Safety,Avoid,Avoid,3,// Avoid unrolling when optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:30,Performance,optimiz,optimized,30,"// Set number of instructions optimized when ""back edge""; // becomes ""fall through"" to default value of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:110,Performance,scalab,scalable,110,/// FIXME: a bitfield is not a reasonable abstraction for talking about; /// which elements are needed from a scalable vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:11,Integrability,wrap,wrapper,11,/// Helper wrapper for the DemandedElts variant of getScalarizationOverhead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:31,Usability,simpl,simple,31,"// Ensure we return a sensible simple VT here, since many callers of; // this function require it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:23,Performance,scalab,scalable,23,"// We cannot scalarize scalable vectors, so return Invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:71,Modifiability,extend,extending,71,"// If this is a zext/sext of a load, return 0 if the corresponding; // extending load exists on target and the result type is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:31,Performance,load,load,31,"// If this is a zext/sext of a load, return 0 if the corresponding; // extending load exists on target and the result type is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:81,Performance,load,load,81,"// If this is a zext/sext of a load, return 0 if the corresponding; // extending load exists on target and the result type is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:66,Usability,simpl,simple,66,"// If the cast is between same-sized registers, then the check is simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:44,Performance,load,loading,44,// Illegal bitcasts are done by storing and loading from a stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:7,Availability,Mask,Mask,7,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:62,Availability,Mask,Mask,62,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:184,Availability,mask,mask,184,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:240,Availability,mask,mask,240,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:271,Availability,mask,mask,271,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:399,Availability,mask,mask,399,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:429,Availability,mask,mask,429,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:500,Availability,mask,mask,500,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:21,Performance,load,loads,21,// Assuming that all loads of legal types cost 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:83,Modifiability,extend,extending,83,// In practice it's not currently possible to have a change in lane; // length for extending loads or truncating stores so both types should; // have the same scalable property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:93,Performance,load,loads,93,// In practice it's not currently possible to have a change in lane; // length for extending loads or truncating stores so both types should; // have the same scalable property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:159,Performance,scalab,scalable,159,// In practice it's not currently possible to have a change in lane; // length for extending loads or truncating stores so both types should; // have the same scalable property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:110,Modifiability,extend,extending,110,"// This is a vector load that legalizes to a larger type than the vector; // itself. Unless the corresponding extending load or truncating store is; // legal, then this will scalarize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:20,Performance,load,load,20,"// This is a vector load that legalizes to a larger type than the vector; // itself. Unless the corresponding extending load or truncating store is; // legal, then this will scalarize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:120,Performance,load,load,120,"// This is a vector load that legalizes to a larger type than the vector; // itself. Unless the corresponding extending load or truncating store is; // legal, then this will scalarize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:20,Performance,load,load,20,// This is a vector load/store for some illegal type that is scalarized.; // We must account for the cost of building or decomposing the vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:23,Performance,scalab,scalable,23,"// We cannot scalarize scalable vectors, so return Invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:24,Performance,load,load,24,"// Firstly, the cost of load/store operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:582,Availability,mask,masked,582,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:232,Performance,load,load,232,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:261,Performance,load,load,261,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:385,Performance,load,loads,385,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:406,Performance,load,loads,406,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:518,Performance,load,loads,518,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:589,Performance,load,loads,589,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:632,Performance,load,loads,632,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:17,Performance,load,loads,17,// The number of loads of a legal type it will take to represent a load; // of the unlegalized vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:67,Performance,load,load,67,// The number of loads of a legal type it will take to represent a load; // of the unlegalized vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:25,Performance,load,load,25,// Scale the cost of the load by the fraction of legal instructions that; // will be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:155,Performance,load,load,155,"// The interleave cost is similar to extract sub vectors' elements; // from the wide vector, and insert them into sub vectors.; //; // E.g. An interleaved load of factor 2 (with one member of index 0):; // %vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle %vec, undef, <0, 2, 4, 6> ; Index 0; // The cost is estimated as extract elements at 0, 2, 4, 6 from the; // <8 x i32> vector and insert them into a <4 x i32> vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:213,Performance,load,load,213,"// The interleave cost is similar to extract sub vectors' elements; // from the wide vector, and insert them into sub vectors.; //; // E.g. An interleaved load of factor 2 (with one member of index 0):; // %vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle %vec, undef, <0, 2, 4, 6> ; Index 0; // The cost is estimated as extract elements at 0, 2, 4, 6 from the; // <8 x i32> vector and insert them into a <4 x i32> vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:281,Availability,mask,mask,281,"// The interleave cost is extract elements from sub vectors, and; // insert them into the wide vector.; //; // E.g. An interleaved store of factor 3 with 2 members at indices 0,1:; // (using VF=4):; // %v0_v1 = shuffle %v0, %v1, <0,4,undef,1,5,undef,2,6,undef,3,7,undef>; // %gaps.mask = <true, true, false, true, true, false,; // true, true, false, true, true, false>; // call llvm.masked.store <12 x i32> %v0_v1, <12 x i32>* %ptr,; // i32 Align, <12 x i1> %gaps.mask; // The cost is estimated as extract all elements (of actual members,; // excluding gaps) from both <4 x i32> vectors and insert into the <12 x; // i32> vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:383,Availability,mask,masked,383,"// The interleave cost is extract elements from sub vectors, and; // insert them into the wide vector.; //; // E.g. An interleaved store of factor 3 with 2 members at indices 0,1:; // (using VF=4):; // %v0_v1 = shuffle %v0, %v1, <0,4,undef,1,5,undef,2,6,undef,3,7,undef>; // %gaps.mask = <true, true, false, true, true, false,; // true, true, false, true, true, false>; // call llvm.masked.store <12 x i32> %v0_v1, <12 x i32>* %ptr,; // i32 Align, <12 x i1> %gaps.mask; // The cost is estimated as extract all elements (of actual members,; // excluding gaps) from both <4 x i32> vectors and insert into the <12 x; // i32> vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:464,Availability,mask,mask,464,"// The interleave cost is extract elements from sub vectors, and; // insert them into the wide vector.; //; // E.g. An interleaved store of factor 3 with 2 members at indices 0,1:; // (using VF=4):; // %v0_v1 = shuffle %v0, %v1, <0,4,undef,1,5,undef,2,6,undef,3,7,undef>; // %gaps.mask = <true, true, false, true, true, false,; // true, true, false, true, true, false>; // call llvm.masked.store <12 x i32> %v0_v1, <12 x i32>* %ptr,; // i32 Align, <12 x i1> %gaps.mask; // The cost is estimated as extract all elements (of actual members,; // excluding gaps) from both <4 x i32> vectors and insert into the <12 x; // i32> vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:12,Availability,mask,mask,12,"// The Gaps mask is invariant and created outside the loop, therefore the; // cost of creating it is not accounted for here. However if we have both; // a MaskForGaps and some other mask that guards the execution of the; // memory access, we need to account for the cost of And-ing the two masks; // inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:155,Availability,Mask,MaskForGaps,155,"// The Gaps mask is invariant and created outside the loop, therefore the; // cost of creating it is not accounted for here. However if we have both; // a MaskForGaps and some other mask that guards the execution of the; // memory access, we need to account for the cost of And-ing the two masks; // inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:182,Availability,mask,mask,182,"// The Gaps mask is invariant and created outside the loop, therefore the; // cost of creating it is not accounted for here. However if we have both; // a MaskForGaps and some other mask that guards the execution of the; // memory access, we need to account for the cost of And-ing the two masks; // inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:290,Availability,mask,masks,290,"// The Gaps mask is invariant and created outside the loop, therefore the; // cost of creating it is not accounted for here. However if we have both; // a MaskForGaps and some other mask that guards the execution of the; // memory access, we need to account for the cost of And-ing the two masks; // inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:231,Security,access,access,231,"// The Gaps mask is invariant and created outside the loop, therefore the; // cost of creating it is not accounted for here. However if we have both; // a MaskForGaps and some other mask that guards the execution of the; // memory access, we need to account for the cost of And-ing the two masks; // inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:40,Performance,perform,performed,40,// The cost is modeled on the expansion performed by ExpandPowI in; // SelectionDAGBuilder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:30,Performance,scalab,scalable,30,// FIXME: Handle case where a scalable vector is extracted from a scalable; // vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:66,Performance,scalab,scalable,66,// FIXME: Handle case where a scalable vector is extracted from a scalable; // vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:30,Performance,scalab,scalable,30,// FIXME: Handle case where a scalable vector is inserted into a scalable; // vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:65,Performance,scalab,scalable,65,// FIXME: Handle case where a scalable vector is inserted into a scalable; // vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:49,Availability,mask,mask,49,// Non-vp version will have same Args/Tys except mask and vector length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot be scalarized, so return Invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot be scalarized, so return Invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:1187,Energy Efficiency,reduce,reduced,1187,"/// Try to calculate arithmetic and shuffle op costs for reduction intrinsics.; /// We're assuming that reduction operation are performing the following way:; ///; /// %val1 = shufflevector<n x t> %val, <n x t> %undef,; /// <n x i32> <i32 n/2, i32 n/2 + 1, ..., i32 n, i32 undef, ..., i32 undef>; /// \----------------v-------------/ \----------v------------/; /// n/2 elements n/2 elements; /// %red1 = op <n x t> %val, <n x t> val1; /// After this operation we have a vector %red1 where only the first n/2; /// elements are meaningful, the second n/2 elements are undefined and can be; /// dropped. All other operations are actually working with the vector of; /// length n/2, not n, though the real vector length is still n.; /// %val2 = shufflevector<n x t> %red1, <n x t> %undef,; /// <n x i32> <i32 n/4, i32 n/4 + 1, ..., i32 n/2, i32 undef, ..., i32 undef>; /// \----------------v-------------/ \----------v------------/; /// n/4 elements 3*n/4 elements; /// %red2 = op <n x t> %red1, <n x t> val2 - working with the vector of; /// length n/2, the resulting vector has length n/4 etc.; ///; /// The cost model should take into account that the actual length of the; /// vector is reduced on each iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:128,Performance,perform,performing,128,"/// Try to calculate arithmetic and shuffle op costs for reduction intrinsics.; /// We're assuming that reduction operation are performing the following way:; ///; /// %val1 = shufflevector<n x t> %val, <n x t> %undef,; /// <n x i32> <i32 n/2, i32 n/2 + 1, ..., i32 n, i32 undef, ..., i32 undef>; /// \----------------v-------------/ \----------v------------/; /// n/2 elements n/2 elements; /// %red1 = op <n x t> %val, <n x t> val1; /// After this operation we have a vector %red1 where only the first n/2; /// elements are meaningful, the second n/2 elements are undefined and can be; /// dropped. All other operations are actually working with the vector of; /// length n/2, not n, though the real vector length is still n.; /// %val2 = shufflevector<n x t> %red1, <n x t> %undef,; /// <n x i32> <i32 n/4, i32 n/4 + 1, ..., i32 n/2, i32 undef, ..., i32 undef>; /// \----------------v-------------/ \----------v------------/; /// n/4 elements 3*n/4 elements; /// %red2 = op <n x t> %red1, <n x t> val2 - working with the vector of; /// length n/2, the resulting vector has length n/4 etc.; ///; /// The cost model should take into account that the actual length of the; /// vector is reduced on each iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:50,Performance,scalab,scalable,50,"// Targets must implement a default value for the scalable case, since; // we don't know how many lanes the vector has.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:236,Integrability,depend,dependent,236,// The minimal length of the vector is limited by the real length of vector; // operations performed on the current platform. That's why several final; // reduction operations are performed on the vectors with the same; // architecture-dependent length.; // By default reductions need one shuffle per reduction level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:91,Performance,perform,performed,91,// The minimal length of the vector is limited by the real length of vector; // operations performed on the current platform. That's why several final; // reduction operations are performed on the vectors with the same; // architecture-dependent length.; // By default reductions need one shuffle per reduction level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:180,Performance,perform,performed,180,// The minimal length of the vector is limited by the real length of vector; // operations performed on the current platform. That's why several final; // reduction operations are performed on the vectors with the same; // architecture-dependent length.; // By default reductions need one shuffle per reduction level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:33,Performance,perform,performing,33,"/// Try to calculate the cost of performing strict (in-order) reductions,; /// which involves doing a sequence of floating point additions in lane; /// order, starting with an initial value. For example, consider a scalar; /// initial value 'InitVal' of type float and a vector of type <4 x float>:; ///; /// Vector = <float %v0, float %v1, float %v2, float %v3>; ///; /// %add1 = %InitVal + %v0; /// %add2 = %add1 + %v1; /// %add3 = %add2 + %v2; /// %add4 = %add3 + %v3; ///; /// As a simple estimate we can say the cost of such a reduction is 4 times; /// the cost of a scalar FP addition. We can only estimate the costs for; /// fixed-width vectors here because for scalable vectors we do not know the; /// runtime number of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:669,Performance,scalab,scalable,669,"/// Try to calculate the cost of performing strict (in-order) reductions,; /// which involves doing a sequence of floating point additions in lane; /// order, starting with an initial value. For example, consider a scalar; /// initial value 'InitVal' of type float and a vector of type <4 x float>:; ///; /// Vector = <float %v0, float %v1, float %v2, float %v3>; ///; /// %add1 = %InitVal + %v0; /// %add2 = %add1 + %v1; /// %add3 = %add2 + %v2; /// %add4 = %add3 + %v3; ///; /// As a simple estimate we can say the cost of such a reduction is 4 times; /// the cost of a scalar FP addition. We can only estimate the costs for; /// fixed-width vectors here because for scalable vectors we do not know the; /// runtime number of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:486,Usability,simpl,simple,486,"/// Try to calculate the cost of performing strict (in-order) reductions,; /// which involves doing a sequence of floating point additions in lane; /// order, starting with an initial value. For example, consider a scalar; /// initial value 'InitVal' of type float and a vector of type <4 x float>:; ///; /// Vector = <float %v0, float %v1, float %v2, float %v3>; ///; /// %add1 = %InitVal + %v0; /// %add2 = %add1 + %v1; /// %add3 = %add2 + %v2; /// %add4 = %add3 + %v3; ///; /// As a simple estimate we can say the cost of such a reduction is 4 times; /// the cost of a scalar FP addition. We can only estimate the costs for; /// fixed-width vectors here because for scalable vectors we do not know the; /// runtime number of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:50,Performance,scalab,scalable,50,"// Targets must implement a default value for the scalable case, since; // we don't know how many lanes the vector has.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:50,Performance,scalab,scalable,50,"// Targets must implement a default value for the scalable case, since; // we don't know how many lanes the vector has.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:234,Integrability,depend,dependent,234,// The minimal length of the vector is limited by the real length of vector; // operations performed on the current platform. That's why several final; // reduction opertions are perfomed on the vectors with the same; // architecture-dependent length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:91,Performance,perform,performed,91,// The minimal length of the vector is limited by the real length of vector; // operations performed on the current platform. That's why several final; // reduction opertions are perfomed on the vectors with the same; // architecture-dependent length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h:50,Integrability,depend,depending,50,"// The constant 25 instructions is added to avoid depending too much on; // accidental SlotIndex gaps for small intervals. The effect is that small; // intervals have a spill weight that is mostly proportional to the number; // of uses, while large intervals get a spill weight that is closer to a use; // density.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h:44,Safety,avoid,avoid,44,"// The constant 25 instructions is added to avoid depending too much on; // accidental SlotIndex gaps for small intervals. The effect is that small; // intervals have a spill weight that is mostly proportional to the number; // of uses, while large intervals get a spill weight that is closer to a use; // density.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:21,Modifiability,extend,extended,21,// The value is sign extended in the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:21,Modifiability,extend,extended,21,// The value is zero extended in the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:16,Modifiability,extend,extended,16,// The value is extended with undefined upper bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:73,Modifiability,extend,extended,73,// The value is in the upper bits of the location and should be; // sign extended when retrieved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:73,Modifiability,extend,extended,73,// The value is in the upper bits of the location and should be; // zero extended when retrieved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:68,Modifiability,extend,extended,68,// The value is in the upper bits of the location and should be; // extended with undefined upper bits when retrieved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:34,Modifiability,extend,extended,34,// The floating-point value is fp-extended in the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:223,Integrability,depend,dependent,223,// Holds one of:; // - the register that the value is assigned to;; // - the memory offset at which the value resides;; // - additional information about pending location; the exact interpretation; // of the data is target-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:210,Energy Efficiency,allocate,allocate,210,/// CCState - This class holds information needed while lowering arguments and; /// return values. It captures which registers are already assigned and which; /// stack slots are used. It provides accessors to allocate these values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:197,Security,access,accessors,197,/// CCState - This class holds information needed while lowering arguments and; /// return values. It captures which registers are already assigned and which; /// stack slots are used. It provides accessors to allocate these values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:31,Energy Efficiency,allocate,allocated,31,// True if arguments should be allocated at negative offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:18,Energy Efficiency,allocate,allocated,18,// First register allocated for current parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:29,Energy Efficiency,allocate,allocated,29,// First after last register allocated for current parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:38,Energy Efficiency,allocate,allocated,38,/// Returns the size of the currently allocated portion of the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:78,Energy Efficiency,allocate,allocated,78,/// isAllocated - Return true if the specified register (or an alias) is; /// allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:100,Performance,perform,performed,100,"/// CheckReturn - Analyze the return values of a function, returning; /// true if the return can be performed without sret-demotion, and; /// false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:13,Energy Efficiency,allocate,allocated,13,/// A shadow allocated register is a register that was allocated; /// but wasn't added to the location list (Locs).; /// \returns true if the register was allocated as shadow or false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:55,Energy Efficiency,allocate,allocated,55,/// A shadow allocated register is a register that was allocated; /// but wasn't added to the location list (Locs).; /// \returns true if the register was allocated as shadow or false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:155,Energy Efficiency,allocate,allocated,155,/// A shadow allocated register is a register that was allocated; /// but wasn't added to the location list (Locs).; /// \returns true if the register was allocated as shadow or false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:125,Energy Efficiency,allocate,allocated,125,"/// getFirstUnallocated - Return the index of the first unallocated register; /// in the set, or Regs.size() if they are all allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:65,Availability,avail,available,65,"/// AllocateReg - Attempt to allocate one register. If it is not available,; /// return zero. Otherwise, return the register, marking it and any aliases; /// as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:4,Energy Efficiency,Allocate,AllocateReg,4,"/// AllocateReg - Attempt to allocate one register. If it is not available,; /// return zero. Otherwise, return the register, marking it and any aliases; /// as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:29,Energy Efficiency,allocate,allocate,29,"/// AllocateReg - Attempt to allocate one register. If it is not available,; /// return zero. Otherwise, return the register, marking it and any aliases; /// as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:161,Energy Efficiency,allocate,allocated,161,"/// AllocateReg - Attempt to allocate one register. If it is not available,; /// return zero. Otherwise, return the register, marking it and any aliases; /// as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:15,Energy Efficiency,Allocate,AllocateReg,15,/// Version of AllocateReg with extra register to be shadowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:87,Availability,avail,available,87,"/// AllocateReg - Attempt to allocate one of the specified registers. If none; /// are available, return zero. Otherwise, return the first one available,; /// marking it and any aliases as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:143,Availability,avail,available,143,"/// AllocateReg - Attempt to allocate one of the specified registers. If none; /// are available, return zero. Otherwise, return the first one available,; /// marking it and any aliases as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:4,Energy Efficiency,Allocate,AllocateReg,4,"/// AllocateReg - Attempt to allocate one of the specified registers. If none; /// are available, return zero. Otherwise, return the first one available,; /// marking it and any aliases as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:29,Energy Efficiency,allocate,allocate,29,"/// AllocateReg - Attempt to allocate one of the specified registers. If none; /// are available, return zero. Otherwise, return the first one available,; /// marking it and any aliases as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:189,Energy Efficiency,allocate,allocated,189,"/// AllocateReg - Attempt to allocate one of the specified registers. If none; /// are available, return zero. Otherwise, return the first one available,; /// marking it and any aliases as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:65,Energy Efficiency,allocate,allocated,65,// Didn't find the reg.; // Mark the register and any aliases as allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:4,Energy Efficiency,Allocate,AllocateRegBlock,4,"/// AllocateRegBlock - Attempt to allocate a block of RegsRequired consecutive; /// registers. If this is not possible, return zero. Otherwise, return the first; /// register of the block that were allocated, marking the entire block as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:34,Energy Efficiency,allocate,allocate,34,"/// AllocateRegBlock - Attempt to allocate a block of RegsRequired consecutive; /// registers. If this is not possible, return zero. Otherwise, return the first; /// register of the block that were allocated, marking the entire block as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:198,Energy Efficiency,allocate,allocated,198,"/// AllocateRegBlock - Attempt to allocate a block of RegsRequired consecutive; /// registers. If this is not possible, return zero. Otherwise, return the first; /// register of the block that were allocated, marking the entire block as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:237,Energy Efficiency,allocate,allocated,237,"/// AllocateRegBlock - Attempt to allocate a block of RegsRequired consecutive; /// registers. If this is not possible, return zero. Otherwise, return the first; /// register of the block that were allocated, marking the entire block as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:21,Energy Efficiency,allocate,allocated,21,// Check for already-allocated regs in this block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:28,Energy Efficiency,allocate,allocated,28,// Mark the entire block as allocated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:16,Availability,avail,available,16,// No block was available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:15,Energy Efficiency,Allocate,AllocateReg,15,/// Version of AllocateReg with list of registers to be shadowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:65,Energy Efficiency,allocate,allocated,65,// Didn't find the reg.; // Mark the register and any aliases as allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:4,Energy Efficiency,Allocate,AllocateStack,4,/// AllocateStack - Allocate a chunk of stack space with the specified size; /// and alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:20,Energy Efficiency,Allocate,Allocate,20,/// AllocateStack - Allocate a chunk of stack space with the specified size; /// and alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:15,Energy Efficiency,Allocate,AllocateStack,15,"/// Version of AllocateStack with list of extra registers to be shadowed.; /// Note that, unlike AllocateReg, this shadows ALL of the shadow registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:97,Energy Efficiency,Allocate,AllocateReg,97,"/// Version of AllocateStack with list of extra registers to be shadowed.; /// Note that, unlike AllocateReg, this shadows ALL of the shadow registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:17,Energy Efficiency,Allocate,Allocate,17,// HandleByVal - Allocate a stack slot large enough to pass an argument by; // value. The size and alignment information of the argument is encoded in its; // parameter attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:3,Usability,Clear,Clear,3,// Clear byval registers tracking info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:62,Energy Efficiency,allocate,allocated,62,/// MarkAllocated - Mark a register and all of its aliases as allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:604,Availability,failure,failure,604,"/// Encapsulates all of the information needed to generate a stack protector; /// check, and signals to isel when initialized that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point wer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:1899,Availability,avail,available,1899,"n the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a tim",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:4625,Availability,failure,failure,4625," a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector check; /// in by reusing the logic already therein.; ///; /// b. After we finish selecting the basic block, we produce the validation; /// code with one of these techniques:; /// 1) with a call to a guard check function; /// 2) with inlined instrumentation; ///; /// 1) We insert a call to the check function before the terminator.; ///; /// 2) We first find a splice point in the parent basic block; /// before the terminator and then splice the terminator of said basic; /// block into the success basic block. Then we code-gen a new tail for; /// the parent basic block consisting of the two loads, the comparison,; /// and finally two branches to the success/failure basic blocks. We; /// conclude by code-gening the failure basic block if we have not; /// code-gened it already (all stack protector checks we generate in; /// the same function, use the same failure basic block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:4683,Availability,failure,failure,4683," a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector check; /// in by reusing the logic already therein.; ///; /// b. After we finish selecting the basic block, we produce the validation; /// code with one of these techniques:; /// 1) with a call to a guard check function; /// 2) with inlined instrumentation; ///; /// 1) We insert a call to the check function before the terminator.; ///; /// 2) We first find a splice point in the parent basic block; /// before the terminator and then splice the terminator of said basic; /// block into the success basic block. Then we code-gen a new tail for; /// the parent basic block consisting of the two loads, the comparison,; /// and finally two branches to the success/failure basic blocks. We; /// conclude by code-gening the failure basic block if we have not; /// code-gened it already (all stack protector checks we generate in; /// the same function, use the same failure basic block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:4825,Availability,failure,failure,4825," a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector check; /// in by reusing the logic already therein.; ///; /// b. After we finish selecting the basic block, we produce the validation; /// code with one of these techniques:; /// 1) with a call to a guard check function; /// 2) with inlined instrumentation; ///; /// 1) We insert a call to the check function before the terminator.; ///; /// 2) We first find a splice point in the parent basic block; /// before the terminator and then splice the terminator of said basic; /// block into the success basic block. Then we code-gen a new tail for; /// the parent basic block consisting of the two loads, the comparison,; /// and finally two branches to the success/failure basic blocks. We; /// conclude by code-gening the failure basic block if we have not; /// code-gened it already (all stack protector checks we generate in; /// the same function, use the same failure basic block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:753,Performance,optimiz,optimization,753,"/// Encapsulates all of the information needed to generate a stack protector; /// check, and signals to isel when initialized that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point wer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:794,Performance,optimiz,optimization,794,"/// Encapsulates all of the information needed to generate a stack protector; /// check, and signals to isel when initialized that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point wer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:973,Performance,optimiz,optimization,973,"d that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowerin",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:1201,Performance,optimiz,optimization,1201,"d that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowerin",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:1781,Performance,perform,perform,1781,"n the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a tim",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:2045,Performance,perform,perform,2045,"ack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:2442,Performance,optimiz,optimization,2442,"hitecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:4557,Performance,load,loads,4557," a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector check; /// in by reusing the logic already therein.; ///; /// b. After we finish selecting the basic block, we produce the validation; /// code with one of these techniques:; /// 1) with a call to a guard check function; /// 2) with inlined instrumentation; ///; /// 1) We insert a call to the check function before the terminator.; ///; /// 2) We first find a splice point in the parent basic block; /// before the terminator and then splice the terminator of said basic; /// block into the success basic block. Then we code-gen a new tail for; /// the parent basic block consisting of the two loads, the comparison,; /// and finally two branches to the success/failure basic blocks. We; /// conclude by code-gening the failure basic block if we have not; /// code-gened it already (all stack protector checks we generate in; /// the same function, use the same failure basic block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:4085,Security,validat,validation,4085," a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector check; /// in by reusing the logic already therein.; ///; /// b. After we finish selecting the basic block, we produce the validation; /// code with one of these techniques:; /// 1) with a call to a guard check function; /// 2) with inlined instrumentation; ///; /// 1) We insert a call to the check function before the terminator.; ///; /// 2) We first find a splice point in the parent basic block; /// before the terminator and then splice the terminator of said basic; /// block into the success basic block. Then we code-gen a new tail for; /// the parent basic block consisting of the two loads, the comparison,; /// and finally two branches to the success/failure basic blocks. We; /// conclude by code-gening the failure basic block if we have not; /// code-gened it already (all stack protector checks we generate in; /// the same function, use the same failure basic block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:2967,Testability,test,tests,2967,"//; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:3991,Testability,log,logic,3991," a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector check; /// in by reusing the logic already therein.; ///; /// b. After we finish selecting the basic block, we produce the validation; /// code with one of these techniques:; /// 1) with a call to a guard check function; /// 2) with inlined instrumentation; ///; /// 1) We insert a call to the check function before the terminator.; ///; /// 2) We first find a splice point in the parent basic block; /// before the terminator and then splice the terminator of said basic; /// block into the success basic block. Then we code-gen a new tail for; /// the parent basic block consisting of the two loads, the comparison,; /// and finally two branches to the success/failure basic blocks. We; /// conclude by code-gening the failure basic block if we have not; /// code-gened it already (all stack protector checks we generate in; /// the same function, use the same failure basic block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:1580,Usability,guid,guided,1580," tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:108,Availability,Failure,FailureMBB,108,/// Reset state that only changes when we switch functions.; ///; /// This currently includes:; ///; /// 1. FailureMBB since we reuse the failure code path for all stack; /// protector checks created in an individual function.; ///; /// 2.The guard variable since the guard variable we are checking against is; /// always the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:138,Availability,failure,failure,138,/// Reset state that only changes when we switch functions.; ///; /// This currently includes:; ///; /// 1. FailureMBB since we reuse the failure code path for all stack; /// protector checks created in an individual function.; ///; /// 2.The guard variable since the guard variable we are checking against is; /// always the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:249,Modifiability,variab,variable,249,/// Reset state that only changes when we switch functions.; ///; /// This currently includes:; ///; /// 1. FailureMBB since we reuse the failure code path for all stack; /// protector checks created in an individual function.; ///; /// 2.The guard variable since the guard variable we are checking against is; /// always the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:274,Modifiability,variab,variable,274,/// Reset state that only changes when we switch functions.; ///; /// This currently includes:; ///; /// 1. FailureMBB since we reuse the failure code path for all stack; /// protector checks created in an individual function.; ///; /// 2.The guard variable since the guard variable we are checking against is; /// always the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:292,Availability,Failure,FailureMBB,292,"/// The basic block for which we are generating the stack protector.; ///; /// As a result of stack protector generation, we will splice the; /// terminators of this basic block into the successor mbb SuccessMBB and; /// replace it with a compare/branch to the successor mbbs; /// SuccessMBB/FailureMBB depending on whether or not the stack protector; /// was violated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:303,Integrability,depend,depending,303,"/// The basic block for which we are generating the stack protector.; ///; /// As a result of stack protector generation, we will splice the; /// terminators of this basic block into the successor mbb SuccessMBB and; /// replace it with a compare/branch to the successor mbbs; /// SuccessMBB/FailureMBB depending on whether or not the stack protector; /// was violated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:54,Availability,failure,failure,54,/// This basic block visited on stack protector check failure that will; /// contain a call to __stack_chk_fail().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:55,Performance,perform,performed,55,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:40,Testability,test,test,40,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:166,Testability,test,test,166,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:244,Testability,Test,Test,244,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:253,Testability,test,test,253,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:336,Testability,test,test,336,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:398,Testability,test,test,398,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:390,Usability,simpl,simpler,390,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:36,Deployability,pipeline,pipelines,36,"//===- Construction of codegen pass pipelines ------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Interfaces for registering analysis passes, producing common pass manager; /// configurations, and parsing of pass pipelines.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:475,Deployability,configurat,configurations,475,"//===- Construction of codegen pass pipelines ------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Interfaces for registering analysis passes, producing common pass manager; /// configurations, and parsing of pass pipelines.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:511,Deployability,pipeline,pipelines,511,"//===- Construction of codegen pass pipelines ------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Interfaces for registering analysis passes, producing common pass manager; /// configurations, and parsing of pass pipelines.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:396,Integrability,Interface,Interfaces,396,"//===- Construction of codegen pass pipelines ------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Interfaces for registering analysis passes, producing common pass manager; /// configurations, and parsing of pass pipelines.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:475,Modifiability,config,configurations,475,"//===- Construction of codegen pass pipelines ------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Interfaces for registering analysis passes, producing common pass manager; /// configurations, and parsing of pass pipelines.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:107,Availability,avail,available,107,"/// This class provides access to building LLVM's passes.; ///; /// Its members provide the baseline state available to passes during their; /// construction. The \c MachinePassRegistry.def file specifies how to construct; /// all of the built-in passes, and those may reference these members during; /// construction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:24,Security,access,access,24,"/// This class provides access to building LLVM's passes.; ///; /// Its members provide the baseline state available to passes during their; /// construction. The \c MachinePassRegistry.def file specifies how to construct; /// all of the built-in passes, and those may reference these members during; /// construction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:52,Availability,error,error,52,"/// Check whether or not GlobalISel should abort on error.; /// When this is disabled, GlobalISel will fall back on SDISel instead of; /// erroring out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:139,Availability,error,erroring,139,"/// Check whether or not GlobalISel should abort on error.; /// When this is disabled, GlobalISel will fall back on SDISel instead of; /// erroring out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:43,Safety,abort,abort,43,"/// Check whether or not GlobalISel should abort on error.; /// When this is disabled, GlobalISel will fall back on SDISel instead of; /// erroring out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:41,Deployability,install,install,41,"/// addInstSelector - This method should install an instruction selector pass,; /// which converts from LLVM code to machine instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:20,Performance,optimiz,optimize,20,"/// Add passes that optimize instruction level parallelism for out-of-order; /// targets. These passes are run while the machine code is still in SSA; /// form, so they can use MachineTraceMetrics to control their heuristics.; ///; /// All passes added here should preserve the MachineDominatorTree,; /// MachineLoopInfo, and MachineTraceMetrics analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:68,Deployability,pipeline,pipeline,68,"/// addPreRewrite - Add passes to the optimized register allocation pipeline; /// after register allocation is complete, but before virtual registers are; /// rewritten to physical registers.; ///; /// These passes must preserve VirtRegMap and LiveIntervals, and when running; /// after RABasic or RAGreedy, they should take advantage of LiveRegMatrix.; /// When these passes run, VirtRegMap contains legal physreg assignments for; /// all virtual registers.; ///; /// Note if the target overloads addRegAssignAndRewriteOptimized, this may not; /// be honored. This is also not generally used for the fast variant,; /// where the allocation and rewriting are done in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:38,Performance,optimiz,optimized,38,"/// addPreRewrite - Add passes to the optimized register allocation pipeline; /// after register allocation is complete, but before virtual registers are; /// rewritten to physical registers.; ///; /// These passes must preserve VirtRegMap and LiveIntervals, and when running; /// after RABasic or RAGreedy, they should take advantage of LiveRegMatrix.; /// When these passes run, VirtRegMap contains legal physreg assignments for; /// all virtual registers.; ///; /// Note if the target overloads addRegAssignAndRewriteOptimized, this may not; /// be honored. This is also not generally used for the fast variant,; /// where the allocation and rewriting are done in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:106,Deployability,pipeline,pipeline,106,/// This method may be implemented by targets that want to run passes after; /// register allocation pass pipeline but before prolog-epilog insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:139,Energy Efficiency,schedul,scheduling,139,/// This method may be implemented by targets that want to run passes after; /// prolog-epilog insertion and before the second instruction scheduling pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:23,Deployability,install,install,23,"/// This method should install an IR translator pass, which converts from; /// LLVM code to machine instructions with possibly generic opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:23,Deployability,install,install,23,"/// This method should install a legalize pass, which converts the instruction; /// sequence into one that can be selected by the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:23,Deployability,install,install,23,"/// This method should install a register bank selector pass, which; /// assigns register banks to virtual registers without a register; /// class or register banks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:23,Deployability,install,install,23,"/// This method should install a (global) instruction selector pass, which; /// converts possibly generic instructions to fully target-specific; /// instructions, thereby constraining all generic virtual registers to; /// register classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:177,Performance,optimiz,optimization,177,/// @}}; /// High level function that adds all passes necessary to go from llvm IR; /// representation to the MI representation.; /// Adds IR based lowering and target specific optimization passes and finally; /// the core instruction selection passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:22,Modifiability,config,configurable,22,/// Add common target configurable passes that perform LLVM IR to IR; /// transforms following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:47,Performance,perform,perform,47,/// Add common target configurable passes that perform LLVM IR to IR; /// transforms following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:115,Performance,optimiz,optimization,115,/// Add common target configurable passes that perform LLVM IR to IR; /// transforms following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:27,Performance,perform,perform,27,/// Add common passes that perform LLVM IR to IR transforms in preparation for; /// instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:94,Deployability,pipeline,pipeline,94,"/// Methods with trivial inline returns are convenient points in the common; /// codegen pass pipeline where targets may insert passes. Methods with; /// out-of-line standard implementations are major CodeGen stages called by; /// addMachinePasses. Some targets may override major stages when inserting; /// passes is insufficient, but maintaining overriden stages is more work.; ///; /// addMachineSSAOptimization - Add standard passes that optimize machine; /// instructions in SSA form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:442,Performance,optimiz,optimize,442,"/// Methods with trivial inline returns are convenient points in the common; /// codegen pass pipeline where targets may insert passes. Methods with; /// out-of-line standard implementations are major CodeGen stages called by; /// addMachinePasses. Some targets may override major stages when inserting; /// passes is insufficient, but maintaining overriden stages is more work.; ///; /// addMachineSSAOptimization - Add standard passes that optimize machine; /// instructions in SSA form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:20,Performance,optimiz,optimize,20,/// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:174,Performance,optimiz,optimization,174,/// Utilities for targets to add passes to the pass manager.; ///; /// createTargetRegisterAllocator - Create the register allocator pass for; /// this target at the current optimization level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:11,Modifiability,variab,variable,11,/// Helper variable for `-start-before/-start-after/-stop-before/-stop-after`,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:22,Modifiability,config,configurable,22,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:47,Performance,perform,perform,47,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:115,Performance,optimiz,optimization,115,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:110,Performance,optimiz,optimizer,110,"// Before running any passes, run the verifier to determine if the input; // coming from the front-end and/or optimizer is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:80,Performance,load,loads,80,// The MergeICmpsPass tries to create memcmp calls by grouping sequences of; // loads and compares. ExpandMemCmpPass then tries to expand those calls; // into optimally-sized loads and compares. The transforms are enabled by a; // target lowering hook.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:175,Performance,load,loads,175,// The MergeICmpsPass tries to create memcmp calls by grouping sequences of; // loads and compares. ExpandMemCmpPass then tries to expand those calls; // into optimally-sized loads and compares. The transforms are enabled by a; // target lowering hook.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:48,Testability,log,log,48,"// Replace calls to LLVM intrinsics (e.g., exp, log) operating on vector; // operands with calls to the corresponding functions in a vector library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:45,Availability,mask,masked,45,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:213,Availability,mask,mask,213,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:169,Performance,load,loads,169,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:24,Modifiability,Rewrite,RewriteSymbolPass,24,// TODO: Default ctor'd RewriteSymbolPass is no-op.; // addPass(RewriteSymbolPass());,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:64,Modifiability,Rewrite,RewriteSymbolPass,64,// TODO: Default ctor'd RewriteSymbolPass is no-op.; // addPass(RewriteSymbolPass());,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:27,Performance,perform,perform,27,/// Add common passes that perform LLVM IR to IR transforms in preparation for; /// instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:16,Safety,safe,safe,16,// Add both the safe stack and the stack protection passes: each of them will; // only protect functions that have corresponding attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:50,Safety,abort,abort,50,// Provide a fallback path when we do not want to abort on; // not-yet-supported input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:186,Deployability,configurat,configuration,186,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:258,Integrability,rout,routines,258,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:317,Integrability,rout,routine,317,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:431,Integrability,inject,injecting,431,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:638,Integrability,rout,routines,638,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
