id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html604/TStructViewerGUI.html:28482,Deployability,update,updates,28482,"om given ""node"". void DrawVolumes(TStructNode* visObj); Recursive method to draw GeoVolumes. TStructNodeProperty* FindNodeProperty(TStructNode* node); Returns pointer to property associated with node ""node"". If property is not found; then it returns default property. TCanvas* GetCanvas(); Returns canvas used to keep TGeoVolumes. Int_t GetColor(TStructNode* node); Returns color form fColors for given ""node"". TStructNodeProperty* GetDefaultColor(); Return default color for nodes. Bool_t GetLinksVisibility() const; Returns true if links are visible, otherwise return false. TStructNode* GetNodePtr() const; Returns top node pointer. void GLWidgetProcessedEventSlot(Event_t* event); Handle events. Sets fMouseX and fMouseY when user move a mouse over viewer and hides ToolTip. void LevelDistValueSetSlot(Long_t dist); Emmited when user changes distance between levels. void MouseOverSlot(TGLPhysicalShape* shape); MouseOver slot. Activated when user out mouse over object on scene.; Sets ToolTip and updates labels. void RedoButtonSlot(); Activated when user click Redo button. Repeat last Undo action. void ResetButtonSlot(); Resets camera. void Scale(TStructNode* parent); Recursive method to scaling all modes on scene. We have to scale nodes to get real ratio between nodes.; Uses fMaxRatio. void SetNodePtr(TStructNode* val); Sets top node pointer and updates view. void SetLinksVisibility(Bool_t val); Sets links visibility to ""visible"". void SetPointerButtonSlot(); Sets pointer given in fPointerTestEntry to the main pointer. void ShowLinksToggled(Bool_t on); Changes links visibility and refresh view. void UnCheckMaxObjects(); Shows hidden nodes. void Update(Bool_t resetCamera = false); Updates view. Clear all the nodes, call draw function and update scene. Doesn't reset camera. void UpdateButtonSlot(); Update button slot. Updates scene. void UpdateLabels(TStructNode* node); Refresh information in labels when user put mouse over object. void UndoButtonSlot(); UndoButton Slot. Activ",MatchSource.WIKI,root/html604/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStructViewerGUI.html
https://root.cern/root/html604/TStructViewerGUI.html:28839,Deployability,update,updates,28839,"_t GetColor(TStructNode* node); Returns color form fColors for given ""node"". TStructNodeProperty* GetDefaultColor(); Return default color for nodes. Bool_t GetLinksVisibility() const; Returns true if links are visible, otherwise return false. TStructNode* GetNodePtr() const; Returns top node pointer. void GLWidgetProcessedEventSlot(Event_t* event); Handle events. Sets fMouseX and fMouseY when user move a mouse over viewer and hides ToolTip. void LevelDistValueSetSlot(Long_t dist); Emmited when user changes distance between levels. void MouseOverSlot(TGLPhysicalShape* shape); MouseOver slot. Activated when user out mouse over object on scene.; Sets ToolTip and updates labels. void RedoButtonSlot(); Activated when user click Redo button. Repeat last Undo action. void ResetButtonSlot(); Resets camera. void Scale(TStructNode* parent); Recursive method to scaling all modes on scene. We have to scale nodes to get real ratio between nodes.; Uses fMaxRatio. void SetNodePtr(TStructNode* val); Sets top node pointer and updates view. void SetLinksVisibility(Bool_t val); Sets links visibility to ""visible"". void SetPointerButtonSlot(); Sets pointer given in fPointerTestEntry to the main pointer. void ShowLinksToggled(Bool_t on); Changes links visibility and refresh view. void UnCheckMaxObjects(); Shows hidden nodes. void Update(Bool_t resetCamera = false); Updates view. Clear all the nodes, call draw function and update scene. Doesn't reset camera. void UpdateButtonSlot(); Update button slot. Updates scene. void UpdateLabels(TStructNode* node); Refresh information in labels when user put mouse over object. void UndoButtonSlot(); UndoButton Slot. Activated when user press Undo button. Restore last top node pointer. void ScaleByChangedSlot(); Activated when user press radio button. TStructViewerGUI(TStructViewer* parent, TStructNode* nodePtr, TList* colors, const TGWindow* p = __null, UInt_t w = 800, UInt_t h = 600). » Author: Tomasz Sosnicki 18/09/09 » Copyright (C) 1995-2009, Ren",MatchSource.WIKI,root/html604/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStructViewerGUI.html
https://root.cern/root/html604/TStructViewerGUI.html:29238,Deployability,update,update,29238,"GetNodePtr() const; Returns top node pointer. void GLWidgetProcessedEventSlot(Event_t* event); Handle events. Sets fMouseX and fMouseY when user move a mouse over viewer and hides ToolTip. void LevelDistValueSetSlot(Long_t dist); Emmited when user changes distance between levels. void MouseOverSlot(TGLPhysicalShape* shape); MouseOver slot. Activated when user out mouse over object on scene.; Sets ToolTip and updates labels. void RedoButtonSlot(); Activated when user click Redo button. Repeat last Undo action. void ResetButtonSlot(); Resets camera. void Scale(TStructNode* parent); Recursive method to scaling all modes on scene. We have to scale nodes to get real ratio between nodes.; Uses fMaxRatio. void SetNodePtr(TStructNode* val); Sets top node pointer and updates view. void SetLinksVisibility(Bool_t val); Sets links visibility to ""visible"". void SetPointerButtonSlot(); Sets pointer given in fPointerTestEntry to the main pointer. void ShowLinksToggled(Bool_t on); Changes links visibility and refresh view. void UnCheckMaxObjects(); Shows hidden nodes. void Update(Bool_t resetCamera = false); Updates view. Clear all the nodes, call draw function and update scene. Doesn't reset camera. void UpdateButtonSlot(); Update button slot. Updates scene. void UpdateLabels(TStructNode* node); Refresh information in labels when user put mouse over object. void UndoButtonSlot(); UndoButton Slot. Activated when user press Undo button. Restore last top node pointer. void ScaleByChangedSlot(); Activated when user press radio button. TStructViewerGUI(TStructViewer* parent, TStructNode* nodePtr, TList* colors, const TGWindow* p = __null, UInt_t w = 800, UInt_t h = 600). » Author: Tomasz Sosnicki 18/09/09 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gviz3d:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStructViewerGUI.html
https://root.cern/root/html604/TStructViewerGUI.html:414,Integrability,interface,interface,414,". TStructViewerGUI. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GVIZ3D; » TStructViewerGUI. class TStructViewerGUI: public TGMainFrame. TStructViewerGUI is main window of TStructViewer. It provides graphical; interface. In the window we can find panel with tabs and frame with; GLViewer. Tab ""Info"" serves information about node and is used to naviagate; backward and forward. Second tab ""Options"" is used to set few options; such as links visibility, scaling method or setting a pointer.; Last tab ""Editor"" is tab when the TStructNodeEditor is placed. Function Members (Methods); public:. virtual~TStructViewerGUI(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidAutoRefreshButtonSlot(Bool_t on); virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBoxHeightValueSetSlot(Long_t h); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(",MatchSource.WIKI,root/html604/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStructViewerGUI.html
https://root.cern/root/html604/TStructViewerGUI.html:122,Modifiability,inherit,inheritance,122,". TStructViewerGUI. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GVIZ3D; » TStructViewerGUI. class TStructViewerGUI: public TGMainFrame. TStructViewerGUI is main window of TStructViewer. It provides graphical; interface. In the window we can find panel with tabs and frame with; GLViewer. Tab ""Info"" serves information about node and is used to naviagate; backward and forward. Second tab ""Options"" is used to set few options; such as links visibility, scaling method or setting a pointer.; Last tab ""Editor"" is tab when the TStructNodeEditor is placed. Function Members (Methods); public:. virtual~TStructViewerGUI(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidAutoRefreshButtonSlot(Bool_t on); virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBoxHeightValueSetSlot(Long_t h); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(",MatchSource.WIKI,root/html604/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStructViewerGUI.html
https://root.cern/root/html604/TStyle.html:1852,Availability,error,error,1852,"dPad(Option_t* option = """"); Int_tAxisChoice(Option_t* axis) const; virtual voidBrowse(TBrowser* b); static voidBuildStyles(); virtual voidcd(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& style) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TAttText*GetAttDate(); Color_tGetAxisColor(Option_t* axis = ""X"") const; Float_tGetBarOffset() const; Float_tGetBarWidth() const; Int_tGetCanvasBorderMode() const; Width_tGetCanvasBorderSize() const; Color_tGetCanvasColor() const; Int_tGetCanvasDefH() const; Int_tGetCanvasDefW() const; Int_tGetCanvasDefX() const; Int_tGetCanvasDefY() const; Bool_tGetCanvasPreferGL() const; Int_tGetColorModelPS() const; Int_tGetColorPalette(Int_t i) const; Float_tGetDateX() const; Float_tGetDateY() const; Int_tGetDrawBorder() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::Get",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:1936,Availability,error,error,1936,"se(TBrowser* b); static voidBuildStyles(); virtual voidcd(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& style) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TAttText*GetAttDate(); Color_tGetAxisColor(Option_t* axis = ""X"") const; Float_tGetBarOffset() const; Float_tGetBarWidth() const; Int_tGetCanvasBorderMode() const; Width_tGetCanvasBorderSize() const; Color_tGetCanvasColor() const; Int_tGetCanvasDefH() const; Int_tGetCanvasDefW() const; Int_tGetCanvasDefX() const; Int_tGetCanvasDefY() const; Bool_tGetCanvasPreferGL() const; Int_tGetColorModelPS() const; Int_tGetColorPalette(Int_t i) const; Float_tGetDateX() const; Float_tGetDateY() const; Int_tGetDrawBorder() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetEndErrorSize() const; Float_tGetErrorX() const; virtual Color_",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:10497,Availability,error,errorx,10497,"Primitive(ostream& out, Option_t* = """"); voidSaveSource(const char* filename, Option_t* option = 0); virtual voidTAttText::SaveTextAttributes(ostream& out, const char* name, Int_t alidef = 12, Float_t angdef = 0, Int_t coldef = 1, Int_t fondef = 61, Float_t sizdef = 1); voidSetAxisColor(Color_t color = 1, Option_t* axis = ""X""); voidSetBarOffset(Float_t baroff = 0.5); voidSetBarWidth(Float_t barwidth = 0.5); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCanvasBorderMode(Int_t mode = 1); voidSetCanvasBorderSize(Width_t size = 1); voidSetCanvasColor(Color_t color = 19); voidSetCanvasDefH(Int_t h = 500); voidSetCanvasDefW(Int_t w = 700); voidSetCanvasDefX(Int_t topx = 10); voidSetCanvasDefY(Int_t topy = 10); voidSetCanvasPreferGL(Bool_t prefer = kTRUE); voidSetColorModelPS(Int_t c = 0); voidSetDateX(Float_t x = 0.01); voidSetDateY(Float_t y = 0.01); voidSetDrawBorder(Int_t drawborder = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEndErrorSize(Float_t np = 2); voidSetErrorX(Float_t errorx = 0.5); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidSetFitFormat(const char* format = ""5.4g""); voidSetFrameBorderMode(Int_t mode = 1); voidSetFrameBorderSize(Width_t size = 1); voidSetFrameFillColor(Color_t color = 1); voidSetFrameFillStyle(Style_t styl = 0); voidSetFrameLineColor(Color_t color = 1); voidSetFrameLineStyle(Style_t styl = 0); voidSetFrameLineWidth(Width_t width = 1); voidSetFuncColor(Color_t color = 1); voidSetFuncStyle(Style_t style = 1); voidSetFuncWidth(Width_t width = 4); voidSetGridColor(Color_t color = 0); voidSetGridStyle(Style_t style = 3); voidSetGridWidth(Width_t width = 1); voidSetHatchesLineWidth(Int_t l); voidSetHatchesSpacing(Double_t h); voidSetHeaderPS(const char* hea",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:19321,Availability,error,error,19321,,MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:19373,Availability,error,errors,19373,,MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:28608,Availability,error,error,28608,"r model. void SetHistMinimumZero(Bool_t zero = kTRUE); If the argument zero=kTRUE the minimum value for the Y axis of 1-d histograms; is set to 0 if the minimum bin content is greater than 0 and TH1::SetMinimum; has not been called.; Otherwise the minimum is based on the minimum bin content. void SetNdivisions(Int_t n = 510, Option_t* axis = ""X""); Set the number of divisions to draw an axis.; ndiv : Number of divisions. n = N1 + 100*N2 + 10000*N3; N1=number of primary divisions.; N2=number of secondary divisions.; N3=number of 3rd divisions.; e.g.:; nndi=0 --> no tick marks.; nndi=2 --> 2 divisions, one tick mark in the middle; of the axis.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetAxisColor(Color_t color = 1, Option_t* axis = ""X""); Set color to draw the axis line and tick marks.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetEndErrorSize(Float_t np = 2); Set the size (in pixels) of the small lines drawn at the; end of the error bars (TH1 or TGraphErrors).; The default value is 2 pixels.; Set np=0 to remove these lines. void SetHeaderPS(const char* header); Define a string to be inserted in the Postscript header; The string in header will be added to the Postscript file; immediately following the %%Page line; For example, this string may contain special Postscript instructions like; 200 200 translate; the following header string will print the string ""my annotation"" at the; bottom left corner of the page (outside the user area); ""gsave 100 -100 t 0 r 0 0 m /Helvetica-Bold findfont 56 sf 0 0 m ( my annotation ) show gr""; This information is used in TPostScript::Initialize. void SetIsReading(Bool_t reading = kTRUE); Sets the fIsReading member to reading (default=kTRUE); fIsReading (used via gStyle->IsReading()) can be used in; the functions myclass::UseCurrentStyle to read from the current style; or write to the current style. void SetTitlePS(const char* pstitle); Defin",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:33677,Availability,error,errors,33677,"e controlled by:; gStyle->SetDateX(x); x in NDC; gStyle->SetDateY(y); y in NDC. The date text attributes can be changed with:; gStyle->GetAttDate()->SetTextFont(font=62);; gStyle->GetAttDate()->SetTextSize(size=0.025);; gStyle->GetAttDate()->SetTextAngle(angle=0);; gStyle->GetAttDate()->SetTextAlign(align=11);; gStyle->GetAttDate()->SetTextColor(color=1);. The current date attributes can be obtained via:; gStyle->GetAttDate()->GetTextxxxx();. When the date option is active, a text object is created when the pad; paint its list of primitives. The text object is named ""DATE"".; The DATE attributes can also be edited interactively (position; and attributes) via the normal context menu. void SetOptFit(Int_t fit = 1); The type of information about fit parameters printed in the histogram; statistics box can be selected via the parameter mode.; The parameter mode can be = pcev (default = 0111); p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors.; When ""v""=1 is specified, only the non-fixed parameters are shown.; When ""v""=2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to; gStyle->SetOptFit(111). see also SetOptStat below. void SetOptStat(Int_t stat = 1); The type of information printed in the histogram statistics box; can be selected via the parameter mode.; The parameter mode can be = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values prin",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:33832,Availability,error,errors,33832,"e controlled by:; gStyle->SetDateX(x); x in NDC; gStyle->SetDateY(y); y in NDC. The date text attributes can be changed with:; gStyle->GetAttDate()->SetTextFont(font=62);; gStyle->GetAttDate()->SetTextSize(size=0.025);; gStyle->GetAttDate()->SetTextAngle(angle=0);; gStyle->GetAttDate()->SetTextAlign(align=11);; gStyle->GetAttDate()->SetTextColor(color=1);. The current date attributes can be obtained via:; gStyle->GetAttDate()->GetTextxxxx();. When the date option is active, a text object is created when the pad; paint its list of primitives. The text object is named ""DATE"".; The DATE attributes can also be edited interactively (position; and attributes) via the normal context menu. void SetOptFit(Int_t fit = 1); The type of information about fit parameters printed in the histogram; statistics box can be selected via the parameter mode.; The parameter mode can be = pcev (default = 0111); p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors.; When ""v""=1 is specified, only the non-fixed parameters are shown.; When ""v""=2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to; gStyle->SetOptFit(111). see also SetOptStat below. void SetOptStat(Int_t stat = 1); The type of information printed in the histogram statistics box; can be selected via the parameter mode.; The parameter mode can be = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values prin",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:34324,Availability,error,error,34324,"mode.; The parameter mode can be = pcev (default = 0111); p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors.; When ""v""=1 is specified, only the non-fixed parameters are shown.; When ""v""=2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to; gStyle->SetOptFit(111). see also SetOptStat below. void SetOptStat(Int_t stat = 1); The type of information printed in the histogram statistics box; can be selected via the parameter mode.; The parameter mode can be = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed;",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:34393,Availability,error,error,34393,"mode.; The parameter mode can be = pcev (default = 0111); p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors.; When ""v""=1 is specified, only the non-fixed parameters are shown.; When ""v""=2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to; gStyle->SetOptFit(111). see also SetOptStat below. void SetOptStat(Int_t stat = 1); The type of information printed in the histogram statistics box; can be selected via the parameter mode.; The parameter mode can be = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed;",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:34606,Availability,error,error,34606,"mode.; The parameter mode can be = pcev (default = 0111); p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors.; When ""v""=1 is specified, only the non-fixed parameters are shown.; When ""v""=2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to; gStyle->SetOptFit(111). see also SetOptStat below. void SetOptStat(Int_t stat = 1); The type of information printed in the histogram statistics box; can be selected via the parameter mode.; The parameter mode can be = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed;",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:34669,Availability,error,error,34669,"mode.; The parameter mode can be = pcev (default = 0111); p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors.; When ""v""=1 is specified, only the non-fixed parameters are shown.; When ""v""=2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to; gStyle->SetOptFit(111). see also SetOptStat below. void SetOptStat(Int_t stat = 1); The type of information printed in the histogram statistics box; can be selected via the parameter mode.; The parameter mode can be = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed;",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:35554,Availability,error,error,35554," 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed; Example: gStyle->SetOptStat(""ne"");; print only name of histogram and number of entries.; gStyle->SetOptStat(""n"") print only the name of the histogram; gStyle->SetOptStat(""nemr"") is the default. void SetPaperSize(TStyle::EPaperSize size); Set paper size for PostScript output. void SetPaperSize(Float_t xsize = 20, Float_t ysize = 26); Set paper size for PostScript output.; The paper size is specified in centimeters. Default is 20x26.; See also TPad::Print. void SetTickLength(Float_t length = 0.029999999999999999, Option_t* axis = ""X""); Set the tick marks length for an axis.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetTitleColor(Color_t color = 1, Option_t* axis = ""X""); if axis ==""x"" set the X axis title color; if",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:35617,Availability,error,error,35617," 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed; Example: gStyle->SetOptStat(""ne"");; print only name of histogram and number of entries.; gStyle->SetOptStat(""n"") print only the name of the histogram; gStyle->SetOptStat(""nemr"") is the default. void SetPaperSize(TStyle::EPaperSize size); Set paper size for PostScript output. void SetPaperSize(Float_t xsize = 20, Float_t ysize = 26); Set paper size for PostScript output.; The paper size is specified in centimeters. Default is 20x26.; See also TPad::Print. void SetTickLength(Float_t length = 0.029999999999999999, Option_t* axis = ""X""); Set the tick marks length for an axis.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetTitleColor(Color_t color = 1, Option_t* axis = ""X""); if axis ==""x"" set the X axis title color; if",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:35812,Availability,error,error,35812," 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed; Example: gStyle->SetOptStat(""ne"");; print only name of histogram and number of entries.; gStyle->SetOptStat(""n"") print only the name of the histogram; gStyle->SetOptStat(""nemr"") is the default. void SetPaperSize(TStyle::EPaperSize size); Set paper size for PostScript output. void SetPaperSize(Float_t xsize = 20, Float_t ysize = 26); Set paper size for PostScript output.; The paper size is specified in centimeters. Default is 20x26.; See also TPad::Print. void SetTickLength(Float_t length = 0.029999999999999999, Option_t* axis = ""X""); Set the tick marks length for an axis.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetTitleColor(Color_t color = 1, Option_t* axis = ""X""); if axis ==""x"" set the X axis title color; if",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:35871,Availability,error,error,35871," 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed; Example: gStyle->SetOptStat(""ne"");; print only name of histogram and number of entries.; gStyle->SetOptStat(""n"") print only the name of the histogram; gStyle->SetOptStat(""nemr"") is the default. void SetPaperSize(TStyle::EPaperSize size); Set paper size for PostScript output. void SetPaperSize(Float_t xsize = 20, Float_t ysize = 26); Set paper size for PostScript output.; The paper size is specified in centimeters. Default is 20x26.; See also TPad::Print. void SetTickLength(Float_t length = 0.029999999999999999, Option_t* axis = ""X""); Set the tick marks length for an axis.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetTitleColor(Color_t color = 1, Option_t* axis = ""X""); if axis ==""x"" set the X axis title color; if",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:45835,Availability,error,errorx,45835,"ScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. void SetCanvasDefY(Int_t topy = 10); {fCanvasDefY = topy;}. void SetLegendBorderSize(Width_t size = 4); {fLegendBorderSize = size;}. void SetLegendFillColor(Color_t color = 0); {fLegendFillColor = color;}. void SetLegendFont(Style_t font = 62); {fLegendFont = font;}. void SetLegendTextSize(Double_t size = 0.); {fLegendTextSize = size;}. void SetPadColor(Color_t color = 19); {fPadColor = color;}. void SetPadBorderSize(Width_t size",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:45861,Availability,error,errorx,45861,"ScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. void SetCanvasDefY(Int_t topy = 10); {fCanvasDefY = topy;}. void SetLegendBorderSize(Width_t size = 4); {fLegendBorderSize = size;}. void SetLegendFillColor(Color_t color = 0); {fLegendFillColor = color;}. void SetLegendFont(Style_t font = 62); {fLegendFont = font;}. void SetLegendTextSize(Double_t size = 0.); {fLegendTextSize = size;}. void SetPadColor(Color_t color = 19); {fPadColor = color;}. void SetPadBorderSize(Width_t size = 1); {fPadBorderSize = size",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:112,Modifiability,inherit,inheritance,112,". TStyle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TStyle. class TStyle: public TNamed, public TAttLine, public TAttFill, public TAttMarker, public TAttText. TStyle objects may be created to define special styles.; By default ROOT creates a default style that can be accessed via; the gStyle pointer. This class includes functions to set some of the following object attributes.; - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles. Function Members (Methods); public:. virtual~TStyle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tAxisChoice(Option_t* axis) const; virtual voidBrowse(TBrowser* b); static voidBuildStyles(); virtual voidcd(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& style) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t ",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:30130,Performance,scalab,scalable,30130,"er of the page (outside the user area); ""gsave 100 -100 t 0 r 0 0 m /Helvetica-Bold findfont 56 sf 0 0 m ( my annotation ) show gr""; This information is used in TPostScript::Initialize. void SetIsReading(Bool_t reading = kTRUE); Sets the fIsReading member to reading (default=kTRUE); fIsReading (used via gStyle->IsReading()) can be used in; the functions myclass::UseCurrentStyle to read from the current style; or write to the current style. void SetTitlePS(const char* pstitle); Define a string to be used in the %%Title of the Postscript files.; If this string is not defined, ROOT will use the canvas title. void SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); Set axis labels color.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); Set font number used to draw axis labels.; font : Text font code = 10*fontnumber + precision; Font numbers must be between 1 and 14; precision = 1 fast hardware fonts (steps in the size); precision = 2 scalable and rotatable hardware fonts; The default font number is 62.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetLabelOffset(Float_t offset = 0.0050000000000000001, Option_t* axis = ""X""); Set offset between axis and axis labels.; The offset is expressed as a percent of the pad height.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetLabelSize(Float_t size = 0.040000000000000001, Option_t* axis = ""X""); Set size of axis labels. The size is expressed as a percent of the pad height.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetLineStyleString(Int_t i, const char* text); Set line style string using the PostScript convention.; A line is a suite of segments, each segment is described by the number of; pixels. The initial and alternating elements (second, fourth, and so on); are the dashes, and the othe",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:481,Security,access,accessed,481,". TStyle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TStyle. class TStyle: public TNamed, public TAttLine, public TAttFill, public TAttMarker, public TAttText. TStyle objects may be created to define special styles.; By default ROOT creates a default style that can be accessed via; the gStyle pointer. This class includes functions to set some of the following object attributes.; - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles. Function Members (Methods); public:. virtual~TStyle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tAxisChoice(Option_t* axis) const; virtual voidBrowse(TBrowser* b); static voidBuildStyles(); virtual voidcd(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& style) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t ",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:13294,Testability,log,logx,13294,".0050000000000000001, Option_t* axis = ""X""); voidSetLabelSize(Float_t size = 0.040000000000000001, Option_t* axis = ""X""); voidSetLegendBorderSize(Width_t size = 4); voidSetLegendFillColor(Color_t color = 0); voidSetLegendFont(Style_t font = 62); voidSetLegendTextSize(Double_t size = 0.); voidSetLegoInnerR(Float_t rad = 0.5); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); voidSetLineScalePS(Float_t scale = 3); virtual voidTAttLine::SetLineStyle(Style_t lstyle); voidSetLineStyleString(Int_t i, const char* text); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t mcolor = 1); virtual voidTAttMarker::SetMarkerColorAlpha(Color_t mcolor, Float_t malpha); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNdivisions(Int_t n = 510, Option_t* axis = ""X""); voidSetNumberContours(Int_t number = 20); static voidTObject::SetObjectStat(Bool_t stat); voidSetOptDate(Int_t datefl = 1); voidSetOptFile(Int_t file = 1); voidSetOptFit(Int_t fit = 1); voidSetOptLogx(Int_t logx = 1); voidSetOptLogy(Int_t logy = 1); voidSetOptLogz(Int_t logz = 1); voidSetOptStat(Int_t stat = 1); voidSetOptStat(Option_t* stat); voidSetOptTitle(Int_t tit = 1); voidSetPadBorderMode(Int_t mode = 1); voidSetPadBorderSize(Width_t size = 1); voidSetPadBottomMargin(Float_t margin = 0.10000000000000001); voidSetPadColor(Color_t color = 19); voidSetPadGridX(Bool_t gridx); voidSetPadGridY(Bool_t gridy); voidSetPadLeftMargin(Float_t margin = 0.10000000000000001); voidSetPadRightMargin(Float_t margin = 0.10000000000000001); voidSetPadTickX(Int_t tickx); voidSetPadTickY(Int_t ticky); voidSetPadTopMargin(Flo",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:13326,Testability,log,logy,13326,".0050000000000000001, Option_t* axis = ""X""); voidSetLabelSize(Float_t size = 0.040000000000000001, Option_t* axis = ""X""); voidSetLegendBorderSize(Width_t size = 4); voidSetLegendFillColor(Color_t color = 0); voidSetLegendFont(Style_t font = 62); voidSetLegendTextSize(Double_t size = 0.); voidSetLegoInnerR(Float_t rad = 0.5); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); voidSetLineScalePS(Float_t scale = 3); virtual voidTAttLine::SetLineStyle(Style_t lstyle); voidSetLineStyleString(Int_t i, const char* text); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t mcolor = 1); virtual voidTAttMarker::SetMarkerColorAlpha(Color_t mcolor, Float_t malpha); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNdivisions(Int_t n = 510, Option_t* axis = ""X""); voidSetNumberContours(Int_t number = 20); static voidTObject::SetObjectStat(Bool_t stat); voidSetOptDate(Int_t datefl = 1); voidSetOptFile(Int_t file = 1); voidSetOptFit(Int_t fit = 1); voidSetOptLogx(Int_t logx = 1); voidSetOptLogy(Int_t logy = 1); voidSetOptLogz(Int_t logz = 1); voidSetOptStat(Int_t stat = 1); voidSetOptStat(Option_t* stat); voidSetOptTitle(Int_t tit = 1); voidSetPadBorderMode(Int_t mode = 1); voidSetPadBorderSize(Width_t size = 1); voidSetPadBottomMargin(Float_t margin = 0.10000000000000001); voidSetPadColor(Color_t color = 19); voidSetPadGridX(Bool_t gridx); voidSetPadGridY(Bool_t gridy); voidSetPadLeftMargin(Float_t margin = 0.10000000000000001); voidSetPadRightMargin(Float_t margin = 0.10000000000000001); voidSetPadTickX(Int_t tickx); voidSetPadTickY(Int_t ticky); voidSetPadTopMargin(Flo",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:13358,Testability,log,logz,13358,".0050000000000000001, Option_t* axis = ""X""); voidSetLabelSize(Float_t size = 0.040000000000000001, Option_t* axis = ""X""); voidSetLegendBorderSize(Width_t size = 4); voidSetLegendFillColor(Color_t color = 0); voidSetLegendFont(Style_t font = 62); voidSetLegendTextSize(Double_t size = 0.); voidSetLegoInnerR(Float_t rad = 0.5); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); voidSetLineScalePS(Float_t scale = 3); virtual voidTAttLine::SetLineStyle(Style_t lstyle); voidSetLineStyleString(Int_t i, const char* text); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t mcolor = 1); virtual voidTAttMarker::SetMarkerColorAlpha(Color_t mcolor, Float_t malpha); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNdivisions(Int_t n = 510, Option_t* axis = ""X""); voidSetNumberContours(Int_t number = 20); static voidTObject::SetObjectStat(Bool_t stat); voidSetOptDate(Int_t datefl = 1); voidSetOptFile(Int_t file = 1); voidSetOptFit(Int_t fit = 1); voidSetOptLogx(Int_t logx = 1); voidSetOptLogy(Int_t logy = 1); voidSetOptLogz(Int_t logz = 1); voidSetOptStat(Int_t stat = 1); voidSetOptStat(Option_t* stat); voidSetOptTitle(Int_t tit = 1); voidSetPadBorderMode(Int_t mode = 1); voidSetPadBorderSize(Width_t size = 1); voidSetPadBottomMargin(Float_t margin = 0.10000000000000001); voidSetPadColor(Color_t color = 19); voidSetPadGridX(Bool_t gridx); voidSetPadGridY(Bool_t gridy); voidSetPadLeftMargin(Float_t margin = 0.10000000000000001); voidSetPadRightMargin(Float_t margin = 0.10000000000000001); voidSetPadTickX(Int_t tickx); voidSetPadTickY(Int_t ticky); voidSetPadTopMargin(Flo",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:21249,Testability,log,log,21249,,MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:21284,Testability,log,log,21284,,MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:21319,Testability,log,log,21319,,MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:45394,Testability,log,logx,45394,"leYOffset() const; {return GetTitleOffset(""Y"");}. Float_t GetTitleYSize() const; {return GetTitleSize(""Y"");}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. vo",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:45417,Testability,log,logx,45417,"leYOffset() const; {return GetTitleOffset(""Y"");}. Float_t GetTitleYSize() const; {return GetTitleSize(""Y"");}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. vo",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:45447,Testability,log,logy,45447,"at_t GetTitleYSize() const; {return GetTitleSize(""Y"");}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. void SetCanvasDefY(Int_t topy = 10); {fCanvasDefY = top",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:45470,Testability,log,logy,45470,"at_t GetTitleYSize() const; {return GetTitleSize(""Y"");}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. void SetCanvasDefY(Int_t topy = 10); {fCanvasDefY = top",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:45500,Testability,log,logz,45500,";}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. void SetCanvasDefY(Int_t topy = 10); {fCanvasDefY = topy;}. void SetLegendBorderSize(Width_t size = 4); {fLe",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyle.html:45523,Testability,log,logz,45523,";}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. void SetCanvasDefY(Int_t topy = 10); {fCanvasDefY = topy;}. void SetLegendBorderSize(Width_t size = 4); {fLe",MatchSource.WIKI,root/html604/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyle.html
https://root.cern/root/html604/TStyleDialog.html:4564,Availability,error,error,4564," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html604/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleDialog.html
https://root.cern/root/html604/TStyleDialog.html:4648,Availability,error,error,4648,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html604/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleDialog.html
https://root.cern/root/html604/TStyleDialog.html:20209,Availability,mask,mask,20209,,MatchSource.WIKI,root/html604/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleDialog.html
https://root.cern/root/html604/TStyleDialog.html:24823,Integrability,message,message,24823,"CurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TStyleDialog. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK button is clicked. Rename or create the style; before closing the window. void DoUpdate(); Slot called every time the name is changed. Provide some protection; to avoid letting the user use an empty name or an already used one.; A warning message can be shown and the OK button disabled. TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0). » Author: Denis Favre-Miville 08/09/05 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleDialog.html
https://root.cern/root/html604/TStyleDialog.html:118,Modifiability,inherit,inheritance,118,". TStyleDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleDialog. class TStyleDialog: public TGTransientFrame. TStyleDialog. This small class is useful to ask the user for a name and a title,; in order to rename a style, create a new style or import a; style from a canvas. Function Members (Methods); public:. virtual~TStyleDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::",MatchSource.WIKI,root/html604/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleDialog.html
https://root.cern/root/html604/TStyleDialog.html:23649,Safety,avoid,avoid,23649,"untercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TStyleDialog. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window mana",MatchSource.WIKI,root/html604/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleDialog.html
https://root.cern/root/html604/TStyleDialog.html:23693,Safety,avoid,avoid,23693,"untercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TStyleDialog. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window mana",MatchSource.WIKI,root/html604/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleDialog.html
https://root.cern/root/html604/TStyleDialog.html:24747,Safety,avoid,avoid,24747,"CurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TStyleDialog. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK button is clicked. Rename or create the style; before closing the window. void DoUpdate(); Slot called every time the name is changed. Provide some protection; to avoid letting the user use an empty name or an already used one.; A warning message can be shown and the OK button disabled. TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0). » Author: Denis Favre-Miville 08/09/05 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleDialog.html
https://root.cern/root/html604/TStyleManager.html:880,Availability,avail,available,880,". TStyleManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:1405,Availability,avail,available,1405,"nterface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A clone of the selected style will be used as a base of the new; style. All its values can be modified via the style editor later.; The dialog that appears will ask for the name and description of the; new style. Import a style (from a macro):; A style macro can be imported at any time. The new imported style in; the ROOT session will become the selected o",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:3297,Availability,avail,available,3297,"ed at any time. The new imported style in; the ROOT session will become the selected one. Import a style (from a canvas):; You can do that selecting the Style menu/Import from.../Canvas or; the corresponding Tool bar button. A new style will be created in the; ROOT session and will become the selected one. This style is a clone; of the gStyle with modified values as they are set in the currently; selected canvas. You can import a style from any canvas and apply it; later on some objects. Export a style (in a C++ macro file):; To store a style longer than for the current ROOT session you can; save it in a C++ macro file. This can be done via the menu or the; tool bar button. There is a naming convention for the style macros:; the name must be 'Style_*.C', where * can be replaced by anything; you want. Delete a style:; The selected style can be deleted from the list when you use the; Style menu/Delete or the corresponding tool bar button. The selected; style is removed from the list of all available styles for the; current ROOT session. WARRNING: it will be lost if you didn't saved; it in a C++ macro file before its deletion. Also, you cannot delete; the selected style if it is set to gStyle. A message 'Can not delete; gStyle' will be displayed on the CINT prompt. /*. */. Editor's buttons:; Open / close the style editor:; The button 'Edit >>' opens the style editor and its label changes to; 'Close <<'. For all details of what can be changed and how please see; the provided Help. Reset a style (to a previously saved state):; When the editor is opened, the 'Reset' button allows you to reset; the values of the selected style for editing. Doing that you cancel; all changes made since the last time you saved that style in a macro.; If the selected style is one of the five ROOT styles (Plain, Bold,; Video, Pub or Default), it will be recreated. Update the preview:; The button 'Update Preview' is available when a preview is shown and; the run time option is not selected. Thi",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:4215,Availability,avail,available,4215,"g tool bar button. The selected; style is removed from the list of all available styles for the; current ROOT session. WARRNING: it will be lost if you didn't saved; it in a C++ macro file before its deletion. Also, you cannot delete; the selected style if it is set to gStyle. A message 'Can not delete; gStyle' will be displayed on the CINT prompt. /*. */. Editor's buttons:; Open / close the style editor:; The button 'Edit >>' opens the style editor and its label changes to; 'Close <<'. For all details of what can be changed and how please see; the provided Help. Reset a style (to a previously saved state):; When the editor is opened, the 'Reset' button allows you to reset; the values of the selected style for editing. Doing that you cancel; all changes made since the last time you saved that style in a macro.; If the selected style is one of the five ROOT styles (Plain, Bold,; Video, Pub or Default), it will be recreated. Update the preview:; The button 'Update Preview' is available when a preview is shown and; the run time option is not selected. This button allows you to; refresh the preview any time you want to see how the style you edit; looks like. Help button:; Provides a help of the currently selected tab. Function Members (Methods); public:. virtual~TStyleManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuildList(TStyle* style = 0); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char*",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:8792,Availability,error,error,8792," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:8876,Availability,error,error,8876,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:32070,Availability,mask,mask,32070,,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:37422,Availability,error,error,37422,n; TGFileInfo*fCurMacrocurrent macro; TObject*fCurObjcurrent object; TGLabel*fCurObjLabellabel 'Object:'; TGTextEntry*fCurObjTextEntrylabel showing current object's name; TVirtualPad*fCurPadcurrent pad; TGLabel*fCurPadLabellabel 'Canvas:'; TGTextEntry*fCurPadTextEntrylabel showing current pad's name; TStyle*fCurSelStylecurrent selected style; TGLabel*fCurStylabellabel 'gStyle is set to:'; TGTextEntry*fCurStylelabel showing gStyle's name; Int_tfCurTabAxisNumcurrent opened axis tab number; Int_tfCurTabNumcurrent opened tab number; TGNumberEntry*fDateXcanvas date abscissa number entry; TGNumberEntry*fDateYcanvas date ordinate number entry; TGCheckButton*fDrawBorderfunction border show/hide check box; TGHorizontalFrame*fEditionButtonFrameeditor's buttons; TGVerticalFrame*fEditionFrameeditor; TGTextButton*fEditionHelphelp button; TGTextButton*fEditionResetreset button; TGTab*fEditionTabeditor's tabs; TGTextButton*fEditionUpdatePreviewupdate preview button; TGNumberEntry*fEndErrorSizeend error size number entry; TGNumberEntry*fErrorXerror along abscissa number entry; TGColorSelect*fFillColorgeneral fill color selection widget; TGedPatternSelect*fFillStylegeneral fill pattern selection widget; TGTextEntry*fFitFormatfit format text entry; TGLabel*fFitFormatLabellabel 'fit format'; TGButtonGroup*fFrameBorderModeframe border mode button group; TGLineWidthComboBox*fFrameBorderSizeframe border size combo box; TGColorSelect*fFrameFillColorframe fill color selection widget; TGedPatternSelect*fFrameFillStyleframe fill pattern selection widget; TGColorSelect*fFrameLineColorframe line color selection widget; TGLineStyleComboBox*fFrameLineStyleframe line style combo box; TGLineWidthComboBox*fFrameLineWidthframe line width combo box; TGColorSelect*fFuncColorfunction color selection widget; TGLineStyleComboBox*fFuncStylefunction line style combo box; TGLineWidthComboBox*fFuncWidthfunction width number entry; TGColorSelect*fGridColorpad grid line color selection widget; TGLineStyleCombo,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:40121,Availability,avail,available,40121,Tab*fHistosTabhistos' tabs; TGHorizontal3DLine*fHorizontal3DLinea line under the tool bar; TGPopupMenu*fImportCascadeCascaded menu 'Import'; Bool_tfLastChoice=kTRUE if the user choose OK in the last TStyleDialog; TGLayoutHints*fLayoutExpandXoften used layout; TGLayoutHints*fLayoutExpandXCenterYMarginoften used layout; TGLayoutHints*fLayoutExpandXMarginoften used layout; TGLayoutHints*fLayoutExpandXYoften used layout; TGLayoutHints*fLayoutExpandXYMarginoften used layout; TGLineWidthComboBox*fLegendBorderSizelegend border size combo box; TGLabel*fLegendBorderSizeLabellabel 'Legend's'; TGNumberEntry*fLegoInnerRhistograms lego inner radius number entry; TGColorSelect*fLineColorgeneral line color selection widget; TGNumberEntry*fLineScalePSps/pdf line scale number entry; TGLineStyleComboBox*fLineStylegeneral line style combo box; TGTextButton*fLineStyleEditgeneral line style editor open button; TGLineWidthComboBox*fLineWidthgeneral line width combo box; TGComboBox*fListComboBoxlist of available styles; TGLabel*fListLabellabel 'Available Styles:'; TGPictureButton*fMakeDefaultselected style becom gStyle; const TGPicture*fMakeDefaultPicbutton picture; TGColorSelect*fMarkerColorgeneral marker color selection widget; TGComboBox*fMarkerSizegeneral marker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOp,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:40963,Availability,error,errors,40963,extButton*fLineStyleEditgeneral line style editor open button; TGLineWidthComboBox*fLineWidthgeneral line width combo box; TGComboBox*fListComboBoxlist of available styles; TGLabel*fListLabellabel 'Available Styles:'; TGPictureButton*fMakeDefaultselected style becom gStyle; const TGPicture*fMakeDefaultPicbutton picture; TGColorSelect*fMarkerColorgeneral marker color selection widget; TGComboBox*fMarkerSizegeneral marker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOptLogxX axis logarithmic scale check box; TGCheckButton*fOptLogyY axis logarithmic scale check box; TGCheckButton*fOptLogzZ axis logarithmic scale check box; TGCheckButton*fOptStatEntriesstats entries show/hide check box; TGCheckButton*fOptStatErrorsstats errors check box; TGCheckButton*fOptStatIntegralstats integral show/hide check box; TGCheckButton*fOptStatKurtosisstats kurtosis show/hide check box; TGCheckButton*fOptStatMeanstats mean show/hide check box; TGCheckButton*fOptStatNamestats name show/hide check box; TGCheckButton*fOptStatOverflowstats overflow show/hide check box; TGCheckButton*fOptStatRMSstats RMS show/hide check box; TGCheckButton*fOptStatSkewnessstats Skewness show/hide check box; TGCheckButton*fOptStatUnderflowstats underflow show/hide check box; TGCheckButton*fOptTitletitle show/hide check box; TGButtonGroup*,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:41381,Availability,error,errors,41381,arker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOptLogxX axis logarithmic scale check box; TGCheckButton*fOptLogyY axis logarithmic scale check box; TGCheckButton*fOptLogzZ axis logarithmic scale check box; TGCheckButton*fOptStatEntriesstats entries show/hide check box; TGCheckButton*fOptStatErrorsstats errors check box; TGCheckButton*fOptStatIntegralstats integral show/hide check box; TGCheckButton*fOptStatKurtosisstats kurtosis show/hide check box; TGCheckButton*fOptStatMeanstats mean show/hide check box; TGCheckButton*fOptStatNamestats name show/hide check box; TGCheckButton*fOptStatOverflowstats overflow show/hide check box; TGCheckButton*fOptStatRMSstats RMS show/hide check box; TGCheckButton*fOptStatSkewnessstats Skewness show/hide check box; TGCheckButton*fOptStatUnderflowstats underflow show/hide check box; TGCheckButton*fOptTitletitle show/hide check box; TGButtonGroup*fPadBorderModepad border mode button group; TGLineWidthComboBox*fPadBorderSizepad border size combo box; TGNumberEntry*fPadBottomMarginpad bottom margin number entry; TGColorSelect*fPadColorpad fill color selection widget; TGCheckButton*fPadGridXpad grid along X show/hide check box; TGCheckButton*fPadGridYpad grid along Y show/hide check box; TGNumberEntry*fPadLeftMarginpad left margin number entry; TGNumberEntry*f,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:51218,Availability,avail,available,51218,"r or the tool bar. void DoDelete(); Delete the current selected style from the ROOT session.; Called via the menu or the tool bar. void DoRename(); Rename the current selected style. Called via the menu bar. void DoExport(); Save the current selected style in a C++ macro file. Called via the menu; or the tool bar. void DoExit(); Close the style manager. Called via the menu bar. void DoHelp(Int_t i); Open an help window. Called via the menu bar or the tool bar. void DoImportCanvas(); Create a new style (a copy of gStyle) and import the properties of the; current canvas inside. void CreateMacro(); Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this metho",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:60873,Availability,avail,available,60873,"TGCompositeFrame* f, Int_t id); Add a text align combo box to the frame f. TGButtonGroup * AddBorderModeEntry(TGCompositeFrame* f, Int_t id1, Int_t id2, Int_t id3); Add a border mode button group to the frame f. TGComboBox * AddDateFormatEntry(TGCompositeFrame* f, Int_t id); Add a date format combo box to the frame f. TGCheckButton * AddCheckButton(TGCompositeFrame* f, const char* s, Int_t id, Int_t e1 = 0, Int_t e2 = 2); Add a check button to the frame f. TGTextEntry * AddTextEntry(TGCompositeFrame* f, const char* s, Int_t id); Add a text entry to the frame f. A caption can be added. TGComboBox * AddPaperSizeEntry(TGCompositeFrame* f, Int_t id); Add a prefered paper size combo box to the frame f. void DoMenu(Int_t menuID); Slot called when an item of the menu is selected. void DoImportMacro(Bool_t create); Slot called to import a style from a C++ macro file. If create=kTRUE,; a new style is created. Otherwise, the current style is reseted. void DoListSelect(); Slot called when the user select an item in the available styles' list.; Update the preview, the editor, the status bar. The current selected; style is changed. void DoRealTime(Bool_t b); Slot called when the user click on the run time update check button.; If b=kTRUE, the user asks for a real time preview. void DoPreview(Bool_t b); Slot called when the user click on the preview check button. If b=kTRUE,; the user asks for a preview, otherwise they want to close it. void DoPreviewClosed(); Slot called to close the preview, via the preview check button, or; when the preview window is closed via the window manager. void DoMakeDefault(); Slot called to make the current selected style (in the ComboBox); become gStyle. void DoApplyOnSelect(Int_t i); Slot called to choose on which object(s) the 'Apply' button will; have an effect. void DoApplyOn(); Slot called when the user clicks on the 'Apply' button. Apply the; current selected style to the specified object(s). void DoMoreLess(); Slot called when the user try to ",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:69165,Availability,error,error,69165, fill style is modified by the user. void ModFrameLineColor(); Slot called whenever the frame line color is modified by the user. void ModFrameLineWidth(); Slot called whenever the frame line width is modified by the user. void ModFrameLineStyle(); Slot called whenever the frame line style is modified by the user. void ModPaletteEdit(); Slot called whenever the palette editor is opened by the user. void ModFrameBorderMode(); Slot called whenever the frame border mode is modified by the user. void ModFrameBorderSize(); Slot called whenever the frame border size is modified by the user. void ModFuncColor(); Slot called whenever the function line color is modified by the user. void ModFuncWidth(); Slot called whenever the function line width is modified by the user. void ModFuncStyle(); Slot called whenever the function line style is modified by the user. void ModDrawBorder(); Slot called whenever the draw border boolean is modified by the user. void ModEndErrorSize(); Slot called whenever the end error size is modified by the user. void ModErrorX(); Slot called whenever the error along X is modified by the user. void ModTimeOffset(); Slot called whenever the time offset is modified by the user. void ModStripDecimals(); Slot called whenever the strip decimal boolean is modified by the user. void ModApplyOnXYZ(); Slot called whenever the apply on XYZ button is clicked. The settings of; the current selected axis pad are applyed on all axis.; NB: The logarithmic scale option isn't modified by this method. void ModXTitleSize(); Slot called whenever the X axis title size is modified by the user. void ModXTitleSizeInPixels(Bool_t b); Slot called whenever the X axis title size mode is modified by the user. void ModXTitleColor(); Slot called whenever the X axis title color is modified by the user. void ModXTitleOffset(); Slot called whenever the X axis title offset is modified by the user. void ModXTitleFont(); Slot called whenever the X axis title font is modified by the user.,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:69244,Availability,error,error,69244,e frame line color is modified by the user. void ModFrameLineWidth(); Slot called whenever the frame line width is modified by the user. void ModFrameLineStyle(); Slot called whenever the frame line style is modified by the user. void ModPaletteEdit(); Slot called whenever the palette editor is opened by the user. void ModFrameBorderMode(); Slot called whenever the frame border mode is modified by the user. void ModFrameBorderSize(); Slot called whenever the frame border size is modified by the user. void ModFuncColor(); Slot called whenever the function line color is modified by the user. void ModFuncWidth(); Slot called whenever the function line width is modified by the user. void ModFuncStyle(); Slot called whenever the function line style is modified by the user. void ModDrawBorder(); Slot called whenever the draw border boolean is modified by the user. void ModEndErrorSize(); Slot called whenever the end error size is modified by the user. void ModErrorX(); Slot called whenever the error along X is modified by the user. void ModTimeOffset(); Slot called whenever the time offset is modified by the user. void ModStripDecimals(); Slot called whenever the strip decimal boolean is modified by the user. void ModApplyOnXYZ(); Slot called whenever the apply on XYZ button is clicked. The settings of; the current selected axis pad are applyed on all axis.; NB: The logarithmic scale option isn't modified by this method. void ModXTitleSize(); Slot called whenever the X axis title size is modified by the user. void ModXTitleSizeInPixels(Bool_t b); Slot called whenever the X axis title size mode is modified by the user. void ModXTitleColor(); Slot called whenever the X axis title color is modified by the user. void ModXTitleOffset(); Slot called whenever the X axis title offset is modified by the user. void ModXTitleFont(); Slot called whenever the X axis title font is modified by the user. void ModXLabelSize(); Slot called whenever the X axis label size is modified by the ,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:1788,Deployability,update,updates,1788," the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A clone of the selected style will be used as a base of the new; style. All its values can be modified via the style editor later.; The dialog that appears will ask for the name and description of the; new style. Import a style (from a macro):; A style macro can be imported at any time. The new imported style in; the ROOT session will become the selected one. Import a style (from a canvas):; You can do that selecting the Style menu/Import from.../Canvas or; the corresponding Tool bar button. A new style will be created in the; ROOT session and will become the selected one. This style is a clone; of the gStyle with modified values as they are set in the currently; selected canvas. You can import a style from any canvas and apply it; later on some objects. Exp",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:61061,Deployability,update,update,61061,"utton group to the frame f. TGComboBox * AddDateFormatEntry(TGCompositeFrame* f, Int_t id); Add a date format combo box to the frame f. TGCheckButton * AddCheckButton(TGCompositeFrame* f, const char* s, Int_t id, Int_t e1 = 0, Int_t e2 = 2); Add a check button to the frame f. TGTextEntry * AddTextEntry(TGCompositeFrame* f, const char* s, Int_t id); Add a text entry to the frame f. A caption can be added. TGComboBox * AddPaperSizeEntry(TGCompositeFrame* f, Int_t id); Add a prefered paper size combo box to the frame f. void DoMenu(Int_t menuID); Slot called when an item of the menu is selected. void DoImportMacro(Bool_t create); Slot called to import a style from a C++ macro file. If create=kTRUE,; a new style is created. Otherwise, the current style is reseted. void DoListSelect(); Slot called when the user select an item in the available styles' list.; Update the preview, the editor, the status bar. The current selected; style is changed. void DoRealTime(Bool_t b); Slot called when the user click on the run time update check button.; If b=kTRUE, the user asks for a real time preview. void DoPreview(Bool_t b); Slot called when the user click on the preview check button. If b=kTRUE,; the user asks for a preview, otherwise they want to close it. void DoPreviewClosed(); Slot called to close the preview, via the preview check button, or; when the preview window is closed via the window manager. void DoMakeDefault(); Slot called to make the current selected style (in the ComboBox); become gStyle. void DoApplyOnSelect(Int_t i); Slot called to choose on which object(s) the 'Apply' button will; have an effect. void DoApplyOn(); Slot called when the user clicks on the 'Apply' button. Apply the; current selected style to the specified object(s). void DoMoreLess(); Slot called when the user try to show or hide the editor part of the; style manager. void DoEditionUpdatePreview(); Slot called when the user clicks on the 'Update preview' button. void DoChangeTab(Int_t i); Slot cal",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:658,Integrability,interface,interface,658,". TStyleManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:711,Integrability,interface,interface,711,". TStyleManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:3506,Integrability,message,message,3506,"created in the; ROOT session and will become the selected one. This style is a clone; of the gStyle with modified values as they are set in the currently; selected canvas. You can import a style from any canvas and apply it; later on some objects. Export a style (in a C++ macro file):; To store a style longer than for the current ROOT session you can; save it in a C++ macro file. This can be done via the menu or the; tool bar button. There is a naming convention for the style macros:; the name must be 'Style_*.C', where * can be replaced by anything; you want. Delete a style:; The selected style can be deleted from the list when you use the; Style menu/Delete or the corresponding tool bar button. The selected; style is removed from the list of all available styles for the; current ROOT session. WARRNING: it will be lost if you didn't saved; it in a C++ macro file before its deletion. Also, you cannot delete; the selected style if it is set to gStyle. A message 'Can not delete; gStyle' will be displayed on the CINT prompt. /*. */. Editor's buttons:; Open / close the style editor:; The button 'Edit >>' opens the style editor and its label changes to; 'Close <<'. For all details of what can be changed and how please see; the provided Help. Reset a style (to a previously saved state):; When the editor is opened, the 'Reset' button allows you to reset; the values of the selected style for editing. Doing that you cancel; all changes made since the last time you saved that style in a macro.; If the selected style is one of the five ROOT styles (Plain, Bold,; Video, Pub or Default), it will be recreated. Update the preview:; The button 'Update Preview' is available when a preview is shown and; the run time option is not selected. This button allows you to; refresh the preview any time you want to see how the style you edit; looks like. Help button:; Provides a help of the currently selected tab. Function Members (Methods); public:. virtual~TStyleManager(); voidTObject::Abstr",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:49784,Integrability,interface,interface,49784,number entry; TGNumberEntry*fZNdivSubZ axis secondary division number entry; TGNumberEntry*fZNdivSubSubZ axis tertiary division number entry; TGCheckButton*fZNdivisionsOptimizeZ axis division optimization check box; TGNumberEntry*fZTickLengthZ axis tick length number entry; TGColorSelect*fZTitleColorZ axis title color selection widget; TGFontTypeComboBox*fZTitleFontZ axis title font combo box; TGNumberEntry*fZTitleOffsetZ axis title offset number entry; TGNumberEntry*fZTitleSizeZ axis title size number entry; TGCheckButton*fZTitleSizeInPixelsZ axis title size check box; static TStyleManager*fgStyleManagersingleton style manager. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TStyleManager. Function documentation; TStyleManager(const TGWindow* ); Constructor. Create the main window of the style manager. ~TStyleManager(); Destructor. TStyleManager *& GetSM(); static: return style manager. void Init(); Set up the interface. Called by the ctor or by the 'Show' method. void Hide(); Called to hide the style manager. void Show(); Called to show the style manager. Static method. void Terminate(); Called to delete the style manager. Called when the ROOT session is; closed via a canvas' menu. void AddMenus(TGCompositeFrame* p); Add the menu bar to the frame 'p'. void DoNew(); Create a new style. Called via the menu bar or the tool bar. void DoDelete(); Delete the current selected style from the ROOT session.; Called via the menu or the tool bar. void DoRename(); Rename the current selected style. Called via the menu bar. void DoExport(); Save the current selected style in a C++ macro file. Called via the menu; or the tool bar. void DoExit(); Close the style manager. Called via the menu bar. void DoHelp(Int_t i); Open an help window. Called via the menu bar or the tool bar. void DoImportCanvas(); Create a new style (a copy of gStyle) and import the properties of the; current canvas inside. void ,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:51001,Integrability,interface,interface,51001,"e the style manager. Called when the ROOT session is; closed via a canvas' menu. void AddMenus(TGCompositeFrame* p); Add the menu bar to the frame 'p'. void DoNew(); Create a new style. Called via the menu bar or the tool bar. void DoDelete(); Delete the current selected style from the ROOT session.; Called via the menu or the tool bar. void DoRename(); Rename the current selected style. Called via the menu bar. void DoExport(); Save the current selected style in a C++ macro file. Called via the menu; or the tool bar. void DoExit(); Close the style manager. Called via the menu bar. void DoHelp(Int_t i); Open an help window. Called via the menu bar or the tool bar. void DoImportCanvas(); Create a new style (a copy of gStyle) and import the properties of the; current canvas inside. void CreateMacro(); Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect e",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:51048,Integrability,interface,interface,51048,"mpositeFrame* p); Add the menu bar to the frame 'p'. void DoNew(); Create a new style. Called via the menu bar or the tool bar. void DoDelete(); Delete the current selected style from the ROOT session.; Called via the menu or the tool bar. void DoRename(); Rename the current selected style. Called via the menu bar. void DoExport(); Save the current selected style in a C++ macro file. Called via the menu; or the tool bar. void DoExit(); Close the style manager. Called via the menu bar. void DoHelp(Int_t i); Open an help window. Called via the menu bar or the tool bar. void DoImportCanvas(); Create a new style (a copy of gStyle) and import the properties of the; current canvas inside. void CreateMacro(); Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recurs",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:51727,Integrability,interface,interface,51727,"tyle) and import the properties of the; current canvas inside. void CreateMacro(); Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this method, we can know if the style differs from the original style. void AddEdition(TGCompositeFrame* p); Add the editor to the frame 'p'. It contains the tabs allowing the user; to modify every data member of the current TStyle object. void CreateTabGeneral(TGCompositeFrame* tab); Add the tab 'General' to the editor. void AddGeneralFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'General' tab. void AddGeneralLine(TGCompositeFrame* f); Add the 'Line' group frame to the 'General' tab. void AddGeneralText(TGComp",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:51812,Integrability,interface,interface,51812," Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this method, we can know if the style differs from the original style. void AddEdition(TGCompositeFrame* p); Add the editor to the frame 'p'. It contains the tabs allowing the user; to modify every data member of the current TStyle object. void CreateTabGeneral(TGCompositeFrame* tab); Add the tab 'General' to the editor. void AddGeneralFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'General' tab. void AddGeneralLine(TGCompositeFrame* f); Add the 'Line' group frame to the 'General' tab. void AddGeneralText(TGCompositeFrame* f); Add the 'Text' group frame to the 'General' tab. void AddGeneralMa",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:119,Modifiability,inherit,inheritance,119,". TStyleManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:1046,Modifiability,variab,variable,1046,"y. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A clone of the selected style will be used as a bas",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:47002,Performance,optimiz,optimization,47002,BarImportCanvasPictool bar 'Import from canvas' picture; TGPictureButton*fToolBarImportMacrotool bar 'Import from macro' button; const TGPicture*fToolBarImportMacroPictool bar 'Import from macro' picture; TGPictureButton*fToolBarNewtool bar 'New' button; const TGPicture*fToolBarNewPictool bar 'New' picture; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGColorSelect*fXAxisColorX axis color selection widget; TGColorSelect*fXLabelColorX axis label color selection widget; TGFontTypeComboBox*fXLabelFontX axis label font combo box; TGNumberEntry*fXLabelOffsetX axis label offset number entry; TGNumberEntry*fXLabelSizeX axis label size number entry; TGCheckButton*fXLabelSizeInPixelsX axis label size check box; TGNumberEntry*fXNdivMainX axis primary division number entry; TGNumberEntry*fXNdivSubX axis secondary division number entry; TGNumberEntry*fXNdivSubSubX axis tertiary division number entry; TGCheckButton*fXNdivisionsOptimizeX axis division optimization check box; TGNumberEntry*fXTickLengthX axis tick length number entry; TGColorSelect*fXTitleColorX axis title color selection widget; TGFontTypeComboBox*fXTitleFontX axis title font combo box; TGNumberEntry*fXTitleOffsetX axis title offset number entry; TGNumberEntry*fXTitleSizeX axis title size number entry; TGCheckButton*fXTitleSizeInPixelsX axis title size check box; TGColorSelect*fYAxisColorY axis color selection widget; TGColorSelect*fYLabelColorY axis label color selection widget; TGFontTypeComboBox*fYLabelFontY axis label font combo box; TGNumberEntry*fYLabelOffsetY axis label offset number entry; TGNumberEntry*fYLabelSizeY axis label size number entry; TGCheckButton*fYLabelSizeInPixelsY axis label size check box; TGNumberEntry*fYNdivMainY axis primary division number entry; TGNumberEntry*fYNdivSubY axis secondary division number entry; TGNumberEntry*fYNdivSubSubY axis tertiary division number entry; TGCheckButton*fYNdivisionsOptimizeY axis division optimization check box; ,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:47985,Performance,optimiz,optimization,47985,s division optimization check box; TGNumberEntry*fXTickLengthX axis tick length number entry; TGColorSelect*fXTitleColorX axis title color selection widget; TGFontTypeComboBox*fXTitleFontX axis title font combo box; TGNumberEntry*fXTitleOffsetX axis title offset number entry; TGNumberEntry*fXTitleSizeX axis title size number entry; TGCheckButton*fXTitleSizeInPixelsX axis title size check box; TGColorSelect*fYAxisColorY axis color selection widget; TGColorSelect*fYLabelColorY axis label color selection widget; TGFontTypeComboBox*fYLabelFontY axis label font combo box; TGNumberEntry*fYLabelOffsetY axis label offset number entry; TGNumberEntry*fYLabelSizeY axis label size number entry; TGCheckButton*fYLabelSizeInPixelsY axis label size check box; TGNumberEntry*fYNdivMainY axis primary division number entry; TGNumberEntry*fYNdivSubY axis secondary division number entry; TGNumberEntry*fYNdivSubSubY axis tertiary division number entry; TGCheckButton*fYNdivisionsOptimizeY axis division optimization check box; TGNumberEntry*fYTickLengthY axis tick length number entry; TGColorSelect*fYTitleColorY axis title color selection widget; TGFontTypeComboBox*fYTitleFontY axis title font combo box; TGNumberEntry*fYTitleOffsetY axis title offset number entry; TGNumberEntry*fYTitleSizeY axis title size number entry; TGCheckButton*fYTitleSizeInPixelsY axis title size check box; TGColorSelect*fZAxisColorZ axis color selection widget; TGColorSelect*fZLabelColorZ axis label color selection widget; TGFontTypeComboBox*fZLabelFontZ axis label font combo box; TGNumberEntry*fZLabelOffsetZ axis label offset number entry; TGNumberEntry*fZLabelSizeZ axis label size number entry; TGCheckButton*fZLabelSizeInPixelsZ axis label size check box; TGNumberEntry*fZNdivMainZ axis primary division number entry; TGNumberEntry*fZNdivSubZ axis secondary division number entry; TGNumberEntry*fZNdivSubSubZ axis tertiary division number entry; TGCheckButton*fZNdivisionsOptimizeZ axis division optimization check box; ,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:48968,Performance,optimiz,optimization,48968,rY axis color selection widget; TGColorSelect*fYLabelColorY axis label color selection widget; TGFontTypeComboBox*fYLabelFontY axis label font combo box; TGNumberEntry*fYLabelOffsetY axis label offset number entry; TGNumberEntry*fYLabelSizeY axis label size number entry; TGCheckButton*fYLabelSizeInPixelsY axis label size check box; TGNumberEntry*fYNdivMainY axis primary division number entry; TGNumberEntry*fYNdivSubY axis secondary division number entry; TGNumberEntry*fYNdivSubSubY axis tertiary division number entry; TGCheckButton*fYNdivisionsOptimizeY axis division optimization check box; TGNumberEntry*fYTickLengthY axis tick length number entry; TGColorSelect*fYTitleColorY axis title color selection widget; TGFontTypeComboBox*fYTitleFontY axis title font combo box; TGNumberEntry*fYTitleOffsetY axis title offset number entry; TGNumberEntry*fYTitleSizeY axis title size number entry; TGCheckButton*fYTitleSizeInPixelsY axis title size check box; TGColorSelect*fZAxisColorZ axis color selection widget; TGColorSelect*fZLabelColorZ axis label color selection widget; TGFontTypeComboBox*fZLabelFontZ axis label font combo box; TGNumberEntry*fZLabelOffsetZ axis label offset number entry; TGNumberEntry*fZLabelSizeZ axis label size number entry; TGCheckButton*fZLabelSizeInPixelsZ axis label size check box; TGNumberEntry*fZNdivMainZ axis primary division number entry; TGNumberEntry*fZNdivSubZ axis secondary division number entry; TGNumberEntry*fZNdivSubSubZ axis tertiary division number entry; TGCheckButton*fZNdivisionsOptimizeZ axis division optimization check box; TGNumberEntry*fZTickLengthZ axis tick length number entry; TGColorSelect*fZTitleColorZ axis title color selection widget; TGFontTypeComboBox*fZTitleFontZ axis title font combo box; TGNumberEntry*fZTitleOffsetZ axis title offset number entry; TGNumberEntry*fZTitleSizeZ axis title size number entry; TGCheckButton*fZTitleSizeInPixelsZ axis title size check box; static TStyleManager*fgStyleManagersingleton style manager.,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:51631,Performance,load,loaded,51631,"the tool bar. void DoImportCanvas(); Create a new style (a copy of gStyle) and import the properties of the; current canvas inside. void CreateMacro(); Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this method, we can know if the style differs from the original style. void AddEdition(TGCompositeFrame* p); Add the editor to the frame 'p'. It contains the tabs allowing the user; to modify every data member of the current TStyle object. void CreateTabGeneral(TGCompositeFrame* tab); Add the tab 'General' to the editor. void AddGeneralFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'General' tab. void AddGeneralLine(TGCompositeFrame* f); Add t",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:46341,Safety,avoid,avoid,46341,fTitleTextColortitle text color selection widget; TGNumberEntry*fTitleWtitle width number entry; TGNumberEntry*fTitleXtitle abscissa number entry; TGNumberEntry*fTitleYtitle ordinate number entry; TGToolBar*fToolBarthe tool bar; TGPictureButton*fToolBarDeletetool bar 'Delete' button; const TGPicture*fToolBarDeletePictool bar 'Delete' picture; TGPictureButton*fToolBarExporttool bar 'Export' button; const TGPicture*fToolBarExportPictool bar 'Export' picture; TGPictureButton*fToolBarHelptool bar 'Help' button; const TGPicture*fToolBarHelpPictool bar 'Help' picture; TGPictureButton*fToolBarImportCanvastool bar 'Import from canvas' button; const TGPicture*fToolBarImportCanvasPictool bar 'Import from canvas' picture; TGPictureButton*fToolBarImportMacrotool bar 'Import from macro' button; const TGPicture*fToolBarImportMacroPictool bar 'Import from macro' picture; TGPictureButton*fToolBarNewtool bar 'New' button; const TGPicture*fToolBarNewPictool bar 'New' picture; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGColorSelect*fXAxisColorX axis color selection widget; TGColorSelect*fXLabelColorX axis label color selection widget; TGFontTypeComboBox*fXLabelFontX axis label font combo box; TGNumberEntry*fXLabelOffsetX axis label offset number entry; TGNumberEntry*fXLabelSizeX axis label size number entry; TGCheckButton*fXLabelSizeInPixelsX axis label size check box; TGNumberEntry*fXNdivMainX axis primary division number entry; TGNumberEntry*fXNdivSubX axis secondary division number entry; TGNumberEntry*fXNdivSubSubX axis tertiary division number entry; TGCheckButton*fXNdivisionsOptimizeX axis division optimization check box; TGNumberEntry*fXTickLengthX axis tick length number entry; TGColorSelect*fXTitleColorX axis title color selection widget; TGFontTypeComboBox*fXTitleFontX axis title font combo box; TGNumberEntry*fXTitleOffsetX axis title offset number entry; TGNumberEntry*fXTitleSizeX axis title size number entry; TGCheckButton*fXTit,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:46385,Safety,avoid,avoid,46385,dget; TGNumberEntry*fTitleWtitle width number entry; TGNumberEntry*fTitleXtitle abscissa number entry; TGNumberEntry*fTitleYtitle ordinate number entry; TGToolBar*fToolBarthe tool bar; TGPictureButton*fToolBarDeletetool bar 'Delete' button; const TGPicture*fToolBarDeletePictool bar 'Delete' picture; TGPictureButton*fToolBarExporttool bar 'Export' button; const TGPicture*fToolBarExportPictool bar 'Export' picture; TGPictureButton*fToolBarHelptool bar 'Help' button; const TGPicture*fToolBarHelpPictool bar 'Help' picture; TGPictureButton*fToolBarImportCanvastool bar 'Import from canvas' button; const TGPicture*fToolBarImportCanvasPictool bar 'Import from canvas' picture; TGPictureButton*fToolBarImportMacrotool bar 'Import from macro' button; const TGPicture*fToolBarImportMacroPictool bar 'Import from macro' picture; TGPictureButton*fToolBarNewtool bar 'New' button; const TGPicture*fToolBarNewPictool bar 'New' picture; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGColorSelect*fXAxisColorX axis color selection widget; TGColorSelect*fXLabelColorX axis label color selection widget; TGFontTypeComboBox*fXLabelFontX axis label font combo box; TGNumberEntry*fXLabelOffsetX axis label offset number entry; TGNumberEntry*fXLabelSizeX axis label size number entry; TGCheckButton*fXLabelSizeInPixelsX axis label size check box; TGNumberEntry*fXNdivMainX axis primary division number entry; TGNumberEntry*fXNdivSubX axis secondary division number entry; TGNumberEntry*fXNdivSubSubX axis tertiary division number entry; TGCheckButton*fXNdivisionsOptimizeX axis division optimization check box; TGNumberEntry*fXTickLengthX axis tick length number entry; TGColorSelect*fXTitleColorX axis title color selection widget; TGFontTypeComboBox*fXTitleFontX axis title font combo box; TGNumberEntry*fXTitleOffsetX axis title offset number entry; TGNumberEntry*fXTitleSizeX axis title size number entry; TGCheckButton*fXTitleSizeInPixelsX axis title size check box; T,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:52069,Safety,avoid,avoid,52069,"ill provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this method, we can know if the style differs from the original style. void AddEdition(TGCompositeFrame* p); Add the editor to the frame 'p'. It contains the tabs allowing the user; to modify every data member of the current TStyle object. void CreateTabGeneral(TGCompositeFrame* tab); Add the tab 'General' to the editor. void AddGeneralFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'General' tab. void AddGeneralLine(TGCompositeFrame* f); Add the 'Line' group frame to the 'General' tab. void AddGeneralText(TGCompositeFrame* f); Add the 'Text' group frame to the 'General' tab. void AddGeneralMarker(TGCompositeFrame* f); Add the 'Marker' group frame to the 'General' tab. void CreateTabCanvas(TGCompositeFrame* tab); Add the tab 'Canvas' to the editor. void AddCanvasFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'Canvas' tab. void AddCanvasGeome",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:41138,Testability,log,logarithmic,41138,el*fListLabellabel 'Available Styles:'; TGPictureButton*fMakeDefaultselected style becom gStyle; const TGPicture*fMakeDefaultPicbutton picture; TGColorSelect*fMarkerColorgeneral marker color selection widget; TGComboBox*fMarkerSizegeneral marker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOptLogxX axis logarithmic scale check box; TGCheckButton*fOptLogyY axis logarithmic scale check box; TGCheckButton*fOptLogzZ axis logarithmic scale check box; TGCheckButton*fOptStatEntriesstats entries show/hide check box; TGCheckButton*fOptStatErrorsstats errors check box; TGCheckButton*fOptStatIntegralstats integral show/hide check box; TGCheckButton*fOptStatKurtosisstats kurtosis show/hide check box; TGCheckButton*fOptStatMeanstats mean show/hide check box; TGCheckButton*fOptStatNamestats name show/hide check box; TGCheckButton*fOptStatOverflowstats overflow show/hide check box; TGCheckButton*fOptStatRMSstats RMS show/hide check box; TGCheckButton*fOptStatSkewnessstats Skewness show/hide check box; TGCheckButton*fOptStatUnderflowstats underflow show/hide check box; TGCheckButton*fOptTitletitle show/hide check box; TGButtonGroup*fPadBorderModepad border mode button group; TGLineWidthComboBox*fPadBorderSizepad border size combo box; TGNumberEntry*fPadBottomMarginpad bottom margin number entry; TGColorSel,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:41196,Testability,log,logarithmic,41196,akeDefaultselected style becom gStyle; const TGPicture*fMakeDefaultPicbutton picture; TGColorSelect*fMarkerColorgeneral marker color selection widget; TGComboBox*fMarkerSizegeneral marker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOptLogxX axis logarithmic scale check box; TGCheckButton*fOptLogyY axis logarithmic scale check box; TGCheckButton*fOptLogzZ axis logarithmic scale check box; TGCheckButton*fOptStatEntriesstats entries show/hide check box; TGCheckButton*fOptStatErrorsstats errors check box; TGCheckButton*fOptStatIntegralstats integral show/hide check box; TGCheckButton*fOptStatKurtosisstats kurtosis show/hide check box; TGCheckButton*fOptStatMeanstats mean show/hide check box; TGCheckButton*fOptStatNamestats name show/hide check box; TGCheckButton*fOptStatOverflowstats overflow show/hide check box; TGCheckButton*fOptStatRMSstats RMS show/hide check box; TGCheckButton*fOptStatSkewnessstats Skewness show/hide check box; TGCheckButton*fOptStatUnderflowstats underflow show/hide check box; TGCheckButton*fOptTitletitle show/hide check box; TGButtonGroup*fPadBorderModepad border mode button group; TGLineWidthComboBox*fPadBorderSizepad border size combo box; TGNumberEntry*fPadBottomMarginpad bottom margin number entry; TGColorSelect*fPadColorpad fill color selection widget; TGCheckButto,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:41254,Testability,log,logarithmic,41254,keDefaultPicbutton picture; TGColorSelect*fMarkerColorgeneral marker color selection widget; TGComboBox*fMarkerSizegeneral marker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOptLogxX axis logarithmic scale check box; TGCheckButton*fOptLogyY axis logarithmic scale check box; TGCheckButton*fOptLogzZ axis logarithmic scale check box; TGCheckButton*fOptStatEntriesstats entries show/hide check box; TGCheckButton*fOptStatErrorsstats errors check box; TGCheckButton*fOptStatIntegralstats integral show/hide check box; TGCheckButton*fOptStatKurtosisstats kurtosis show/hide check box; TGCheckButton*fOptStatMeanstats mean show/hide check box; TGCheckButton*fOptStatNamestats name show/hide check box; TGCheckButton*fOptStatOverflowstats overflow show/hide check box; TGCheckButton*fOptStatRMSstats RMS show/hide check box; TGCheckButton*fOptStatSkewnessstats Skewness show/hide check box; TGCheckButton*fOptStatUnderflowstats underflow show/hide check box; TGCheckButton*fOptTitletitle show/hide check box; TGButtonGroup*fPadBorderModepad border mode button group; TGLineWidthComboBox*fPadBorderSizepad border size combo box; TGNumberEntry*fPadBottomMarginpad bottom margin number entry; TGColorSelect*fPadColorpad fill color selection widget; TGCheckButton*fPadGridXpad grid along X show/hide check box; TGCheckBu,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:69624,Testability,log,logarithmic,69624,user. void ModFrameBorderSize(); Slot called whenever the frame border size is modified by the user. void ModFuncColor(); Slot called whenever the function line color is modified by the user. void ModFuncWidth(); Slot called whenever the function line width is modified by the user. void ModFuncStyle(); Slot called whenever the function line style is modified by the user. void ModDrawBorder(); Slot called whenever the draw border boolean is modified by the user. void ModEndErrorSize(); Slot called whenever the end error size is modified by the user. void ModErrorX(); Slot called whenever the error along X is modified by the user. void ModTimeOffset(); Slot called whenever the time offset is modified by the user. void ModStripDecimals(); Slot called whenever the strip decimal boolean is modified by the user. void ModApplyOnXYZ(); Slot called whenever the apply on XYZ button is clicked. The settings of; the current selected axis pad are applyed on all axis.; NB: The logarithmic scale option isn't modified by this method. void ModXTitleSize(); Slot called whenever the X axis title size is modified by the user. void ModXTitleSizeInPixels(Bool_t b); Slot called whenever the X axis title size mode is modified by the user. void ModXTitleColor(); Slot called whenever the X axis title color is modified by the user. void ModXTitleOffset(); Slot called whenever the X axis title offset is modified by the user. void ModXTitleFont(); Slot called whenever the X axis title font is modified by the user. void ModXLabelSize(); Slot called whenever the X axis label size is modified by the user. void ModXLabelSizeInPixels(Bool_t b); Slot called whenever the X axis label size mode is modified by the user. void ModXLabelColor(); Slot called whenever the X axis label color is modified by the user. void ModXLabelOffset(); Slot called whenever the X axis label offset is modified by the user. void ModXLabelFont(); Slot called whenever the X axis label font is modified by the user. void ModXAxis,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:70862,Testability,log,log,70862,s modified by the user. void ModXTitleColor(); Slot called whenever the X axis title color is modified by the user. void ModXTitleOffset(); Slot called whenever the X axis title offset is modified by the user. void ModXTitleFont(); Slot called whenever the X axis title font is modified by the user. void ModXLabelSize(); Slot called whenever the X axis label size is modified by the user. void ModXLabelSizeInPixels(Bool_t b); Slot called whenever the X axis label size mode is modified by the user. void ModXLabelColor(); Slot called whenever the X axis label color is modified by the user. void ModXLabelOffset(); Slot called whenever the X axis label offset is modified by the user. void ModXLabelFont(); Slot called whenever the X axis label font is modified by the user. void ModXAxisColor(); Slot called whenever the X axis color is modified by the user. void ModXTickLength(); Slot called whenever the X axis tick length is modified by the user. void ModOptLogx(); Slot called whenever the X axis log scale boolean is modified; by the user. void ModXNdivisions(); Slot called whenever the X axis Number of divisions is modified; by the user. void ModYTitleSize(); Slot called whenever the Y axis title size is modified by the user. void ModYTitleSizeInPixels(Bool_t b); Slot called whenever the Y axis title size mode is modified by the user. void ModYTitleColor(); Slot called whenever the Y axis title color is modified by the user. void ModYTitleOffset(); Slot called whenever the Y axis title offset is modified by the user. void ModYTitleFont(); Slot called whenever the Y axis title font is modified by the user. void ModYLabelSize(); Slot called whenever the Y axis label size is modified by the user. void ModYLabelSizeInPixels(Bool_t b); Slot called whenever the Y axis label size mode is modified by the user. void ModYLabelColor(); Slot called whenever the Y axis label color is modified by the user. void ModYLabelOffset(); Slot called whenever the Y axis label offset is modified ,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:72189,Testability,log,log,72189,s modified by the user. void ModYTitleColor(); Slot called whenever the Y axis title color is modified by the user. void ModYTitleOffset(); Slot called whenever the Y axis title offset is modified by the user. void ModYTitleFont(); Slot called whenever the Y axis title font is modified by the user. void ModYLabelSize(); Slot called whenever the Y axis label size is modified by the user. void ModYLabelSizeInPixels(Bool_t b); Slot called whenever the Y axis label size mode is modified by the user. void ModYLabelColor(); Slot called whenever the Y axis label color is modified by the user. void ModYLabelOffset(); Slot called whenever the Y axis label offset is modified by the user. void ModYLabelFont(); Slot called whenever the Y axis label font is modified by the user. void ModYAxisColor(); Slot called whenever the Y axis color is modified by the user. void ModYTickLength(); Slot called whenever the Y axis tick length is modified by the user. void ModOptLogy(); Slot called whenever the Y axis log scale boolean is modified by the user. void ModYNdivisions(); Slot called whenever the Y axis Number of divisions is modified; by the user. void ModZTitleSize(); Slot called whenever the Z axis title size is modified by the user. void ModZTitleSizeInPixels(Bool_t b); Slot called whenever the Z axis title size mode is modified by the user. void ModZTitleColor(); Slot called whenever the Z axis title color is modified by the user. void ModZTitleOffset(); Slot called whenever the Z axis title offset is modified by the user. void ModZTitleFont(); Slot called whenever the Z axis title font is modified by the user. void ModZLabelSize(); Slot called whenever the Z axis label size is modified by the user. void ModZLabelSizeInPixels(Bool_t b); Slot called whenever the Z axis Label size mode is modified by the user. void ModZLabelColor(); Slot called whenever the Z axis label color is modified by the user. void ModZLabelOffset(); Slot called whenever the Z axis label offset is modified ,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:73515,Testability,log,log,73515,s modified by the user. void ModZTitleColor(); Slot called whenever the Z axis title color is modified by the user. void ModZTitleOffset(); Slot called whenever the Z axis title offset is modified by the user. void ModZTitleFont(); Slot called whenever the Z axis title font is modified by the user. void ModZLabelSize(); Slot called whenever the Z axis label size is modified by the user. void ModZLabelSizeInPixels(Bool_t b); Slot called whenever the Z axis Label size mode is modified by the user. void ModZLabelColor(); Slot called whenever the Z axis label color is modified by the user. void ModZLabelOffset(); Slot called whenever the Z axis label offset is modified by the user. void ModZLabelFont(); Slot called whenever the Z axis label font is modified by the user. void ModZAxisColor(); Slot called whenever the Z axis color is modified by the user. void ModZTickLength(); Slot called whenever the Z axis tick length is modified by the user. void ModOptLogz(); Slot called whenever the Z axis log scale boolean is modified by the user. void ModZNdivisions(); Slot called whenever the Z axis Number of divisions is modified; by the user. void ModOptTitle(); Slot called whenever the OptTitle boolean is modified by the user. void ModTitleFillColor(); Slot called whenever the title fill color is modified by the user. void ModTitleStyle(); Slot called whenever the title fill style is modified by the user. void ModTitleTextColor(); Slot called whenever the title text color is modified by the user. void ModTitleFontSize(); Slot called whenever the text size is modified by the user. void ModTitleFontSizeInPixels(Bool_t b); Slot called whenever the text size mode is modified by the user. void ModTitleFont(); Slot called whenever the title text font is modified by the user. void ModTitleAlign(); Slot called whenever the title text align is modified by the user. void ModTitleBorderSize(); Slot called whenever the title border size is modified by the user. void ModLegendBorderSize();,MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStyleManager.html:1446,Usability,undo,undo,1446,"cted object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A clone of the selected style will be used as a base of the new; style. All its values can be modified via the style editor later.; The dialog that appears will ask for the name and description of the; new style. Import a style (from a macro):; A style macro can be imported at any time. The new imported style in; the ROOT session will become the selected one. Import a style (from a canvas):; You can do that selecting the Style menu/Import from.../Canvas or; the corresponding Tool b",MatchSource.WIKI,root/html604/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStyleManager.html
https://root.cern/root/html604/TStylePreview.html:4527,Availability,error,error,4527," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html604/TStylePreview.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStylePreview.html
https://root.cern/root/html604/TStylePreview.html:4611,Availability,error,error,4611,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html604/TStylePreview.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStylePreview.html
https://root.cern/root/html604/TStylePreview.html:20253,Availability,mask,mask,20253,,MatchSource.WIKI,root/html604/TStylePreview.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStylePreview.html
https://root.cern/root/html604/TStylePreview.html:119,Modifiability,inherit,inheritance,119,". TStylePreview. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStylePreview. class TStylePreview: public TGTransientFrame. TStylePreview. This class may be used to preview the result of applying a style; to a canvas. The result is shown on a clone of the object,; in a different shown over the initial canvas. Function Members (Methods); public:. virtual~TStylePreview(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* sl",MatchSource.WIKI,root/html604/TStylePreview.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStylePreview.html
https://root.cern/root/html604/TStylePreview.html:23386,Safety,avoid,avoid,23386,"ignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TRootEmbeddedCanvas*fEcancanvas for preview; TVirtualPad*fPadoriginal pad previewed; TList*fTrashListLayoutto avoid memory leak. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TStylePreview. Function documentation; TStylePreview(const TGWindow* p, TStyle* style, TVirtualPad* currentPad); Constructor. Create a new window and draw a clone of; currentPad->GetCanvas() in it, using the style 'style'.; Thanks to that method, one can have a preview of any; style with any object. ~TStylePreview(); Destructor. void Update(TStyle* style, TVirtualPad* pad); Update the preview with possibly another style and; another object than previously. void MapTheWindow(); Initialize the layout algorithm. TCanvas * GetMainCanvas(); Return pointer to the selected canvas. TStylePreview(const TGWindow* p, TStyle* style, TVirtualPad* currentPad). » Author: Denis Favre-Miville 08/09/05 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id",MatchSource.WIKI,root/html604/TStylePreview.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TStylePreview.html
https://root.cern/root/html604/TSubString.html:2519,Availability,error,error,2519,"onst; TString&String(); voidToLower(); voidToUpper(); TSubString(const TSubString& s). protected:. voidAssertElement(Ssiz_t i) const; voidSubStringError(Ssiz_t, Ssiz_t, Ssiz_t) const. private:. TSubString(const TString& s, Ssiz_t start, Ssiz_t len). Data Members; private:. Ssiz_tfBeginIndex of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSubString(const TString& s, Ssiz_t start, Ssiz_t len); Private constructor. char& operator[](Ssiz_t i); Return character at pos i from sub-string. Check validity of i. char& operator()(Ssiz_t i); Return character at pos i from sub-string. No check on i. TSubString& operator=(const TString& s); Assign string to sub-string. TSubString& operator=(const char* s); Assign char* to sub-string. void ToLower(); Convert sub-string to lower-case. void ToUpper(); Convert sub-string to upper-case. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const; Output error message. void AssertElement(Ssiz_t i) const; Check to make sure a sub-string index is in range. const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s,",MatchSource.WIKI,root/html604/TSubString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSubString.html
https://root.cern/root/html604/TSubString.html:2525,Integrability,message,message,2525,"onst; TString&String(); voidToLower(); voidToUpper(); TSubString(const TSubString& s). protected:. voidAssertElement(Ssiz_t i) const; voidSubStringError(Ssiz_t, Ssiz_t, Ssiz_t) const. private:. TSubString(const TString& s, Ssiz_t start, Ssiz_t len). Data Members; private:. Ssiz_tfBeginIndex of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSubString(const TString& s, Ssiz_t start, Ssiz_t len); Private constructor. char& operator[](Ssiz_t i); Return character at pos i from sub-string. Check validity of i. char& operator()(Ssiz_t i); Return character at pos i from sub-string. No check on i. TSubString& operator=(const TString& s); Assign string to sub-string. TSubString& operator=(const char* s); Assign char* to sub-string. void ToLower(); Convert sub-string to lower-case. void ToUpper(); Convert sub-string to upper-case. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const; Output error message. void AssertElement(Ssiz_t i) const; Check to make sure a sub-string index is in range. const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s,",MatchSource.WIKI,root/html604/TSubString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSubString.html
https://root.cern/root/html604/TSubString.html:3673,Safety,detect,detecting,3673,"rom sub-string. Check validity of i. char& operator()(Ssiz_t i); Return character at pos i from sub-string. No check on i. TSubString& operator=(const TString& s); Assign string to sub-string. TSubString& operator=(const char* s); Assign char* to sub-string. void ToLower(); Convert sub-string to lower-case. void ToUpper(); Convert sub-string to upper-case. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const; Output error message. void AssertElement(Ssiz_t i) const; Check to make sure a sub-string index is in range. const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. Ssiz_t Length() const; { return fExtent; }. Ssiz_t Start() const; { return fBegin; }. Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TSubString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSubString.html
https://root.cern/root/html604/TSubString.html:420,Security,access,accessed,420,". TSubString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSubString. class TSubString. TString. Basic string class. Cannot be stored in a TCollection... use TObjString instead. The underlying string is stored as a char* that can be accessed via; TString::Data().; TString provides Short String Optimization (SSO) so that short; strings (<15 on 64-bit and <11 on 32-bit) are contained in the; TString internal data structure without the need for mallocing the; required space. Substring operations are provided by the TSubString class, which; holds a reference to the original string and its data, along with; the offset and length of the substring. To retrieve the substring; as a TString, construct a TString from it, eg:; root [0] TString s(""hello world""); root [1] TString s2( s(0,5) ); root [2] s2; (class TString)""hello"". Function Members (Methods); public:. ~TSubString(); const char*Data() const; Bool_tIsNull() const; Ssiz_tLength() const; stringoperator basic_string() const; string_viewoperator basic_string_view() const; intoperator!() const; char&operator()(Ssiz_t i); charoperator()(Ssiz_t i) const; TSubString&operator=(const char* s); TSubString&operator=(const TString& s); TSubString&operator=(const TSubString& s); char&operator[](Ssiz_t i); charoperator[](Ssiz_t i) const; Ssiz_tStart() const; TString&String(); voidToLower(); voidToUpper(); TSubString(const TSubString& s). protected:. voidAssertElement(Ssiz_t i) const; voidSubStringError(Ssiz_t, Ssiz_t, Ssiz_t) const. private:. TSubString(const TString& s, Ssiz_t start, Ssiz_t len). Data Members; private:. Ssiz_tfBeginIndex of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSubString(const TString& s, Ssiz_",MatchSource.WIKI,root/html604/TSubString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSubString.html
https://root.cern/root/html604/TSVDUnfold.html:1150,Availability,error,errors,1150," TSVDUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TSVDUnfold. class TSVDUnfold: public TObject. SVD Approach to Data Unfolding. Reference: Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]. TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum.; ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition.; ; Monte Carlo inputs:; ; xini: true underlying spectrum (TH1D, n bins); bini: reconstructed spectrum (TH1D, n bins); Adet: response matrix (TH2D, nxn bins); ; Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will le",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:4095,Availability,error,error,4095,"l~TSVDUnfold(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeChiSquared(const TH1D& truspec, const TH1D& unfspec); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TH2D*GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); TH2D*GetBCov() const; TH1D*GetD() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetKReg() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1D*GetSV() const; virtual const char*TObject::GetTitle() const; TH2D*GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); virtual UInt_tTObject::GetUniqueID() const; TH2D*GetXinv() con",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:4179,Availability,error,error,4179,"Object::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeChiSquared(const TH1D& truspec, const TH1D& unfspec); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TH2D*GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); TH2D*GetBCov() const; TH1D*GetD() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetKReg() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1D*GetSV() const; virtual const char*TObject::GetTitle() const; TH2D*GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); virtual UInt_tTObject::GetUniqueID() const; TH2D*GetXinv() const; TH2D*GetXtau() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:11379,Availability,error,error,11379,"umentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments; Note that this covariance matrix will contain effects of forced normalisation if spectrum is normalised to unit area. TH2D* GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); Determine covariance matrix of unfolded spectrum from finite statistics in; response matrix using pseudo experiments; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments. TH1D* GetD() const; Returns d vector (for choosing appropriate regularisation). TH1D* GetSV() const; Returns singular values vector. TH2D* GetXtau() const; Returns the computed regularized covariance matrix corresponding to total uncertainties on measured spectrum as passed in the constructor.; Note that this covariance matrix will not contain the effects of forced normalization if spectrum is normalized to unit area. TH2D* GetXinv() const; Returns the computed ",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:12768,Availability,error,errors,12768,"d normalisation if spectrum is normalised to unit area. TH2D* GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); Determine covariance matrix of unfolded spectrum from finite statistics in; response matrix using pseudo experiments; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments. TH1D* GetD() const; Returns d vector (for choosing appropriate regularisation). TH1D* GetSV() const; Returns singular values vector. TH2D* GetXtau() const; Returns the computed regularized covariance matrix corresponding to total uncertainties on measured spectrum as passed in the constructor.; Note that this covariance matrix will not contain the effects of forced normalization if spectrum is normalized to unit area. TH2D* GetXinv() const; Returns the computed inverse of the covariance matrix. TH2D* GetBCov() const; Returns the covariance matrix. void H2V(const TH1D* histo, TVectorD& vec); Fill 1D histogram into vector. void H2Verr(const TH1D* histo, TVectorD& vec); Fill 1D histogram errors into vector. void V2H(const TVectorD& vec, TH1D& histo); Fill vector into 1D histogram. void H2M(const TH2D* histo, TMatrixD& mat); Fill 2D histogram into matrix. void M2H(const TMatrixD& mat, TH2D& histo); Fill 2D histogram into matrix. TVectorD VecDiv(const TVectorD& vec1, const TVectorD& vec2, Int_t zero = 0); Divide entries of two vectors. TMatrixD MatDivVec(const TMatrixD& mat, const TVectorD& vec, Int_t zero = 0); Divide matrix entries by vector. TVectorD CompProd(const TVectorD& vec1, const TVectorD& vec2); Multiply entries of two vectors. Double_t GetCurvature(const TVectorD& vec, const TMatrixD& curv); Compute curvature of vector. void FillCurvatureMatrix(TMatrixD& tCurv, TMatrixD& tC) const. void InitHistos(). void RegularisedSymMatInvert(TMatrixDSym& mat, Double_t eps = 0.001); naive regularised inversion cuts off small elements. Double_t ComputeChiSquared(const TH1D& truspec, const TH1D& unfspec); Helper routine to compute chi-squared between d",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:13705,Integrability,rout,routine,13705,"his covariance matrix will not contain the effects of forced normalization if spectrum is normalized to unit area. TH2D* GetXinv() const; Returns the computed inverse of the covariance matrix. TH2D* GetBCov() const; Returns the covariance matrix. void H2V(const TH1D* histo, TVectorD& vec); Fill 1D histogram into vector. void H2Verr(const TH1D* histo, TVectorD& vec); Fill 1D histogram errors into vector. void V2H(const TVectorD& vec, TH1D& histo); Fill vector into 1D histogram. void H2M(const TH2D* histo, TMatrixD& mat); Fill 2D histogram into matrix. void M2H(const TMatrixD& mat, TH2D& histo); Fill 2D histogram into matrix. TVectorD VecDiv(const TVectorD& vec1, const TVectorD& vec2, Int_t zero = 0); Divide entries of two vectors. TMatrixD MatDivVec(const TMatrixD& mat, const TVectorD& vec, Int_t zero = 0); Divide matrix entries by vector. TVectorD CompProd(const TVectorD& vec1, const TVectorD& vec2); Multiply entries of two vectors. Double_t GetCurvature(const TVectorD& vec, const TMatrixD& curv); Compute curvature of vector. void FillCurvatureMatrix(TMatrixD& tCurv, TMatrixD& tC) const. void InitHistos(). void RegularisedSymMatInvert(TMatrixDSym& mat, Double_t eps = 0.001); naive regularised inversion cuts off small elements. Double_t ComputeChiSquared(const TH1D& truspec, const TH1D& unfspec); Helper routine to compute chi-squared between distributions using the computed inverse of the covariance matrix for the unfolded spectrum as given in paper. void SetNormalize(Bool_t normalize); Set option to normalize unfolded spectrum to unit area; ""normalize"" - switch. { fNormalize = normalize; }. Int_t GetKReg() const; Regularisation parameter. { return fKReg; }. » Author: Kerstin Tackmann, Andreas Hoecker, Heiko Lacker » Copyright (c) 2010: *; » Last changed: Tue Jun 2 16:32:36 2015 » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:116,Modifiability,inherit,inheritance,116,". TSVDUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TSVDUnfold. class TSVDUnfold: public TObject. SVD Approach to Data Unfolding. Reference: Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]. TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum.; ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition.; ; Monte Carlo inputs:; ; xini: true underlying spectrum (TH1D, n bins); bini: reconstructed spectrum (TH1D, n bins); Adet: response matrix (TH2D, nxn bins); ; Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will l",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:1649,Performance,perform,performed,1649,"trum.; ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition.; ; Monte Carlo inputs:; ; xini: true underlying spectrum (TH1D, n bins); bini: reconstructed spectrum (TH1D, n bins); Adet: response matrix (TH2D, nxn bins); ; Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i|<\tt> that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments.; ; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the GetUnfoldCovMatrix method, which uses pseudo experiments for the propagation. In addition, GetAdetCovMatrix allows for the propagation of the statistical uncertainties on the respo",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:1284,Safety,detect,detector,1284,"um. Meth. A372, 469 (1996) [hep-ph/9509307]. TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum.; ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition.; ; Monte Carlo inputs:; ; xini: true underlying spectrum (TH1D, n bins); bini: reconstructed spectrum (TH1D, n bins); Adet: response matrix (TH2D, nxn bins); ; Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i|<\tt> that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments.; ; Covariance matrices on the measured spectrum (for either the total uncertai",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:10299,Safety,detect,detector,10299,"asUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. const TH2D*fAdetDetector response matrix; TH2D*fBcovcovariance matrix of measured distribution (data); const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHist! Distribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance Chart:. TObject. ←; TSVDUnfold. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as w",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:10711,Safety,detect,detector,10711," (data); const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHist! Distribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance Chart:. TObject. ←; TSVDUnfold. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments;",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:11034,Safety,detect,detector,11034,"tion of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance Chart:. TObject. ←; TSVDUnfold. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments; Note that this covariance matrix will contain effects of forced normalisation if spectrum is normalised to unit area. TH2D* GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); Determine covariance matrix of unfolded spectrum from finite statistics in; response matrix using pseudo experiments; ""nto",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:10686,Testability,test,test,10686," (data); const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHist! Distribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance Chart:. TObject. ←; TSVDUnfold. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments;",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:11009,Testability,test,test,11009,"tion of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance Chart:. TObject. ←; TSVDUnfold. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments; Note that this covariance matrix will contain effects of forced normalisation if spectrum is normalised to unit area. TH2D* GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); Determine covariance matrix of unfolded spectrum from finite statistics in; response matrix using pseudo experiments; ""nto",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVDUnfold.html:2108,Usability,guid,guidelines,2108,"ed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i|<\tt> that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments.; ; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the GetUnfoldCovMatrix method, which uses pseudo experiments for the propagation. In addition, GetAdetCovMatrix allows for the propagation of the statistical uncertainties on the response matrix using pseudo experiments. The covariance matrix corresponding to Bcov is also computed as described in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] and can be obtained from tsvdunf->GetXtau() and its (regularisation independent) inverse from tsvdunf->GetXinv(). The distribution of singular values can be retrieved using tsvdunf->GetSV().; ; See also the tutorial for a toy example.; ; . Function Members (Methods); public:",MatchSource.WIKI,root/html604/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVDUnfold.html
https://root.cern/root/html604/TSVG.html:3268,Availability,error,error,3268,"py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); voidDrawPolyLine(Int_t n, TPoints* xy); voidDrawPolyLineNDC(Int_t n, TPoints* uv); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObje",MatchSource.WIKI,root/html604/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVG.html
https://root.cern/root/html604/TSVG.html:3352,Availability,error,error,3352,"istancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); voidDrawPolyLine(Int_t n, TPoints* xy); voidDrawPolyLineNDC(Int_t n, TPoints* uv); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Opt",MatchSource.WIKI,root/html604/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVG.html
https://root.cern/root/html604/TSVG.html:15643,Energy Efficiency,power,power,15643,"y to point x,y.; If NN=0 the x,y are written in the SVG file; according to the current transformation.; If NN>0 the line is clipped as a line.; If NN<0 the line is clipped as a fill area. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); Paint PolyMarker. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); Paint PolyMarker. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn>0 a line is drawn.; If nn<0 a closed polygon is drawn. void Initialize(); Initialize the SVG file. The main task of the function is to output the; SVG header file which consist in <title>, <desc> and <defs>. The; HeaderPS provided by the user program is written in the <defs> part. void MovePS(Double_t x, Double_t y); Move to a new position (ix, iy). The move is done in relative coordinates; which allows to have short numbers which decrease the size of the file.; This function use the full power of the SVG's paths by using the; horizontal and vertical move whenever it is possible. void NewPage(); Start the SVG page. This function initialize the pad conversion; coefficients and output the <svg> directive which is close later in the; the function Close. void Range(Float_t xrange, Float_t yrange); Set the range for the paper in centimetres. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Set the lines width. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set color with its color index. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetTextColor(Color_t c",MatchSource.WIKI,root/html604/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVG.html
https://root.cern/root/html604/TSVG.html:16609,Energy Efficiency,green,green,16609,"e.; This function use the full power of the SVG's paths by using the; horizontal and vertical move whenever it is possible. void NewPage(); Start the SVG page. This function initialize the pad conversion; coefficients and output the <svg> directive which is close later in the; the function Close. void Range(Float_t xrange, Float_t yrange); Set the range for the paper in centimetres. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Set the lines width. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set color with its color index. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetTextColor(Color_t cindex = 1); Set color index for text. void Text(Double_t x, Double_t y, const char* string); Draw text. xx: x position of the text; yy: y position of the text; chars: text to be drawn. void TextNDC(Double_t u, Double_t v, const char* string); Write a string of characters in NDC. Double_t UtoSVG(Double_t u); Convert U from NDC coordinate to SVG. Double_t VtoSVG(Double_t v); Convert V from NDC coordinate to SVG. Double_t XtoSVG(Double_t x); Convert X from world coordinate to SVG. Double_t YtoSVG(Double_t y); Convert Y from world coordinate to SVG. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); Begin the Cell Array painting. void CellArrayFill(Int_t r, Int_t g, Int_t b); Paint the Cell Array. void CellArrayEnd(); End the Cell Array painting. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); Not needed in SVG case. TSVG(). Double_t CMtoSVG(Double_t u); {return 0.5 + 72*u/2.54;}. void Set",MatchSource.WIKI,root/html604/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVG.html
https://root.cern/root/html604/TSVG.html:323,Integrability,interface,interface,323,". TSVG. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TSVG. class TSVG: public TVirtualPS. TSVG: Graphics interface to SVG; SVG; (Scalable Vector Graphics) is a language for describing two-dimensional; graphics in XML. SVG allows high quality vector graphics in; HTML pages. To print a ROOT canvas ""c1"" into an SVG file simply do:. c1->Print(""c1.svg"");. The result is the ASCII file c1.svg. It can be open direclty using a web browser or included in a html document; the following way:. <embed width=""95%"" height=""500"" src=""c1.svg"" />>. It is best viewed with Internet Explorer and you need the; Adobe SVG; Viewer. To zoom using the Adobe SVG Viewer, position the mouse over; the area you want to zoom and click the right button. To define the zoom area,; use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.; By clicking with the right mouse button on the SVG graphics you will get; a pop-up menu giving other ways to interact with the image. SVG files can be used directly in compressed mode to minimize the time; transfer over the network. Compressed SVG files should be created using; gzip on a normal ASCII SVG file and should then be renamed; using the file extension .svgz.; . Function Members (Methods); public:. virtual~TSVG(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtu",MatchSource.WIKI,root/html604/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVG.html
https://root.cern/root/html604/TSVG.html:13211,Integrability,interface,interface,13211,":fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Int_tTVirtualPS::fSizBufferBuffer size; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypeWorkstation type used to know if the SVG is open; Float_tfXsizePage size along X; Float_tfYsizePage size along Y; Double_tfYsizeSVGPage's Y size in SVG units. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAttMarker. TAttText. ←; TVirtualPS. ←; TSVG. Function documentation; TSVG(); Default SVG constructor. TSVG(const char* filename, Int_t type = -113); Initialize the SVG interface. fname : SVG file name; wtype : SVG workstation type. Not used in the SVG driver. But as TSVG; inherits from TVirtualPS it should be kept. Anyway it is not; necessary to specify this parameter at creation time because it; has a default value (which is ignore in the SVG case). void Open(const char* filename, Int_t type = -111); Open a SVG file. ~TSVG(); Default SVG destructor. void Close(Option_t* opt = """"); Close a SVG file. void On(); Activate an already open SVG file. void Off(); Deactivate an already open SVG file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed SVG units dark is the; color for the dark part of the fr",MatchSource.WIKI,root/html604/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVG.html
https://root.cern/root/html604/TSVG.html:110,Modifiability,inherit,inheritance,110,". TSVG. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TSVG. class TSVG: public TVirtualPS. TSVG: Graphics interface to SVG; SVG; (Scalable Vector Graphics) is a language for describing two-dimensional; graphics in XML. SVG allows high quality vector graphics in; HTML pages. To print a ROOT canvas ""c1"" into an SVG file simply do:. c1->Print(""c1.svg"");. The result is the ASCII file c1.svg. It can be open direclty using a web browser or included in a html document; the following way:. <embed width=""95%"" height=""500"" src=""c1.svg"" />>. It is best viewed with Internet Explorer and you need the; Adobe SVG; Viewer. To zoom using the Adobe SVG Viewer, position the mouse over; the area you want to zoom and click the right button. To define the zoom area,; use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.; By clicking with the right mouse button on the SVG graphics you will get; a pop-up menu giving other ways to interact with the image. SVG files can be used directly in compressed mode to minimize the time; transfer over the network. Compressed SVG files should be created using; gzip on a normal ASCII SVG file and should then be renamed; using the file extension .svgz.; . Function Members (Methods); public:. virtual~TSVG(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtu",MatchSource.WIKI,root/html604/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVG.html
https://root.cern/root/html604/TSVG.html:13316,Modifiability,inherit,inherits,13316,"d::fNameobject identifier; Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Int_tTVirtualPS::fSizBufferBuffer size; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypeWorkstation type used to know if the SVG is open; Float_tfXsizePage size along X; Float_tfYsizePage size along Y; Double_tfYsizeSVGPage's Y size in SVG units. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAttMarker. TAttText. ←; TVirtualPS. ←; TSVG. Function documentation; TSVG(); Default SVG constructor. TSVG(const char* filename, Int_t type = -113); Initialize the SVG interface. fname : SVG file name; wtype : SVG workstation type. Not used in the SVG driver. But as TSVG; inherits from TVirtualPS it should be kept. Anyway it is not; necessary to specify this parameter at creation time because it; has a default value (which is ignore in the SVG case). void Open(const char* filename, Int_t type = -111); Open a SVG file. ~TSVG(); Default SVG destructor. void Close(Option_t* opt = """"); Close a SVG file. void On(); Activate an already open SVG file. void Off(); Deactivate an already open SVG file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed SVG units dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyLine(Int_t n, TPoints* xy); Draw a PolyLine. Draw a polyline through the point",MatchSource.WIKI,root/html604/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVG.html
https://root.cern/root/html604/TSVG.html:537,Usability,simpl,simply,537,". TSVG. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TSVG. class TSVG: public TVirtualPS. TSVG: Graphics interface to SVG; SVG; (Scalable Vector Graphics) is a language for describing two-dimensional; graphics in XML. SVG allows high quality vector graphics in; HTML pages. To print a ROOT canvas ""c1"" into an SVG file simply do:. c1->Print(""c1.svg"");. The result is the ASCII file c1.svg. It can be open direclty using a web browser or included in a html document; the following way:. <embed width=""95%"" height=""500"" src=""c1.svg"" />>. It is best viewed with Internet Explorer and you need the; Adobe SVG; Viewer. To zoom using the Adobe SVG Viewer, position the mouse over; the area you want to zoom and click the right button. To define the zoom area,; use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.; By clicking with the right mouse button on the SVG graphics you will get; a pop-up menu giving other ways to interact with the image. SVG files can be used directly in compressed mode to minimize the time; transfer over the network. Compressed SVG files should be created using; gzip on a normal ASCII SVG file and should then be renamed; using the file extension .svgz.; . Function Members (Methods); public:. virtual~TSVG(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtu",MatchSource.WIKI,root/html604/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSVG.html
https://root.cern/root/html604/TSynapse.html:1478,Availability,error,error,1478," virtual~TSynapse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDeDw() const; Double_tGetDEDw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObjec",MatchSource.WIKI,root/html604/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSynapse.html
https://root.cern/root/html604/TSynapse.html:1562,Availability,error,error,1562," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDeDw() const; Double_tGetDEDw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TNeuron*GetPost() const; TNeuron*GetPre() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue() const; Double_tGetWeight() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) c",MatchSource.WIKI,root/html604/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSynapse.html
https://root.cern/root/html604/TSynapse.html:6097,Availability,error,error,6097,"protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_tfDEDw! the derivative of the total error wrt the synapse weight; TNeuron*fpostthe neuron after the synapse; TNeuron*fprethe neuron before the synapse; Double_tfweightthe weight of the synapse. Class Charts. Inheritance Chart:. TObject. ←; TSynapse. Function documentation; TSynapse(); Default constructor. TSynapse(TNeuron* , TNeuron* , Double_t w = 1); Constructor that connects two neurons. void SetPre(TNeuron* pre); Sets the pre-neuron. void SetPost(TNeuron* post); Sets the post-neuron. Double_t GetValue() const; Returns the value: weithted input. Double_t GetDeDw() const; Computes the derivative of the error wrt the synapse weight. void SetWeight(Double_t w); Sets the weight of the synapse.; This weight is the multiplying factor applied on the; output of a neuron in the linear combination given as input; of another neuron. void SetDEDw(Double_t in); Sets the derivative of the total error wrt the synapse weight. TSynapse(). virtual ~TSynapse(); {}. TNeuron* GetPre() const; { return fpre; }. TNeuron* GetPost() const; { return fpost; }. Double_t GetWeight() const; { return fwei",MatchSource.WIKI,root/html604/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSynapse.html
https://root.cern/root/html604/TSynapse.html:6673,Availability,error,error,6673,":kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_tfDEDw! the derivative of the total error wrt the synapse weight; TNeuron*fpostthe neuron after the synapse; TNeuron*fprethe neuron before the synapse; Double_tfweightthe weight of the synapse. Class Charts. Inheritance Chart:. TObject. ←; TSynapse. Function documentation; TSynapse(); Default constructor. TSynapse(TNeuron* , TNeuron* , Double_t w = 1); Constructor that connects two neurons. void SetPre(TNeuron* pre); Sets the pre-neuron. void SetPost(TNeuron* post); Sets the post-neuron. Double_t GetValue() const; Returns the value: weithted input. Double_t GetDeDw() const; Computes the derivative of the error wrt the synapse weight. void SetWeight(Double_t w); Sets the weight of the synapse.; This weight is the multiplying factor applied on the; output of a neuron in the linear combination given as input; of another neuron. void SetDEDw(Double_t in); Sets the derivative of the total error wrt the synapse weight. TSynapse(). virtual ~TSynapse(); {}. TNeuron* GetPre() const; { return fpre; }. TNeuron* GetPost() const; { return fpost; }. Double_t GetWeight() const; { return fweight; }. Double_t GetDEDw() const; { return fDEDw; }. » Author: Christophe.Delaere@cern.ch 20/07/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSynapse.html
https://root.cern/root/html604/TSynapse.html:6958,Availability,error,error,6958,":kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_tfDEDw! the derivative of the total error wrt the synapse weight; TNeuron*fpostthe neuron after the synapse; TNeuron*fprethe neuron before the synapse; Double_tfweightthe weight of the synapse. Class Charts. Inheritance Chart:. TObject. ←; TSynapse. Function documentation; TSynapse(); Default constructor. TSynapse(TNeuron* , TNeuron* , Double_t w = 1); Constructor that connects two neurons. void SetPre(TNeuron* pre); Sets the pre-neuron. void SetPost(TNeuron* post); Sets the post-neuron. Double_t GetValue() const; Returns the value: weithted input. Double_t GetDeDw() const; Computes the derivative of the error wrt the synapse weight. void SetWeight(Double_t w); Sets the weight of the synapse.; This weight is the multiplying factor applied on the; output of a neuron in the linear combination given as input; of another neuron. void SetDEDw(Double_t in); Sets the derivative of the total error wrt the synapse weight. TSynapse(). virtual ~TSynapse(); {}. TNeuron* GetPre() const; { return fpre; }. TNeuron* GetPost() const; { return fpost; }. Double_t GetWeight() const; { return fweight; }. Double_t GetDEDw() const; { return fDEDw; }. » Author: Christophe.Delaere@cern.ch 20/07/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSynapse.html
https://root.cern/root/html604/TSynapse.html:114,Modifiability,inherit,inheritance,114,". TSynapse. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TSynapse. class TSynapse: public TObject. TSynapse. This is a simple weighted bidirectionnal connection between; two neurons.; A network is built connecting two neurons by a synapse.; In addition to the value, the synapse can return the DeDw. Function Members (Methods); public:. virtual~TSynapse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDeDw() const; Double_tGetDEDw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObjec",MatchSource.WIKI,root/html604/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSynapse.html
https://root.cern/root/html604/TSynapse.html:328,Usability,simpl,simple,328,". TSynapse. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TSynapse. class TSynapse: public TObject. TSynapse. This is a simple weighted bidirectionnal connection between; two neurons.; A network is built connecting two neurons by a synapse.; In addition to the value, the synapse can return the DeDw. Function Members (Methods); public:. virtual~TSynapse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDeDw() const; Double_tGetDEDw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObjec",MatchSource.WIKI,root/html604/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSynapse.html
https://root.cern/root/html604/TSysEvtHandler.html:542,Availability,avail,available,542,". TSysEvtHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSysEvtHandler. class TSysEvtHandler: public TObject, public TQObject. TSysEvtHandler. Abstract base class for handling system events. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSysEvtHandler(); voidTObject::AbstractMethod(const char* method) const; voidActivate(); virtual voidActivated()SIGNAL ; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidDeActivate(); virtual voidDeActivated()SIGNAL ; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destro",MatchSource.WIKI,root/html604/TSysEvtHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSysEvtHandler.html
https://root.cern/root/html604/TSysEvtHandler.html:3811,Availability,error,error,3811," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(",MatchSource.WIKI,root/html604/TSysEvtHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSysEvtHandler.html
https://root.cern/root/html604/TSysEvtHandler.html:3895,Availability,error,error,3895,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQ",MatchSource.WIKI,root/html604/TSysEvtHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSysEvtHandler.html
https://root.cern/root/html604/TSysEvtHandler.html:120,Modifiability,inherit,inheritance,120,". TSysEvtHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSysEvtHandler. class TSysEvtHandler: public TObject, public TQObject. TSysEvtHandler. Abstract base class for handling system events. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSysEvtHandler(); voidTObject::AbstractMethod(const char* method) const; voidActivate(); virtual voidActivated()SIGNAL ; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidDeActivate(); virtual voidDeActivated()SIGNAL ; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destro",MatchSource.WIKI,root/html604/TSysEvtHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSysEvtHandler.html
https://root.cern/root/html604/TSysEvtHandler.html:10185,Safety,avoid,avoid,10185,"e; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TSysEvtHandler. ←. TFileHandler; ←. TXSocketHandler. TSignalHandler. TStdExceptionHandler; ←. TEveManager::TExceptionHandler. TTimer; ←. TProcessEventTimer. Function documentation; void Activate(); Activate a system event handler. All handlers are by default; activated. Use this method to activate a de-activated handler. void DeActivate(); De-activate a system event handler. Use this method to temporarily; disable an event handler to avoid it from being recursively called.; Use DeActivate() / Activate() instead of Remove() / Add() for this; purpose, since the Add() will add the handler back to the end of; the list of handlers and cause it to be called again for the same,; already handled, event. void * GetSender(); { return this; }. TSysEvtHandler(); { }. virtual ~TSysEvtHandler(); { }. Bool_t IsActive() const; { return fIsActive; }. void Add(). void Remove(). Bool_t Notify(). void Activated(); { Emit(""Activated()""); }. void DeActivated(); { Emit(""DeActivated()""); }. void Notified(); { Emit(""Notified()""); }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TSysEvtHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSysEvtHandler.html
https://root.cern/root/html604/TSystem.html:3402,Availability,error,error,3402,"onst char* build_dir = """", UInt_t dirmode = 0); virtual char*ConcatFileName(const char* dir, const char* name); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidExitLoop(); virtual Bool_tExpandPathName(TString& path); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeGetAclicMode() const; virtual Int_tGetAclicProperties() const; voidGetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*GetBuildArch() const; virtual const char*GetBuildCom",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:3486,Availability,error,error,3486,"ar* dir, const char* name); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidExitLoop(); virtual Bool_tExpandPathName(TString& path); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeGetAclicMode() const; virtual Int_tGetAclicProperties() const; voidGetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*GetBuildArch() const; virtual const char*GetBuildCompiler() const; virtual const char*GetBuildCompilerVersion() const; virtual const cha",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:11728,Availability,mask,mask,11728,"oidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives); virtual voidSetMakeSharedLib(const char* directives); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int kind, int val); virtual voidSetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidShowOutput(RedirectHandle_t* h); virtual Int_tTNamed::Sizeof() const; virtual voidSleep(UInt_t milliSec); virtual TStringSplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) co",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:13325,Availability,mask,mask,13325,"ves); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int kind, int val); virtual voidSetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidShowOutput(RedirectHandle_t* h); virtual Int_tTNamed::Sizeof() const; virtual voidSleep(UInt_t milliSec); virtual TStringSplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidStackTrace(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual intSymlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidSyslog(ELogLevel level, const char* mess); virtual const char*TempDirectory() const; virtual FILE*TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); virtual intUmask(Int_t mask); virtual const char*UnixPathName(const char* unixpathname); virtual intUnlink(const char* name); virtual voidUnload(const char* module); virtual voidUnsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intUtime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:17293,Availability,mask,mask,17293,"Collection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Ge",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:17331,Availability,mask,mask,17331,"Collection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Ge",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:17403,Availability,mask,masks,17403,"Collection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Ge",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:18665,Availability,error,error,18665,"_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:18779,Availability,error,error,18779," that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:18807,Availability,error,error,18807,"SeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t Pr",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:18937,Availability,error,error,18937,"ction*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the re",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:19002,Availability,error,error,19002,"tle; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT:",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:19068,Availability,error,error,19068," should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); can be set during the handling of the events. T",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:22830,Availability,mask,mask,22830,"he default handler, else restore previous behaviour. void ResetSignals(); Reset signals handlers to previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void IgnoreInterrupt(Bool_t ignore = kTRUE); If ignore is true ignore the interrupt signal, else restore previous; behaviour. Typically call ignore interrupt before writing to disk. void AddStdExceptionHandler(TStdExceptionHandler* eh); Add an exception handler to list of system exception handlers. Only adds; the handler if it is not already in the list of exception handlers. TStdExceptionHandler * RemoveStdExceptionHandler(TStdExceptionHandler* eh); Remove an exception handler from list of exception handlers. Returns; the handler or 0 if the handler was not in the list of exception handlers. Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* command, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. TString GetFromPipe(const char* command); Execute command and return output in TString. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. TSystem * FindHelper(const char* path, void* dirptr = 0); Create helper TSystem to handle file and directory operations that; might be special for remote file access, like via rfiod or rootd. Bool_t ConsistentWith(const char* path, void* dirptr = 0); Check consistency of this helper with the one required; by 'path' or 'dirptr'. int MakeDirectory(const char* name); Make a directory. Returns 0 in case of success and; -1 if the directory could not be created (either alread",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:26176,Availability,error,error,26176,"st be deleted by the caller. const char * DirName(const char* pathname); Return the directory name in pathname. DirName of /user/root is /user.; In case no dirname is specified ""."" is returned. const char * UnixPathName(const char* unixpathname); Convert from a Unix pathname to a local pathname. E.g. from /user/root to \user\root. char * ConcatFileName(const char* dir, const char* name); Concatenate a directory and a file name. User must delete returned string. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. const char * ExpandFileName(const char* fname); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Retur",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:27505,Availability,failure,failure,27505,"tting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. int Link(const char* from, const char* to); Create a link from file1 to file2. int Symlink(const char* from, const char* to); Create a symbolic link from file1 to file2. int Unlink(const char* name); Unlink, i.e. remove, a file. int GetPathInfo(const char* path, Long_t* id, Long_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id is (statbuf.st_dev << 24) + statbuf.st_ino; Size is the file size; Flags is file type: 0 is regular file, bit 0 set executable,; bit 1 set directory, bit 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:27592,Availability,error,error,27592,"tting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. int Link(const char* from, const char* to); Create a link from file1 to file2. int Symlink(const char* from, const char* to); Create a symbolic link from file1 to file2. int Unlink(const char* name); Unlink, i.e. remove, a file. int GetPathInfo(const char* path, Long_t* id, Long_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id is (statbuf.st_dev << 24) + statbuf.st_ino; Size is the file size; Flags is file type: 0 is regular file, bit 0 set executable,; bit 1 set directory, bit 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:29776,Availability,error,error,29776," function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effec",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:29877,Availability,error,error,29877,"path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(cons",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:29913,Availability,mask,mask,29913,"s returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:29955,Availability,mask,mask,29955,"s returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:30153,Availability,error,error,30153,", Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t ui",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:31256,Availability,error,error,31256,"ion of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(cons",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:31488,Availability,error,error,31488,"e mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:31755,Availability,error,error,31755," the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", Re",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:32078,Availability,error,error,32078,"ile being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this fu",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:33458,Availability,error,error,33458,"cility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course o",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:34139,Availability,error,error,34139,"ly the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:35503,Availability,error,error,35503,"amicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:35614,Availability,error,error,35614,"search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:35789,Availability,error,error,35789,"using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service)",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:38327,Availability,error,error,38327,"e unix domain service. int AcceptConnection(int sock); Accept a connection. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket connection. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:38504,Availability,error,error,38504,", void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : compile only, do not attempt to load the library.; s : silence all informational output; ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:38755,Availability,error,error,38755,"ly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : compile only, do not attempt to load the library.; s : silence all informational output; v : output all information output; d : debug ACLiC, keep all the output files.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:38914,Availability,error,error,38914,"gth indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : compile only, do not attempt to load the library.; s : silence all informational output; v : output all information output; d : debug ACLiC, keep all the output files.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext is the shared library extension for; the current platform. If build_dir is specified, it is used as an alternative 'root' for the; generation of the shared lib",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:39242,Availability,error,error,39242," system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : compile only, do not attempt to load the library.; s : silence all informational output; v : output all information output; d : debug ACLiC, keep all the output files.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext is the shared library extension for; the current platform. If build_dir is specified, it is used as an alternative 'root' for the; generation of the shared library. The library is stored in a sub-directories; of 'build_dir' including the full pathname of the script unless a flat; directory structure is requested ('-' option). With the '-' option the libraries; are created directly in the directory 'build_dir'; in particular this means that; 2 scripts ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:42418,Availability,avail,available,42418,"nopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow them to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been sele",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:43215,Availability,avail,available,43215,"unction TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of ea",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:43506,Availability,avail,available,43506,":. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of each bit. const char * GetBuildArch() const; Return the build architecture. const char * GetBuildCompiler() const; Return the build compiler. const char * GetBuildCompilerVersion() const; Return the build compiler version. const char * GetBuildNode() const; Return the build node name. const char * GetBuildDir() const; Return the path of the build directory. const char ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:34806,Deployability,update,updated,34806,"h to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(con",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:329,Integrability,interface,interface,329,". TSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSystem. class TSystem: public TNamed. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. virtual~TSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* pathname); virtual voidAddFileHandler(TFileHandler* fh); virtual voidAddIncludePath(const char* includePath); virtual voidAddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidAddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* t); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*BaseName(const char* pathname); voidBeep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tcd(const char* path); virtual Bool_tChangeDirectory(const char* path); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidCleanC",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:9073,Integrability,protocol,protocol,9073,"llpath = 0); virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intLink(const char* from, const char* to); virtual voidListLibraries(const char* regexp = """"); virtual voidListSymbols(const char* module, const char* re = """"); virtual intLoad(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual intMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intmkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tNextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidNotifyApplicationCreated(); virtual TTimeNow(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intOpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* name); virtual voidOpenlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*OpenPipe(const char* command, const char* mode); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual const char*PrependPathName(const char* dir, TString& name); virtual voidTNamed::Print(Option_t* option = """") const; virtual Bool_tProcessEvents(); const char*pwd(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:18315,Integrability,interface,interface,18315," Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:18352,Integrability,interface,interface,18352,"gTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(In",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:18396,Integrability,interface,interface,18396,"dNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:19164,Integrability,interface,interface,19164,"ng. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); can be set during the handling of the events. This mechanism allows; macros running in tight calculating loops to be interrupte",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:20150,Integrability,depend,depending,20150,"should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); can be set during the handling of the events. This mechanism allows; macros running in tight calculating loops to be interrupted by some; GUI event (depending on the interval with which this method is; called). For example hitting ctrl-c in a canvas will set the; interrupt flag. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milli seconds. Int_t Select(TList* active, Long_t timeout); Select on active file descriptors (called by TMonitor). Int_t Select(TFileHandler* fh, Long_t timeout); Select on active file descriptors (called by TMonitor). TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. void AddTimer(TTimer* t); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* t); Remove timer from list of system timers. Returns removed timer or 0; if timer was not active. Long_t NextTimeOut(Bool_t mode); Time when next timer of mode (synchronous=kTRUE or; asynchronous=kFALSE) will time-out (in ms). void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handle",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:32597,Integrability,message,message,32597,"ure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:35509,Integrability,message,message,35509,"amicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:35620,Integrability,message,message,35620,"search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:36947,Integrability,protocol,protocol,36947," loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to another host. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service. int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service. int AcceptConnection(int sock); Accept a connection. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket connection. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int S",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:47936,Integrability,depend,depends,47936,"ate an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc"". gSystem->SetMakeSharedLib(; ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; -shared -o $SharedLib"");. gSystem->SetMakeSharedLib(; ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:15866,Modifiability,config,configure,15866,TObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TSystem::EAclicModekOpt; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TSystem::EAclicModefAclicModeWhether the compilation should be done debug or opt; Int_tfAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tfBeepDurationUsed by Beep(); Int_tfBeepFreqUsed by Beep(); TStringfBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringfBuildCompilerCompiler used to build this ROOT; TStringfBuildCompilerVersionCompiler version used to build this ROOT; TStringfBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringfBuildNodeDetailed information where ROOT was built; TSeqCollection*fCompiledList of shared libs from compiled macros to be deleted; Bool_tfDoneTrue if eventloop should be finished; TSeqCollection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfL,MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:18567,Modifiability,variab,variable,18567,"at should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectivel",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:25926,Modifiability,variab,variables,25926,"at can be found in the ROOT include; path or the current directory.; If 'name' contains any ACLiC style information (e.g. trailing +[+][g|O]),; it will be striped off 'name'.; If fullpath is != 0, the full path to the file is returned in *fullpath,; which must be deleted by the caller. const char * DirName(const char* pathname); Return the directory name in pathname. DirName of /user/root is /user.; In case no dirname is specified ""."" is returned. const char * UnixPathName(const char* unixpathname); Convert from a Unix pathname to a local pathname. E.g. from /user/root to \user\root. char * ConcatFileName(const char* dir, const char* name); Concatenate a directory and a file name. User must delete returned string. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. const char * ExpandFileName(const char* fname); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can a",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:26376,Modifiability,variab,variables,26376,". const char * UnixPathName(const char* unixpathname); Convert from a Unix pathname to a local pathname. E.g. from /user/root to \user\root. char * ConcatFileName(const char* dir, const char* name); Concatenate a directory and a file name. User must delete returned string. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. const char * ExpandFileName(const char* fname); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t over",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:26666,Modifiability,variab,variables,26666,"pendPathName(const char* dir, TString& name); Concatenate a directory and a file name. const char * ExpandFileName(const char* fname); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* fro",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:29313,Modifiability,config,configured,29313," of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id is (statbuf.st_dev << 24) + statbuf.st_ino; Size is the file size; Flags is file type: 0 is regular file, bit 0 set executable,; bit 1 set directory, bit 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:32165,Modifiability,variab,variable,32165,"d); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a stati",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:32226,Modifiability,variab,variable,32226,"; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:32290,Modifiability,variab,variable,32290,"returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:41177,Modifiability,variab,variables,41177,"hat; 2 scripts with the same name in different source directory will over-write each; other's library.; See also TSystem::SetBuildDir. If dirmode is not zero and we need to create the target directory, the; file mode bit will be change to 'dirmode' using chmod. If library_specified is not specified, CompileMacro generate a default name; for library by taking the name of the file ""filename"" but replacing the; dot before the extension by an underscore and by adding the shared; library extension for the current platform.; For example on most platform, hsimple.cxx will generate hsimple_cxx.so. It uses the directive fMakeSharedLibs to create a shared library.; If loading the shared library fails, it tries to output a list of missing; symbols by creating an executable (on some platforms like OSF, this does; not HAVE to be an executable) containing the script. It uses the; directive fMakeExe to do so.; For both directives, before passing them to TSystem::Exec, it expands the; variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; information on those variables. This method is used to implement the following feature:. Synopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow them to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the funct",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:41342,Modifiability,variab,variables,41342,"uildDir. If dirmode is not zero and we need to create the target directory, the; file mode bit will be change to 'dirmode' using chmod. If library_specified is not specified, CompileMacro generate a default name; for library by taking the name of the file ""filename"" but replacing the; dot before the extension by an underscore and by adding the shared; library extension for the current platform.; For example on most platform, hsimple.cxx will generate hsimple_cxx.so. It uses the directive fMakeSharedLibs to create a shared library.; If loading the shared library fails, it tries to output a list of missing; symbols by creating an executable (on some platforms like OSF, this does; not HAVE to be an executable) containing the script. It uses the; directive fMakeExe to do so.; For both directives, before passing them to TSystem::Exec, it expands the; variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; information on those variables. This method is used to implement the following feature:. Synopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow them to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a goo",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:43703,Modifiability,variab,variables,43703,"es try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of each bit. const char * GetBuildArch() const; Return the build architecture. const char * GetBuildCompiler() const; Return the build compiler. const char * GetBuildCompilerVersion() const; Return the build compiler version. const char * GetBuildNode() const; Return the build node name. const char * GetBuildDir() const; Return the path of the build directory. const char * GetFlagsDebug() const; Return the debug flags. const char * GetFlagsOpt() const; Return the optimization flags. const char * GetMakeSh",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:46917,Modifiability,variab,variable,46917," Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this libra",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:47455,Modifiability,variab,variables,47455,"ilt in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; \$Opt -shared",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:47520,Modifiability,variab,variables,47520,"ate an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc"". gSystem->SetMakeSharedLib(; ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; -shared -o $SharedLib"");. gSystem->SetMakeSharedLib(; ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:49846,Modifiability,config,config,49846,"ncludePath $SourceFile; /link -PDB:NONE /NODEFAULTLIB /INCREMENTAL:NO /RELEASE /NOLOGO; $LinkedLibs -entry:_DllMainCRTStartup@12 -dll /out:$SharedLib""). void AddIncludePath(const char* includePath); Add includePath to the already set include path. void AddLinkedLibs(const char* linkedLib); Add linkedLib to already set linked libs. void SetIncludePath(const char* includePath); IncludePath should contain the list of compiler flags to indicate where; to find user defined header files. It is used to expand $IncludePath in; the directives given to SetMakeSharedLib() and SetMakeExe(), e.g.:; gSystem->SetInclude(""-I$ROOTSYS/include -Imydirectory/include"");; the default value of IncludePath on Unix is:; ""-I$ROOTSYS/include ""; and on Windows:; ""/I%ROOTSYS%/include "". void SetLinkedLibs(const char* linkedLibs); LinkedLibs should contain the library directory and list of libraries; needed to recreate the current executable. It is used to expand $LinkedLibs; in the directives given to SetMakeSharedLib() and SetMakeExe(); The default value on Unix is: root-config --glibs. void SetLinkdefSuffix(const char* suffix); The 'suffix' will be appended to the name of a script loaded by ACLiC; and used to locate any eventual additional linkdef information that; ACLiC should used to produce the dictionary.; So by default, when doing .L MyScript.cxx, ACLiC will look; for a file name MyScript_linkdef and having one of the .h (.hpp,; etc.) extensions. If such a file exist, it will be added to; the end of the linkdef file used to created the ACLiC dictionary.; This effectively enable the full customization of the creation; of the dictionary. It should be noted that the file is intended; as a linkdef 'fragment', so usually you would not list the; typical '#pragma link off ...."". void SetSoExt(const char* soExt); Set shared library extension, should be either .so, .sl, .a, .dll, etc. void SetObjExt(const char* objExt); Set object files extension, should be either .o, .obj, etc. TString SplitAclic",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:16402,Performance,optimiz,optimized,16402,"AclicModeWhether the compilation should be done debug or opt; Int_tfAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tfBeepDurationUsed by Beep(); Int_tfBeepFreqUsed by Beep(); TStringfBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringfBuildCompilerCompiler used to build this ROOT; TStringfBuildCompilerVersionCompiler version used to build this ROOT; TStringfBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringfBuildNodeDetailed information where ROOT was built; TSeqCollection*fCompiledList of shared libs from compiled macros to be deleted; Bool_tfDoneTrue if eventloop should be finished; TSeqCollection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdS",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:17007,Performance,cache,cache,17007,"AclicModeWhether the compilation should be done debug or opt; Int_tfAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tfBeepDurationUsed by Beep(); Int_tfBeepFreqUsed by Beep(); TStringfBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringfBuildCompilerCompiler used to build this ROOT; TStringfBuildCompilerVersionCompiler version used to build this ROOT; TStringfBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringfBuildNodeDetailed information where ROOT was built; TSeqCollection*fCompiledList of shared libs from compiled macros to be deleted; Bool_tfDoneTrue if eventloop should be finished; TSeqCollection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdS",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:34050,Performance,load,loading,34050,"ly the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:34086,Performance,load,loaded,34086,"ly the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:34210,Performance,load,loaded,34210,"illed with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """");",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:35333,Performance,load,loaded,35333,"system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:35693,Performance,load,loaded,35693,"r * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:35931,Performance,load,loaded,35931,"und, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConne",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:36161,Performance,load,loaded,36161,"ary. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to another host. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service. int AnnounceUdpService(int port, int backlog); Announce UDP service. i",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:36280,Performance,load,loaded,36280,"d ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to another host. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service. int AnnounceUnixService(",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:38424,Performance,load,load,38424,"nnection(int sock, Bool_t force = kFALSE); Close socket connection. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : c",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:38441,Performance,load,load,38441,"nnection(int sock, Bool_t force = kFALSE); Close socket connection. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : c",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:38579,Performance,load,load,38579," buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : compile only, do not attempt to load the library.; s : silence all informational output; v : output all information output; d : debug ACLiC, keep all the output",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:39098,Performance,load,loads,39098,"int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : compile only, do not attempt to load the library.; s : silence all informational output; v : output all information output; d : debug ACLiC, keep all the output files.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext is the shared library extension for; the current platform. If build_dir is specified, it is used as an alternative 'root' for the; generation of the shared library. The library is stored in a sub-directories; of 'build_dir' including the full pathname of the script unless a flat; directory struct",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:39389,Performance,optimiz,optimized,39389,"nst; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : compile only, do not attempt to load the library.; s : silence all informational output; v : output all information output; d : debug ACLiC, keep all the output files.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext is the shared library extension for; the current platform. If build_dir is specified, it is used as an alternative 'root' for the; generation of the shared library. The library is stored in a sub-directories; of 'build_dir' including the full pathname of the script unless a flat; directory structure is requested ('-' option). With the '-' option the libraries; are created directly in the directory 'build_dir'; in particular this means that; 2 scripts with the same name in different source directory will over-write each; other's library.; See also TSystem::SetBuildDir. If dirmode is not zero and we need to create the target directory, the; file mo",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:39445,Performance,load,load,39445,"nst; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code; c : compile only, do not attempt to load the library.; s : silence all informational output; v : output all information output; d : debug ACLiC, keep all the output files.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext is the shared library extension for; the current platform. If build_dir is specified, it is used as an alternative 'root' for the; generation of the shared library. The library is stored in a sub-directories; of 'build_dir' including the full pathname of the script unless a flat; directory structure is requested ('-' option). With the '-' option the libraries; are created directly in the directory 'build_dir'; in particular this means that; 2 scripts with the same name in different source directory will over-write each; other's library.; See also TSystem::SetBuildDir. If dirmode is not zero and we need to create the target directory, the; file mo",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:40860,Performance,load,loading,40860,"ries; of 'build_dir' including the full pathname of the script unless a flat; directory structure is requested ('-' option). With the '-' option the libraries; are created directly in the directory 'build_dir'; in particular this means that; 2 scripts with the same name in different source directory will over-write each; other's library.; See also TSystem::SetBuildDir. If dirmode is not zero and we need to create the target directory, the; file mode bit will be change to 'dirmode' using chmod. If library_specified is not specified, CompileMacro generate a default name; for library by taking the name of the file ""filename"" but replacing the; dot before the extension by an underscore and by adding the shared; library extension for the current platform.; For example on most platform, hsimple.cxx will generate hsimple_cxx.so. It uses the directive fMakeSharedLibs to create a shared library.; If loading the shared library fails, it tries to output a list of missing; symbols by creating an executable (on some platforms like OSF, this does; not HAVE to be an executable) containing the script. It uses the; directive fMakeExe to do so.; For both directives, before passing them to TSystem::Exec, it expands the; variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; information on those variables. This method is used to implement the following feature:. Synopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow them to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:41853,Performance,load,loaded,41853," shared library fails, it tries to output a list of missing; symbols by creating an executable (on some platforms like OSF, this does; not HAVE to be an executable) containing the script. It uses the; directive fMakeExe to do so.; For both directives, before passing them to TSystem::Exec, it expands the; variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; information on those variables. This method is used to implement the following feature:. Synopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow them to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the l",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:42737,Performance,load,loaded,42737,"C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:42870,Performance,load,loading,42870,"ments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:43161,Performance,load,loader,43161,"unction TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of ea",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:43277,Performance,load,loaded,43277,"icate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of each bit. const char * GetBuildArch() const; Return the build archit",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:44654,Performance,optimiz,optimization,44654,"ustomization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of each bit. const char * GetBuildArch() const; Return the build architecture. const char * GetBuildCompiler() const; Return the build compiler. const char * GetBuildCompilerVersion() const; Return the build compiler version. const char * GetBuildNode() const; Return the build node name. const char * GetBuildDir() const; Return the path of the build directory. const char * GetFlagsDebug() const; Return the debug flags. const char * GetFlagsOpt() const; Return the optimization flags. const char * GetMakeSharedLib() const; Return the command line use to make a shared library.; See TSystem::CompileMacro for more details. const char * GetMakeExe() const; Return the command line use to make an executable.; See TSystem::CompileMacro for more details. const char * GetIncludePath(); Get the list of include path. const char * GetLinkedLibs() const; Return the list of library linked to this executable.; See TSystem::CompileMacro for more details. const char * GetLinkdefSuffix() const; Return the linkdef suffix chosen by the user for ACLiC.; See TSystem::CompileMacro for more details. const char * GetSoExt() const; Get the shared library extension. const char * GetObjExt() const; Get the object file extension. void SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_d",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:46339,Performance,optimiz,optimized,46339,"st char * GetSoExt() const; Get the shared library extension. const char * GetObjExt() const; Get the object file extension. void SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell comm",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:46474,Performance,optimiz,optimized,46474,"ir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this d",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:46618,Performance,optimiz,optimized,46618,"s flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before executio",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:46866,Performance,load,loading,46866,"ubdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:48063,Performance,optimiz,optimization,48063,"11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc"". gSystem->SetMakeSharedLib(; ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; -shared -o $SharedLib"");. gSystem->SetMakeSharedLib(; ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN32; -D_WINDOWS $IncludePath $SourceFile; /link -PDB:NONE /NODEFAULTLIB /INCREMENTAL:NO /RELEASE /NOLOGO; $LinkedLibs -entry:_DllMainCRTStartup@12 -dll /out:$SharedLib""). void AddIncludePath(const char* includePath); Add includePath to the already set include path. void AddLinkedLibs(const char* linkedLib); Ad",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:49959,Performance,load,loaded,49959,"udePath); Add includePath to the already set include path. void AddLinkedLibs(const char* linkedLib); Add linkedLib to already set linked libs. void SetIncludePath(const char* includePath); IncludePath should contain the list of compiler flags to indicate where; to find user defined header files. It is used to expand $IncludePath in; the directives given to SetMakeSharedLib() and SetMakeExe(), e.g.:; gSystem->SetInclude(""-I$ROOTSYS/include -Imydirectory/include"");; the default value of IncludePath on Unix is:; ""-I$ROOTSYS/include ""; and on Windows:; ""/I%ROOTSYS%/include "". void SetLinkedLibs(const char* linkedLibs); LinkedLibs should contain the library directory and list of libraries; needed to recreate the current executable. It is used to expand $LinkedLibs; in the directives given to SetMakeSharedLib() and SetMakeExe(); The default value on Unix is: root-config --glibs. void SetLinkdefSuffix(const char* suffix); The 'suffix' will be appended to the name of a script loaded by ACLiC; and used to locate any eventual additional linkdef information that; ACLiC should used to produce the dictionary.; So by default, when doing .L MyScript.cxx, ACLiC will look; for a file name MyScript_linkdef and having one of the .h (.hpp,; etc.) extensions. If such a file exist, it will be added to; the end of the linkdef file used to created the ACLiC dictionary.; This effectively enable the full customization of the creation; of the dictionary. It should be noted that the file is intended; as a linkdef 'fragment', so usually you would not list the; typical '#pragma link off ...."". void SetSoExt(const char* soExt); Set shared library extension, should be either .so, .sl, .a, .dll, etc. void SetObjExt(const char* objExt); Set object files extension, should be either .o, .obj, etc. TString SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; This method split a filename of the form:; [path/]macro.C[+|++[k|f|g|O|c|s|d|v|-]][(args)].; It stores the ACli",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:10945,Safety,timeout,timeout,10945,"l voidTObject::RecursiveRemove(TObject* obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidRemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* t); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer*); virtual voidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:11000,Safety,timeout,timeout,11000,"ntRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidRemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* t); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer*); virtual voidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives); virtual voidSetMakeSharedLib(const char* directives)",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:20452,Safety,timeout,timeout,20452,"eq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); can be set during the handling of the events. This mechanism allows; macros running in tight calculating loops to be interrupted by some; GUI event (depending on the interval with which this method is; called). For example hitting ctrl-c in a canvas will set the; interrupt flag. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milli seconds. Int_t Select(TList* active, Long_t timeout); Select on active file descriptors (called by TMonitor). Int_t Select(TFileHandler* fh, Long_t timeout); Select on active file descriptors (called by TMonitor). TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. void AddTimer(TTimer* t); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* t); Remove timer from list of system timers. Returns removed timer or 0; if timer was not active. Long_t NextTimeOut(Bool_t mode); Time when next timer of mode (synchronous=kTRUE or; asynchronous=kFALSE) will time-out (in ms). void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handl",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:20556,Safety,timeout,timeout,20556,"fault value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); can be set during the handling of the events. This mechanism allows; macros running in tight calculating loops to be interrupted by some; GUI event (depending on the interval with which this method is; called). For example hitting ctrl-c in a canvas will set the; interrupt flag. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milli seconds. Int_t Select(TList* active, Long_t timeout); Select on active file descriptors (called by TMonitor). Int_t Select(TFileHandler* fh, Long_t timeout); Select on active file descriptors (called by TMonitor). TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. void AddTimer(TTimer* t); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* t); Remove timer from list of system timers. Returns removed timer or 0; if timer was not active. Long_t NextTimeOut(Bool_t mode); Time when next timer of mode (synchronous=kTRUE or; asynchronous=kFALSE) will time-out (in ms). void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFi",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:27234,Safety,avoid,avoid,27234,"f special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. int Link(const char* from, const char* to); Create a link from file1 to file2. int Symlink(const char* from, const char* to); Create a symbolic link from file1 to file2. int Unlink(const char* name); Unlink, i.e. remove, a file. int GetPathInfo(const char* path, Long_t* id, Long_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id is (statbuf.st_dev << 24) + statbuf.st_ino; Size is the file size; Flags is file type: 0 is regular file, bit 0 set executable,; bit 1 set directory, bit 2 set special file; (socket, fifo, pipe, ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:29685,Safety,safe,safely,29685,"it 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:29719,Safety,avoid,avoids,29719,"it 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:45969,Safety,risk,risk,45969," path. const char * GetLinkedLibs() const; Return the list of library linked to this executable.; See TSystem::CompileMacro for more details. const char * GetLinkdefSuffix() const; Return the linkdef suffix chosen by the user for ACLiC.; See TSystem::CompileMacro for more details. const char * GetSoExt() const; Get the shared library extension. const char * GetObjExt() const; Get the object file extension. void SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:47390,Safety,avoid,avoided,47390,"e(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:16502,Security,access,access,16502,"AclicModeWhether the compilation should be done debug or opt; Int_tfAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tfBeepDurationUsed by Beep(); Int_tfBeepFreqUsed by Beep(); TStringfBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringfBuildCompilerCompiler used to build this ROOT; TStringfBuildCompilerVersionCompiler version used to build this ROOT; TStringfBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringfBuildNodeDetailed information where ROOT was built; TSeqCollection*fCompiledList of shared libs from compiled macros to be deleted; Bool_tfDoneTrue if eventloop should be finished; TSeqCollection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdS",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:23542,Security,access,access,23542,"tion handlers. TStdExceptionHandler * RemoveStdExceptionHandler(TStdExceptionHandler* eh); Remove an exception handler from list of exception handlers. Returns; the handler or 0 if the handler was not in the list of exception handlers. Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* command, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. TString GetFromPipe(const char* command); Execute command and return output in TString. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. TSystem * FindHelper(const char* path, void* dirptr = 0); Create helper TSystem to handle file and directory operations that; might be special for remote file access, like via rfiod or rootd. Bool_t ConsistentWith(const char* path, void* dirptr = 0); Check consistency of this helper with the one required; by 'path' or 'dirptr'. int MakeDirectory(const char* name); Make a directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * OpenDirectory(const char* name); Open a directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Free a directory. const char * GetDirEntry(void* dirp); Get a directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. int mkdir(const char* name, Bool_t recursive = kFALSE); Make a file system directory. Returns 0 in case of success and; -1 if the directory cou",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:26896,Security,access,access,26896,"ility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. int Link(const char* from, const char* to); Create a link from file1 to file2. int Symlink(const char* from, const char* to); Create a symbolic link from file1 to file2. int Unlink(const char* name)",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:26930,Security,access,access,26930,"ility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. int Link(const char* from, const char* to); Create a link from file1 to file2. int Symlink(const char* from, const char* to); Create a symbolic link from file1 to file2. int Unlink(const char* name)",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:29445,Security,secur,secure,29445,"gs, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id is (statbuf.st_dev << 24) + statbuf.st_ino; Size is the file size; Flags is file type: 0 is regular file, bit 0 set executable,; bit 1 set directory, bit 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(co",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:29734,Security,secur,security,29734,"it 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's ",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:30054,Security,access,access,30054,"rns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective grou",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:32396,Testability,log,log,32396,"e UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subse",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:32569,Testability,log,logging,32569,"ure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:32633,Testability,log,log,32633,"ure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:32682,Testability,log,log,32682,"ll are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dyn",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:643,Usability,simpl,simple,643,". TSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSystem. class TSystem: public TNamed. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. virtual~TSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* pathname); virtual voidAddFileHandler(TFileHandler* fh); virtual voidAddIncludePath(const char* includePath); virtual voidAddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidAddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* t); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*BaseName(const char* pathname); voidBeep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tcd(const char* path); virtual Bool_tChangeDirectory(const char* path); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidCleanC",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystem.html:43630,Usability,simpl,simplify,43630," .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of each bit. const char * GetBuildArch() const; Return the build architecture. const char * GetBuildCompiler() const; Return the build compiler. const char * GetBuildCompilerVersion() const; Return the build compiler version. const char * GetBuildNode() const; Return the build node name. const char * GetBuildDir() const; Return the path of the build directory. const char * GetFlagsDebug() const; Return the debug flags. const char * GetFlagsOpt() const; Return the",MatchSource.WIKI,root/html604/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystem.html
https://root.cern/root/html604/TSystemDirectory.html:1460,Availability,error,error,1460," virtual~TSystemDirectory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char*); virtual voidCopy(TObject&) const; virtual voidDelete(); virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidTSystemFile::Dump() const; virtual voidEdit(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TSystemFile::GetIconName() ",MatchSource.WIKI,root/html604/TSystemDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystemDirectory.html
https://root.cern/root/html604/TSystemDirectory.html:1544,Availability,error,error,1544,"temDirectory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char*); virtual voidCopy(TObject&) const; virtual voidDelete(); virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidTSystemFile::Dump() const; virtual voidEdit(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TSystemFile::GetIconName() const; virtual TList*GetListOfFiles() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) c",MatchSource.WIKI,root/html604/TSystemDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystemDirectory.html
https://root.cern/root/html604/TSystemDirectory.html:7275,Availability,error,errors,7275,"(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TOrdCollection*fDirsInBrowser; TOrdCollection*fFilesInBrowser; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSystemFile. ←; TSystemDirectory. Function documentation; TSystemDirectory(); Create a system directory object. TSystemDirectory(const char* dirname, const char* path); Create a system directory object. TSystemDirectory(const TSystemDirectory& ); copy constructor. TSystemDirectory& operator=(const TSystemDirectory& ); assignment operator. ~TSystemDirectory(); Delete system directory object. TList * GetListOfFiles() const; Returns a TList of TSystemFile objects representing the contents; of the directory. It's the responsibility of the user to delete; the list (the list owns the contained objects).; Returns 0 in case of errors. void SetDirectory(const char* name); Create a system directory object. Bool_t IsItDirectory(const char* name) const; Check if name is a directory. void Browse(TBrowser* b); Browse OS system directories. TSystemDirectory * FindDirObj(const char* name); Method that returns system directory object if it; exists in list, 0 otherwise. TSystemFile * FindFileObj(const char* name, const char* dir); Method that returns system file object if it exists in; list, 0 otherwise. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsDirectory(const char* = 0) const; { return kTRUE; }. void Edit(); { }. void Delete(); {}. void Copy(const char* ); {}. void Move(const char* ); {}. void DrawClass() const; dummy methods from TObject. { }. TObject * DrawClone(Option_t* ) const; { return 0; }. void SetDrawOption(Option_t* ); { }. void SetName(const char* name); { TSystemFile::SetName(name); }. void SetTitle(const char* title); { TSystemFile::SetTitle(title); }. void Delete(Option_t* ); { }. vo",MatchSource.WIKI,root/html604/TSystemDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystemDirectory.html
https://root.cern/root/html604/TSystemDirectory.html:122,Modifiability,inherit,inheritance,122,". TSystemDirectory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSystemDirectory. class TSystemDirectory: public TSystemFile. TSystemDirectory. Describes an Operating System directory for the browser. Author: Christian Bormann 30/09/97; http://www.ikf.physik.uni-frankfurt.de/~bormann/. Function Members (Methods); public:. virtual~TSystemDirectory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char*); virtual voidCopy(TObject&) const; virtual voidDelete(); virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidTSystemFile::Dump() const; virtual voidEdit(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TSystemFile::GetIconName() ",MatchSource.WIKI,root/html604/TSystemDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystemDirectory.html
https://root.cern/root/html604/TSystemFile.html:1398,Availability,error,error,1398," virtual~TSystemFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char* to)MENU ; virtual voidCopy(TObject&) const; virtual voidDelete()MENU ; virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidDump() const; virtual voidEdit()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::Ge",MatchSource.WIKI,root/html604/TSystemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystemFile.html
https://root.cern/root/html604/TSystemFile.html:1482,Availability,error,error,1482,"temFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char* to)MENU ; virtual voidCopy(TObject&) const; virtual voidDelete()MENU ; virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidDump() const; virtual voidEdit()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TCl",MatchSource.WIKI,root/html604/TSystemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystemFile.html
https://root.cern/root/html604/TSystemFile.html:117,Modifiability,inherit,inheritance,117,". TSystemFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSystemFile. class TSystemFile: public TNamed. TSystemFile. A TSystemFile describes an operating system file.; The information is used by the browser (see TBrowser). Function Members (Methods); public:. virtual~TSystemFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char* to)MENU ; virtual voidCopy(TObject&) const; virtual voidDelete()MENU ; virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidDump() const; virtual voidEdit()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::Ge",MatchSource.WIKI,root/html604/TSystemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TSystemFile.html
https://root.cern/root/html604/TTabCom.html:2683,Availability,error,error,2683,"complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should be #ifdef'd for the different sytems?. 9. the TabCom.FileIgnore resource is always applied, even if you; are not trying to complete a filename. 10. anything in quotes is assumed to be a filename; so (among other things) you can't complete a quoted class name:; eg, TClass class1( ""TDict[TAB] //; this won't work... looks for a file in pwd starting with TDict. 11. the prototypes tend to omit the word ""const"" a lot.; this is a problem with ROOT or CINT. 12. when listing ambiguous matches, only one column is used,; even if there are many completions. 13. anonymous objects are not currently identified; so, for example,. root> printf( TString([TAB. gives an error message instead of listing TString's constructors.; (this could be fixed). 14. the routine that adds the ""appendage"" isn't smart enough to know; if it's already there:. root> TCanvas::Update(); press [TAB] here ^; root> TCanvas::Update()(); (this could be fixed). 15. the appendage is only applied if there is exactly 1 match.; eg, this. root> G__at[TAB]; root> G__ateval. happens instead of this. root> G__at[TAB]; root> G__ateval(. because there are several overloaded versions of G__ateval().; (this could be fixed). Function Members (Methods); public:. virtual~TTabCom(); static Char_tAllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); static voidAppendListOfFilesInDirectory(const char[] dirName, TSeqCollection* pList); static TClass*Class(); voidClearAll(); voidClearClasses(); voidClearCppDirectives(); voidClearEnvVars(); voidClearFiles(); voidClearGlobalFunctions(); voidClearGlobals(); voidClearPragmas(); voidClearSysIncFiles(); voidClearUsers(); static TStringDetermineClass(const c",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:4407,Availability,error,errorLevel,4407,"_ateval. happens instead of this. root> G__at[TAB]; root> G__ateval(. because there are several overloaded versions of G__ateval().; (this could be fixed). Function Members (Methods); public:. virtual~TTabCom(); static Char_tAllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); static voidAppendListOfFilesInDirectory(const char[] dirName, TSeqCollection* pList); static TClass*Class(); voidClearAll(); voidClearClasses(); voidClearCppDirectives(); voidClearEnvVars(); voidClearFiles(); voidClearGlobalFunctions(); voidClearGlobals(); voidClearPragmas(); voidClearSysIncFiles(); voidClearUsers(); static TStringDetermineClass(const char[] varName); static Bool_tExcludedByFignore(TString s); const TSeqCollection*GetListOfClasses(); const TSeqCollection*GetListOfCppDirectives(); const TSeqCollection*GetListOfEnvVars(); const TSeqCollection*GetListOfFilesInPath(const char[] path); TCollection*GetListOfGlobalFunctions(); const TSeqCollection*GetListOfGlobals(); const TSeqCollection*GetListOfPragmas(); const TSeqCollection*GetListOfSysIncFiles(); const TSeqCollection*GetListOfUsers(); static TStringGetSysIncludePath(); Int_tHook(char* buf, int* pLoc, ostream& out); virtual TClass*IsA() const; static Bool_tIsDirectory(const char[] fileName); static TSeqCollection*NewListOfFilesInPath(const char[] path); static voidNoMsg(Int_t errorLevel); static Bool_tPathIsSpecifiedInFileName(const TString& fileName); voidRehashAll(); voidRehashClasses(); voidRehashCppDirectives(); voidRehashEnvVars(); voidRehashFiles(); voidRehashGlobalFunctions(); voidRehashGlobals(); voidRehashPragmas(); voidRehashSysIncFiles(); voidRehashUsers(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTabCom(). private:. Int_tComplete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); voidCopyMatch(char[] de",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:10412,Availability,failure,failure,10412," GetListOfPragmas(); Return the list of pragmas. const TSeqCollection * GetListOfSysIncFiles(); Return the list of system include files. const TSeqCollection * GetListOfUsers(); reads from ""/etc/passwd"". Char_t AllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); [static utility function]. if all the strings in ""*pList"" have the same ith character,; that character is returned.; otherwise 0 is returned. any string ""s"" for which ""ExcludedByFignore(s)"" is true; will be ignored unless All the strings in ""*pList""; are ""ExcludedByFignore()"". in addition, the number of strings which were not; ""ExcludedByFignore()"" is returned in ""nGoodStrings"". void AppendListOfFilesInDirectory(const char[] dirName, TSeqCollection* pList); [static utility function]. adds a TObjString to ""*pList""; for each entry found in the system directory ""dirName"". directories that do not exist are silently ignored. TString DetermineClass(const char[] varName); [static utility function]. returns empty string on failure.; otherwise returns something like this: ""TROOT*"".; fails for non-class types (ie, int, char, etc).; fails for pointers to functions. Bool_t ExcludedByFignore(TString s); [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char[] fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char[] path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static uti",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:10893,Availability,failure,failure,10893,"; will be ignored unless All the strings in ""*pList""; are ""ExcludedByFignore()"". in addition, the number of strings which were not; ""ExcludedByFignore()"" is returned in ""nGoodStrings"". void AppendListOfFilesInDirectory(const char[] dirName, TSeqCollection* pList); [static utility function]. adds a TObjString to ""*pList""; for each entry found in the system directory ""dirName"". directories that do not exist are silently ignored. TString DetermineClass(const char[] varName); [static utility function]. returns empty string on failure.; otherwise returns something like this: ""TROOT*"".; fails for non-class types (ie, int, char, etc).; fails for pointers to functions. Bool_t ExcludedByFignore(TString s); [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char[] fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char[] path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); re",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:11635,Availability,error,errorLevel,11635,"ith one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char[] fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char[] path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error handling that makes the function unsuitable for general u",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:11691,Availability,error,errorLevel,11691,"static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char[] fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char[] path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of ",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:11736,Availability,error,errorLevel,11736,"static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char[] fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char[] path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of ",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:11763,Availability,error,errors,11763,"static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char[] fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char[] path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of ",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:11784,Availability,error,errorLevel,11784,"static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char[] fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char[] path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of ",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:12583,Availability,error,error,12583,"ts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char[] className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char[] varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char[] regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t Determine",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:12743,Availability,error,error,12743," ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char[] className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char[] varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char[] regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id$ » Last generated: 20",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:12853,Availability,error,error,12853,"red. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char[] className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char[] varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char[] regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments ",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:12996,Availability,error,error,12996,"l to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char[] className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char[] varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char[] regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:13159,Availability,error,error,13159,"l to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char[] className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char[] varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char[] regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:11242,Energy Efficiency,allocate,allocated,11242," not exist are silently ignored. TString DetermineClass(const char[] varName); [static utility function]. returns empty string on failure.; otherwise returns something like this: ""TROOT*"".; fails for non-class types (ie, int, char, etc).; fails for pointers to functions. Bool_t ExcludedByFignore(TString s); [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char[] fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char[] path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const cha",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:2689,Integrability,message,message,2689,"complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should be #ifdef'd for the different sytems?. 9. the TabCom.FileIgnore resource is always applied, even if you; are not trying to complete a filename. 10. anything in quotes is assumed to be a filename; so (among other things) you can't complete a quoted class name:; eg, TClass class1( ""TDict[TAB] //; this won't work... looks for a file in pwd starting with TDict. 11. the prototypes tend to omit the word ""const"" a lot.; this is a problem with ROOT or CINT. 12. when listing ambiguous matches, only one column is used,; even if there are many completions. 13. anonymous objects are not currently identified; so, for example,. root> printf( TString([TAB. gives an error message instead of listing TString's constructors.; (this could be fixed). 14. the routine that adds the ""appendage"" isn't smart enough to know; if it's already there:. root> TCanvas::Update(); press [TAB] here ^; root> TCanvas::Update()(); (this could be fixed). 15. the appendage is only applied if there is exactly 1 match.; eg, this. root> G__at[TAB]; root> G__ateval. happens instead of this. root> G__at[TAB]; root> G__ateval(. because there are several overloaded versions of G__ateval().; (this could be fixed). Function Members (Methods); public:. virtual~TTabCom(); static Char_tAllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); static voidAppendListOfFilesInDirectory(const char[] dirName, TSeqCollection* pList); static TClass*Class(); voidClearAll(); voidClearClasses(); voidClearCppDirectives(); voidClearEnvVars(); voidClearFiles(); voidClearGlobalFunctions(); voidClearGlobals(); voidClearPragmas(); voidClearSysIncFiles(); voidClearUsers(); static TStringDetermineClass(const c",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:2772,Integrability,rout,routine,2772,"terpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should be #ifdef'd for the different sytems?. 9. the TabCom.FileIgnore resource is always applied, even if you; are not trying to complete a filename. 10. anything in quotes is assumed to be a filename; so (among other things) you can't complete a quoted class name:; eg, TClass class1( ""TDict[TAB] //; this won't work... looks for a file in pwd starting with TDict. 11. the prototypes tend to omit the word ""const"" a lot.; this is a problem with ROOT or CINT. 12. when listing ambiguous matches, only one column is used,; even if there are many completions. 13. anonymous objects are not currently identified; so, for example,. root> printf( TString([TAB. gives an error message instead of listing TString's constructors.; (this could be fixed). 14. the routine that adds the ""appendage"" isn't smart enough to know; if it's already there:. root> TCanvas::Update(); press [TAB] here ^; root> TCanvas::Update()(); (this could be fixed). 15. the appendage is only applied if there is exactly 1 match.; eg, this. root> G__at[TAB]; root> G__ateval. happens instead of this. root> G__at[TAB]; root> G__ateval(. because there are several overloaded versions of G__ateval().; (this could be fixed). Function Members (Methods); public:. virtual~TTabCom(); static Char_tAllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); static voidAppendListOfFilesInDirectory(const char[] dirName, TSeqCollection* pList); static TClass*Class(); voidClearAll(); voidClearClasses(); voidClearCppDirectives(); voidClearEnvVars(); voidClearFiles(); voidClearGlobalFunctions(); voidClearGlobals(); voidClearPragmas(); voidClearSysIncFiles(); voidClearUsers(); static TStringDetermineClass(const char[] varName); static Bool_tExcludedByFignore(TString s); const TSeqCollection*GetListOfClasses(); const ",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:12859,Integrability,message,message,12859,"red. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char[] className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char[] varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char[] regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments ",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:113,Modifiability,inherit,inheritance,113,". TTabCom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TTabCom. class TTabCom. TTabCom. This class performs basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; f",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:428,Modifiability,variab,variable,428,". TTabCom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TTabCom. class TTabCom. TTabCom. This class performs basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; f",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:583,Modifiability,variab,variable,583,". TTabCom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TTabCom. class TTabCom. TTabCom. This class performs basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; f",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:1293,Modifiability,variab,variables,1293,"basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should be #ifdef'd for the different sytems?. 9. the TabCom.FileIgnore resource is always applied, even if you; are not trying to complete a filename. 10. anything in quotes is assumed to be a filename; so (among other things) you can't complete a quoted class name:; eg, TClass class1( ""TDict[TAB] //; ",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:7765,Modifiability,variab,variables,7765,T_Load; static TTabCom::EContext_tkSYS_EnvVar; static TTabCom::EContext_tkSYS_FileName; static TTabCom::EContext_tkSYS_UserName; static TTabCom::EContext_tkUNKNOWN_CONTEXT. private:. char*fBufinitialized by Hook(); Int_tfLastIterfrodo: iteration counter for recursive MakeClassFromVarName; Pattern_tfPat[25][1024]array of patterns; ULong64_tfPrevInterpMarker; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance Chart:. TTabCom. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds ,MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:7993,Modifiability,variab,variables,7993,odo: iteration counter for recursive MakeClassFromVarName; Pattern_tfPat[25][1024]array of patterns; ULong64_tfPrevInterpMarker; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance Chart:. TTabCom. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollec,MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:8437,Modifiability,variab,variables,8437,"n*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance Chart:. TTabCom. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char[] path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); Return the list of globals. TCollection * GetListOfGlobalFunctions(); Return the list of global functions. const TSeqCollection * GetListOfPragmas(); Return",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:9220,Modifiability,variab,variables,9220," system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char[] path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); Return the list of globals. TCollection * GetListOfGlobalFunctions(); Return the list of global functions. const TSeqCollection * GetListOfPragmas(); Return the list of pragmas. const TSeqCollection * GetListOfSysIncFiles(); Return the list of system include files. const TSeqCollection * GetListOfUsers(); reads from ""/etc/passwd"". Char_t AllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); [static utility function]. if all the strings in ""*pList"" have the same ith character,; that character is returned.; otherwise 0 is returned. any string ""s"" for which ""ExcludedByFignore(s)"" is true; will be ignored unless All the strings in ""*pList""; are ""ExcludedByFignore()"". in addition, the number of strings which were not; ""ExcludedByFignore()"" is returned in ""nGoodStrings"". void AppendListOfFilesInDirectory(const char[] dirName, TSeqCollection* pList); [static utility functi",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:11591,Modifiability,variab,variable,11591," [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char[] fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char[] path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error h",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:13108,Modifiability,variab,variable,13108,"l to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char[] className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char[] className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char[] varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char[] regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:310,Performance,perform,performs,310,". TTabCom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TTabCom. class TTabCom. TTabCom. This class performs basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; f",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:888,Security,access,access,888,". TTabCom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TTabCom. class TTabCom. TTabCom. This class performs basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; f",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:11516,Testability,test,test,11516," fails for pointers to functions. Bool_t ExcludedByFignore(TString s); [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char[] fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char[] path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char[] defaultPath) const; [private]. TString ExtendPath(const char[] originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:8251,Usability,clear,clears,8251,"ctives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance Chart:. TTabCom. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char[] path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); R",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTabCom.html:8729,Usability,clear,clears,8729,"ent variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char[] path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); Return the list of globals. TCollection * GetListOfGlobalFunctions(); Return the list of global functions. const TSeqCollection * GetListOfPragmas(); Return the list of pragmas. const TSeqCollection * GetListOfSysIncFiles(); Return the list of system include files. const TSeqCollection * GetListOfUsers(); reads from ""/etc/passwd"". Char_t AllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); [static utility function]. if all the strings in ""*pList"" have the same it",MatchSource.WIKI,root/html604/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTabCom.html
https://root.cern/root/html604/TTable.html:6610,Availability,error,error,6610,"newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TTable& array); virtual voidDeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*GetArray() const; virtua",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:6694,Availability,error,error,6694," voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TTable& array); virtual voidDeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual const Char_t*GetColumnComm",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:27661,Availability,down,down,27661," row index the ""row"" has occupied. row == 0 see method TTable::AddAt(const void *row, Int_t i). void AddAt(const void* c, Int_t i); Add one element (""row"") of structure at position ""i"".; Check for out of bounds. If the row == 0 the ""i"" cell is still occupied and; filled with the pattern ""ff"". void CopyStruct(Char_t* dest, const Char_t* src); Copy the C-structure src into the new location; the length of the strucutre is defined by this class descriptor. void CopySet(TTable& array); to be documented. const Char_t * GetColumnComment(Int_t columnIndex) const; Get a comment from the table descriptor. Long_t AppendRows(const void* row, UInt_t nRows); Append nRows row of the array ""row"" to the table; return; - the new table size (# of table rows); - 0 if the object doesn't own the internal array and can not expand it. Long_t InsertRows(const void* rows, Long_t indx, UInt_t nRows = 1); void InsertRows(cons void *row, Long_t indx, UInt_t nRows). Insert one or several rows into the table at ""indx"" position; The rest table stuff is shifted down. cons void - a pointer to the array of rows to be inserted; Long_t indx = The position these rows will be inserted to; Int_t nRows - the total number of rows to be inserted; = 1 ""by default; return:; The number of the rows has been shifted to accomodate; the new rows. void * ReAllocate(); Reallocate this table leaving only (used rows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if spa",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:28626,Availability,avail,available,28626,"rows into the table at ""indx"" position; The rest table stuff is shifted down. cons void - a pointer to the array of rows to be inserted; Long_t indx = The position these rows will be inserted to; Int_t nRows - the total number of rows to be inserted; = 1 ""by default; return:; The number of the rows has been shifted to accomodate; the new rows. void * ReAllocate(); Reallocate this table leaving only (used rows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); Fit a projected item(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See ",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:30530,Availability,error,error,30530,"(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See TTable::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; table.Fit(pol4,""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. const Char_t * GetType() const; Returns the type of the wrapped C-structure kept as the TNamed title. Bool_t IsFolder() const; return Folder flag to be used by TBrowse object; The table is a folder if; - it has sub-dataset; or; - GetNRows > 0. Int_t NaN(). return the total number of the NaN for float/double cells of this table; Thanks Victor Perevoztchikov. TTable * New(const Char_t* name, const Char_t* type, void* array, UInt_t size); This static method creates a new TTable object if provided. Bool_t OutOfBoundsError(const char* where, Int_t i) const; Generate an out-of-bounds error. Always returns false. Char_t * Print(Char_t* buf, Int_t n) const; Create IDL table defintion (to be used for XDF I/O). const Char_t * PrintHeader() const; Print general table inforamtion. const Char_t * Print(Int_t row, Int_t rownumber = 10, const Char_t* colfirst = """", const Char_t* collast = """") const; const Char_t *TTable::Print(Int_t row, Int_t rownumber, const Char_t *colfirst, const Char_t *collast) const. Print the contents of internal table per COLUMN. row - the index of the first row to print (counting from ZERO); rownumber - the total number of rows to print out (=10 by default). (No use !) Char_t *colfirst, *collast - the names of the first/last; to print out (not implemented yet). Check bounds and adjust it. void PrintContents(Option_t* opt = """") const; to be documented. void Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); -*-*",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:2315,Energy Efficiency,charge,charge,2315,"t start (cm). See also comments*; float phi0; /* azimuthal angle at start (deg) *; float z0; /* z-coord. at start (cm) *; float psi; /* azimuthal angle of pT vector (deg) *; float tanl; /* tan(dip) =pz/pt at start *; float invpt; /* 1/pt at start (GeV/c)^(-1) *; float curvature; /* Track curvature (1/cm) *; float covar[15]; /* full covariance matrix *; float chisq[2]; /* Chi-square per degree of freedom *; float x_first[3]; /* coord. of first measured point (cm) *; float x_last[3]; /* coord. of last measured point (cm) *; float length; /* from first to last point (cm) *; float impact; /* primary vertex (cm) *; unsigned long map[2]; /* extrap. info. (see preceding comments)*; int id; /* Primary key (see comments) *; int iflag; /* bitmask quality info. (see comments) *; int det_id; /* Detector id information *; int method; /* Track finding/fitting method, packed *; int pid; /* Geant particle ID for assumed mass *; int n_point; /* SVT, TPC, FTPC component #s are packed *; int n_max_point; /* SVT, TPC, FTPC component #s are packed *; int n_fit_point; /* SVT, TPC, FTPC component #s are packed *; int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(stru",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:28005,Energy Efficiency,allocate,allocated,28005,"ss descriptor. void CopySet(TTable& array); to be documented. const Char_t * GetColumnComment(Int_t columnIndex) const; Get a comment from the table descriptor. Long_t AppendRows(const void* row, UInt_t nRows); Append nRows row of the array ""row"" to the table; return; - the new table size (# of table rows); - 0 if the object doesn't own the internal array and can not expand it. Long_t InsertRows(const void* rows, Long_t indx, UInt_t nRows = 1); void InsertRows(cons void *row, Long_t indx, UInt_t nRows). Insert one or several rows into the table at ""indx"" position; The rest table stuff is shifted down. cons void - a pointer to the array of rows to be inserted; Long_t indx = The position these rows will be inserted to; Int_t nRows - the total number of rows to be inserted; = 1 ""by default; return:; The number of the rows has been shifted to accomodate; the new rows. void * ReAllocate(); Reallocate this table leaving only (used rows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be docum",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:28262,Energy Efficiency,allocate,allocated,28262," the table; return; - the new table size (# of table rows); - 0 if the object doesn't own the internal array and can not expand it. Long_t InsertRows(const void* rows, Long_t indx, UInt_t nRows = 1); void InsertRows(cons void *row, Long_t indx, UInt_t nRows). Insert one or several rows into the table at ""indx"" position; The rest table stuff is shifted down. cons void - a pointer to the array of rows to be inserted; Long_t indx = The position these rows will be inserted to; Int_t nRows - the total number of rows to be inserted; = 1 ""by default; return:; The number of the rows has been shifted to accomodate; the new rows. void * ReAllocate(); Reallocate this table leaving only (used rows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const ",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:29277,Energy Efficiency,allocate,allocated,29277,"size> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); Fit a projected item(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See TTable::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; table.Fit(pol4,""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. const Char_t * GetType() const; Returns the type of the wrapped C-structure kept as the TNamed title. Bool_t IsFolder() const; return Folder flag to be used by TBrowse object; The table is a folder if; - it has sub-dataset; or; - GetNRows > 0. Int_t NaN(). return the total number of the NaN for float/double cel",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:31871,Energy Efficiency,allocate,allocated,31871,"nst; const Char_t *TTable::Print(Int_t row, Int_t rownumber, const Char_t *colfirst, const Char_t *collast) const. Print the contents of internal table per COLUMN. row - the index of the first row to print (counting from ZERO); rownumber - the total number of rows to print out (=10 by default). (No use !) Char_t *colfirst, *collast - the names of the first/last; to print out (not implemented yet). Check bounds and adjust it. void PrintContents(Option_t* opt = """") const; to be documented. void Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); -*-*Make a projection of a TTable using selections; *-* =============================================. Depending on the value of varexp (described in Draw) a 1-D,2-D,etc; projection of the TTable will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. Int_t Purge(Option_t* opt = """"); Shrink the table to free the unused but still allocated rows. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Set(Int_t n); Set array size of TTable object to n longs. If n<0 leave array unchanged. void SetTablePointer(void* table); to be documented. void SetType(const char*const type); to be documented. Char_t * MakeExpression(const Char_t*[] expressions, Int_t nExpressions); Create CINT macro to evaluate the user-provided expresssion; Expression may contains:; - the table columen names; - 2 meta names: i$ - the current column index,; n$ - the total table size provided by TTable::GetNRows() method. return the name of temporary file with the current expressions. void Reset(Int_t c = 0); Fill the entire table with byte ""c"" ;; c=0 ""be default"". void ResetMap(Bool_t wipe = kTRUE); Clean all filled columns with the pointers to TTableMap; if any; wipe = kTRUE - delete all object the Map's point to; kFALSE - zero pointer, do not ",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:2545,Integrability,wrap,wrapper,2545," /* full covariance matrix *; float chisq[2]; /* Chi-square per degree of freedom *; float x_first[3]; /* coord. of first measured point (cm) *; float x_last[3]; /* coord. of last measured point (cm) *; float length; /* from first to last point (cm) *; float impact; /* primary vertex (cm) *; unsigned long map[2]; /* extrap. info. (see preceding comments)*; int id; /* Primary key (see comments) *; int iflag; /* bitmask quality info. (see comments) *; int det_id; /* Detector id information *; int method; /* Track finding/fitting method, packed *; int pid; /* Geant particle ID for assumed mass *; int n_point; /* SVT, TPC, FTPC component #s are packed *; int n_max_point; /* SVT, TPC, FTPC component #s are packed *; int n_fit_point; /* SVT, TPC, FTPC component #s are packed *; int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(Int_t n) : TTable(_QUOTE_(className),n,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:4326,Integrability,wrap,wrapped,4326,"e));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;}; structName &operator[](Int_t i){ assert(i>=0 && i < GetNRows()); return *GetTable(i); }; const structName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2. Second entry for the C-structure wrapped into the class.; Since C-structuire is not derived from TObject it must be; properly defined as ""foreign"" ROOT class; #pragma C++ class dst_track_st+;. meta-variables i$ and n$ introduced; where ""i$"" stands for the current row index; ""n$"" stands for the total number of rows; meta-variable can be used along the normal; table column names in the expressions (see for example; method TTable::Draw. Function Members (Methods); public:. virtual~TTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual Int_tAddAt(const void* c); virtual voidAddAt(const void* c, Int_t i); virtual voidAddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidAdopt(Int_t n, void* array); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long_tAppendRows(const voi",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:29134,Integrability,wrap,wrapped,29134,"le; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); Fit a projected item(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See TTable::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; table.Fit(pol4,""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. const Char_t * GetType() const; Returns the type of the wrapped C-structure kept as the TNamed title. Bool_t IsFolder() const; return Folder flag to be used by T",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:30001,Integrability,wrap,wrapped,30001,"DataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); Fit a projected item(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See TTable::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; table.Fit(pol4,""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. const Char_t * GetType() const; Returns the type of the wrapped C-structure kept as the TNamed title. Bool_t IsFolder() const; return Folder flag to be used by TBrowse object; The table is a folder if; - it has sub-dataset; or; - GetNRows > 0. Int_t NaN(). return the total number of the NaN for float/double cells of this table; Thanks Victor Perevoztchikov. TTable * New(const Char_t* name, const Char_t* type, void* array, UInt_t size); This static method creates a new TTable object if provided. Bool_t OutOfBoundsError(const char* where, Int_t i) const; Generate an out-of-bounds error. Always returns false. Char_t * Print(Char_t* buf, Int_t n) const; Create IDL table defintion (to be used for XDF I/O). const Char_t * PrintHeader() const; Print general table inforamtion. const Char_t * Print(Int_t row, Int_t rownumber = 10, const Char_t* colfirst = """", const Char_t* collast = """") const; const Char_t *TTable::Print(Int_t row, Int_t rownumber, const Char_t *colfirst, const Char_t *collast) const. Print the contents of internal table per C",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:112,Modifiability,inherit,inheritance,112,". TTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTable. class TTable: public TDataSet. TTable. Wraps the array of the plain C-structures (one C-structure per element). class TTable provides the automatic schema evolution for; the derived ""table"" classes saved with ROOT format. ""Automatic Schema evolution"" provides:; - skipping data-member if it is not present for the current; implementation of the ""table"" but was present at the time the; table was written;; - assign a default value ZERO for the brand-new data-members,; those were not in the structure when the object was written but; present now;; - trace propely any change in the order of the data-members. To enjoy this class one has to derive one's own custom class:. St_dst_track_Table.h:. #ifndef STAF_St_dst_track_Table; #define STAF_St_dst_track_Table. #include ""TTable.h"". #include ""dst_track.h"" the C-structure defintion may be kept; separately; typedef struct dst_track_st {; float r0; /* radius at start (cm). See also comments*; float phi0; /* azimuthal angle at start (deg) *; float z0; /* z-coord. at start (cm) *; float psi; /* azimuthal angle of pT vector (deg) *; float tanl; /* tan(dip) =pz/pt at start *; float invpt; /* 1/pt at start (GeV/c)^(-1) *; float curvature; /* Track curvature (1/cm) *; float covar[15]; /* full covariance matrix *; float chisq[2]; /* Chi-square per degree of freedom *; float x_first[3]; /* coord. of first measured point (cm) *; float x_last[3]; /* coord. of last measured point (cm) *; float length; /* from first to last point (cm) *; float impact; /* primary vertex (cm) *; unsigned long map[2]; /* extrap. info. (see preceding comments)*; int id; /* Primary key (see comments) *; int iflag; /* bitmask quality info. (see comments) *; int det_id; /* Detector id information *",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:4491,Modifiability,variab,variables,4491,"tructName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2. Second entry for the C-structure wrapped into the class.; Since C-structuire is not derived from TObject it must be; properly defined as ""foreign"" ROOT class; #pragma C++ class dst_track_st+;. meta-variables i$ and n$ introduced; where ""i$"" stands for the current row index; ""n$"" stands for the total number of rows; meta-variable can be used along the normal; table column names in the expressions (see for example; method TTable::Draw. Function Members (Methods); public:. virtual~TTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual Int_tAddAt(const void* c); virtual voidAddAt(const void* c, Int_t i); virtual voidAddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidAdopt(Int_t n, void* array); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long_tAppendRows(const void* row, UInt_t nRows); virtual voidAsString(void* buf, TTable::EColumnType type, Int_t width, ostream& out) const; const void*At(Int_t i) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual TObject*TDataSet::Clone(const c",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:4615,Modifiability,variab,variable,4615,"tructName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2. Second entry for the C-structure wrapped into the class.; Since C-structuire is not derived from TObject it must be; properly defined as ""foreign"" ROOT class; #pragma C++ class dst_track_st+;. meta-variables i$ and n$ introduced; where ""i$"" stands for the current row index; ""n$"" stands for the total number of rows; meta-variable can be used along the normal; table column names in the expressions (see for example; method TTable::Draw. Function Members (Methods); public:. virtual~TTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual Int_tAddAt(const void* c); virtual voidAddAt(const void* c, Int_t i); virtual voidAddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidAdopt(Int_t n, void* array); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long_tAppendRows(const void* row, UInt_t nRows); virtual voidAsString(void* buf, TTable::EColumnType type, Int_t width, ostream& out) const; const void*At(Int_t i) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual TObject*TDataSet::Clone(const c",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:21503,Modifiability,variab,variable,21503,"he rows been copied. void DeleteRows(Long_t indx, UInt_t nRows = 1); Delete one or several rows from the table. Int_t indx - index of the first row to be deleted; Int_t nRows - the total number of rows to be deleted; = 1 ""by default. TH1 * Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); *-*-*-*-*-*Draw expression varexp for specified entries; *-* ===========================================. This function accepts TCut objects as arguments.; Useful to use the string operator +; example:; table.Draw(""x"",cut1+cut2+cut3);. TCutG object with ""CUTG"" name can be created via the graphics editor. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); *-*-*-*-*-*Draw expression varexp for specified entries; *-* ===========================================. varexp is an expression of the general form e1:e2:e3; where e1,etc is a C++ expression referencing a combination of the TTable columns; One can use two extra meta variable ""i$"" and ""n$"" along with the table; column names.; i$ is to involve the current row number; n$ refers the total num,ber of rows of this table provided by TTable::GetNRows(). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x); = i$:sqrt(x) 2-Dim dsitribution of i versus sqrt(x[i]); = phep[0]:sqrt(phep[3]) 2-Dim dsitribution of phep[0] versus sqrt(phep[3]). Note that the variables e1, e2 or e3 may contain a boolean expression as well.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. selection is a C++ expression with a combination of the columns.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is no",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:22016,Modifiability,variab,variables,22016," object with ""CUTG"" name can be created via the graphics editor. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); *-*-*-*-*-*Draw expression varexp for specified entries; *-* ===========================================. varexp is an expression of the general form e1:e2:e3; where e1,etc is a C++ expression referencing a combination of the TTable columns; One can use two extra meta variable ""i$"" and ""n$"" along with the table; column names.; i$ is to involve the current row number; n$ refers the total num,ber of rows of this table provided by TTable::GetNRows(). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x); = i$:sqrt(x) 2-Dim dsitribution of i versus sqrt(x[i]); = phep[0]:sqrt(phep[3]) 2-Dim dsitribution of phep[0] versus sqrt(phep[3]). Note that the variables e1, e2 or e3 may contain a boolean expression as well.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. selection is a C++ expression with a combination of the columns.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:. value*(boolean expression). if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2 && 6 < i$ && i$ < n$""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection3 = ""signal*(log(signal)>1.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise.; selection3 returns a weight = signal if log(signal)>1.2. option is the drawing option; see TH1::Draw for the list of all drawing options.; If option contains th",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:23345,Modifiability,variab,variable,23345," operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:. value*(boolean expression). if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2 && 6 < i$ && i$ < n$""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection3 = ""signal*(log(signal)>1.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise.; selection3 returns a weight = signal if log(signal)>1.2. option is the drawing option; see TH1::Draw for the list of all drawing options.; If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). Saving the result of Draw to an histogram. By default the temporary histogram created is called htemp.; If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name;; table.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Saving the result of Draw to a TEventList. TTable::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; ",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:24229,Modifiability,variab,variable,24229,"ess (default is 0). Saving the result of Draw to an histogram. By default the temporary histogram created is called htemp.; If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name;; table.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Saving the result of Draw to a TEventList. TTable::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive session, one can type (after TTable::Draw); yplus.Print(""all""); to print the list of entry numbers in the list. By default, the specified entry list is reset.; To continue to append data to an existing list, use ""+"" in front; of the list name;; table.Draw("">>+yplus"",""y>0""); will not reset yplus, but will enter the selected entries at the end; of the existing list. Bool_t EntryLoop(const Char_t* exprFileName, Int_t& action, TObject* obj, Int_t nentries = 1000000000, Int_t firstentry = 0, Option_t* option = """"). EntryLoop creates a CINT bytecode to evaluate the given expressions for; all table rows in loop and fill the",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:28986,Performance,perform,perform,28986,"ows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); Fit a projected item(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See TTable::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; table.Fit(pol4,""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. const Char_t * GetType() const; Returns the type of t",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:3544,Testability,assert,assert,3544,"int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(Int_t n) : TTable(_QUOTE_(className),n,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;}; structName &operator[](Int_t i){ assert(i>=0 && i < GetNRows()); return *GetTable(i); }; const structName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:3646,Testability,assert,assert,3646,"int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(Int_t n) : TTable(_QUOTE_(className),n,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;}; structName &operator[](Int_t i){ assert(i>=0 && i < GetNRows()); return *GetTable(i); }; const structName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:22741,Testability,log,log,22741,"distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x); = i$:sqrt(x) 2-Dim dsitribution of i versus sqrt(x[i]); = phep[0]:sqrt(phep[3]) 2-Dim dsitribution of phep[0] versus sqrt(phep[3]). Note that the variables e1, e2 or e3 may contain a boolean expression as well.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. selection is a C++ expression with a combination of the columns.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:. value*(boolean expression). if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2 && 6 < i$ && i$ < n$""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection3 = ""signal*(log(signal)>1.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise.; selection3 returns a weight = signal if log(signal)>1.2. option is the drawing option; see TH1::Draw for the list of all drawing options.; If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). Saving the result of Draw to an histogram. By default the temporary histogram created is called htemp.; If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name;; table.Draw(""sqrt(x",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:22921,Testability,log,log,22921,"versus sqrt(x[i]); = phep[0]:sqrt(phep[3]) 2-Dim dsitribution of phep[0] versus sqrt(phep[3]). Note that the variables e1, e2 or e3 may contain a boolean expression as well.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. selection is a C++ expression with a combination of the columns.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:. value*(boolean expression). if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2 && 6 < i$ && i$ < n$""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection3 = ""signal*(log(signal)>1.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise.; selection3 returns a weight = signal if log(signal)>1.2. option is the drawing option; see TH1::Draw for the list of all drawing options.; If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). Saving the result of Draw to an histogram. By default the temporary histogram created is called htemp.; If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name;; table.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instea",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable.html:21707,Usability,simpl,simplest,21707,"ied entries; *-* ===========================================. This function accepts TCut objects as arguments.; Useful to use the string operator +; example:; table.Draw(""x"",cut1+cut2+cut3);. TCutG object with ""CUTG"" name can be created via the graphics editor. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); *-*-*-*-*-*Draw expression varexp for specified entries; *-* ===========================================. varexp is an expression of the general form e1:e2:e3; where e1,etc is a C++ expression referencing a combination of the TTable columns; One can use two extra meta variable ""i$"" and ""n$"" along with the table; column names.; i$ is to involve the current row number; n$ refers the total num,ber of rows of this table provided by TTable::GetNRows(). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x); = i$:sqrt(x) 2-Dim dsitribution of i versus sqrt(x[i]); = phep[0]:sqrt(phep[3]) 2-Dim dsitribution of phep[0] versus sqrt(phep[3]). Note that the variables e1, e2 or e3 may contain a boolean expression as well.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. selection is a C++ expression with a combination of the columns.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:. value*(boolean expression). if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2 && 6 < i$ && i$ < n$""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection3 = ""signal*(log(signal)>1.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>",MatchSource.WIKI,root/html604/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable.html
https://root.cern/root/html604/TTable3Points.html:3951,Availability,error,error,3951,"z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tTTablePoints::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAnyPoint(Int_t idx, TTable3Points::EPointDirection xAxis) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetKey(Int_t); virtual Int_tTTablePoints::GetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TTablePoints::GetOption() const; virtual Float_t*GetP() const; virtual void*TTablePoints::GetTable(); virtual const char*TObject::GetTitle() const; virt",MatchSource.WIKI,root/html604/TTable3Points.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable3Points.html
https://root.cern/root/html604/TTable3Points.html:4035,Availability,error,error,4035,"se(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tTTablePoints::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAnyPoint(Int_t idx, TTable3Points::EPointDirection xAxis) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetKey(Int_t); virtual Int_tTTablePoints::GetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TTablePoints::GetOption() const; virtual Float_t*GetP() const; virtual void*TTablePoints::GetTable(); virtual const char*TObject::GetTitle() const; virtual Int_tGetTotalKeys(); virtual UInt_tTObject::GetUniqueID() const; virtual Float_t",MatchSource.WIKI,root/html604/TTable3Points.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable3Points.html
https://root.cern/root/html604/TTable3Points.html:119,Modifiability,inherit,inheritance,119,". TTable3Points. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTable3Points. class TTable3Points: public TTablePoints. TTable3Points class is to create 3D view of any 3 columns of the TTable objects; with one and the same ""key column value"". For example all values of the column ""x[0]"" ""x[1]"" ""x[2]"" of the g2t_tpc_hit ; table; from the rows with one and same ""track_id"" column value will be regarded; as an image of one and the same ""track"".; The last means all those points will be painted with one and the same 3D; attributes like ""color"", ""size"", ""style"", ""light"",""markers"", ""connections"" etc. The original TTable object must be pre-sorted by ""key column"" via TTableSorter; class. void CreatePoints(Tg2t_tpc_hit *points); {; g2t_tpc_hit_st *p = points->GetTable();. TTable3Points *track = 0;; TString tr;; tr = ""track_p"";; TTable &ttt = *((TTable *)points);; // Track2Line MUST be on heap otherwise 3D view will crash just code leaves this; // subroutine; We will assemble all points by its ""track_p"" field. TTableSorter *Track2Line = new TTableSorter (ttt,""track_p"");. Int_t i = 0;; Char_t buffer[10];; Int_t ntracks = 0;; const Int_t maxtracks = 5;; ---------------------------- Fill tracks -------------------; long currentId = -1;; long newId = 0;; g2t_tpc_hit_st *hitPoint = 0;; TVolume *thisTrack[7] = {0,0,0,0,0,0,0}; // seven volumes for 7 different colors; Int_t MaxRowtoCount = 5000; // 5000;; Int_t MaxTracks = Track2Line->CountKeys();; MaxTracks = 100;; for (i=0;i<Track2Line->GetNRows() && ntracks < MaxTracks ;i++); {; hitPoint = p + Track2Line->GetIndex(i);; newId = hitPoint->track_p;; if (newId != currentId) { // The hit for the new track has been found. const Char_t *xName = ""x[0]"";; const Char_t *yName = ""x[1]"";; const Char_t *zName = ""x[2]"";. track = new TTable3P",MatchSource.WIKI,root/html604/TTable3Points.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable3Points.html
https://root.cern/root/html604/TTableDescriptor.html:2956,Availability,error,error,2956,", Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); TStringCreateLeafList() const; virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); UInt_tDimensions(Int_t columnIndex) const; Int_tDimensions(const Char_t* columnName = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; tableDescriptor_st*end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray",MatchSource.WIKI,root/html604/TTableDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableDescriptor.html
https://root.cern/root/html604/TTableDescriptor.html:3040,Availability,error,error,3040,"ay); TStringCreateLeafList() const; virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); UInt_tDimensions(Int_t columnIndex) const; Int_tDimensions(const Char_t* columnName = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; tableDescriptor_st*end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual const Char",MatchSource.WIKI,root/html604/TTableDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableDescriptor.html
https://root.cern/root/html604/TTableDescriptor.html:19477,Deployability,update,updates,19477,"ted. void LearnTable(TClass* classPtr). LearnTable() creates an array of the descriptors for elements of the row. It creates a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C-structure only !!!. This is to introduce an artificial restriction demanded by STAR database group. 1. the name may be 31 symbols at most; 2. the number the dimension is 3 at most. To lift this restriction one has to provide -DNORESTRICTIONS CPP symbol and; recompile code (and debug code NOW!). TTableDescriptor * MakeDescriptor(const char* structName). MakeDescriptor(const char *structName) - static method; structName - the name of the C structure; to create descriptor of; return a new instance of the TTableDescriptor or 0; if the ""structName is not present with the dictionary. TDataSet * MakeCommentField(Bool_t createFlag = kTRUE); Instantiate a comment dataset if any. Int_t UpdateOffsets(const TTableDescriptor* newDesciptor); ""Schema evolution""; Method updates the offsets with a new ones from another descriptor. Int_t ColumnByName(const Char_t* columnName = 0) const; Find the column index but the column name. Int_t Offset(const Char_t* columnName = 0) const; Return offset of the column defined by ""columnName""; Take in account index if provided; Can not handle multidimensional indeces yet. Int_t ColumnSize(const Char_t* columnName = 0) const; to be documented. Int_t TypeSize(const Char_t* columnName = 0) const; to be documented. Int_t Dimensions(const Char_t* columnName = 0) const; to be documented. TTable::EColumnType ColumnType(const Char_t* columnName = 0) const; to be documented. Int_t Sizeof() const; to be documented. const Char_t * ColumnName(Int_t columnIndex) const. inline TTableDescriptor(const TTableDescriptor &dsc) : TTable(dsc), fRowClass(dsc.fRowClass),fSecondDescriptor(0){}. {return ((tableDescriptor_st *)At(column))->fColumnName;}. UInt_t Offset(Int_t columnIndex) const; {return ((tableDescriptor_st *)At(co",MatchSource.WIKI,root/html604/TTableDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableDescriptor.html
https://root.cern/root/html604/TTableDescriptor.html:17886,Safety,avoid,avoid,17886,"taset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTableDescriptor * GetDescriptorPointer() const; return column descriptor. void SetDescriptorPointer(TTableDescriptor* list); set table descriptor. void SetCommentsSetName(const char* name = "".comments""); set comments name. void Streamer(TBuffer& ); The custom Streamer for this table. TTableDescriptor(const TTable* parentTable); to be documented. TTableDescriptor(TClass* classPtr); Create a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C_struture only !!!. ~TTableDescriptor(); class destructor. Int_t AddAt(const void* c); Append one row pointed by ""c"" to the descriptor. void AddAt(const void* c, Int_t i); Add one row pointed by ""c"" to the ""i""-th row of the descriptor. void AddAt(TDataSet* dataset, Int_t idx = 0); Add one dataset to the descriptor.; There is no new implementation here.; One needs it to avoid the ""hidden method"" compilation warning. void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx); Add the descriptor element followed by its commentText; at the indx-th position of the descriptor (counted from zero). TString CreateLeafList() const; Create a list of leaf to be useful for TBranch::TBranch ctor. void Init(TClass* classPtr); Create a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C_structure only !!!. void LearnTable(const TTable* parentTable); to be documented. void LearnTable(TClass* classPtr). LearnTable() creates an array of the descriptors for elements of the row. It creates a descriptor of the C-structure defined by TClass; TClass *classPtr must be a valid pointer to TClass object for; ""plain"" C-structure only !!!. This is to introduce an artificial restriction demanded by STAR database group. 1. the name may be 31 symbols at most; 2. the number the dimension is 3 at most. To lift",MatchSource.WIKI,root/html604/TTableDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableDescriptor.html
https://root.cern/root/html604/TTableDescriptor.html:22100,Testability,assert,assert,22100,"n))->fTypeSize; }. UInt_t Dimensions(Int_t columnIndex) const; {return ((tableDescriptor_st *)At(column))->fDimensions;}. TTable::EColumnType ColumnType(Int_t columnIndex) const; {return EColumnType(((tableDescriptor_st *)At(column))->fType);}. TClass * RowClass() const; { return fRowClass;}. void SetOffset(UInt_t offset, Int_t column); {((tableDescriptor_st *)At(column))->fOffset = offset;}. void SetSize(UInt_t size, Int_t column); {((tableDescriptor_st *)At(column))->fSize = size; }. void SetTypeSize(UInt_t size, Int_t column); {((tableDescriptor_st *)At(column))->fTypeSize = size; }. void SetDimensions(UInt_t dim, Int_t column); {((tableDescriptor_st *)At(column))->fDimensions = dim; }. void SetColumnType(TTable::EColumnType type, Int_t column); {((tableDescriptor_st *)At(column))->fType = type; }. TTableDescriptor & operator=(const TTableDescriptor& dsc). TTableDescriptor(const TTable* parentTable). TTableDescriptor(TClass* classPtr). TTableDescriptor(const TTableDescriptor& dsc); {}. TTableDescriptor(); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name); {SetType(""tableDescriptor_st"");}. tableDescriptor_st * GetTable(Int_t i = 0) const; { return ((tableDescriptor_st *)GetArray())+i;}. tableDescriptor_st & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const tableDescriptor_st & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const tableDescriptor_st *)(GetTable(i))); }. tableDescriptor_st * begin() const; { return GetNRows()? GetTable(0):0;}. tableDescriptor_st * end() const; {Long_t i = GetNRows(); return i? GetTable(i):0;}. const char * TableDictionary(). » Author: Valery Fine 09/08/99 (E-mail: fine@bnl.gov) » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTableDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableDescriptor.html
https://root.cern/root/html604/TTableDescriptor.html:22212,Testability,assert,assert,22212,"n))->fTypeSize; }. UInt_t Dimensions(Int_t columnIndex) const; {return ((tableDescriptor_st *)At(column))->fDimensions;}. TTable::EColumnType ColumnType(Int_t columnIndex) const; {return EColumnType(((tableDescriptor_st *)At(column))->fType);}. TClass * RowClass() const; { return fRowClass;}. void SetOffset(UInt_t offset, Int_t column); {((tableDescriptor_st *)At(column))->fOffset = offset;}. void SetSize(UInt_t size, Int_t column); {((tableDescriptor_st *)At(column))->fSize = size; }. void SetTypeSize(UInt_t size, Int_t column); {((tableDescriptor_st *)At(column))->fTypeSize = size; }. void SetDimensions(UInt_t dim, Int_t column); {((tableDescriptor_st *)At(column))->fDimensions = dim; }. void SetColumnType(TTable::EColumnType type, Int_t column); {((tableDescriptor_st *)At(column))->fType = type; }. TTableDescriptor & operator=(const TTableDescriptor& dsc). TTableDescriptor(const TTable* parentTable). TTableDescriptor(TClass* classPtr). TTableDescriptor(const TTableDescriptor& dsc); {}. TTableDescriptor(); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name); {SetType(""tableDescriptor_st"");}. tableDescriptor_st * GetTable(Int_t i = 0) const; { return ((tableDescriptor_st *)GetArray())+i;}. tableDescriptor_st & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const tableDescriptor_st & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const tableDescriptor_st *)(GetTable(i))); }. tableDescriptor_st * begin() const; { return GetNRows()? GetTable(0):0;}. tableDescriptor_st * end() const; {Long_t i = GetNRows(); return i? GetTable(i):0;}. const char * TableDictionary(). » Author: Valery Fine 09/08/99 (E-mail: fine@bnl.gov) » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTableDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableDescriptor.html
https://root.cern/root/html604/TTableIter.html:1513,Availability,error,error,1513,"ad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountKey(Float_t& keyvalue); Int_tCountKey(Long_t& keyvalue); Int_tCountKey(Int_t& keyvalue); Int_tCountKey(Short_t& keyvalue); Int_tCountKey(Double_t& keyvalue); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNRows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(con",MatchSource.WIKI,root/html604/TTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableIter.html
https://root.cern/root/html604/TTableIter.html:1597,Availability,error,error,1597,"lass(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountKey(Float_t& keyvalue); Int_tCountKey(Long_t& keyvalue); Int_tCountKey(Int_t& keyvalue); Int_tCountKey(Short_t& keyvalue); Int_tCountKey(Double_t& keyvalue); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNRows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) con",MatchSource.WIKI,root/html604/TTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableIter.html
https://root.cern/root/html604/TTableIter.html:116,Modifiability,inherit,inheritance,116,". TTableIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTableIter. class TTableIter: public TObject. TTableIter - class iterator to loop over sorted TTable's. Function Members (Methods); public:. virtual~TTableIter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountKey(Float_t& keyvalue); Int_tCountKey(Long_t& keyvalue); Int_tCountKey(Int_t& keyvalue); Int_tCountKey(Short_t& keyvalue); Int_tCountKey(Double_t& keyvalue); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName(",MatchSource.WIKI,root/html604/TTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableIter.html
https://root.cern/root/html604/TTableMap.html:3738,Availability,error,error,3738,"long>::crbegin() const; vector<long>::const_reverse_iteratorvector<long>::crend() const; long*vector<long>::data(); const long*vector<long>::data() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; boolvector<long>::empty() const; TTable::iteratorEnd(); TTable::iteratorEnd() const; vector<long>::iteratorvector<long>::end(); vector<long>::const_iteratorvector<long>::end() const; vector<long>::iteratorvector<long>::erase(vector<long>::iterator __position); vector<long>::iteratorvector<long>::erase(vector<long>::iterator __first, vector<long>::iterator __last); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; vector<long>::referencevector<long>::front(); vector<long>::const_referencevector<long>::front() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const",MatchSource.WIKI,root/html604/TTableMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableMap.html
https://root.cern/root/html604/TTableMap.html:3822,Availability,error,error,3822,"nst; long*vector<long>::data(); const long*vector<long>::data() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; boolvector<long>::empty() const; TTable::iteratorEnd(); TTable::iteratorEnd() const; vector<long>::iteratorvector<long>::end(); vector<long>::const_iteratorvector<long>::end() const; vector<long>::iteratorvector<long>::erase(vector<long>::iterator __position); vector<long>::iteratorvector<long>::erase(vector<long>::iterator __first, vector<long>::iterator __last); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; vector<long>::referencevector<long>::front(); vector<long>::const_referencevector<long>::front() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const ",MatchSource.WIKI,root/html604/TTableMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableMap.html
https://root.cern/root/html604/TTableMap.html:115,Modifiability,inherit,inheritance,115,". TTableMap. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTableMap. class TTableMap: public TObject, public vector<long>. TTableMap class is helper class to keep the list of the referencs to the; TTable rows and iterate over it.; TTableMap is a persistent class.; The pointer to the TTableMap object may be used as an element; of the TTable row and saved with the table all together. For example, the track table may contain a member to the ""map"" of the hits; struct {; float helix;; TTableMap *hits;; } tracks_t;. // Create track table:; LArTrackTable *tracks = new LArTrackTable(...);. // Get pointer to the hit table; LArHitTable *hits = GiveMeHits();; // Loop over all tracks; LArTrackTable::iterator track = tracks->begin();; LArTrackTable::iterator last = tracks->end();; for (;track != last;track++) {; // Find all hits of this track; LArHitTable::iterator hit = hits->begin();; LArHitTable::iterator lastHit = hits->end();; Long_t hitIndx = 0;; // Create an empty list of this track hits; (*track).hits = new TTableMap(hits);; for(;hit != lastHit;hit++,hitIndx) {; if (IsMyHit(*hit)) { // add this hit index to the current track; (*track).hits->push_back(hitIndx);; }; }; }. Function Members (Methods); public:. virtual~TTableMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidvector<long>::assign(initializer_list<vector<long>::value_type> __l); voidvector<long>::assign(vector<unsigned int>::size_type __n, const vector<long>::value_type& __val); vector<long>::referencevector<long>::at(vector<unsigned int>::size_type __n); vector<long>::const_referencevector<long>::at(vector<unsigned int>::size_type __n) const; vector<long>::referencevector<long>::back(); vector<long>::const_referencevector<long>::back()",MatchSource.WIKI,root/html604/TTableMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableMap.html
https://root.cern/root/html604/TTableMap.html:2474,Usability,clear,clear,2474,"hod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidvector<long>::assign(initializer_list<vector<long>::value_type> __l); voidvector<long>::assign(vector<unsigned int>::size_type __n, const vector<long>::value_type& __val); vector<long>::referencevector<long>::at(vector<unsigned int>::size_type __n); vector<long>::const_referencevector<long>::at(vector<unsigned int>::size_type __n) const; vector<long>::referencevector<long>::back(); vector<long>::const_referencevector<long>::back() const; TTable::iteratorBegin(); TTable::iteratorBegin() const; vector<long>::iteratorvector<long>::begin(); vector<long>::const_iteratorvector<long>::begin() const; virtual voidTObject::Browse(TBrowser* b); vector<unsigned int>::size_typevector<long>::capacity() const; vector<long>::const_iteratorvector<long>::cbegin() const; vector<long>::const_iteratorvector<long>::cend() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidvector<long>::clear(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; vector<long>::const_reverse_iteratorvector<long>::crbegin() const; vector<long>::const_reverse_iteratorvector<long>::crend() const; long*vector<long>::data(); const long*vector<long>::data() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; boolvector<long>::empty() const; TTable::iteratorEnd(); TTable::iteratorEnd() const; vector<long>::iteratorvector<long>::end(); vector<long>::const_iteratorvector<long>::end() const; vector<long>::iteratorvector<long>::erase(vector<long>::iterator __positi",MatchSource.WIKI,root/html604/TTableMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableMap.html
https://root.cern/root/html604/TTablePoints.html:1122,Availability,avail,available,1122,"le; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTablePoints. class TTablePoints: public TPoints3DABC. Defines the TTable as an element of ""event"" geometry. +SEQ,TTablePoints.; +SEQ,T<your_table_name_here>. class T<your_table_name_here>_Points : public TTablePoints; {; public:; T<your_table_name_here>_Points(TTableSorter *sorter,const void *key,Option_t *opt):; TTablePoints(sorter,key,opt){}; virtual ~T<your_table_name_here>_Points(){} // default destructor; virtual Float_t GetX(Int_t indx) { return ((<your_table_name_here>_st *)fRows)[Indx(idx)]-> <x>;}; virtual Float_t GetY(Int_t indx) { return ((<your_table_name_here>_st *)fRows)[Indx(idx)]-> <y>;}; virtual Float_t GetZ(Int_t indx) { return ((<your_table_name_here>_st *)fRows)[Indx(idx)]-> <z>;}; };. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TTablePoints(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTPoints3DABC::Add(Float_t x, Float_t y, Float_t z); virtual Int_tTPoints3DABC::AddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::Dr",MatchSource.WIKI,root/html604/TTablePoints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTablePoints.html
https://root.cern/root/html604/TTablePoints.html:2348,Availability,error,error,2348,"_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tTPoints3DABC::GetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*TPoints3DABC::GetP() const; virtual void*GetTable(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*TPoints3DABC::GetXYZ(Int_",MatchSource.WIKI,root/html604/TTablePoints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTablePoints.html
https://root.cern/root/html604/TTablePoints.html:2432,Availability,error,error,2432,"dTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tTPoints3DABC::GetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*TPoints3DABC::GetP() const; virtual void*GetTable(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*TPoints3DABC::GetXYZ(Int_t idx); virtual Float_t*TPoints3DABC::GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1)",MatchSource.WIKI,root/html604/TTablePoints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTablePoints.html
https://root.cern/root/html604/TTablePoints.html:118,Modifiability,inherit,inheritance,118,". TTablePoints. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTablePoints. class TTablePoints: public TPoints3DABC. Defines the TTable as an element of ""event"" geometry. +SEQ,TTablePoints.; +SEQ,T<your_table_name_here>. class T<your_table_name_here>_Points : public TTablePoints; {; public:; T<your_table_name_here>_Points(TTableSorter *sorter,const void *key,Option_t *opt):; TTablePoints(sorter,key,opt){}; virtual ~T<your_table_name_here>_Points(){} // default destructor; virtual Float_t GetX(Int_t indx) { return ((<your_table_name_here>_st *)fRows)[Indx(idx)]-> <x>;}; virtual Float_t GetY(Int_t indx) { return ((<your_table_name_here>_st *)fRows)[Indx(idx)]-> <y>;}; virtual Float_t GetZ(Int_t indx) { return ((<your_table_name_here>_st *)fRows)[Indx(idx)]-> <z>;}; };. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TTablePoints(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTPoints3DABC::Add(Float_t x, Float_t y, Float_t z); virtual Int_tTPoints3DABC::AddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual ",MatchSource.WIKI,root/html604/TTablePoints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTablePoints.html
https://root.cern/root/html604/TTableRange.html:478,Availability,avail,available,478,". TTableRange. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TTableRange. class TTableRange. TGTable. TGTable implements a table widget to display data in rows and; columns. The data is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimp",MatchSource.WIKI,root/html604/TTableRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableRange.html
https://root.cern/root/html604/TTableRange.html:2297,Deployability,update,update,2297,"is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; It is also possible to visualise data from a tree. A simple macro; showing the use of a TTreeTableInterface follows. Picture; Source. {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");. // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. // Set a selection; iface->SetSelection(""px >",MatchSource.WIKI,root/html604/TTableRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableRange.html
https://root.cern/root/html604/TTableRange.html:3382,Deployability,update,update,3382,"e; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; It is also possible to visualise data from a tree. A simple macro; showing the use of a TTreeTableInterface follows. Picture; Source. {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");. // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. // Set a selection; iface->SetSelection(""px > 0."");; // Add a column; iface->AddColumn(""(px+py)/(px-py)"", 0);; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }. Function Members (Methods); public:. virtual~TTableRange(); static TClass*Class(); virtual TClass*IsA() const; TTableRange&operator=(const TTableRange&); Bool_toperator==(TTableRange& other); virtual voidPrint(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTableRange(); TTableRange(const TTableRange&). Data Members; public:. UInt_tfXbrBottom right X coordinate; UInt_tfXtlTop left X coordinate; UInt_tfYbrBottom right Y coordinate; UInt_tfYtlTop left Y coordinate. Class Charts. Inheritance Chart:. TTableRange. Function documentation; TTableRange(); TTableRange constuctor. void Print(); Print the values of a range. Bool_t operator==(T",MatchSource.WIKI,root/html604/TTableRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableRange.html
https://root.cern/root/html604/TTableRange.html:1462,Integrability,interface,interface,1462,"ta is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetW",MatchSource.WIKI,root/html604/TTableRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableRange.html
https://root.cern/root/html604/TTableRange.html:1984,Integrability,interface,interface,1984,"n in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; It is also possible to visualise data from a tree. A simple macro; showing the use of a TTreeTableInterface follows. Picture; Source. {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");. // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, ",MatchSource.WIKI,root/html604/TTableRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableRange.html
https://root.cern/root/html604/TTableRange.html:2856,Integrability,interface,interface,2856,"me* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; It is also possible to visualise data from a tree. A simple macro; showing the use of a TTreeTableInterface follows. Picture; Source. {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");. // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. // Set a selection; iface->SetSelection(""px > 0."");; // Add a column; iface->AddColumn(""(px+py)/(px-py)"", 0);; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }. Function Members (Methods); public:. virtual~TTableRange(); static TClass*Class(); virtual TClass*IsA() const; TTableRange&operator=(const TTableRange&); Bool_toperator==(TTableRange& other); virtual voidPrint(); virtual voidShowMembers(TMemberInspector& insp",MatchSource.WIKI,root/html604/TTableRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableRange.html
https://root.cern/root/html604/TTableRange.html:117,Modifiability,inherit,inheritance,117,". TTableRange. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TTableRange. class TTableRange. TGTable. TGTable implements a table widget to display data in rows and; columns. The data is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimp",MatchSource.WIKI,root/html604/TTableRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableRange.html
https://root.cern/root/html604/TTableRange.html:524,Performance,optimiz,optimizations,524,". TTableRange. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TTableRange. class TTableRange. TGTable. TGTable implements a table widget to display data in rows and; columns. The data is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimp",MatchSource.WIKI,root/html604/TTableRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableRange.html
https://root.cern/root/html604/TTableRange.html:803,Performance,load,load,803,". TTableRange. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TTableRange. class TTableRange. TGTable. TGTable implements a table widget to display data in rows and; columns. The data is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimp",MatchSource.WIKI,root/html604/TTableRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableRange.html
https://root.cern/root/html604/TTableRange.html:1475,Usability,simpl,simple,1475,"onality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe-",MatchSource.WIKI,root/html604/TTableRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableRange.html
https://root.cern/root/html604/TTableRange.html:2595,Usability,simpl,simple,2595,"UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; It is also possible to visualise data from a tree. A simple macro; showing the use of a TTreeTableInterface follows. Picture; Source. {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");. // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. // Set a selection; iface->SetSelection(""px > 0."");; // Add a column; iface->AddColumn(""(px+py)/(px-py)"", 0);; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }",MatchSource.WIKI,root/html604/TTableRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableRange.html
https://root.cern/root/html604/TTableSorter.html:4037,Availability,error,error,4037,"e) const; Int_tBinarySearch(Bool_t value) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const; virtual Int_tCountKeys() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Int_tFindFirstKey(const void* key) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetColumnName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFirstRow() const; virtual const char*TObject::GetIconName() const; Int_tGetIndex(UInt_t sortedIndex) const; virtual const void*GetKeyAddress(Int_t indx); virtual Int_tGetLastFound() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNRows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOptio",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:4121,Availability,error,error,4121,"r* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const; virtual Int_tCountKeys() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Int_tFindFirstKey(const void* key) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetColumnName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFirstRow() const; virtual const char*TObject::GetIconName() const; Int_tGetIndex(UInt_t sortedIndex) const; virtual const void*GetKeyAddress(Int_t indx); virtual Int_tGetLastFound() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNRows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TTable*GetTable() const; virtual const char*GetTableName() const;",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:409,Integrability,interface,interface,409,". TTableSorter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTableSorter. class TTableSorter: public TNamed. TTableSorter - Is an ""observer"" class to sort the TTable objects; The class provides an interface to the standard ""C/C++"". qsort and bsearch subroutines (for further information see your local C/C++ docs); ===== =======. - This class DOESN'T change / touch the ""host"" table itself; For any TTable object one can create as many different ""sorter""; as one finds useful for one's code; - Any instance of this class is meaningful as long as the ""host"" object; ""TTable"" does exist and is not changed; - Any attempt to access this TTableSorter after the ""host"" object deleted; causes the program abnormal termination; - Any attempt to access this TTableSorter after the ""host"" object been changed; causes an unpredictable result; - Any instance (object) of this class is NOT deleted ""by automatic"" just; the ""host object ""TTable"" deleted. It is the responsibility of the user's code; keeping TTableSorter and the the ""host"" TTable objects consistent. ""To do"" list. 1. A separate method to provide lexicographical sort if the ""sorted"" column is a kind of array. Usage:; 1. Create an instance of the sorter for the selected column of your table. new TTableSorter(TTable &table, TString &colName,Int_t firstRow,Int_t numberRows). All sort actions are performed within TTableSorter ctor.; This means one needs no extra effort to SORT table. ""Sorter"" contains; the ""sorted index array"" as soon as you create the sorter. TTableSorter sorter(MyTable,""id"",20, 34);; - Creates a sorter for MyTable column ""id"" ordering; its 34 rows from 20 row with standard ""C"" qsort subroutine. 2. You may use this instance to search any ""id"" value with operator []; to get the table row index as follows:. Int",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:118,Modifiability,inherit,inheritance,118,". TTableSorter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTableSorter. class TTableSorter: public TNamed. TTableSorter - Is an ""observer"" class to sort the TTable objects; The class provides an interface to the standard ""C/C++"". qsort and bsearch subroutines (for further information see your local C/C++ docs); ===== =======. - This class DOESN'T change / touch the ""host"" table itself; For any TTable object one can create as many different ""sorter""; as one finds useful for one's code; - Any instance of this class is meaningful as long as the ""host"" object; ""TTable"" does exist and is not changed; - Any attempt to access this TTableSorter after the ""host"" object deleted; causes the program abnormal termination; - Any attempt to access this TTableSorter after the ""host"" object been changed; causes an unpredictable result; - Any instance (object) of this class is NOT deleted ""by automatic"" just; the ""host object ""TTable"" deleted. It is the responsibility of the user's code; keeping TTableSorter and the the ""host"" TTable objects consistent. ""To do"" list. 1. A separate method to provide lexicographical sort if the ""sorted"" column is a kind of array. Usage:; 1. Create an instance of the sorter for the selected column of your table. new TTableSorter(TTable &table, TString &colName,Int_t firstRow,Int_t numberRows). All sort actions are performed within TTableSorter ctor.; This means one needs no extra effort to SORT table. ""Sorter"" contains; the ""sorted index array"" as soon as you create the sorter. TTableSorter sorter(MyTable,""id"",20, 34);; - Creates a sorter for MyTable column ""id"" ordering; its 34 rows from 20 row with standard ""C"" qsort subroutine. 2. You may use this instance to search any ""id"" value with operator []; to get the table row index as follows:. Int",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:1563,Performance,perform,performed,1563," / touch the ""host"" table itself; For any TTable object one can create as many different ""sorter""; as one finds useful for one's code; - Any instance of this class is meaningful as long as the ""host"" object; ""TTable"" does exist and is not changed; - Any attempt to access this TTableSorter after the ""host"" object deleted; causes the program abnormal termination; - Any attempt to access this TTableSorter after the ""host"" object been changed; causes an unpredictable result; - Any instance (object) of this class is NOT deleted ""by automatic"" just; the ""host object ""TTable"" deleted. It is the responsibility of the user's code; keeping TTableSorter and the the ""host"" TTable objects consistent. ""To do"" list. 1. A separate method to provide lexicographical sort if the ""sorted"" column is a kind of array. Usage:; 1. Create an instance of the sorter for the selected column of your table. new TTableSorter(TTable &table, TString &colName,Int_t firstRow,Int_t numberRows). All sort actions are performed within TTableSorter ctor.; This means one needs no extra effort to SORT table. ""Sorter"" contains; the ""sorted index array"" as soon as you create the sorter. TTableSorter sorter(MyTable,""id"",20, 34);; - Creates a sorter for MyTable column ""id"" ordering; its 34 rows from 20 row with standard ""C"" qsort subroutine. 2. You may use this instance to search any ""id"" value with operator []; to get the table row index as follows:. Int_t id = 5;; Int_t index = sorter[id]; // Look for the row index with id = 5; // using the standard ""C"" ""bsearch"" binary search; // subroutine; Int_t index = sorter(id); // Look for the row index with id ""nearest"" to 5; // using the internal ""BinarySearch"" method. 3. Some useful methods of this class:. 3.1. CountKeys(); 3.2 CountKey(const void *key, Int_t firstIndx=0,Bool_t bSearch=kTRUE,Int_t *firstRow=0); 3.3. FindFirstKey(const void *key); 3.4. GetIndex(UInt_t sortedIndex). Function Members (Methods); public:. virtual~TTableSorter(); voidTObject::AbstractMethod",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:15353,Safety,safe,safe,15353,"ingle integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const TTable& table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table according the function ""search"". - search - the function to compare the ""key"" and the table rows during sorting; typedef Int_t (*SEARCHMETHOD) (const void *, const void **);. - compare - the function to compare two table rows during searching; typedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. TTableSorter(const TTable* table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table according the function ""search"". - search - the function to compare the ""key"" and the table rows during sorting; typedef Int_t (*SEARCHMETHOD) (const void *, const void **);. - compare - the function to compare two table rows during searching; typedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:16205,Safety,safe,safe,16205,"from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. TTableSorter(const TTable* table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table according the function ""search"". - search - the function to compare the ""key"" and the table rows during sorting; typedef Int_t (*SEARCHMETHOD) (const void *, const void **);. - compare - the function to compare two table rows during searching; typedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:18945,Safety,avoid,avoid,18945,"able rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original index of the row by its sorted index. Int_t CountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const. CountKey counts the number of rows with the key value equal ""key"". key - it is a POINTER to the key value; fistIndx - the first index within sorted array to star search; = 0 by default; bSearch = kTRUE - binary search (by default) is used otherwise linear one. Int_t CountKeys() const. Counts the number of different key values. Bool_t FillIndexArray(). File the array of the pointers and check whether; the original table has been sorted to avoid an extra job. Return: kTRUE - the table has been sorted; kFALSE - otherwise. Int_t FindFirstKey(const void* key) const. Looks for the first index of the ""key""; within SORTED table AFTER sorting. Returns: = -1 if the ""key"" was not found. Note: This method has no sense for; ==== the float and double key. To get the index within the original; unsorted table the GetIndex() method; may be used like this:; GetIndex(FindFirstKey(key)). const char * GetTableName() const; to be documented. const char * GetTableTitle() const; to be documented. const char * GetTableType() const; to be documented. TTable * GetTable() const; to be documented. void SetSearchMethod(); Select search function at once. void QSort(); Call the standard C run-time library ""qsort"" function. void LearnTable(). LearnTable() allows the TTableSorter to learn the structure of the; tables used to fill the ntuple.; table - the name of the table; buildTree - if kTRUE, then add TBranches to t",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:834,Security,access,access,834,". TTableSorter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTableSorter. class TTableSorter: public TNamed. TTableSorter - Is an ""observer"" class to sort the TTable objects; The class provides an interface to the standard ""C/C++"". qsort and bsearch subroutines (for further information see your local C/C++ docs); ===== =======. - This class DOESN'T change / touch the ""host"" table itself; For any TTable object one can create as many different ""sorter""; as one finds useful for one's code; - Any instance of this class is meaningful as long as the ""host"" object; ""TTable"" does exist and is not changed; - Any attempt to access this TTableSorter after the ""host"" object deleted; causes the program abnormal termination; - Any attempt to access this TTableSorter after the ""host"" object been changed; causes an unpredictable result; - Any instance (object) of this class is NOT deleted ""by automatic"" just; the ""host object ""TTable"" deleted. It is the responsibility of the user's code; keeping TTableSorter and the the ""host"" TTable objects consistent. ""To do"" list. 1. A separate method to provide lexicographical sort if the ""sorted"" column is a kind of array. Usage:; 1. Create an instance of the sorter for the selected column of your table. new TTableSorter(TTable &table, TString &colName,Int_t firstRow,Int_t numberRows). All sort actions are performed within TTableSorter ctor.; This means one needs no extra effort to SORT table. ""Sorter"" contains; the ""sorted index array"" as soon as you create the sorter. TTableSorter sorter(MyTable,""id"",20, 34);; - Creates a sorter for MyTable column ""id"" ordering; its 34 rows from 20 row with standard ""C"" qsort subroutine. 2. You may use this instance to search any ""id"" value with operator []; to get the table row index as follows:. Int",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:950,Security,access,access,950,". TTableSorter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTableSorter. class TTableSorter: public TNamed. TTableSorter - Is an ""observer"" class to sort the TTable objects; The class provides an interface to the standard ""C/C++"". qsort and bsearch subroutines (for further information see your local C/C++ docs); ===== =======. - This class DOESN'T change / touch the ""host"" table itself; For any TTable object one can create as many different ""sorter""; as one finds useful for one's code; - Any instance of this class is meaningful as long as the ""host"" object; ""TTable"" does exist and is not changed; - Any attempt to access this TTableSorter after the ""host"" object deleted; causes the program abnormal termination; - Any attempt to access this TTableSorter after the ""host"" object been changed; causes an unpredictable result; - Any instance (object) of this class is NOT deleted ""by automatic"" just; the ""host object ""TTable"" deleted. It is the responsibility of the user's code; keeping TTableSorter and the the ""host"" TTable objects consistent. ""To do"" list. 1. A separate method to provide lexicographical sort if the ""sorted"" column is a kind of array. Usage:; 1. Create an instance of the sorter for the selected column of your table. new TTableSorter(TTable &table, TString &colName,Int_t firstRow,Int_t numberRows). All sort actions are performed within TTableSorter ctor.; This means one needs no extra effort to SORT table. ""Sorter"" contains; the ""sorted index array"" as soon as you create the sorter. TTableSorter sorter(MyTable,""id"",20, 34);; - Creates a sorter for MyTable column ""id"" ordering; its 34 rows from 20 row with standard ""C"" qsort subroutine. 2. You may use this instance to search any ""id"" value with operator []; to get the table row index as follows:. Int",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:8235,Usability,simpl,simpleArray,8235,"al voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTableSorter(); TTableSorter(const TTable& table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0); TTableSorter(const TTable* table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0); TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0); TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0); TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0); TTableSorter(const TTable& table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0); TTableSorter(const TTable* table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:8337,Usability,simpl,simpleArray,8337,"al voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTableSorter(); TTableSorter(const TTable& table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0); TTableSorter(const TTable* table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0); TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0); TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0); TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0); TTableSorter(const TTable& table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0); TTableSorter(const TTable* table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:8437,Usability,simpl,simpleArray,8437,"al voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTableSorter(); TTableSorter(const TTable& table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0); TTableSorter(const TTable* table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0); TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0); TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0); TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0); TTableSorter(const TTable& table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0); TTableSorter(const TTable* table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:12401,Usability,simpl,simple,12401,"ct; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfColDimensionsThe number of the dimensions for array (=-1 means it is a ""simple"" array); TStringfColName; Int_tfColOffset; Int_tfColSizeThe size of the selected column in bytes; TTable::EColumnTypefColTypedata type of the selected column; COMPAREMETHODfCompareMethodFunction to sort the original array; const char*fFirstParentRow! pointer to the internal array of TTable object;; Int_tfFirstRowfirst row of the table to be sorted; Int_t*fIndexArray""parsed"" indecis; Int_tfLastFoundThe index of the last found index within fSortIndex; TStringTNamed::fNameobject identifier; Int_tfNumberOfRowsnumber of rows of the table to be sorted; Long_tfParentRowSizeTo be filled from TTable::GetRowSize() method; const TTable*fParentTable!- the back pointer to the sorted table; SEARCHMETHODfSearchMethodFunction selected to search values; void**fSortIndexArray of pointers to columns of the sorted table; TStringTNamed::fTitleobject title; const Char_t*fsimpleArrayPointer to the ""simple"" array;. private:. union(anonymous)fValue. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TTableSorter. Function documentation; TTableSorter(); default ctor for RootCint dictionary. TTableSorter(const TTable& table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table along its column defined with colName. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression i",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:13297,Usability,simpl,simple,13297,"ct; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfColDimensionsThe number of the dimensions for array (=-1 means it is a ""simple"" array); TStringfColName; Int_tfColOffset; Int_tfColSizeThe size of the selected column in bytes; TTable::EColumnTypefColTypedata type of the selected column; COMPAREMETHODfCompareMethodFunction to sort the original array; const char*fFirstParentRow! pointer to the internal array of TTable object;; Int_tfFirstRowfirst row of the table to be sorted; Int_t*fIndexArray""parsed"" indecis; Int_tfLastFoundThe index of the last found index within fSortIndex; TStringTNamed::fNameobject identifier; Int_tfNumberOfRowsnumber of rows of the table to be sorted; Long_tfParentRowSizeTo be filled from TTable::GetRowSize() method; const TTable*fParentTable!- the back pointer to the sorted table; SEARCHMETHODfSearchMethodFunction selected to search values; void**fSortIndexArray of pointers to columns of the sorted table; TStringTNamed::fTitleobject title; const Char_t*fsimpleArrayPointer to the ""simple"" array;. private:. union(anonymous)fValue. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TTableSorter. Function documentation; TTableSorter(); default ctor for RootCint dictionary. TTableSorter(const TTable& table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table along its column defined with colName. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression i",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:16875,Usability,simpl,simpleArray,16875,"pedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the nu",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:16982,Usability,simpl,simpleArray,16982,"he first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows fr",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:17264,Usability,simpl,simpleArray,17264,"ved class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be ",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:17371,Usability,simpl,simpleArray,17371,"String& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original ",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:17651,Usability,simpl,simpleArray,17651,"table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original index of the row by its sorted index. Int_t CountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const. CountKey counts the number of rows with the key value equal ""key"". key - it is a POINTER to the key value; fistIndx - the first index within sorted array to star search; ",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:17758,Usability,simpl,simpleArray,17758,"able rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original index of the row by its sorted index. Int_t CountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const. CountKey counts the number of rows with the key value equal ""key"". key - it is a POINTER to the key value; fistIndx - the first index within sorted array to star search; = 0 by default; bSearch = kTRUE - binary search (by default) is used other",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:18119,Usability,simpl,simple,18119,"to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original index of the row by its sorted index. Int_t CountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const. CountKey counts the number of rows with the key value equal ""key"". key - it is a POINTER to the key value; fistIndx - the first index within sorted array to star search; = 0 by default; bSearch = kTRUE - binary search (by default) is used otherwise linear one. Int_t CountKeys() const. Counts the number of different key values. Bool_t FillIndexArray(). File the array of the pointers and check whether; the original table has been sorted to avoid an extra job. Return: kTRUE - the table has been sorted; kFALSE - otherwise. Int_t FindFirstKey(const void* key) const. L",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTableSorter.html:19773,Usability,learn,learn,19773,"const. Counts the number of different key values. Bool_t FillIndexArray(). File the array of the pointers and check whether; the original table has been sorted to avoid an extra job. Return: kTRUE - the table has been sorted; kFALSE - otherwise. Int_t FindFirstKey(const void* key) const. Looks for the first index of the ""key""; within SORTED table AFTER sorting. Returns: = -1 if the ""key"" was not found. Note: This method has no sense for; ==== the float and double key. To get the index within the original; unsorted table the GetIndex() method; may be used like this:; GetIndex(FindFirstKey(key)). const char * GetTableName() const; to be documented. const char * GetTableTitle() const; to be documented. const char * GetTableType() const; to be documented. TTable * GetTable() const; to be documented. void SetSearchMethod(); Select search function at once. void QSort(); Call the standard C run-time library ""qsort"" function. void LearnTable(). LearnTable() allows the TTableSorter to learn the structure of the; tables used to fill the ntuple.; table - the name of the table; buildTree - if kTRUE, then add TBranches to the TTree for each table; column (default=kFALSE). const char * At(Int_t i) const; {return fFirstParentRow + i*fParentRowSize;}. Long_t GetRowSize(); { return fParentRowSize; }. Int_t operator[](Int_t value) const; { return BSearch(value); }. Int_t operator[](Long_t value) const; { return BSearch(value); }. Int_t operator[](Double_t value) const; { return BSearch(value); }. Int_t operator[](void* value) const; { return BSearch(value); }. Int_t operator()(Float_t value); { return BinarySearch(value); }. Int_t operator()(Int_t value); { return BinarySearch(value); }. Int_t operator()(Long_t value); { return BinarySearch(value); }. Int_t operator()(Double_t value); { return BinarySearch(value); }. TTableSorter(const TTableSorter& ). TTableSorter & operator=(const TTableSorter& ). int CompareFloat_t(const void** , const void** ). int CompareInt_t(const void** , con",MatchSource.WIKI,root/html604/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTableSorter.html
https://root.cern/root/html604/TTable__iterator.html:2304,Energy Efficiency,charge,charge,2304,"t start (cm). See also comments*; float phi0; /* azimuthal angle at start (deg) *; float z0; /* z-coord. at start (cm) *; float psi; /* azimuthal angle of pT vector (deg) *; float tanl; /* tan(dip) =pz/pt at start *; float invpt; /* 1/pt at start (GeV/c)^(-1) *; float curvature; /* Track curvature (1/cm) *; float covar[15]; /* full covariance matrix *; float chisq[2]; /* Chi-square per degree of freedom *; float x_first[3]; /* coord. of first measured point (cm) *; float x_last[3]; /* coord. of last measured point (cm) *; float length; /* from first to last point (cm) *; float impact; /* primary vertex (cm) *; unsigned long map[2]; /* extrap. info. (see preceding comments)*; int id; /* Primary key (see comments) *; int iflag; /* bitmask quality info. (see comments) *; int det_id; /* Detector id information *; int method; /* Track finding/fitting method, packed *; int pid; /* Geant particle ID for assumed mass *; int n_point; /* SVT, TPC, FTPC component #s are packed *; int n_max_point; /* SVT, TPC, FTPC component #s are packed *; int n_fit_point; /* SVT, TPC, FTPC component #s are packed *; int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(stru",MatchSource.WIKI,root/html604/TTable__iterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable__iterator.html
https://root.cern/root/html604/TTable__iterator.html:2534,Integrability,wrap,wrapper,2534," /* full covariance matrix *; float chisq[2]; /* Chi-square per degree of freedom *; float x_first[3]; /* coord. of first measured point (cm) *; float x_last[3]; /* coord. of last measured point (cm) *; float length; /* from first to last point (cm) *; float impact; /* primary vertex (cm) *; unsigned long map[2]; /* extrap. info. (see preceding comments)*; int id; /* Primary key (see comments) *; int iflag; /* bitmask quality info. (see comments) *; int det_id; /* Detector id information *; int method; /* Track finding/fitting method, packed *; int pid; /* Geant particle ID for assumed mass *; int n_point; /* SVT, TPC, FTPC component #s are packed *; int n_max_point; /* SVT, TPC, FTPC component #s are packed *; int n_fit_point; /* SVT, TPC, FTPC component #s are packed *; int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(Int_t n) : TTable(_QUOTE_(className),n,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;",MatchSource.WIKI,root/html604/TTable__iterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable__iterator.html
https://root.cern/root/html604/TTable__iterator.html:4315,Integrability,wrap,wrapped,4315,"e));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;}; structName &operator[](Int_t i){ assert(i>=0 && i < GetNRows()); return *GetTable(i); }; const structName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2. Second entry for the C-structure wrapped into the class.; Since C-structuire is not derived from TObject it must be; properly defined as ""foreign"" ROOT class; #pragma C++ class dst_track_st+;. meta-variables i$ and n$ introduced; where ""i$"" stands for the current row index; ""n$"" stands for the total number of rows; meta-variable can be used along the normal; table column names in the expressions (see for example; method TTable::Draw. Function Members (Methods); public:. ~iterator(); TTable::iteratoriterator(); TTable::iteratoriterator(const TTable::iterator& iter); TTable::iteratoriterator(const TTable& table, TTable::iterator::vec_iterator& arowPtr); TTable::iteratoriterator(const TTable& table, TTable::iterator::vec_const_iterator& arowPtr); void*operator void *() const; Bool_toperator!=(const TTable::iterator& t) const; Long_toperator*() const; TTable::iteratoroperator+(Int_t idx); voidoperator++(); voidoperator++(int); voidoperator+=(Int_t idx); TTable::iteratoroperator-(Int_t idx); Int_toperator-(const TTabl",MatchSource.WIKI,root/html604/TTable__iterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable__iterator.html
https://root.cern/root/html604/TTable__iterator.html:4480,Modifiability,variab,variables,4480,"tructName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2. Second entry for the C-structure wrapped into the class.; Since C-structuire is not derived from TObject it must be; properly defined as ""foreign"" ROOT class; #pragma C++ class dst_track_st+;. meta-variables i$ and n$ introduced; where ""i$"" stands for the current row index; ""n$"" stands for the total number of rows; meta-variable can be used along the normal; table column names in the expressions (see for example; method TTable::Draw. Function Members (Methods); public:. ~iterator(); TTable::iteratoriterator(); TTable::iteratoriterator(const TTable::iterator& iter); TTable::iteratoriterator(const TTable& table, TTable::iterator::vec_iterator& arowPtr); TTable::iteratoriterator(const TTable& table, TTable::iterator::vec_const_iterator& arowPtr); void*operator void *() const; Bool_toperator!=(const TTable::iterator& t) const; Long_toperator*() const; TTable::iteratoroperator+(Int_t idx); voidoperator++(); voidoperator++(int); voidoperator+=(Int_t idx); TTable::iteratoroperator-(Int_t idx); Int_toperator-(const TTable::iterator& it) const; voidoperator--(); voidoperator--(int); voidoperator-=(Int_t idx); TTable::iterator&operator=(const TTable::iterator& iter); Bool_toperator==(const TTable::iterator& t) const; const vector<long>::iterator&Row() const; void*rowPtr() const; const Long_t&RowSize() co",MatchSource.WIKI,root/html604/TTable__iterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable__iterator.html
https://root.cern/root/html604/TTable__iterator.html:4604,Modifiability,variab,variable,4604,"tructName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2. Second entry for the C-structure wrapped into the class.; Since C-structuire is not derived from TObject it must be; properly defined as ""foreign"" ROOT class; #pragma C++ class dst_track_st+;. meta-variables i$ and n$ introduced; where ""i$"" stands for the current row index; ""n$"" stands for the total number of rows; meta-variable can be used along the normal; table column names in the expressions (see for example; method TTable::Draw. Function Members (Methods); public:. ~iterator(); TTable::iteratoriterator(); TTable::iteratoriterator(const TTable::iterator& iter); TTable::iteratoriterator(const TTable& table, TTable::iterator::vec_iterator& arowPtr); TTable::iteratoriterator(const TTable& table, TTable::iterator::vec_const_iterator& arowPtr); void*operator void *() const; Bool_toperator!=(const TTable::iterator& t) const; Long_toperator*() const; TTable::iteratoroperator+(Int_t idx); voidoperator++(); voidoperator++(int); voidoperator+=(Int_t idx); TTable::iteratoroperator-(Int_t idx); Int_toperator-(const TTable::iterator& it) const; voidoperator--(); voidoperator--(int); voidoperator-=(Int_t idx); TTable::iterator&operator=(const TTable::iterator& iter); Bool_toperator==(const TTable::iterator& t) const; const vector<long>::iterator&Row() const; void*rowPtr() const; const Long_t&RowSize() co",MatchSource.WIKI,root/html604/TTable__iterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable__iterator.html
https://root.cern/root/html604/TTable__iterator.html:3533,Testability,assert,assert,3533,"int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(Int_t n) : TTable(_QUOTE_(className),n,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;}; structName &operator[](Int_t i){ assert(i>=0 && i < GetNRows()); return *GetTable(i); }; const structName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2",MatchSource.WIKI,root/html604/TTable__iterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable__iterator.html
https://root.cern/root/html604/TTable__iterator.html:3635,Testability,assert,assert,3635,"int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(Int_t n) : TTable(_QUOTE_(className),n,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;}; structName &operator[](Int_t i){ assert(i>=0 && i < GetNRows()); return *GetTable(i); }; const structName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2",MatchSource.WIKI,root/html604/TTable__iterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTable__iterator.html
https://root.cern/root/html604/TTask.html:4211,Availability,error,error,4211,"Method(const char* method) const; virtual voidAdd(TTask* task); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidCleanTasks(); virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidContinue()MENU ; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExec(Option_t* option); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteTask(Option_t* option = ""0"")MENU ; virtual voidExecuteTasks(Option_t* option); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBreakin() const; Int_tGetBreakout() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfTasks() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; ",MatchSource.WIKI,root/html604/TTask.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTask.html
https://root.cern/root/html604/TTask.html:4295,Availability,error,error,4295,":AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidCleanTasks(); virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidContinue()MENU ; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExec(Option_t* option); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteTask(Option_t* option = ""0"")MENU ; virtual voidExecuteTasks(Option_t* option); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBreakin() const; Int_tGetBreakout() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfTasks() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() con",MatchSource.WIKI,root/html604/TTask.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTask.html
https://root.cern/root/html604/TTask.html:111,Modifiability,inherit,inheritance,111,". TTask. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTask. class TTask: public TNamed. TTask is a base class that can be used to build a complex tree of Tasks.; Each TTask derived class may contain other TTasks that can be executed; recursively, such that a complex program can be dynamically built and executed; by invoking the services of the top level Task or one of its subtasks. Use the TTask::Add function to add a subtask to an existing TTask.; To execute a TTask, one calls the ExecuteTask function. ExecuteTask will; call recursively:; - the TTask::Exec function of the derived class; - TTask::ExecuteTasks to execute for each task the list of its subtasks.; If the top level task (see example below) is added to the list of Root; browsable objects, the tree of tasks can be visualized by the Root browser.; The browser can be used to start a task, set break points at the beginning; of a task or when the task has completed. At a breakpoint, data structures; generated by the execution up this point may be inspected asyncronously; and then the execution can be resumed by selecting the ""Continue"" function; of a task. A Task may be active or inactive (controlled by TTask::SetActive).; When a task is not active, its sub tasks are not executed. A TTask tree may be made persistent, saving the status of all the tasks. The picture in the Root browser below has been generated by executing; the following script:. { //------------------script tasks.C---------------------------; TTask *aliroot = new TTask(""aliroot"",""ALICE reconstruction main task"");; TTask *geominit = new TTask(""geomInit"",""Initialize ALICE geometry"");; TTask *matinit = new TTask(""matInit"",""Initialize ALICE materials"");; TTask *physinit = new TTask(""physInit"",""Initialize Physics processes"");; TTask *tracker =",MatchSource.WIKI,root/html604/TTask.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTask.html
https://root.cern/root/html604/TTask.html:1284,Usability,resume,resumed,1284,"T; » CORE; » BASE; » TTask. class TTask: public TNamed. TTask is a base class that can be used to build a complex tree of Tasks.; Each TTask derived class may contain other TTasks that can be executed; recursively, such that a complex program can be dynamically built and executed; by invoking the services of the top level Task or one of its subtasks. Use the TTask::Add function to add a subtask to an existing TTask.; To execute a TTask, one calls the ExecuteTask function. ExecuteTask will; call recursively:; - the TTask::Exec function of the derived class; - TTask::ExecuteTasks to execute for each task the list of its subtasks.; If the top level task (see example below) is added to the list of Root; browsable objects, the tree of tasks can be visualized by the Root browser.; The browser can be used to start a task, set break points at the beginning; of a task or when the task has completed. At a breakpoint, data structures; generated by the execution up this point may be inspected asyncronously; and then the execution can be resumed by selecting the ""Continue"" function; of a task. A Task may be active or inactive (controlled by TTask::SetActive).; When a task is not active, its sub tasks are not executed. A TTask tree may be made persistent, saving the status of all the tasks. The picture in the Root browser below has been generated by executing; the following script:. { //------------------script tasks.C---------------------------; TTask *aliroot = new TTask(""aliroot"",""ALICE reconstruction main task"");; TTask *geominit = new TTask(""geomInit"",""Initialize ALICE geometry"");; TTask *matinit = new TTask(""matInit"",""Initialize ALICE materials"");; TTask *physinit = new TTask(""physInit"",""Initialize Physics processes"");; TTask *tracker = new TTask(""tracker"",""Track reconstruction manager"");; TTask *tpcrec = new TTask(""tpcrec"",""TPC reconstruction"");; TTask *itsrec = new TTask(""itsrec"",""ITS reconstruction"");; TTask *muonrec = new TTask(""muonRec"",""Muon Reconstruction"");; TTask *",MatchSource.WIKI,root/html604/TTask.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTask.html
https://root.cern/root/html604/TTask.html:10459,Usability,clear,clear,10459,"le; static TTask*fgBeginTaskpointer to task initiator; static TTask*fgBreakPointpointer to current break point. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TTask. Function documentation; TTask(); Default constructor invoked when reading a TTask object from a file. TTask(const char* name, const char* title); Standard constructor. TTask& operator=(const TTask& tt); assignment operator (PLEASE DO NOT USE THIS IS WRONG). TTask(const TTask& task); Copy constructor. ~TTask(); Delete a task and its subtasks. void Abort(); Abort current tree of tasks.; After this call, the tree of tasks is ready to be executed again.; The application must take care of cleaning data structures created; by previous executions. void Browse(TBrowser* b); Browse the list of tasks.; It is recommended to add the top level task to the list of; ROOT browsables by:; gROOT->GetListOfBrowsables()->Add(myTopLevelTask). void CleanTasks(); Reset tasks state: breakpoints and execute flags; also invokes the Clear function of each task to clear all data; structures created by a previous execution of a task. void Clear(Option_t* option = """"); Recursively call the Clear function of this task and its subtasks.; The Clear function must be implemented for each derived class; to clear all data structures created by a previous execution of a task.; This function is automatically called by the CleanTasks function. void Continue(); Resume execution at the current break point. void Exec(Option_t* option); Dummy Execute.; This function must be redefined in the derived classes. void ExecuteTask(Option_t* option = ""0""); Execute main task and its subtasks.; When calling this function, the Exec function of the corresponding class; is invoked, then the list of its subtasks is executed calling recursively; all the subtasks, etc. The option parameter may be used to select different execution steps; within a task. This parameter is passed also to all the subtasks. void ExecuteTasks(Option_t* option); Execute all th",MatchSource.WIKI,root/html604/TTask.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTask.html
https://root.cern/root/html604/TTask.html:10698,Usability,clear,clear,10698," from a file. TTask(const char* name, const char* title); Standard constructor. TTask& operator=(const TTask& tt); assignment operator (PLEASE DO NOT USE THIS IS WRONG). TTask(const TTask& task); Copy constructor. ~TTask(); Delete a task and its subtasks. void Abort(); Abort current tree of tasks.; After this call, the tree of tasks is ready to be executed again.; The application must take care of cleaning data structures created; by previous executions. void Browse(TBrowser* b); Browse the list of tasks.; It is recommended to add the top level task to the list of; ROOT browsables by:; gROOT->GetListOfBrowsables()->Add(myTopLevelTask). void CleanTasks(); Reset tasks state: breakpoints and execute flags; also invokes the Clear function of each task to clear all data; structures created by a previous execution of a task. void Clear(Option_t* option = """"); Recursively call the Clear function of this task and its subtasks.; The Clear function must be implemented for each derived class; to clear all data structures created by a previous execution of a task.; This function is automatically called by the CleanTasks function. void Continue(); Resume execution at the current break point. void Exec(Option_t* option); Dummy Execute.; This function must be redefined in the derived classes. void ExecuteTask(Option_t* option = ""0""); Execute main task and its subtasks.; When calling this function, the Exec function of the corresponding class; is invoked, then the list of its subtasks is executed calling recursively; all the subtasks, etc. The option parameter may be used to select different execution steps; within a task. This parameter is passed also to all the subtasks. void ExecuteTasks(Option_t* option); Execute all the subtasks of a task. void ls(Option_t* option = ""*"") const; List the tree of tasks.; Indentation is used to identify the task tree. void Add(TTask* task); {fTasks->Add(task);}. Int_t GetBreakin() const; { return fBreakin; }. Int_t GetBreakout() const; { return f",MatchSource.WIKI,root/html604/TTask.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTask.html
https://root.cern/root/html604/TTeXDump.html:3367,Availability,error,error,3367,"py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); voidDrawPolyLine(Int_t n, TPoints* xy); voidDrawPolyLineNDC(Int_t n, TPoints* uv); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObje",MatchSource.WIKI,root/html604/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTeXDump.html
https://root.cern/root/html604/TTeXDump.html:3451,Availability,error,error,3451,"istancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); voidDrawPolyLine(Int_t n, TPoints* xy); voidDrawPolyLineNDC(Int_t n, TPoints* uv); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Opt",MatchSource.WIKI,root/html604/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTeXDump.html
https://root.cern/root/html604/TTeXDump.html:16238,Energy Efficiency,green,green,16238," yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn>0 a line is drawn.; If nn<0 a closed polygon is drawn. void NewPage(); Start the TeX page. This function starts the tikzpicture environment. void Range(Float_t xrange, Float_t yrange); Set the range for the paper in centimetres. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Set the lines width. void SetMarkerSize(Size_t msize = 1); Set size for markers. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set color with its color index. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetTextColor(Color_t cindex = 1); Set color index for text. void Text(Double_t x, Double_t y, const char* string); Draw text. xx: x position of the text; yy: y position of the text; chars: text to be drawn. void TextNDC(Double_t u, Double_t v, const char* string); Write a string of characters in NDC. Float_t UtoTeX(Double_t u); Convert U from NDC coordinate to TeX. Float_t VtoTeX(Double_t v); Convert V from NDC coordinate to TeX. Float_t XtoTeX(Double_t x); Convert X from world coordinate to TeX. Float_t YtoTeX(Double_t y); Convert Y from world coordinate to TeX. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); Begin the Cell Array painting. void CellArrayFill(Int_t r, Int_t g, Int_t b); Paint the Cell Array. void CellArrayEnd(); End the Cell Array painting. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); Not needed in TeX case. void DefineMarkers(); add additional pgfplotmarks. TTeXDump(). Int_t CMtoTeX(",MatchSource.WIKI,root/html604/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTeXDump.html
https://root.cern/root/html604/TTeXDump.html:315,Integrability,interface,interface,315,". TTeXDump. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TTeXDump. class TTeXDump: public TVirtualPS. TTeXDump: Graphics interface to TeX; This class allow to generate PGF/TikZ vector graphics output; which can be included in TeX and LaTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* o",MatchSource.WIKI,root/html604/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTeXDump.html
https://root.cern/root/html604/TTeXDump.html:13392,Integrability,interface,interface,13392,"::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Int_tTVirtualPS::fSizBufferBuffer size; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypeWorkstation type used to know if the Tex is open; Float_tfXsizePage size along X; Float_tfYsizePage size along Y. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTeXDump(); Default TeX constructor. TTeXDump(const char* filename, Int_t type = -113); Initialize the TeX interface. fname : TeX file name; wtype : TeX workstation type. Not used in the TeX driver. But as TTeXDump; inherits from TVirtualPS it should be kept. Anyway it is not; necessary to specify this parameter at creation time because it; has a default value (which is ignore in the TeX case). void Open(const char* filename, Int_t type = -111); Open a TeX file. ~TTeXDump(); Default TeX destructor. void Close(Option_t* opt = """"); Close a TeX file. void On(); Activate an already open TeX file. void Off(); Deactivate an already open TeX file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed TeX units dark is the; color for the dark part",MatchSource.WIKI,root/html604/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTeXDump.html
https://root.cern/root/html604/TTeXDump.html:13501,Modifiability,inherit,inherits,13501,"er style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Int_tTVirtualPS::fSizBufferBuffer size; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypeWorkstation type used to know if the Tex is open; Float_tfXsizePage size along X; Float_tfYsizePage size along Y. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTeXDump(); Default TeX constructor. TTeXDump(const char* filename, Int_t type = -113); Initialize the TeX interface. fname : TeX file name; wtype : TeX workstation type. Not used in the TeX driver. But as TTeXDump; inherits from TVirtualPS it should be kept. Anyway it is not; necessary to specify this parameter at creation time because it; has a default value (which is ignore in the TeX case). void Open(const char* filename, Int_t type = -111); Open a TeX file. ~TTeXDump(); Default TeX destructor. void Close(Option_t* opt = """"); Close a TeX file. void On(); Activate an already open TeX file. void Off(); Deactivate an already open TeX file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed TeX units dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyLine(Int_t n, TPoints* xy); Draw a PolyLine. Draw a polyline through the",MatchSource.WIKI,root/html604/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTeXDump.html
https://root.cern/root/html604/TTeXDump.html:646,Usability,user-friendly,user-friendly,646,". TTeXDump. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TTeXDump. class TTeXDump: public TVirtualPS. TTeXDump: Graphics interface to TeX; This class allow to generate PGF/TikZ vector graphics output; which can be included in TeX and LaTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* o",MatchSource.WIKI,root/html604/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTeXDump.html
https://root.cern/root/html604/TTeXDump.html:875,Usability,simpl,simple,875,". TTeXDump. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TTeXDump. class TTeXDump: public TVirtualPS. TTeXDump: Graphics interface to TeX; This class allow to generate PGF/TikZ vector graphics output; which can be included in TeX and LaTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* o",MatchSource.WIKI,root/html604/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTeXDump.html
https://root.cern/root/html604/TTeXDump.html:1018,Usability,simpl,simple,1018," Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TTeXDump. class TTeXDump: public TVirtualPS. TTeXDump: Graphics interface to TeX; This class allow to generate PGF/TikZ vector graphics output; which can be included in TeX and LaTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Cl",MatchSource.WIKI,root/html604/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTeXDump.html
https://root.cern/root/html604/TTeXDump.html:1437,Usability,simpl,simple,1437,"aTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); Int_tCMtoTeX(Double_t u); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidDefineMarkers(); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2)",MatchSource.WIKI,root/html604/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTeXDump.html
https://root.cern/root/html604/TTeXDump.html:1490,Usability,simpl,simple,1490,"e for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); Int_tCMtoTeX(Double_t u); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidDefineMarkers(); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitiv",MatchSource.WIKI,root/html604/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTeXDump.html
https://root.cern/root/html604/TText.html:1880,Availability,error,error,1880,"virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TText*DrawText(Double_t x, Double_t y, const char* text); virtual TText*DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidGetControlBox(Int_t x, Int_t y, Double_t theta, Int_t[4] cBoxX, Int_t[4] cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetTextAdvance(UInt_t& a, const char* ",MatchSource.WIKI,root/html604/TText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TText.html
https://root.cern/root/html604/TText.html:1964,Availability,error,error,1964,"ption = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TText*DrawText(Double_t x, Double_t y, const char* text); virtual TText*DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidGetControlBox(Int_t x, Int_t y, Double_t theta, Int_t[4] cBoxX, Int_t[4] cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetTextAdvance(UInt_t& a, const char* text, const Bool_t kern = kTRUE) const; virtual Short_tTAttText::GetTextAlign() cons",MatchSource.WIKI,root/html604/TText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TText.html
https://root.cern/root/html604/TText.html:111,Modifiability,inherit,inheritance,111,". TText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TText. class TText: public TNamed, public TAttText, public TAttBBox2D. TText is the base class for several text objects.; See TAttText for a list of text attributes or fonts,; and also for a discussion on text speed and font quality. By default, the text is drawn in the pad coordinates system.; One can draw in NDC coordinates [0,1] if the function SetNDC; is called for a TText object. Function Members (Methods); public:. virtual~TText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TText*DrawText(Double_t x, Double_t y, const char* text); virtual TText*DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(",MatchSource.WIKI,root/html604/TText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TText.html
https://root.cern/root/html604/TTextEditor.html:4374,Availability,error,error,4374," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html604/TTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTextEditor.html
https://root.cern/root/html604/TTextEditor.html:4458,Availability,error,error,4458,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html604/TTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTextEditor.html
https://root.cern/root/html604/TTextEditor.html:18217,Availability,mask,mask,18217,,MatchSource.WIKI,root/html604/TTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTextEditor.html
https://root.cern/root/html604/TTextEditor.html:117,Modifiability,inherit,inheritance,117,". TTextEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TTextEditor. class TTextEditor: public TGedFrame. Function Members (Methods); public:. virtual~TTextEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); vi",MatchSource.WIKI,root/html604/TTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTextEditor.html
https://root.cern/root/html604/TTF.html:1645,Deployability,patch,patch,1645,". Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TTF. class TTF. TTF. Interface to the freetype 2 library. Function Members (Methods); public:. virtual~TTF(); static Short_tCharToUnicode(UInt_t code); static TClass*Class(); static voidCleanup(); static Int_tGetAscent(); static const FT_BBox&GetBox(); static TTGlyph*GetGlyphs(); static Bool_tGetHinting(); static Bool_tGetKerning(); static Int_tGetNumGlyphs(); static FT_Matrix*GetRotMatrix(); static Bool_tGetSmoothing(); static voidGetTextAdvance(UInt_t& a, char* text); static voidGetTextExtent(UInt_t& w, UInt_t& h, char* text); static voidGetTextExtent(UInt_t& w, UInt_t& h, wchar_t* text); static Int_tGetWidth(); static voidInit(); virtual TClass*IsA() const; static Bool_tIsInitialized(); static voidLayoutGlyphs(); TTF&operator=(const TTF&); static voidPrepareString(const char* string); static voidPrepareString(const wchar_t* string); static voidSetHinting(Bool_t state); static voidSetKerning(Bool_t state); static voidSetRotationMatrix(Float_t angle); static voidSetSmoothing(Bool_t state); static voidSetTextFont(Font_t fontnumber); static Int_tSetTextFont(const char* fontname, Int_t italic = 0); static voidSetTextSize(Float_t textsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTF(); TTF(const TTF&); static voidVersion(Int_t& major, Int_t& minor, Int_t& patch). Data Members; protected:. static Int_tfgAscentstring ascent, used to compute Y alignment; static FT_BBoxfgCBoxstring control box; static FT_CharMapfgCharMap[32]font character map; static Int_tfgCurFontIdxcurrent font index; static FT_FacefgFace[32]font face; static Int_tfgFontCountnumber of fonts loaded; static char*fgFontName[32]font name; static TT",MatchSource.WIKI,root/html604/TTF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTF.html
https://root.cern/root/html604/TTF.html:5088,Deployability,patch,patch,5088,"ing(const wchar_t* string); Put the characters in ""string"" in the ""glyphs"" array. void SetHinting(Bool_t state); Set hinting flag. void SetKerning(Bool_t state); Set kerning flag. void SetRotationMatrix(Float_t angle); Set the rotation matrix used to rotate the font outlines. void SetSmoothing(Bool_t state); Set smoothing (anti-aliasing) flag. Int_t SetTextFont(const char* fontname, Int_t italic = 0); Set text font to specified name.; font : font name; italic : the fonts should be slanted. Used for symbol font. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextFont(Font_t fontnumber); Set specified font.; List of the currently supported fonts (screen and PostScript). Font ID X11 TTF; 1 : times-medium-i-normal timesi.ttf; 2 : times-bold-r-normal timesbd.ttf; 3 : times-bold-i-normal timesi.ttf; 4 : helvetica-medium-r-normal arial.ttf; 5 : helvetica-medium-o-normal ariali.ttf; 6 : helvetica-bold-r-normal arialbd.ttf; 7 : helvetica-bold-o-normal arialbi.ttf; 8 : courier-medium-r-normal cour.ttf; 9 : courier-medium-o-normal couri.ttf; 10 : courier-bold-r-normal courbd.ttf; 11 : courier-bold-o-normal courbi.ttf; 12 : symbol-medium-r-normal symbol.ttf; 13 : times-medium-r-normal times.ttf; 14 : wingding.ttf; 15 : symbol oblique is emulated from symbol.ttf. void SetTextSize(Float_t textsize); Set current text size. void Version(Int_t& major, Int_t& minor, Int_t& patch). Bool_t GetHinting(). Bool_t GetKerning(). Bool_t GetSmoothing(). Bool_t IsInitialized(). Int_t GetWidth(). Int_t GetAscent(). Int_t GetNumGlyphs(). FT_Matrix * GetRotMatrix(). const FT_BBox & GetBox(). TTGlyph * GetGlyphs(). TTF(); { }. » Author: Olivier Couet 01/10/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/graf:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTF.html
https://root.cern/root/html604/TTF.html:2792,Integrability,interface,interface,2792,"ol box; static FT_CharMapfgCharMap[32]font character map; static Int_tfgCurFontIdxcurrent font index; static FT_FacefgFace[32]font face; static Int_tfgFontCountnumber of fonts loaded; static char*fgFontName[32]font name; static TTGlyphfgGlyphs[1024]glyphs; static Bool_tfgHintinguse hinting (true by default); static Bool_tfgInittrue if the Init has been called; static Bool_tfgKerninguse kerning (true by default); static FT_LibraryfgLibraryFreeType font library; static Int_tfgNumGlyphsnumber of glyphs in the string; static FT_Matrix*fgRotMatrixrotation matrix; static Bool_tfgSmoothinguse anti-aliasing (true when >8 planes, false otherwise); static Int_tfgSymbItaFontIdxSymbol italic font index; static Int_tfgTBlankWtrailing blanks width; static Int_tfgWidthstring width, used to compute X alignment; static TTF::(anonymous)kMaxGlyphs; static TTF::(anonymous)kTTMaxFonts. Class Charts. Inheritance Chart:. TTF. Function documentation; ~TTF(); Cleanup TTF environment. void Init(); Initialise the TrueType fonts interface. void Cleanup(); Cleanup. Is called by the gCleanupTTF destructor. Short_t CharToUnicode(UInt_t code); Map char to unicode. Returns 0 in case no mapping exists. void GetTextExtent(UInt_t& w, UInt_t& h, char* text); Get width (w) and height (h) when text is horizontal. void GetTextAdvance(UInt_t& a, char* text); Get advance (a) when text is horizontal. void GetTextExtent(UInt_t& w, UInt_t& h, wchar_t* text); Get width (w) and height (h) when text is horizontal. void LayoutGlyphs(); Compute the glyps positions, fgAscent and fgWidth (needed for alignment).; Perform the Glyphs transformation.; Compute the string control box.; If required take the ""kerning"" into account.; SetRotation and PrepareString should have been called before. void PrepareString(const char* string); Put the characters in ""string"" in the ""glyphs"" array. void PrepareString(const wchar_t* string); Put the characters in ""string"" in the ""glyphs"" array. void SetHinting(Bool_t state); Set hinting f",MatchSource.WIKI,root/html604/TTF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTF.html
https://root.cern/root/html604/TTF.html:109,Modifiability,inherit,inheritance,109,". TTF. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TTF. class TTF. TTF. Interface to the freetype 2 library. Function Members (Methods); public:. virtual~TTF(); static Short_tCharToUnicode(UInt_t code); static TClass*Class(); static voidCleanup(); static Int_tGetAscent(); static const FT_BBox&GetBox(); static TTGlyph*GetGlyphs(); static Bool_tGetHinting(); static Bool_tGetKerning(); static Int_tGetNumGlyphs(); static FT_Matrix*GetRotMatrix(); static Bool_tGetSmoothing(); static voidGetTextAdvance(UInt_t& a, char* text); static voidGetTextExtent(UInt_t& w, UInt_t& h, char* text); static voidGetTextExtent(UInt_t& w, UInt_t& h, wchar_t* text); static Int_tGetWidth(); static voidInit(); virtual TClass*IsA() const; static Bool_tIsInitialized(); static voidLayoutGlyphs(); TTF&operator=(const TTF&); static voidPrepareString(const char* string); static voidPrepareString(const wchar_t* string); static voidSetHinting(Bool_t state); static voidSetKerning(Bool_t state); static voidSetRotationMatrix(Float_t angle); static voidSetSmoothing(Bool_t state); static voidSetTextFont(Font_t fontnumber); static Int_tSetTextFont(const char* fontname, Int_t italic = 0); static voidSetTextSize(Float_t textsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTF(); TTF(const TTF&); static voidVersion(Int_t& major, Int_t& minor, Int_t& patch). Data Members; protected:. static Int_tfgAscentstring ascent, used to compute Y alignment; static FT_BBoxfgCBoxstring control box; static FT_CharMapfgCharMap[32]font character map; static Int_tfgCurFontIdxcurrent font index; static FT_FacefgFace[32]font face; static Int_tfgFontCountnumber of fonts loaded; static char*fgFontName[32]font name; stati",MatchSource.WIKI,root/html604/TTF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTF.html
https://root.cern/root/html604/TTF.html:1951,Performance,load,loaded,1951,"rning(Bool_t state); static voidSetRotationMatrix(Float_t angle); static voidSetSmoothing(Bool_t state); static voidSetTextFont(Font_t fontnumber); static Int_tSetTextFont(const char* fontname, Int_t italic = 0); static voidSetTextSize(Float_t textsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTF(); TTF(const TTF&); static voidVersion(Int_t& major, Int_t& minor, Int_t& patch). Data Members; protected:. static Int_tfgAscentstring ascent, used to compute Y alignment; static FT_BBoxfgCBoxstring control box; static FT_CharMapfgCharMap[32]font character map; static Int_tfgCurFontIdxcurrent font index; static FT_FacefgFace[32]font face; static Int_tfgFontCountnumber of fonts loaded; static char*fgFontName[32]font name; static TTGlyphfgGlyphs[1024]glyphs; static Bool_tfgHintinguse hinting (true by default); static Bool_tfgInittrue if the Init has been called; static Bool_tfgKerninguse kerning (true by default); static FT_LibraryfgLibraryFreeType font library; static Int_tfgNumGlyphsnumber of glyphs in the string; static FT_Matrix*fgRotMatrixrotation matrix; static Bool_tfgSmoothinguse anti-aliasing (true when >8 planes, false otherwise); static Int_tfgSymbItaFontIdxSymbol italic font index; static Int_tfgTBlankWtrailing blanks width; static Int_tfgWidthstring width, used to compute X alignment; static TTF::(anonymous)kMaxGlyphs; static TTF::(anonymous)kTTMaxFonts. Class Charts. Inheritance Chart:. TTF. Function documentation; ~TTF(); Cleanup TTF environment. void Init(); Initialise the TrueType fonts interface. void Cleanup(); Cleanup. Is called by the gCleanupTTF destructor. Short_t CharToUnicode(UInt_t code); Map char to unicode. Returns 0 in case no mapping exists. void GetTextExtent(UInt_t& w, UInt_t& h, char* text); Get width (w) and height (h) when text is horizontal. void GetTextAdvance(UInt_t& a, char* text); Get advance (a) when text is horizontal. void GetT",MatchSource.WIKI,root/html604/TTF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTF.html
https://root.cern/root/html604/TThread.html:1679,Availability,error,error,1679,"pendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; static Int_tCleanUp(); static Int_tCleanUpPop(Int_t exe = 0); static Int_tCleanUpPush(void* free, void* arg = 0); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); static Int_tDelete(TThread*& th); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Int_tExists(); static Int_tExit(void* ret = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Long_tGetId() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TThread::EPriorityGetPriority() const; TThread::EStateGetState() const; static TThread*GetThread(Long_t id); static TThread*GetThread(const char* name); static Int_tGetTime(ULong_t* absSec, UL",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:1763,Availability,error,error,1763,"_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; static Int_tCleanUp(); static Int_tCleanUpPop(Int_t exe = 0); static Int_tCleanUpPush(void* free, void* arg = 0); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); static Int_tDelete(TThread*& th); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Int_tExists(); static Int_tExit(void* ret = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Long_tGetId() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TThread::EPriorityGetPriority() const; TThread::EStateGetState() const; static TThread*GetThread(Long_t id); static TThread*GetThread(const char* name); static Int_tGetTime(ULong_t* absSec, ULong_t* absNanoSec); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObje",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:12396,Availability,error,error,12396,"thod to delete the specified thread.; Returns -1 in case the thread was running and has been killed. Returns; 0 in case the thread has been Delete and Cleaned up. The th pointer is; not valid anymore in that case. Int_t Exists(); Static method to check if threads exist.; Returns the number of running threads. void SetPriority(TThread::EPriority pri); Set thread priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer to current thread. Long_t Join(void** ret = 0); Join this thread. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static method TThread::Function(); which calls the user function specified in the TThread ctor with; the arg argument. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancell",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:12495,Availability,error,error,12495,". Returns; 0 in case the thread has been Delete and Cleaned up. The th pointer is; not valid anymore in that case. Int_t Exists(); Static method to check if threads exist.; Returns the number of running threads. void SetPriority(TThread::EPriority pri); Set thread priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer to current thread. Long_t Join(void** ret = 0); Join this thread. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static method TThread::Function(); which calls the user function specified in the TThread ctor with; the arg argument. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint()",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:12626,Availability,error,error,12626," Static method to check if threads exist.; Returns the number of running threads. void SetPriority(TThread::EPriority pri); Set thread priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer to current thread. Long_t Join(void** ret = 0); Join this thread. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static method TThread::Function(); which calls the user function specified in the TThread ctor with; the arg argument. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:12761,Availability,error,error,12761,"priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer to current thread. Long_t Join(void** ret = 0); Join this thread. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static method TThread::Function(); which calls the user function specified in the TThread ctor with; the arg argument. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of ",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:12897,Availability,error,error,12897,"find a thread by name. TThread * Self(); Static method returning pointer to current thread. Long_t Join(void** ret = 0); Join this thread. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static method TThread::Function(); which calls the user function specified in the TThread ctor with; the arg argument. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUpPop(Int_t exe = 0); Static method which pops thread cleanup method off stack.; Returns 0 in case of success and -1 i",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:13031,Availability,error,error,13031,"ead. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static method TThread::Function(); which calls the user function specified in the TThread ctor with; the arg argument. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUpPop(Int_t exe = 0); Static method which pops thread cleanup method off stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUp(); Static method to cleanup the calling thread. void AfterCancel(TThread* th); Static method which is c",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:13443,Availability,error,error,13443,"); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUpPop(Int_t exe = 0); Static method which pops thread cleanup method off stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUp(); Static method to cleanup the calling thread. void AfterCancel(TThread* th); Static method which is called after the thread has been canceled. Int_t Exit(void* ret = 0); Static method which terminates the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:13574,Availability,error,error,13574,"l the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUpPop(Int_t exe = 0); Static method which pops thread cleanup method off stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUp(); Static method to cleanup the calling thread. void AfterCancel(TThread* th); Static method which is called after the thread has been canceled. Int_t Exit(void* ret = 0); Static method which terminates the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. vo",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:13758,Availability,error,error,13758,"n success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUpPop(Int_t exe = 0); Static method which pops thread cleanup method off stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUp(); Static method to cleanup the calling thread. void AfterCancel(TThread* th); Static method which is called after the thread has been canceled. Int_t Exit(void* ret = 0); Static method which terminates the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method list",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:13904,Availability,error,error,13904,"; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUpPop(Int_t exe = 0); Static method which pops thread cleanup method off stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUp(); Static method to cleanup the calling thread. void AfterCancel(TThread* th); Static method which is called after the thread has been canceled. Int_t Exit(void* ret = 0); Static method which terminates the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling th",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:15273,Availability,error,error,15273,"p the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread(const TThread& ). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { return fState; }. Long_t GetId() const; { return fId; }. void ps(); { Ps(); }. » ",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:15320,Availability,error,error,15320,"get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread(const TThread& ). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { return fState; }. Long_t GetId() const; { return fId; }. void ps(); { Ps(); }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:113,Modifiability,inherit,inheritance,113,". TThread. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThread. class TThread: public TNamed. TThread. This class implements threads. A thread is an execution environment; much lighter than a process. A single process can have multiple; threads. The actual work is done via the TThreadImp class (either; TPosixThread or TWin32Thread). Function Members (Methods); public:. virtual~TThread(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; static Int_tCleanUp(); static Int_tCleanUpPop(Int_t exe = 0); static Int_tCleanUpPush(void* free, void* arg = 0); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); static Int_tDelete(TThread*& th); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Int_tExists(); static Int_tExit(void* ret = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffe",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:11261,Modifiability,variab,variables,11261,"un(). TThread(const char *thname, VoidRtnFunc_t fn, void *arg, EPriority pri); Create thread with a name. Specify the function or static class method; to be executed by the thread and a pointer to the argument structure.; The user function should return a void*. To start the thread call Run(). TThread(const char *thname, VoidFunc_t fn, void *arg, EPriority pri); Create a detached thread with a name. Specify the function or static; class method to be executed by the thread and a pointer to the argument; structure. To start the thread call Run(). TThread(Long_t id = 0); Create a TThread for a already running thread. void Initialize(); Initialize the Thread package. This initializes the TThread and ROOT; global mutexes to make parts of ROOT thread safe/aware. This call is; implicit in case a TThread is created. Bool_t IsInitialized(); Return true, if the TThread objects have been initialize. If false,; the process is (from ROOT's point of view) single threaded. void Init(); Initialize global state and variables once. void Constructor(); Common thread constructor. ~TThread(); Cleanup the thread. Int_t Delete(TThread*& th); Static method to delete the specified thread.; Returns -1 in case the thread was running and has been killed. Returns; 0 in case the thread has been Delete and Cleaned up. The th pointer is; not valid anymore in that case. Int_t Exists(); Static method to check if threads exist.; Returns the number of running threads. void SetPriority(TThread::EPriority pri); Set thread priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer to current thread. Long_t Join(void** ret = 0); Join this thread. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:11002,Safety,safe,safe,11002,"function should return a void*. To start the thread call Run(). TThread(VoidFunc_t fn, void *arg, EPriority pri); Create a detached thread. Specify the function or static class method; to be executed by the thread and a pointer to the argument structure.; To start the thread call Run(). TThread(const char *thname, VoidRtnFunc_t fn, void *arg, EPriority pri); Create thread with a name. Specify the function or static class method; to be executed by the thread and a pointer to the argument structure.; The user function should return a void*. To start the thread call Run(). TThread(const char *thname, VoidFunc_t fn, void *arg, EPriority pri); Create a detached thread with a name. Specify the function or static; class method to be executed by the thread and a pointer to the argument; structure. To start the thread call Run(). TThread(Long_t id = 0); Create a TThread for a already running thread. void Initialize(); Initialize the Thread package. This initializes the TThread and ROOT; global mutexes to make parts of ROOT thread safe/aware. This call is; implicit in case a TThread is created. Bool_t IsInitialized(); Return true, if the TThread objects have been initialize. If false,; the process is (from ROOT's point of view) single threaded. void Init(); Initialize global state and variables once. void Constructor(); Common thread constructor. ~TThread(); Cleanup the thread. Int_t Delete(TThread*& th); Static method to delete the specified thread.; Returns -1 in case the thread was running and has been killed. Returns; 0 in case the thread has been Delete and Cleaned up. The th pointer is; not valid anymore in that case. Int_t Exists(); Static method to check if threads exist.; Returns the number of running threads. void SetPriority(TThread::EPriority pri); Set thread priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer ",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:15138,Safety,safe,safe,15138,"s the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread(const TThread& ). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. E",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThread.html:15849,Safety,avoid,avoid,15849,"ain thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread(const TThread& ). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { return fState; }. Long_t GetId() const; { return fId; }. void ps(); { Ps(); }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThread.html
https://root.cern/root/html604/TThreadFactory.html:601,Availability,avail,available,601,". TThreadFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadFactory. class TThreadFactory: public TNamed. TThreadFactory. This ABC is a factory for thread components. Depending on which; factory is active one gets either Posix or Win32 threads. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadFactory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buff",MatchSource.WIKI,root/html604/TThreadFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThreadFactory.html
https://root.cern/root/html604/TThreadFactory.html:1721,Availability,error,error,1721,"voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html604/TThreadFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThreadFactory.html
https://root.cern/root/html604/TThreadFactory.html:1805,Availability,error,error,1805," b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html604/TThreadFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThreadFactory.html
https://root.cern/root/html604/TThreadFactory.html:120,Modifiability,inherit,inheritance,120,". TThreadFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadFactory. class TThreadFactory: public TNamed. TThreadFactory. This ABC is a factory for thread components. Depending on which; factory is active one gets either Posix or Win32 threads. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadFactory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buff",MatchSource.WIKI,root/html604/TThreadFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThreadFactory.html
https://root.cern/root/html604/TThreadImp.html:695,Availability,avail,available,695,". TThreadImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadImp. class TThreadImp: public TObject. TThreadImp. This class implements threads. A thread is an execution environment; much lighter than a process. A single process can have multiple; threads. The actual work is done via the TThreadImp class (either; TPosixThread or TWin32Thread). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); ",MatchSource.WIKI,root/html604/TThreadImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThreadImp.html
https://root.cern/root/html604/TThreadImp.html:1837,Availability,error,error,1837,"ion_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExit(void* ret); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html604/TThreadImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThreadImp.html
https://root.cern/root/html604/TThreadImp.html:1921,Availability,error,error,1921,"int(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExit(void* ret); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* ",MatchSource.WIKI,root/html604/TThreadImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThreadImp.html
https://root.cern/root/html604/TThreadImp.html:116,Modifiability,inherit,inheritance,116,". TThreadImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadImp. class TThreadImp: public TObject. TThreadImp. This class implements threads. A thread is an execution environment; much lighter than a process. A single process can have multiple; threads. The actual work is done via the TThreadImp class (either; TPosixThread or TWin32Thread). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); ",MatchSource.WIKI,root/html604/TThreadImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TThreadImp.html
https://root.cern/root/html604/TTime.html:111,Modifiability,inherit,inheritance,111,". TTime. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTime. class TTime. TTime. Basic time type with millisecond precision. Function Members (Methods); public:. virtual~TTime(); const char*AsString() const; static TClass*Class(); virtual TClass*IsA() const; longoperator long() const; Long64_toperator long long() const; unsigned longoperator unsigned long() const; ULong64_toperator unsigned long long() const; TTimeoperator*=(const TTime& t); TTimeoperator+=(const TTime& t); TTimeoperator-=(const TTime& t); TTimeoperator/=(const TTime& t); TTime&operator=(const TTime& t); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTime(); TTime(Long64_t msec); TTime(const TTime& t). Data Members; private:. Long64_tfMilliSectime with millisecond precision. Class Charts. Inheritance Chart:. TTime. Function documentation; const char * AsString() const; Return the time as a string. operator long() const. operator unsigned long() const. TTime& operator=(const TTime& t); { fMilliSec = t.fMilliSec; return *this; }. TTime operator+=(const TTime& t); { fMilliSec += t.fMilliSec; return *this; }. TTime operator-=(const TTime& t); { fMilliSec -= t.fMilliSec; return *this; }. TTime operator*=(const TTime& t); { fMilliSec *= t.fMilliSec; return *this; }. TTime operator/=(const TTime& t); { fMilliSec /= t.fMilliSec; return *this; }. inline operator long long() const; { return fMilliSec; }. inline operator unsigned long long() const; { return (ULong64_t) fMilliSec; }. TTime(); { }. TTime(Long64_t msec); { }. TTime(const TTime& t); { }. virtual ~TTime(); { }. » Author: Fons Rademakers 28/11/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last g",MatchSource.WIKI,root/html604/TTime.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTime.html
https://root.cern/root/html604/TTimer.html:4834,Availability,error,error,4834," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTimeGetAbsTime() const; const char*GetCommand() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; TObject*GetObject(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTimeGetTime() const; UInt_tGetTimerID(); virtual const char*TObject::GetTitle() const; virtual UInt_t",MatchSource.WIKI,root/html604/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimer.html
https://root.cern/root/html604/TTimer.html:4918,Availability,error,error,4918,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTimeGetAbsTime() const; const char*GetCommand() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; TObject*GetObject(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTimeGetTime() const; UInt_tGetTimerID(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); vir",MatchSource.WIKI,root/html604/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimer.html
https://root.cern/root/html604/TTimer.html:112,Modifiability,inherit,inheritance,112,". TTimer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimer. class TTimer: public TSysEvtHandler. TTimer. Handles synchronous and a-synchronous timer events.; 1. synchronous timer is registered into TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObj",MatchSource.WIKI,root/html604/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimer.html
https://root.cern/root/html604/TTimer.html:1088,Safety,timeout,timeout,1088,".pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimer. class TTimer: public TSysEvtHandler. TTimer. Handles synchronous and a-synchronous timer events.; 1. synchronous timer is registered into TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tCheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::",MatchSource.WIKI,root/html604/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimer.html
https://root.cern/root/html604/TTimer.html:1418,Safety,timeout,timeout,1418,"o TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tCheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const ",MatchSource.WIKI,root/html604/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimer.html
https://root.cern/root/html604/TTimer.html:12162,Safety,timeout,timeout,12162,"bject::(anonymous)TObject::kZombie. protected:. TTimefAbsTimeabsolute time out time in ms; TStringfCommandinterpreter command to be executed; Bool_tfIntSyscallstrue is a-synchronous timer is to interrupt system calls; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TObject*fObjectobject to be notified (if any); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSynctrue if synchrounous timer; TTimefTimetime out time in ms; UInt_tfTimeIDthe system ID of this timer (for WIN32); Bool_tfTimeouttrue if timer has timed out; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TSysEvtHandler. ←; TTimer. ←. TProcessEventTimer. Function documentation; TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms). If mode == kTRUE then the timer is synchronous else; a-synchronous. The default is synchronous. Add a timer to the system; eventloop by calling TurnOn(). Set command to be executed from Notify(); or set the object whose HandleTimer() method will be called via Notify(),; derive from TTimer and override Notify() or connect slots to the; signals Timeout(), TurnOn() and TurnOff(). TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The object's HandleTimer() will be called by Notify(). TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system event",MatchSource.WIKI,root/html604/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimer.html
https://root.cern/root/html604/TTimer.html:12190,Safety,timeout,timeout,12190,"bject::(anonymous)TObject::kZombie. protected:. TTimefAbsTimeabsolute time out time in ms; TStringfCommandinterpreter command to be executed; Bool_tfIntSyscallstrue is a-synchronous timer is to interrupt system calls; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TObject*fObjectobject to be notified (if any); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSynctrue if synchrounous timer; TTimefTimetime out time in ms; UInt_tfTimeIDthe system ID of this timer (for WIN32); Bool_tfTimeouttrue if timer has timed out; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TSysEvtHandler. ←; TTimer. ←. TProcessEventTimer. Function documentation; TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms). If mode == kTRUE then the timer is synchronous else; a-synchronous. The default is synchronous. Add a timer to the system; eventloop by calling TurnOn(). Set command to be executed from Notify(); or set the object whose HandleTimer() method will be called via Notify(),; derive from TTimer and override Notify() or connect slots to the; signals Timeout(), TurnOn() and TurnOff(). TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The object's HandleTimer() will be called by Notify(). TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system event",MatchSource.WIKI,root/html604/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimer.html
https://root.cern/root/html604/TTimer.html:14078,Safety,timeout,timeout,14078,"TRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The interpreter will execute command from Notify(). Bool_t CheckTimer(const TTime& now); Check if timer timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). Make sure to call Reset() also in derived; Notify() so timers will keep working repeatedly. void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t ",MatchSource.WIKI,root/html604/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimer.html
https://root.cern/root/html604/TTimer.html:14254,Safety,timeout,timeout,14254,"he interpreter will execute command from Notify(). Bool_t CheckTimer(const TTime& now); Check if timer timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). Make sure to call Reset() also in derived; Notify() so timers will keep working repeatedly. void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Creat",MatchSource.WIKI,root/html604/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimer.html
https://root.cern/root/html604/TTimer.html:14290,Safety,timeout,timeout,14290,"er timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). Make sure to call Reset() also in derived; Notify() so timers will keep working repeatedly. void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Created internal timer will be deleted after that. TTimer(const TTimer& ). TTimer& operator=(const TTimer",MatchSource.WIKI,root/html604/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimer.html
https://root.cern/root/html604/TTimer.html:14318,Safety,timeout,timeout,14318,"er timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). Make sure to call Reset() also in derived; Notify() so timers will keep working repeatedly. void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Created internal timer will be deleted after that. TTimer(const TTimer& ). TTimer& operator=(const TTimer",MatchSource.WIKI,root/html604/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimer.html
https://root.cern/root/html604/TTimeStamp.html:5464,Availability,error,error,5464," 8*60*60;; TTimeStamp(year,month,day,hour,min,sec,nsec,kTRUE,8*60*60);. TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified date, time, nanosec.; If !isUTC then it is assumed to be the standard local time zone. TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); Create a TTimeStamp and set it to tloc which must be a time_t value; returned by time(). This value is the number of seconds since the EPOCH; (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then the input; is a dosDate value. Double_t AsGMST(Double_t UT1Offset = 0) const; Return Greenwich mean sidereal time (GMST) in hour-angle. Return value; will always be between 0 and 24 (hours). Sidereal time is most accurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:5500,Availability,error,error,5500,"*60*60);. TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified date, time, nanosec.; If !isUTC then it is assumed to be the standard local time zone. TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); Create a TTimeStamp and set it to tloc which must be a time_t value; returned by time(). This value is the number of seconds since the EPOCH; (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then the input; is a dosDate value. Double_t AsGMST(Double_t UT1Offset = 0) const; Return Greenwich mean sidereal time (GMST) in hour-angle. Return value; will always be between 0 and 24 (hours). Sidereal time is most accurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Lon",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:6208,Availability,error,error,6208,"ll always be between 0 and 24 (hours). Sidereal time is most accurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local appara",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:6244,Availability,error,error,6244,"ccurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in ",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:6922,Availability,error,error,6922,"in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(const Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:6957,Availability,error,error,6957,"hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(const Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Opti",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:7551,Availability,error,error,7551,"et = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(const Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-H",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:7586,Availability,error,error,7586,"angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(const Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly con",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:5513,Energy Efficiency,reduce,reduced,5513,"*60*60);. TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified date, time, nanosec.; If !isUTC then it is assumed to be the standard local time zone. TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); Create a TTimeStamp and set it to tloc which must be a time_t value; returned by time(). This value is the number of seconds since the EPOCH; (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then the input; is a dosDate value. Double_t AsGMST(Double_t UT1Offset = 0) const; Return Greenwich mean sidereal time (GMST) in hour-angle. Return value; will always be between 0 and 24 (hours). Sidereal time is most accurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Lon",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:6257,Energy Efficiency,reduce,reduced,6257,"ccurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in ",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:6971,Energy Efficiency,reduce,reduced,6971,"hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(const Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Opti",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:7600,Energy Efficiency,reduce,reduced,7600,"angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(const Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly con",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:7861,Energy Efficiency,allocate,allocated,7861," milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(const Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conforming it should use ""T"" instead of the; blank separating the date and time. Option ""2"" returns as {sec,nsec} integers. Option ""s"" returns ""2001-01-02 18:11:12"" with an implied UTC,; overrides ""l"" option. Internally uses a circular list of buffers to avoid pr",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:12947,Integrability,rout,routine,12947," | 1970 2000 2001 .. 2037. ""year"" | 138...1969 | 1970 .. 2037 | ...; true | undefined | 1970 .. 2037 | undefined. void Set(Int_t date, Int_t time, Int_t nsec, Bool_t isUTC, Int_t secOffset); Set date/time from integers of the form [yy]YYMMDD and HHMMSS,; assume UTC (UTC) components:. MM: 01=January .. 12=December; DD: 01 .. 31. HH: 00=midnight .. 23; MM: 00 .. 59; SS: 00 .. 69. Date must be in format 980418 or 19980418; 1001127 or 20001127 (i.e. year 100 = 2000),; time must be in format 224512 (second precision),; date must be >= 700101. void Set(UInt_t tloc, Bool_t isUTC, Int_t secOffset, Bool_t dosDate); The input arg is a time_t value returned by time() or a value; returned by Convert(). This value is the number of seconds since; the EPOCH (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then; the input is a dosDate value. void NormalizeNanoSec(); Ensure that the fNanoSec field is in range [0,999999999]. time_t MktimeFromUTC(tm_t* tmstruct); Equivalent of standard routine ""mktime"" but; using the assumption that tm struct is filled with UTC, not local, time. This version *ISN'T* configured to handle every possible; weirdness of out-of-range values in the case of normalizing; the tm struct. This version *DOESN'T* correctly handle values that can't be; fit into a time_t (i.e. beyond year 2038-01-18 19:14:07, or; before the start of Epoch). Int_t GetDayOfYear(Int_t day, Int_t month, Int_t year); Get the day of the year represented by day, month and year.; Valid return values range between 1 and 366, where January 1 = 1. Int_t GetDayOfWeek(Int_t day, Int_t month, Int_t year); Method is using Zeller's formula for calculating the day number.; Valid return values range between 1 and 7, where Monday = 1. Int_t GetWeek(Int_t day, Int_t month, Int_t year); Get the week of the year. Valid week values are between 1 and 53.; The return value is the year*100+week (1 Jan may be in the last; week of the previous year so the year must be returned too). Bool_t IsLeapYear(Int_t ye",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:116,Modifiability,inherit,inheritance,116,". TTimeStamp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimeStamp. class TTimeStamp. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. Function Members (Methods); public:. virtual~TTimeStamp(); voidAdd(const TTimeStamp& offset); Double_tAsDouble() const; Double_tAsGAST(Double_t UT1Offset = 0) const; Double_tAsGMST(Double_t UT1Offset = 0) const; Double_tAsJulianDate() const; Double_tAsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Double_tAsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; const char*AsString(const Option_t* option = """") const; static TClass*Class(); voidCopy(TTimeStamp& ts) const; static voidDumpTMStruct(const tm_t& tmstruct); UInt_tGetDate(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* year = 0, UInt_t* month = 0, UInt_t* day = 0) const; Int_tGetDayOfWeek(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; static Int_tGetDayOfWeek(Int_t day, Int_t month, Int_t year); Int_tGetDayOfYear(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; static Int_tGetDayOfYear(Int_t day, Int_t month, Int_t year); Int_tGetMonth(Bool_t in",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:360,Modifiability,extend,extends,360,". TTimeStamp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimeStamp. class TTimeStamp. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. Function Members (Methods); public:. virtual~TTimeStamp(); voidAdd(const TTimeStamp& offset); Double_tAsDouble() const; Double_tAsGAST(Double_t UT1Offset = 0) const; Double_tAsGMST(Double_t UT1Offset = 0) const; Double_tAsJulianDate() const; Double_tAsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Double_tAsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; const char*AsString(const Option_t* option = """") const; static TClass*Class(); voidCopy(TTimeStamp& ts) const; static voidDumpTMStruct(const tm_t& tmstruct); UInt_tGetDate(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* year = 0, UInt_t* month = 0, UInt_t* day = 0) const; Int_tGetDayOfWeek(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; static Int_tGetDayOfWeek(Int_t day, Int_t month, Int_t year); Int_tGetDayOfYear(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; static Int_tGetDayOfYear(Int_t day, Int_t month, Int_t year); Int_tGetMonth(Bool_t in",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:13063,Modifiability,config,configured,13063,", Int_t nsec, Bool_t isUTC, Int_t secOffset); Set date/time from integers of the form [yy]YYMMDD and HHMMSS,; assume UTC (UTC) components:. MM: 01=January .. 12=December; DD: 01 .. 31. HH: 00=midnight .. 23; MM: 00 .. 59; SS: 00 .. 69. Date must be in format 980418 or 19980418; 1001127 or 20001127 (i.e. year 100 = 2000),; time must be in format 224512 (second precision),; date must be >= 700101. void Set(UInt_t tloc, Bool_t isUTC, Int_t secOffset, Bool_t dosDate); The input arg is a time_t value returned by time() or a value; returned by Convert(). This value is the number of seconds since; the EPOCH (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then; the input is a dosDate value. void NormalizeNanoSec(); Ensure that the fNanoSec field is in range [0,999999999]. time_t MktimeFromUTC(tm_t* tmstruct); Equivalent of standard routine ""mktime"" but; using the assumption that tm struct is filled with UTC, not local, time. This version *ISN'T* configured to handle every possible; weirdness of out-of-range values in the case of normalizing; the tm struct. This version *DOESN'T* correctly handle values that can't be; fit into a time_t (i.e. beyond year 2038-01-18 19:14:07, or; before the start of Epoch). Int_t GetDayOfYear(Int_t day, Int_t month, Int_t year); Get the day of the year represented by day, month and year.; Valid return values range between 1 and 366, where January 1 = 1. Int_t GetDayOfWeek(Int_t day, Int_t month, Int_t year); Method is using Zeller's formula for calculating the day number.; Valid return values range between 1 and 7, where Monday = 1. Int_t GetWeek(Int_t day, Int_t month, Int_t year); Get the week of the year. Valid week values are between 1 and 53.; The return value is the year*100+week (1 Jan may be in the last; week of the previous year so the year must be returned too). Bool_t IsLeapYear(Int_t year); Is the given year a leap year.; The calendar year is 365 days long, unless the year is exactly divisible; by 4, in which case an extra day i",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:8844,Safety,avoid,avoid,8844,"ically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conforming it should use ""T"" instead of the; blank separating the date and time. Option ""2"" returns as {sec,nsec} integers. Option ""s"" returns ""2001-01-02 18:11:12"" with an implied UTC,; overrides ""l"" option. Internally uses a circular list of buffers to avoid problems; using AsString multiple times in a single statement. void Copy(TTimeStamp& ts) const; Copy this to ts. UInt_t GetDate(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* year = 0, UInt_t* month = 0, UInt_t* day = 0) const; Return date in form of 19971224 (i.e. 24/12/1997),; if non-zero pointers supplied for year, month, day fill those as well. UInt_t GetTime(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* hour = 0, UInt_t* min = 0, UInt_t* sec = 0) const; Return time in form of 123623 (i.e. 12:36:23),; if non-zero pointers supplied for hour, min, sec fill those as well. Int_t GetDayOfYear(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; Get the day of the year represented by this time stamp value.; Valid return values range between 1 and 366, where January 1 = 1. Int_t GetDayOfWeek(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; Method is using Zeller's formula for calculating the day number.; Valid return values range between 1 and 7, where Monday = 1. Int_t GetMonth(Bool_t ",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:752,Usability,simpl,simply,752,". TTimeStamp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimeStamp. class TTimeStamp. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. Function Members (Methods); public:. virtual~TTimeStamp(); voidAdd(const TTimeStamp& offset); Double_tAsDouble() const; Double_tAsGAST(Double_t UT1Offset = 0) const; Double_tAsGMST(Double_t UT1Offset = 0) const; Double_tAsJulianDate() const; Double_tAsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Double_tAsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; const char*AsString(const Option_t* option = """") const; static TClass*Class(); voidCopy(TTimeStamp& ts) const; static voidDumpTMStruct(const tm_t& tmstruct); UInt_tGetDate(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* year = 0, UInt_t* month = 0, UInt_t* day = 0) const; Int_tGetDayOfWeek(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; static Int_tGetDayOfWeek(Int_t day, Int_t month, Int_t year); Int_tGetDayOfYear(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; static Int_tGetDayOfYear(Int_t day, Int_t month, Int_t year); Int_tGetMonth(Bool_t in",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:3931,Usability,simpl,simply,3931,"Int_t secOffset); voidSetNanoSec(Int_t nsec); voidSetSec(Int_t sec); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTimeStamp(); TTimeStamp(const timespec_t& ts); TTimeStamp(const TTimeStamp&); TTimeStamp(time_t t, Int_t nsec); TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); TTimeStamp(UInt_t year, UInt_t month, UInt_t day, UInt_t hour, UInt_t min, UInt_t sec, UInt_t nsec = 0, Bool_t isUTC = kTRUE, Int_t secOffset = 0). private:. voidNormalizeNanoSec(). Data Members; private:. Int_tfNanoSecnanoseconds; Int_tfSecseconds. Class Charts. Inheritance Chart:. TTimeStamp. Function documentation; TTimeStamp(); Default ctor. Create a TTimeStamp and set it to the current time; (as best possible). The nanosecond part is faked so that subsequenct; calls simply add 1 to ensure that sequential calls are distinct; (and sortable). TTimeStamp(UInt_t year, UInt_t month, UInt_t day, UInt_t hour, UInt_t min, UInt_t sec, UInt_t nsec = 0, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified year, month,; day, time, hour, minute, second and nanosec.; If !isUTC then it is assumed to be the standard local time zone. If local time is PST then one can use; TTimeStamp(year,month,day,hour,min,sec,nsec,kFALSE,0);; or; Int_t secOffset = 8*60*60;; TTimeStamp(year,month,day,hour,min,sec,nsec,kTRUE,8*60*60);. TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified date, time, nanosec.; If !isUTC then it is assumed to be the standard local time zone. TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); Create a TTimeStamp and set it to tloc which must be a time_t value; returned by time(). This value is ",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TTimeStamp.html:11414,Usability,simpl,simply,11414,"xtra day is added to February to make the year; 366 days long. If the year is the last year of a century, eg. 1700, 1800,; 1900, 2000, then it is only a leap year if it is exactly divisible by; 400. Therefore, 1900 wasn't a leap year but 2000 was. The reason for; these rules is to bring the average length of the calendar year into; line with the length of the Earth's orbit around the Sun, so that the; seasons always occur during the same months each year. Int_t GetZoneOffset(); Static method returning local (current) time zone offset from UTC.; This is the value in seconds one must add to the local time to arrive at; Coordinated Universal Time, so it is negative east of the Prime Meridian. void Add(const TTimeStamp& offset); Add ""offset"" as a delta time. void Print(const Option_t* option = """") const; Print date and time. void Set(); Set Date/Time to current time as reported by the system.; No accounting for nanoseconds with std ANSI functions,; ns part faked so that subsequent calls simply add 1 to it; this ensures that calls within the same second come back; distinct (and sortable). Time is since Jan 1, 1970. void Set(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec, Int_t nsec, Bool_t isUTC, Int_t secOffset); Set Date/Time from components. Month & day both use normal 1..12 and 1..31 counting,; hours, min, sec run from 0 to 23, 59, 59 respectively,; secOffset provides method for adjusting for alternative timezones. ""year"" | 0 1 ... 37 | 38...69 | 70 .. 100 101 .. 137; true | 2000 2001 2037 | undefined | 1970 2000 2001 .. 2037. ""year"" | 138...1969 | 1970 .. 2037 | ...; true | undefined | 1970 .. 2037 | undefined. void Set(Int_t date, Int_t time, Int_t nsec, Bool_t isUTC, Int_t secOffset); Set date/time from integers of the form [yy]YYMMDD and HHMMSS,; assume UTC (UTC) components:. MM: 01=January .. 12=December; DD: 01 .. 31. HH: 00=midnight .. 23; MM: 00 .. 59; SS: 00 .. 69. Date must be in format 980418 or 19980418; 1001127 or 20001127 (i.e. year",MatchSource.WIKI,root/html604/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTimeStamp.html
https://root.cern/root/html604/TToggle.html:2090,Availability,error,error,2090," virtual~TToggle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* ms",MatchSource.WIKI,root/html604/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggle.html
https://root.cern/root/html604/TToggle.html:2174,Availability,error,error,2174,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMethodCall*GetGetter() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Long_tGetOffValue(); virtual Long_tGetOnValue(); virtual Option_t*TObject::GetOption() const; TMethodCall*GetSetter() const; virtual Bool_tGetState(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetValue(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtu",MatchSource.WIKI,root/html604/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggle.html
https://root.cern/root/html604/TToggle.html:758,Deployability,toggle,toggle,758,". TToggle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TToggle. class TToggle: public TNamed. TToggle. This class defines toggling facility for both - object's method or; variables.; Assume that user provides an object with a two-state field , and; methods to Get/Set value of this field. This object enables to switch; values via this method when the only thing you know about the field; is the name of the method (or method itself) which sets the field.; This facility is required in context Pop-Up menu, when the only; information about how to toggle a field is a name of methhod which; sets it.; This class may be also used for toggling an integer variable,; which may be important while building universal objects...; When user provides a ""set-method"" of name SetXXX this object tries; automaticaly find a matching ""get-method"" by lookin for a method; with name GetXXX, IsXXX or HasXXX for given object. Function Members (Methods); public:. virtual~TToggle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* ms",MatchSource.WIKI,root/html604/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggle.html
https://root.cern/root/html604/TToggle.html:8351,Deployability,toggle,toggle,8351,"he object this Toggle belongs to; TMethodCall*fSetterMethod to Set a value of fObject;; Int_t*fTglVariableAlternatively: pointer to an integer value to be Toggled instead of TObjectl; TStringTNamed::fTitleobject title. private:. Long_tfOffValueValue recognized as switched OFF(Def=0); Long_tfOnValueValue recognized as switched ON (Def=1); Bool_tfStateObject's state - ""a local copy""; Long_tfValueLocal copy of a value returned by called function. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggle. Function documentation; TToggle(); TToggle default constructor. You have to initialize it before using; by making a call to SetToggledVariable() or SetToggledObject(). void SetToggledVariable(Int_t& var); Initializes object for use with a variable - you pass it via reference; so it will be modified by Toggle. Bool_t GetState(); Returns the state of Toggle according to its current value and; fOnValue, returns true if they match. void SetState(Bool_t state); Sets the value of toggle to fOnValue or fOffValue according to passed; argument. void SetValue(Long_t val); Sets the value of toggle and modifies its state according to whether; the value is equal to fOnValue. void Toggle(); Toggles the Values and State of this object and connected data!. void SetToggledObject(TObject* obj, TMethod* anymethod); Initializes it to toggle an object's datamember using this object's; method. TToggle(). Bool_t IsInitialized(); {return fInitialized;}. void SetOnValue(Long_t lon); {fOnValue=lon;}. Long_t GetOnValue(); {return fOnValue;}. void SetOffValue(Long_t lof); {fOffValue=lof;}. Long_t GetOffValue(); {return fOffValue;}. Int_t GetValue(); {return fValue;}. TMethodCall * GetGetter() const; { return fGetter; }. TMethodCall * GetSetter() const; { return fSetter; }. » Author: Piotr Golonka 30/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or",MatchSource.WIKI,root/html604/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggle.html
https://root.cern/root/html604/TToggle.html:8459,Deployability,toggle,toggle,8459,"glVariableAlternatively: pointer to an integer value to be Toggled instead of TObjectl; TStringTNamed::fTitleobject title. private:. Long_tfOffValueValue recognized as switched OFF(Def=0); Long_tfOnValueValue recognized as switched ON (Def=1); Bool_tfStateObject's state - ""a local copy""; Long_tfValueLocal copy of a value returned by called function. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggle. Function documentation; TToggle(); TToggle default constructor. You have to initialize it before using; by making a call to SetToggledVariable() or SetToggledObject(). void SetToggledVariable(Int_t& var); Initializes object for use with a variable - you pass it via reference; so it will be modified by Toggle. Bool_t GetState(); Returns the state of Toggle according to its current value and; fOnValue, returns true if they match. void SetState(Bool_t state); Sets the value of toggle to fOnValue or fOffValue according to passed; argument. void SetValue(Long_t val); Sets the value of toggle and modifies its state according to whether; the value is equal to fOnValue. void Toggle(); Toggles the Values and State of this object and connected data!. void SetToggledObject(TObject* obj, TMethod* anymethod); Initializes it to toggle an object's datamember using this object's; method. TToggle(). Bool_t IsInitialized(); {return fInitialized;}. void SetOnValue(Long_t lon); {fOnValue=lon;}. Long_t GetOnValue(); {return fOnValue;}. void SetOffValue(Long_t lof); {fOffValue=lof;}. Long_t GetOffValue(); {return fOffValue;}. Int_t GetValue(); {return fValue;}. TMethodCall * GetGetter() const; { return fGetter; }. TMethodCall * GetSetter() const; { return fSetter; }. » Author: Piotr Golonka 30/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggle.html
https://root.cern/root/html604/TToggle.html:8698,Deployability,toggle,toggle,8698,"glVariableAlternatively: pointer to an integer value to be Toggled instead of TObjectl; TStringTNamed::fTitleobject title. private:. Long_tfOffValueValue recognized as switched OFF(Def=0); Long_tfOnValueValue recognized as switched ON (Def=1); Bool_tfStateObject's state - ""a local copy""; Long_tfValueLocal copy of a value returned by called function. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggle. Function documentation; TToggle(); TToggle default constructor. You have to initialize it before using; by making a call to SetToggledVariable() or SetToggledObject(). void SetToggledVariable(Int_t& var); Initializes object for use with a variable - you pass it via reference; so it will be modified by Toggle. Bool_t GetState(); Returns the state of Toggle according to its current value and; fOnValue, returns true if they match. void SetState(Bool_t state); Sets the value of toggle to fOnValue or fOffValue according to passed; argument. void SetValue(Long_t val); Sets the value of toggle and modifies its state according to whether; the value is equal to fOnValue. void Toggle(); Toggles the Values and State of this object and connected data!. void SetToggledObject(TObject* obj, TMethod* anymethod); Initializes it to toggle an object's datamember using this object's; method. TToggle(). Bool_t IsInitialized(); {return fInitialized;}. void SetOnValue(Long_t lon); {fOnValue=lon;}. Long_t GetOnValue(); {return fOnValue;}. void SetOffValue(Long_t lof); {fOffValue=lof;}. Long_t GetOffValue(); {return fOffValue;}. Int_t GetValue(); {return fValue;}. TMethodCall * GetGetter() const; { return fGetter; }. TMethodCall * GetSetter() const; { return fSetter; }. » Author: Piotr Golonka 30/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggle.html
https://root.cern/root/html604/TToggle.html:113,Modifiability,inherit,inheritance,113,". TToggle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TToggle. class TToggle: public TNamed. TToggle. This class defines toggling facility for both - object's method or; variables.; Assume that user provides an object with a two-state field , and; methods to Get/Set value of this field. This object enables to switch; values via this method when the only thing you know about the field; is the name of the method (or method itself) which sets the field.; This facility is required in context Pop-Up menu, when the only; information about how to toggle a field is a name of methhod which; sets it.; This class may be also used for toggling an integer variable,; which may be important while building universal objects...; When user provides a ""set-method"" of name SetXXX this object tries; automaticaly find a matching ""get-method"" by lookin for a method; with name GetXXX, IsXXX or HasXXX for given object. Function Members (Methods); public:. virtual~TToggle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* ms",MatchSource.WIKI,root/html604/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggle.html
https://root.cern/root/html604/TToggle.html:382,Modifiability,variab,variables,382,". TToggle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TToggle. class TToggle: public TNamed. TToggle. This class defines toggling facility for both - object's method or; variables.; Assume that user provides an object with a two-state field , and; methods to Get/Set value of this field. This object enables to switch; values via this method when the only thing you know about the field; is the name of the method (or method itself) which sets the field.; This facility is required in context Pop-Up menu, when the only; information about how to toggle a field is a name of methhod which; sets it.; This class may be also used for toggling an integer variable,; which may be important while building universal objects...; When user provides a ""set-method"" of name SetXXX this object tries; automaticaly find a matching ""get-method"" by lookin for a method; with name GetXXX, IsXXX or HasXXX for given object. Function Members (Methods); public:. virtual~TToggle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* ms",MatchSource.WIKI,root/html604/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggle.html
https://root.cern/root/html604/TToggle.html:863,Modifiability,variab,variable,863,". TToggle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TToggle. class TToggle: public TNamed. TToggle. This class defines toggling facility for both - object's method or; variables.; Assume that user provides an object with a two-state field , and; methods to Get/Set value of this field. This object enables to switch; values via this method when the only thing you know about the field; is the name of the method (or method itself) which sets the field.; This facility is required in context Pop-Up menu, when the only; information about how to toggle a field is a name of methhod which; sets it.; This class may be also used for toggling an integer variable,; which may be important while building universal objects...; When user provides a ""set-method"" of name SetXXX this object tries; automaticaly find a matching ""get-method"" by lookin for a method; with name GetXXX, IsXXX or HasXXX for given object. Function Members (Methods); public:. virtual~TToggle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* ms",MatchSource.WIKI,root/html604/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggle.html
https://root.cern/root/html604/TToggle.html:8111,Modifiability,variab,variable,8111,"s)TObject::kZombie. protected:. TMethodCall*fGetterMethod to Get a value of fObject;; Bool_tfInitializedTrue if either SetToggledObject or SetToggledVariable called - enables Toggle() method.; TStringTNamed::fNameobject identifier; TObject*fObjectThe object this Toggle belongs to; TMethodCall*fSetterMethod to Set a value of fObject;; Int_t*fTglVariableAlternatively: pointer to an integer value to be Toggled instead of TObjectl; TStringTNamed::fTitleobject title. private:. Long_tfOffValueValue recognized as switched OFF(Def=0); Long_tfOnValueValue recognized as switched ON (Def=1); Bool_tfStateObject's state - ""a local copy""; Long_tfValueLocal copy of a value returned by called function. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggle. Function documentation; TToggle(); TToggle default constructor. You have to initialize it before using; by making a call to SetToggledVariable() or SetToggledObject(). void SetToggledVariable(Int_t& var); Initializes object for use with a variable - you pass it via reference; so it will be modified by Toggle. Bool_t GetState(); Returns the state of Toggle according to its current value and; fOnValue, returns true if they match. void SetState(Bool_t state); Sets the value of toggle to fOnValue or fOffValue according to passed; argument. void SetValue(Long_t val); Sets the value of toggle and modifies its state according to whether; the value is equal to fOnValue. void Toggle(); Toggles the Values and State of this object and connected data!. void SetToggledObject(TObject* obj, TMethod* anymethod); Initializes it to toggle an object's datamember using this object's; method. TToggle(). Bool_t IsInitialized(); {return fInitialized;}. void SetOnValue(Long_t lon); {fOnValue=lon;}. Long_t GetOnValue(); {return fOnValue;}. void SetOffValue(Long_t lof); {fOffValue=lof;}. Long_t GetOffValue(); {return fOffValue;}. Int_t GetValue(); {return fValue;}. TMethodCall * GetGetter() const; { return fGetter; }. TMethodCall * GetSetter() c",MatchSource.WIKI,root/html604/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggle.html
https://root.cern/root/html604/TToggleGroup.html:1536,Availability,error,error,1536,"ethod(const char* method) const; virtual Int_tAdd(TToggle* t, Bool_t select = 1); virtual voidTObject::AppendPad(Option_t* option = """"); virtual TToggle*At(Int_t idx); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteAll(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TToggle*First(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetTogglesCount(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Int_tIndexOf(TToggle* t); ",MatchSource.WIKI,root/html604/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggleGroup.html
https://root.cern/root/html604/TToggleGroup.html:1620,Availability,error,error,1620,"rtual voidTObject::AppendPad(Option_t* option = """"); virtual TToggle*At(Int_t idx); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteAll(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TToggle*First(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetTogglesCount(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Int_tIndexOf(TToggle* t); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Boo",MatchSource.WIKI,root/html604/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggleGroup.html
https://root.cern/root/html604/TToggleGroup.html:6799,Deployability,toggle,togglegroup,6799,"EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggleGroup. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or",MatchSource.WIKI,root/html604/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggleGroup.html
https://root.cern/root/html604/TToggleGroup.html:6833,Deployability,toggle,toggled,6833,"EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggleGroup. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or",MatchSource.WIKI,root/html604/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggleGroup.html
https://root.cern/root/html604/TToggleGroup.html:6903,Deployability,toggle,toggle,6903,"itsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggleGroup. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggleGroup.html
https://root.cern/root/html604/TToggleGroup.html:6979,Deployability,toggle,toggle,6979,"itsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggleGroup. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggleGroup.html
https://root.cern/root/html604/TToggleGroup.html:7043,Deployability,toggle,toggle,7043,"itsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggleGroup. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggleGroup.html
https://root.cern/root/html604/TToggleGroup.html:7087,Deployability,toggle,toggle,7087,"itsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggleGroup. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggleGroup.html
https://root.cern/root/html604/TToggleGroup.html:118,Modifiability,inherit,inheritance,118,". TToggleGroup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TToggleGroup. class TToggleGroup: public TNamed. TToggleGroup. This class defines check-box facility for TToggle objects; It is used in context menu ""selectors"" for picking up a value. Function Members (Methods); public:. virtual~TToggleGroup(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(TToggle* t, Bool_t select = 1); virtual voidTObject::AppendPad(Option_t* option = """"); virtual TToggle*At(Int_t idx); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteAll(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TToggle*First(); virtual Option_t*TObject::GetDr",MatchSource.WIKI,root/html604/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggleGroup.html
https://root.cern/root/html604/TToggleGroup.html:7141,Usability,clear,clears,7141,"itsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TToggleGroup. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TToggleGroup.html
https://root.cern/root/html604/TTRAP.html:2559,Availability,error,error,2559,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAlpha1() const; virtual Float_tGetAlpha2() const; virtual Float_tGetBl1() const; virtual Float_tGetBl2() const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual Float_tGetH1() const; virtual Float_tGetH2() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAtt",MatchSource.WIKI,root/html604/TTRAP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTRAP.html
https://root.cern/root/html604/TTRAP.html:2643,Availability,error,error,2643,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAlpha1() const; virtual Float_tGetAlpha2() const; virtual Float_tGetBl1() const; virtual Float_tGetBl2() const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual Float_tGetH1() const; virtual Float_tGetH2() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual W",MatchSource.WIKI,root/html604/TTRAP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTRAP.html
https://root.cern/root/html604/TTRAP.html:111,Modifiability,inherit,inheritance,111,". TTRAP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TTRAP. class TTRAP: public TBRIK. . TRAP is a general trapezoid. The faces perpendicular to z are trapezia and; their centres are not necessarily on a line parallel to the z axis.; This shape has 14 parameters. - name name of the shape; - title shape's title; - material (see TMaterial); - dz half-length along the z axis; - theta polar angle of the line joining the centre of the face; at -DZ to the centre of the one at +DZ; - phi azimuthal angle of the line joining the centre of the face; at -DZ to the centre of the one at +DZ; - h1 half-length along y of the face at -DZ; - bl1 half-length along x of the side at -H1 in y of the face; at -DZ in z; - tl1 half-length along x of the side at +H1 in y of the face; at -DZ in z; - alpha1 angle with respect to the y axis from the centre of the; side at -H1 in y to the centre of the side at +H1 in y; of the face at -DZ in z; - h2 half-length along y of the face at +DZ; - bl2 half-length along x of the side at -H2 in y of the; face at +DZ in z; - tl2 half-length along x of the side at +H2 in y of the face; at +DZ in z; - alpha2 angle with respect to the y axis from the centre of the side; at -H2 in y to the centre of the side at +H2 in y of the; face at +DZ in z. Function Members (Methods); public:. virtual~TTRAP(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::D",MatchSource.WIKI,root/html604/TTRAP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTRAP.html
https://root.cern/root/html604/TTRD1.html:1726,Availability,error,error,1726,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; virtual Float_tGetDx2() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const",MatchSource.WIKI,root/html604/TTRD1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTRD1.html
https://root.cern/root/html604/TTRD1.html:1810,Availability,error,error,1810,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; virtual Float_tGetDx2() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const",MatchSource.WIKI,root/html604/TTRD1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTRD1.html
https://root.cern/root/html604/TTRD1.html:111,Modifiability,inherit,inheritance,111,". TTRD1. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TTRD1. class TTRD1: public TBRIK. . TRD1 is a trapezoid with the x dimension varying along z.; It has 7 parameters:. - name name of the shape; - title shape's title; - material (see TMaterial); - dx1 half-length along x at the z surface positioned at -DZ; - dx2 half-length along x at the z surface positioned at +DZ; - dy half-length along the y-axis; - dz half-length along the z-axis. Function Members (Methods); public:. virtual~TTRD1(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*&",MatchSource.WIKI,root/html604/TTRD1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTRD1.html
https://root.cern/root/html604/TTRD2.html:1823,Availability,error,error,1823,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tGetDx2() const; Float_tTBRIK::GetDy() const; Float_tGetDy2() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetM",MatchSource.WIKI,root/html604/TTRD2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTRD2.html
https://root.cern/root/html604/TTRD2.html:1907,Availability,error,error,1907,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tGetDx2() const; Float_tTBRIK::GetDy() const; Float_tGetDy2() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::Ge",MatchSource.WIKI,root/html604/TTRD2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTRD2.html
https://root.cern/root/html604/TTRD2.html:111,Modifiability,inherit,inheritance,111,". TTRD2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TTRD2. class TTRD2: public TBRIK. . TRD2 is a trapezoid with both x and y dimensions varying along z.; It has 8 parameters:. - name name of the shape; - title shape's title; - material (see TMaterial); - dx1 half-length along x at the z surface positioned at -DZ; - dx2 half-length along x at the z surface positioned at +DZ; - dy1 half-length along y at the z surface positioned at -DZ; - dy2 half-length along y at the z surface positioned at +DZ; - dz half-length along the z-axis. Function Members (Methods); public:. virtual~TTRD2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTO",MatchSource.WIKI,root/html604/TTRD2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTRD2.html
https://root.cern/root/html604/TTree.html:15930,Availability,error,error,15930,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBaskets(); virtual Int_tDropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tDropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidDropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tFlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tGetAutoFlush() const; virtual Long64_tGetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*GetBranchRef() const; virtual Bool_tGetBranchStatus(cons",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:16014,Availability,error,error,16014,"_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBaskets(); virtual Int_tDropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tDropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidDropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tFlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tGetAutoFlush() const; virtual Long64_tGetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*GetBranchRef() const; virtual Bool_tGetBranchStatus(const char* branchname) const; static Int_tGetBranchStyle(); virtual Long64_tGetCacheSiz",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:37885,Availability,error,error,37885,"nction documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:38133,Availability,error,error,38133,"the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (c",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:38470,Availability,error,error,38470," TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:38734,Availability,error,error,38734," branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The t",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:43720,Availability,recover,recovered,43720,"ve tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The follo",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:43796,Availability,recover,recovered,43796,"e branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- scri",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:44560,Availability,error,error,44560,"mation you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* Branc",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:53717,Availability,avail,available,53717,"e; branches (TBranchElement). To get the old behaviour, you can:; - call BranchOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1)",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:56791,Availability,avail,available,56791,"vel = 99); Create a new TTree BranchElement. WARNING about this new function. This function is designed to replace the internal; implementation of the old TTree::Branch (whose implementation; has been moved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the address must be the address of a pointer).; For more flexibility use 'Branch'. Use Bronch only in (rare); cases (likely to be legacy cases) where both the new and old; implementation of Branch needs to be used at the same time. This function is far more powerful than the old Branch; function. It supports the full C++, including STL and has; the same behaviour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:59072,Availability,failure,failure,59072,"e is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. void Browse(TBrowser* ); Browse content of the TTree. Int_t BuildIndex(const char* majorname, const char* minorname = ""0""); Build a Tree Index (default is TTreeIndex).; See a description of the parameters and functionality in; TTreeIndex::TTreeIndex(). The return value is the number of entries in the Index (< 0 indicates failure). A TTreeIndex object pointed by fTreeIndex is created.; This object will be automatically deleted by the TTree destructor.; See also comments in TTree::SetTreeIndex(). TStreamerInfo* BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); Build StreamerInfo for class cl.; pointer is an optional argument that may contain a pointer to an object of cl. TFile* ChangeFile(TFile* file); Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize.; Create a new file. If the original file is named ""myfile.root"",; subsequent files are named ""myfile_1.root"", ""myfile_2.root"", etc. Returns a pointer to the new file. Currently, the automatic change of file is restricted; to the case where the tree is in the top level directory.; The file should not contain sub-directories. Before switching to a new file, the tree header is written; to the current file, then the current file is closed. To process the multiple files created by ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:61459,Availability,error,error,61459,"'t do:; TFile *file = new TFile(""myfile.root"",""recreate"");; TTree *T = new TTree(""T"",""title"");; T->Fill(); //loop; file->Write();; file->Close();; but do the following:; TFile *file = new TFile(""myfile.root"",""recreate"");; TTree *T = new TTree(""T"",""title"");; T->Fill(); //loop; file = T->GetCurrentFile(); //to get the pointer to the current file; file->Write();; file->Close();. Int_t CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); Check whether or not the address described by the last 3 parameters; matches the content of the branch. If a Data Model Evolution conversion; is involved, reset the fInfo of the branch.; The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. TTree* CloneTree(Long64_t nentries = -1, Option_t* option = """"); Create a clone of this tree and copy nentries. By default copy all entries.; The compression level of the cloned tree is set to the destination; file's compression level. NOTE: Only active branches are copied.; NOTE: If the TTree is a TChain, the structure of the first TTree; is used for the copy. IMPORTANT: The cloned tree stays connected with this tree until; this tree is deleted. In particular, any changes in; branch addresses in this tree are forwarded to the; ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:62137,Availability,avail,available,62137,"lass* ptrClass, EDataType datatype, Bool_t ptr); Check whether or not the address described by the last 3 parameters; matches the content of the branch. If a Data Model Evolution conversion; is involved, reset the fInfo of the branch.; The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. TTree* CloneTree(Long64_t nentries = -1, Option_t* option = """"); Create a clone of this tree and copy nentries. By default copy all entries.; The compression level of the cloned tree is set to the destination; file's compression level. NOTE: Only active branches are copied.; NOTE: If the TTree is a TChain, the structure of the first TTree; is used for the copy. IMPORTANT: The cloned tree stays connected with this tree until; this tree is deleted. In particular, any changes in; branch addresses in this tree are forwarded to the; clone trees, unless a branch in a clone tree has had; its address changed, in which case that change stays in; effect. When this tree is deleted, all the addresses of; the cloned tree are reset to their default values. If 'option' contains the word 'fast' and nentries is -1, the; cloning will be done without unzipping or unstreaming the baskets; (i.e., a direct copy of the raw bytes on disk). When 'fast' is specified, 'optio",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:68360,Availability,error,error,68360,"rate file. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree3. Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree.; NOTE that only the active branches are copied. TBasket* CreateBasket(TBranch* ); Create a basket for this tree and given branch. void Delete(Option_t* option = """"); Delete this tree from memory or/and disk. if option == ""all"" delete Tree object from memory AND from disk; all baskets on disk are deleted. All keys with same name; are deleted.; if option =="""" only Tree object in memory is deleted. void DirectoryAutoAdd(TDirectory* ); Called by TKey and TObject::Clone to automatically add us to a directory; when we are read from a file. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +; example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. varexp is an expression of the general form; - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; on the y-axis versus ""e2"" on the x-axis; - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" on the x-, y-, z-axis, respectively.; - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" and ""e4"" mapped on the color number.; (to create histograms in the 2, 3, and 4 dimensional case, see section ""Savin",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:68753,Availability,error,error,68753,"ion = """"); Delete this tree from memory or/and disk. if option == ""all"" delete Tree object from memory AND from disk; all baskets on disk are deleted. All keys with same name; are deleted.; if option =="""" only Tree object in memory is deleted. void DirectoryAutoAdd(TDirectory* ); Called by TKey and TObject::Clone to automatically add us to a directory; when we are read from a file. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +; example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. varexp is an expression of the general form; - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; on the y-axis versus ""e2"" on the x-axis; - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" on the x-, y-, z-axis, respectively.; - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" and ""e4"" mapped on the color number.; (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving; the result of Draw to an histogram""). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim distribution of y versus sqrt(x); = px:py:pz:2.5*E produces a 3-d scatter-plot of px vs py ps pz; and the color number of each marker will be 2.5*E.; If the color number is negative it is set to 0.; If ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:71998,Availability,error,error,71998,"e expression may be of the form:; value*(boolean expression); if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table. The colors for e3 are evaluated once in linear scale before; painting. Therefore changing the pad to log scale along Z as no effect; on the colors.; - If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). This function returns the number of selected entries. It returns -1; if an error occurs. Drawing expressions using arrays and array elements. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equi",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:81422,Availability,avail,available,81422,"; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly suppor",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:83243,Availability,avail,available,83243,"lt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F hist",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:83643,Availability,avail,available,83643,"(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is a",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:83941,Availability,error,error,83941,"of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coor",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:84385,Availability,error,error,84385,"h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:85047,Availability,error,error,85047,"etails on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:85347,Availability,error,error,85347,"=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray"" is used, a TEntryListArray object is created; containing also the subentries satisfying the selection, i.e. the indices of; the branches which hold containers classes.; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:92115,Availability,error,error,92115,"tViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoF",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:92876,Availability,recover,recoverable,92876,"n is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the omitted name of the parent branches.; In case of ambiguity, returns the first match. TLeaf* FindLeaf(const char* name); FIXME: Describe this function. Int_t Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:94799,Availability,error,error,94799,"t_t Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Fit a projected item(s) from a tree. funcname is a TF1 function. See TTree::Draw() for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory. The function returns the number of selected entries. Example:; tree.Fit(pol4,sqrt(x)>>hsqrt,y>0); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. See also TTree::UnbinnedFit. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:95828,Availability,error,errors,95828,"tAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and return total number of bytes read. getall = 0 : get only active branches; getall = 1 : get all branches. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. If the Tree has friends, also read the friends entry. To activate/deactivate one or more b",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:96691,Availability,error,error,96691,"ile. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and return total number of bytes read. getall = 0 : get only active branches; getall = 1 : get all branches. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. If the Tree has friends, also read the friends entry. To activate/deactivate one or more branches, use TBranch::SetBranchStatus; For example, if you have a Tree with several hundred branches, and you; are interested only by branches named ""a"" and ""b"", do; mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read. WARNING!!; If your Tree has been created in split mode with a parent branch ""parent."",; mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; mytree.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative is to call directly; brancha.GetEntry(i); branchb.GetEntry(i);. IMPORTANT NOTE. By default, GetEntry reuses the space allocated by the previous obj",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:100046,Availability,avail,available,100046," TClonesArray *fTracks in the Event example). If ""->"" is not; specified, the pointer member is read via buf >> pointer. In this case; the pointer may be null. Note that the option with ""->"" is faster to; read or write and it also consumes less space in the file. OPTION 2. The option AutoDelete is set; TBranch *branch = T.GetBranch(""event"");; branch->SetAddress(&event);; branch->SetAutoDelete(kTRUE);; for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; In this case, at each iteration, the object event is deleted by GetEntry; and a new instance of Event is created and filled. OPTION 3. Same as option 1, but you delete yourself the event.; for (Long64_t i=0;i<nentries;i++) {; delete event;; event = 0; // EXTREMELY IMPORTANT; T.GetEntry(i);; // the object event has been filled at this point; }. It is strongly recommended to use the default option 1. It has the; additional advantage that functions like TTree::Draw (internally calling; TTree::GetEntry) will be functional even when the classes in the file are; not available. Note: See the comments in TBranchElement::SetAddress() for the; object ownership policy of the underlying (user) data. TEntryList* GetEntryList(); Returns the entry list, set to this tree. Long64_t GetEntryNumber(Long64_t entry) const; Return entry number corresponding to entry. if no TEntryList set returns entry; else returns the entry number corresponding to the list index=entry. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly t",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:106192,Availability,error,error,106192,"t* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton an",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:110976,Availability,error,errors,110976,"ed in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For ex",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:111053,Availability,avail,available,111053,"ed in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For ex",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:111792,Availability,avail,available,111792,"TreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:113549,Availability,avail,available,113549,"ify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the original Tree and Input file name; - Definition of selector class (data and functions); - The following class functions:; - constructor and destructor; - void Begin(TTree *tree); - void SlaveBegin(TTree *tree); - void Init(TTree *tree); - Bool_t Notify(); - Bool_t Process(Long64_t entry); - void Terminate(); - void SlaveTerminate(). The class selector derives from TSelector.; The generated code in selector.C includes empty functions defined above. To use this function:; - connect your Tree file (eg: TFile f(""myfile.root"");); - T->MakeSelector(""myselect""",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:118659,Availability,error,error,118659,"nt a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically l",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:121077,Availability,error,error,121077," with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(""h1test.C+"");; }. Long64_t Process(TSelector* selector, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the code in the specified selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The TSelector class has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If the Tree (Chain) has an associated EventList, the loop is on the nentries; of the EventList, starting at firstentry, otherwise the loop is on the; specified Tree entries. Long64_t Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depend",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:128939,Availability,recover,recover,128939,"oFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = -300000000); This function may be called at the start of a program to change; the default value for fAutoSave (and for SetAutoSave) is -300000000, ie 300 MBytes; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when the watermark is reached.; If fAutoSave is positive the watermark is reached when a multiple of fAutoSave; entries have been written.; If fAutoSave is negative the watermark is reached when -fAutoSave bytes; have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the;",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133049,Availability,error,error,133049,"the branch based on match of the branch; 'name' and not on the branch hierarchy! In order to be able to; selectively enable a top level object that is 'split' you need to make; sure the name of the top level branch is prefixed to the sub-branches'; name (by adding a dot ('.') at the end of the Branch creation and use the; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cache",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133534,Availability,error,error,133534,"activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:134209,Availability,error,error,134209,"0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tre",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:134360,Availability,error,error,134360,"f the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled agai",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:139740,Availability,error,error,139740,"ex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t StopCacheLearningPhase(); stop the cache learning phase; Returns 0 learning phase stopped or not active; -1 on error. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if y",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:141786,Availability,error,error,141786,"unc->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UseCurrentStyle(); Replace current attributes by current style. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write this object to the current directory. For more see TObject::Write; Write calls TTree::FlushBaskets before writing the tree. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see TObject::Write; If option & kFlushBasket, call FlushBasket before writing the tree. TTree(const TTree& tt). TTree& operator=(const TTree& tt). void AddTotBytes(Int_t tot); { fTotBytes += tot; }. void AddZipBytes(Int_t zip); { fZipBytes += zip; }. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"). Int_t Branch(TList* list, Int_t bufsize = 32000, Int_",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:8020,Deployability,update,update,8020,"ess(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For the",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:26355,Deployability,update,updateExisting,26355,"dSetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidSetBranchStyle(Int_t style = 1); virtual Int_tSetCacheEntryRange(Long64_t first, Long64_t last); virtual voidSetCacheLearnEntries(Int_t n = 10); virtual Int_tSetCacheSize(Long64_t cachesize = -1); virtual voidSetChainOffset(Long64_t offset = 0); virtual voidSetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidSetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidSetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* list); virtual voidSetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetMakeClass(Int_t make); virtual voidTAttMarker::SetMarkerAttrib",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:95531,Deployability,configurat,configuration,95531,"ram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and return total number of bytes read. getall = 0 : get only act",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:111196,Deployability,update,updated,111196,"keleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_method",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:125006,Deployability,update,updated,125006,"is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. char GetNewlineValue(istream& inputStream); Determine which newline this file is using.; Return '\r' for Windows '\r\n' as that already terminates. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being; updated by another process. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over tree entries and print entries passing selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::S",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:135625,Deployability,update,updateExisting,135625,"er branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in the debug range, the functions TBranchElement::Fill; and TBranchElement::GetEntry will print the number of bytes filled; or read for each branch. void SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); Update the default value for the branch's fEntryOffsetLen.; If updateExisting is true, also update all the existing branches.; If newdefault is less than 10, the new default value will be 10. void SetDirectory(TDirectory* dir); Change the tree's directory. Remove reference to this tree from current directory and; add reference to new directory dir. The dir parameter can; be 0 in which case the tree does not belong to any directory. Long64_t SetEntries(Long64_t n = -1); Change number of entries in the tree. If n >= 0, set number of entries in the tree = n. If n < 0, set number of entries in the tree to match the; number of entries in each branch. (default for n is -1). This function should be called only when one fills each branch; independently via TBranch::Fill without calling TTree::Fill.; Calling TTree::SetEntries() make sense only if the number of entries; in each branch is identical, a warning is issued otherwise.; The function returns the number of entries. void SetEn",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:135714,Deployability,update,updateExisting,135714,"having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in the debug range, the functions TBranchElement::Fill; and TBranchElement::GetEntry will print the number of bytes filled; or read for each branch. void SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); Update the default value for the branch's fEntryOffsetLen.; If updateExisting is true, also update all the existing branches.; If newdefault is less than 10, the new default value will be 10. void SetDirectory(TDirectory* dir); Change the tree's directory. Remove reference to this tree from current directory and; add reference to new directory dir. The dir parameter can; be 0 in which case the tree does not belong to any directory. Long64_t SetEntries(Long64_t n = -1); Change number of entries in the tree. If n >= 0, set number of entries in the tree = n. If n < 0, set number of entries in the tree to match the; number of entries in each branch. (default for n is -1). This function should be called only when one fills each branch; independently via TBranch::Fill without calling TTree::Fill.; Calling TTree::SetEntries() make sense only if the number of entries; in each branch is identical, a warning is issued otherwise.; The function returns the number of entries. void SetEntryList(TEntryList* list, Option_t* opt = """"); Set an EntryList. void SetEventList(TEventList* list); Th",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:135743,Deployability,update,update,135743,"having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in the debug range, the functions TBranchElement::Fill; and TBranchElement::GetEntry will print the number of bytes filled; or read for each branch. void SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); Update the default value for the branch's fEntryOffsetLen.; If updateExisting is true, also update all the existing branches.; If newdefault is less than 10, the new default value will be 10. void SetDirectory(TDirectory* dir); Change the tree's directory. Remove reference to this tree from current directory and; add reference to new directory dir. The dir parameter can; be 0 in which case the tree does not belong to any directory. Long64_t SetEntries(Long64_t n = -1); Change number of entries in the tree. If n >= 0, set number of entries in the tree = n. If n < 0, set number of entries in the tree to match the; number of entries in each branch. (default for n is -1). This function should be called only when one fills each branch; independently via TBranch::Fill without calling TTree::Fill.; Calling TTree::SetEntries() make sense only if the number of entries; in each branch is identical, a warning is issued otherwise.; The function returns the number of entries. void SetEntryList(TEntryList* list, Option_t* opt = """"); Set an EntryList. void SetEventList(TEventList* list); Th",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:5098,Energy Efficiency,allocate,allocated,5098,"each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; * if splitlevel=2 ,this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; it is processed as a TObject*, only one branch. Note: The pointer whose address is passed to TTree::Branch must not; be destroyed (i.e. go out of scope) until the TTree is deleted or; TTree::ResetBranchAddress is called. Note: The pointer p_object must be initialized before calling TTree::Branch; Do either:; MyDataClass* p_object = 0;; tree->Branch(branchname, &p_object);; Or; MyDataClass* p_object = new MyDataClass;; tree->Branch(branchname, &p_object);; Whether the pointer is set to zero or not, the ownership of the object; is not taken over by the TTree. I.e. eventhough an object will be allocated; by TTree::Branch if the pointer p_object is zero, the object will <b>not</b>; be deleted when the TTree is deleted. ==> Case C. MyClass object;; TBranch *branch = tree->Branch(branchname, &object, bufsize, splitlevel). Note: The 2nd parameter must be the address of a valid object.; The object must not be destroyed (i.e. be deleted) until the TTree; is deleted or TTree::ResetBranchAddress is called. * if splitlevel=0, the object is serialized in the branch buffer.; * if splitlevel=1 (default), this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; * if splitlevel=2 ,this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; it is processed as a TObject*, only one branch. ==> Case D. TBranch *branch = tree->Branch(branchname,c",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:34717,Energy Efficiency,allocate,allocated,34717,s explicitly given by user; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tfFlushedBytesNumber of autoflushed bytes; UInt_tfFriendLockStatus! Record which method is locking the friend recursion; TList*fFriendspointer to list of friend elements; TArrayIfIndexIndex of sorted values; TArrayDfIndexValuesSorted index values; TObjArrayfLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tfMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfMaxClusterRange! Memory allocated for the cluster range.; Long64_tfMaxEntriesMaximum number of entries in case of circular buffers; Long64_tfMaxEntryLoopMaximum number of entries to process; Long64_tfMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tfNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject id,MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:53966,Energy Efficiency,efficient,efficient,53966,"o 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes an",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:56404,Energy Efficiency,power,powerful,56404," objects. At each Tree::Fill, the branch numbers containing the; referenced objects are saved to the TBranchRef basket.; When the Tree header is saved (via TTree::Write), the branch; is saved keeping the information with the pointers to the branches; having referenced objects. TBranch* Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new TTree BranchElement. WARNING about this new function. This function is designed to replace the internal; implementation of the old TTree::Branch (whose implementation; has been moved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the address must be the address of a pointer).; For more flexibility use 'Branch'. Use Bronch only in (rare); cases (likely to be legacy cases) where both the new and old; implementation of Branch needs to be used at the same time. This function is far more powerful than the old Branch; function. It supports the full C++, including STL and has; the same behaviour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of th",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:97675,Energy Efficiency,allocate,allocated,97675," If an I/O error occurs, the function returns -1. If the Tree has friends, also read the friends entry. To activate/deactivate one or more branches, use TBranch::SetBranchStatus; For example, if you have a Tree with several hundred branches, and you; are interested only by branches named ""a"" and ""b"", do; mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read. WARNING!!; If your Tree has been created in split mode with a parent branch ""parent."",; mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; mytree.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative is to call directly; brancha.GetEntry(i); branchb.GetEntry(i);. IMPORTANT NOTE. By default, GetEntry reuses the space allocated by the previous object; for each branch. You can force the previous object to be automatically; deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Example:; Consider the example in $ROOTSYS/test/Event.h; The top level branch in the tree T is declared with:; Event *event = 0; //event must be null or point to a valid object; //it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:. OPTION 1. for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; The default (recommended). At the first entry an object of the class; Event will be created and pointed by event. At the following entries,; event will be overwritten by the new data. All internal members that are; TObject* are automatically deleted. It is important that these members; be in a valid state when GetEntry is called. Pointers must be correctly; initialized. However these internal members wil",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:111913,Energy Efficiency,efficient,efficient,111913,"chname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insur",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:112040,Energy Efficiency,efficient,efficient,112040,"). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the c",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:125585,Energy Efficiency,allocate,allocate,125585,"Stream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being; updated by another process. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over tree entries and print entries passing selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. Bool_t SetAlias(const char* aliasName, const char* aliasFormula); Set a tree variable alias. Set an alias for an expression/formula based on the tree 'variables'. The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw,; TTree::Scan, TTreeViewer) and will be evaluated as the content of; 'aliasFormula'.; If the content of 'aliasFormula' only contains symbol names, periods and; array index specification (for example event.fTracks[3]), then; the content of 'aliasName' can be used as the start of symbol. If the alia",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:65096,Integrability,rout,routines,65096,"r of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. See TTree::CloneTree for a detailed explanation of the semantics of these 3 options. If the tree or any of the underlying tree of the chain has an index, that index and any; index in the subsequent underlying TTree objects will be merged. There are currently three 'options' to control this merging:; NoIndex : all the TTreeIndex object are dropped.; DropIndexOnError : if any of the underlying TTr",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:70517,Integrability,depend,depend,70517,"sqrt(x) 2-Dim distribution of y versus sqrt(x); = px:py:pz:2.5*E produces a 3-d scatter-plot of px vs py ps pz; and the color number of each marker will be 2.5*E.; If the color number is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression that depend on the TTree's data; to static functions and you can only call non-static member function; with 'fixed' parameters. selection is an expression with a combination of the columns.; In a selection all the C++ operators are authorized.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:; value*(boolean expression); if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:83136,Integrability,interface,interface,83136,"ted results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogr",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:90910,Integrability,interface,interface,90910,"t > gr->Draw(""ap""); //draw graph in current pad; creates a TGraph object with a number of points corresponding to the; number of entries selected by the expression ""pz>4"", the x points of the graph; being the px values of the Tree and the y points the py values. Important note: By default TTree::Draw creates the arrays obtained; with GetW, GetV1, GetV2, GetV3, GetV4, GetVal with a length corresponding; to the parameter fEstimate. The content will be the last; GetSelectedRows() % GetEstimate(); values calculated.; By default fEstimate=1000000 and can be modified; via TTree::SetEstimate. To keep in memory all the results (in case; where there is only one result per entry), use; tree->SetEstimate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows; you need to look at is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:90977,Integrability,interface,interface,90977,"with a number of points corresponding to the; number of entries selected by the expression ""pz>4"", the x points of the graph; being the px values of the Tree and the y points the py values. Important note: By default TTree::Draw creates the arrays obtained; with GetW, GetV1, GetV2, GetV3, GetV4, GetVal with a length corresponding; to the parameter fEstimate. The content will be the last; GetSelectedRows() % GetEstimate(); values calculated.; By default fEstimate=1000000 and can be modified; via TTree::SetEstimate. To keep in memory all the results (in case; where there is only one result per entry), use; tree->SetEstimate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows; you need to look at is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediate",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:113442,Integrability,interface,interface,113442,"void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the original Tree and Input file name; - Definition of selector class (data and functions); - The following class functions:; - constructor and destructor; - void Begin(TTree *tree); - void SlaveBegin(TTree *tree); - void Init(TTree *tree); - Bool_t Notify(); - Bool_t Process(Long64_t entry); - void Terminate(); - void SlaveTerminate(). The class selector derives from TSelector.; The generated code in selector.C includes empty fun",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133055,Integrability,message,message,133055,"the branch based on match of the branch; 'name' and not on the branch hierarchy! In order to be able to; selectively enable a top level object that is 'split' you need to make; sure the name of the top level branch is prefixed to the sub-branches'; name (by adding a dot ('.') at the end of the Branch creation and use the; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cache",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:134273,Integrability,interface,interface,134273,"f the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled agai",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:134408,Integrability,interface,interface,134408,"lue when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in t",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:1540,Modifiability,variab,variables,1540," Branch buffers may be; automatically written to disk or kept in memory until the Tree attribute; fMaxVirtualSize is reached. Variables of one branch are written to the; same buffer. A branch buffer is automatically compressed if the file; compression attribute is set (default). Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one; object into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated b",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:1605,Modifiability,inherit,inheriting,1605,"ttribute; fMaxVirtualSize is reached. Variables of one branch are written to the; same buffer. A branch buffer is automatically compressed if the file; compression attribute is set (default). Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one; object into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned inte",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:1944,Modifiability,variab,variable,1944,"ject into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned in",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:2008,Modifiability,variab,variable,2008,"ject into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned in",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:2030,Modifiability,variab,variable,2030,"ject into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned in",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:2079,Modifiability,variab,variable,2079,"t of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tre",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:2267,Modifiability,variab,variable,2267,"hen one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other o",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:2319,Modifiability,variab,variable,2319,"hen one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other o",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:2342,Modifiability,variab,variable,2342,"tributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable (even between CINT and compiled code on the platform); ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:3042,Modifiability,variab,variable,3042,"ze); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable (even between CINT and compiled code on the platform); TTree (i.e. you will not be able to read it back on a platform with a different; padding strategy). ==> Case B. TBranch *branch = tree->Branch(branchname, &p_object, bufsize, splitlevel); TBranch *branch = tree->Branch(branchname, className, &p_object, bufsize, splitlevel); * p_object is a pointer to an object.; * If className is not specified, Branch uses the type of p_object to determine the; type of the object.; * If className is used to specify explicitly the o",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:3177,Modifiability,variab,variable,3177,"ze); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable (even between CINT and compiled code on the platform); TTree (i.e. you will not be able to read it back on a platform with a different; padding strategy). ==> Case B. TBranch *branch = tree->Branch(branchname, &p_object, bufsize, splitlevel); TBranch *branch = tree->Branch(branchname, className, &p_object, bufsize, splitlevel); * p_object is a pointer to an object.; * If className is not specified, Branch uses the type of p_object to determine the; type of the object.; * If className is used to specify explicitly the o",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:3219,Modifiability,variab,variable,3219,"ze); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable (even between CINT and compiled code on the platform); TTree (i.e. you will not be able to read it back on a platform with a different; padding strategy). ==> Case B. TBranch *branch = tree->Branch(branchname, &p_object, bufsize, splitlevel); TBranch *branch = tree->Branch(branchname, className, &p_object, bufsize, splitlevel); * p_object is a pointer to an object.; * If className is not specified, Branch uses the type of p_object to determine the; type of the object.; * If className is used to specify explicitly the o",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:3305,Modifiability,portab,portable,3305,"iable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable (even between CINT and compiled code on the platform); TTree (i.e. you will not be able to read it back on a platform with a different; padding strategy). ==> Case B. TBranch *branch = tree->Branch(branchname, &p_object, bufsize, splitlevel); TBranch *branch = tree->Branch(branchname, className, &p_object, bufsize, splitlevel); * p_object is a pointer to an object.; * If className is not specified, Branch uses the type of p_object to determine the; type of the object.; * If className is used to specify explicitly the object type, the className must; be of a type related to the one pointed to by the pointer. It should be either; a parent or derived class.; * if splitlevel=0, the object is serialized in the branch buffer.; * if splitlevel=1, this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; * if splitlevel=2 ,",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:7575,Modifiability,variab,variable,7575," std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tre",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:8737,Modifiability,extend,extend,8737," new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //____________________________________________________________",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:39349,Modifiability,variab,variable,39349,"f subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""t",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:39812,Modifiability,variab,variables,39812,"ned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:40434,Modifiability,variab,variables,40434,"ps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the mi",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:40580,Modifiability,variab,variablename,40580,"damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. An",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:40628,Modifiability,variab,variable,40628,"damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. An",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:40746,Modifiability,variab,variable,40746,"1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. And when the tree is retrieved, the trees on the friends list are; also retrieved and the friendship restored.; When a tree is deleted, the ele",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:40787,Modifiability,variab,variable,40787,"1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. And when the tree is retrieved, the trees on the friends list are; also retrieved and the friendship restored.; When a tree is deleted, the ele",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:40819,Modifiability,variab,variable,40819,"1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. And when the tree is retrieved, the trees on the friends list are; also retrieved and the friendship restored.; When a tree is deleted, the ele",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:49908,Modifiability,variab,variables,49908,"();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:49955,Modifiability,variab,variables,49955,"();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:50275,Modifiability,variab,variable,50275,"ew TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], wh",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:50339,Modifiability,variab,variable,50339,"ew TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], wh",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:50361,Modifiability,variab,variable,50361,"ew TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], wh",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:50410,Modifiability,variab,variable,50410,"= new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherw",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:50490,Modifiability,variab,variable,50490,"h(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:50542,Modifiability,variab,variable,50542,"h(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:50565,Modifiability,variab,variable,50565,"nt_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non-negative integer, then; it is used as the fixed size of the array.; If leaf name has the f",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:51393,Modifiability,variab,variable,51393,"er :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non-negative integer, then; it is used as the fixed size of the array.; If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]); where nelem and nelem2 are non-negative integer) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:69978,Modifiability,variab,variables,69978,"rsus ""e2"" on the x-axis; - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" on the x-, y-, z-axis, respectively.; - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" and ""e4"" mapped on the color number.; (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving; the result of Draw to an histogram""). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim distribution of y versus sqrt(x); = px:py:pz:2.5*E produces a 3-d scatter-plot of px vs py ps pz; and the color number of each marker will be 2.5*E.; If the color number is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression that depend on the TTree's data; to static functions and you can only call non-static member function; with 'fixed' parameters. selection is an expression with a combination of the columns.; In a selection all the C++ operators are authorized.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:73006,Modifiability,variab,variable,73006,"s. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equivalent. For variable size arrays (and TClonesArray) the range; of the first dimension is recalculated for each entry of the tree.; You can also specify the index as an expression of any other variables from the; tree. TTree::Draw also now properly handling operations involving 2 or more arrays. Let assume a second matrix fResults[5][2], here are a sample of some; of the possible combinations, the number of elements they produce and; the loop used:. expression element(s) Loop. ""fMatrix[2][1] - fResults[5][2]"" one no loop; ""fMatrix[2][] - fResults[5][2]"" three on 2nd dim fMatrix; ""fMatrix[2][] - fResults[5][]"" two on both 2nd dimensions; ""fMatrix[][2] - fResults[][1]"" three on both 1st dimensions; ""fMatrix[][2] - fResults[][]"" six on both 1st and 2nd dimensions of; fResults; ""fMatrix[][2] - fResults[3][]"" two on 1st dim of fMatrix and 2nd of; fResults (at the same time); ""fMatrix[][] - fResults[][]"" six on 1st dim then on 2nd dim. ""fMatrix[][fResult[][]]"" 30 on 1st dim of fMatrix then on both; dimensions of fResults. The value; if fResults[j][k] is used ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:73186,Modifiability,variab,variables,73186,"TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equivalent. For variable size arrays (and TClonesArray) the range; of the first dimension is recalculated for each entry of the tree.; You can also specify the index as an expression of any other variables from the; tree. TTree::Draw also now properly handling operations involving 2 or more arrays. Let assume a second matrix fResults[5][2], here are a sample of some; of the possible combinations, the number of elements they produce and; the loop used:. expression element(s) Loop. ""fMatrix[2][1] - fResults[5][2]"" one no loop; ""fMatrix[2][] - fResults[5][2]"" three on 2nd dim fMatrix; ""fMatrix[2][] - fResults[5][]"" two on both 2nd dimensions; ""fMatrix[][2] - fResults[][1]"" three on both 1st dimensions; ""fMatrix[][2] - fResults[][]"" six on both 1st and 2nd dimensions of; fResults; ""fMatrix[][2] - fResults[3][]"" two on 1st dim of fMatrix and 2nd of; fResults (at the same time); ""fMatrix[][] - fResults[][]"" six on 1st dim then on 2nd dim. ""fMatrix[][fResult[][]]"" 30 on 1st dim of fMatrix then on both; dimensions of fResults. The value; if fResults[j][k] is used as the second; index of fMatrix. In summary, TTree::Draw loops through all unspecified dimensions. To; fi",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:74475,Modifiability,variab,variable,74475," one no loop; ""fMatrix[2][] - fResults[5][2]"" three on 2nd dim fMatrix; ""fMatrix[2][] - fResults[5][]"" two on both 2nd dimensions; ""fMatrix[][2] - fResults[][1]"" three on both 1st dimensions; ""fMatrix[][2] - fResults[][]"" six on both 1st and 2nd dimensions of; fResults; ""fMatrix[][2] - fResults[3][]"" two on 1st dim of fMatrix and 2nd of; fResults (at the same time); ""fMatrix[][] - fResults[][]"" six on 1st dim then on 2nd dim. ""fMatrix[][fResult[][]]"" 30 on 1st dim of fMatrix then on both; dimensions of fResults. The value; if fResults[j][k] is used as the second; index of fMatrix. In summary, TTree::Draw loops through all unspecified dimensions. To; figure out the range of each loop, we match each unspecified dimension; from left to right (ignoring ALL dimensions for which an index has been; specified), in the equivalent loop matched dimensions use the same index; and are restricted to the smallest range (of only the matched dimensions).; When involving variable arrays, the range can of course be different; for each entry of the tree. So the loop equivalent to ""fMatrix[][2] - fResults[3][]"" is:. for (Int_t i0; i < min(3,2); i++) {; use the value of (fMatrix[i0][2] - fMatrix[3][i0]); }. So the loop equivalent to ""fMatrix[][2] - fResults[][]"" is:. for (Int_t i0; i < min(3,5); i++) {; for (Int_t i1; i1 < 2; i1++) {; use the value of (fMatrix[i0][2] - fMatrix[i0][i1]); }; }. So the loop equivalent to ""fMatrix[][] - fResults[][]"" is:. for (Int_t i0; i < min(3,5); i++) {; for (Int_t i1; i1 < min(3,2); i1++) {; use the value of (fMatrix[i0][i1] - fMatrix[i0][i1]); }; }. So the loop equivalent to ""fMatrix[][fResults[][]]"" is:. for (Int_t i0; i0 < 3; i0++) {; for (Int_t j2; j2 < 5; j2++) {; for (Int_t j3; j3 < 2; j3++) {; i1 = fResults[j2][j3];; use the value of fMatrix[i0][i1]; }; }. Retrieving the result of Draw. By default the temporary histogram created is called ""htemp"", but only in; the one dimensional Draw(""e1"") it contains the TTree's data points. For; a two dimension",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:76168,Modifiability,variab,variable,76168,"+) {; for (Int_t j3; j3 < 2; j3++) {; i1 = fResults[j2][j3];; use the value of fMatrix[i0][i1]; }; }. Retrieving the result of Draw. By default the temporary histogram created is called ""htemp"", but only in; the one dimensional Draw(""e1"") it contains the TTree's data points. For; a two dimensional Draw, the data is filled into a TGraph which is named; ""Graph"". They can be retrieved by calling; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp""); // 1D; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D. For a three and four dimensional Draw the TPolyMarker3D is unnamed, and; cannot be retrieved. gPad always contains a TH1 derived object called ""htemp"" which allows to; access the axes:; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D; TH2F *htemp = (TH2F*)gPad->GetPrimitive(""htemp""); // empty, but has axes; TAxis *xaxis = htemp->GetXaxis();. Saving the result of Draw to an histogram. If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory (and also the current pad). This works for all dimensions.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. To retrieve it do:; TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");. The binning information is taken from the environment variables. Hist.Binning.?D.?. In addition, the name of the histogram can be followed by up to 9; numbers between '(' and ')', where the numbers describe the; following:. 1 - bins in x-direction; 2 - lower limit in x-direction; 3 - upper limit in x-direction; 4-6 same for y-direction; 7-9 same for z-direction. When a new binning is used the new value will become the default.; Values can be skipped.; Example:; tree.Draw(""sqrt(x)>>hsqrt(500,10,20)""); // plot sqrt(x) between 10 and 20 using 500 bins; tree.Draw(""sqrt(x):sin(y)>>hsqrt(100,10,60,50,.1,.5)""); // plot sqrt(x) against sin(y); // 100 bins in x-direction; lower limit on x",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:76578,Modifiability,variab,variables,76578," is named; ""Graph"". They can be retrieved by calling; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp""); // 1D; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D. For a three and four dimensional Draw the TPolyMarker3D is unnamed, and; cannot be retrieved. gPad always contains a TH1 derived object called ""htemp"" which allows to; access the axes:; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D; TH2F *htemp = (TH2F*)gPad->GetPrimitive(""htemp""); // empty, but has axes; TAxis *xaxis = htemp->GetXaxis();. Saving the result of Draw to an histogram. If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory (and also the current pad). This works for all dimensions.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. To retrieve it do:; TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");. The binning information is taken from the environment variables. Hist.Binning.?D.?. In addition, the name of the histogram can be followed by up to 9; numbers between '(' and ')', where the numbers describe the; following:. 1 - bins in x-direction; 2 - lower limit in x-direction; 3 - upper limit in x-direction; 4-6 same for y-direction; 7-9 same for z-direction. When a new binning is used the new value will become the default.; Values can be skipped.; Example:; tree.Draw(""sqrt(x)>>hsqrt(500,10,20)""); // plot sqrt(x) between 10 and 20 using 500 bins; tree.Draw(""sqrt(x):sin(y)>>hsqrt(100,10,60,50,.1,.5)""); // plot sqrt(x) against sin(y); // 100 bins in x-direction; lower limit on x-axis is 10; upper limit is 60; // 50 bins in y-direction; lower limit on y-axis is .1; upper limit is .5. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name.; A '+' in front of the histogram name is ignored, when the name is followed by; binning informat",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:78304,Modifiability,variab,variable,78304,"inue to append data to an existing histogram, use ""+"" in front; of the histogram name.; A '+' in front of the histogram name is ignored, when the name is followed by; binning information as described in the previous paragraph.; tree.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling.; This works for 1-D, 2-D and 3-D histograms. Accessing collection objects. TTree::Draw default's handling of collections is to assume that any; request on a collection pertain to it content. For example, if fTracks; is a collection of Track objects, the following:; tree->Draw(""event.fTracks.fPx"");; will plot the value of fPx for each Track objects inside the collection.; Also; tree->Draw(""event.fTracks.size()"");; would plot the result of the member function Track::size() for each; Track object inside the collection.; To access information about the collection itself, TTree::Draw support; the '@' notation. If a variable which points to a collection is prefixed; or postfixed with '@', the next part of the expression will pertain to; the collection object. For example:; tree->Draw(""event.@fTracks.size()"");; will plot the size of the collection referred to by fTracks (i.e the number; of Track objects). Drawing 'objects'. When a class has a member function named AsDouble or AsString, requesting; to directly draw the object will imply a call to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit; that are turned on. Retrieving information about the tree itself. You can refer to the tree (or chain) containing the d",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:79675,Modifiability,variab,variables,79675,"r AsString, requesting; to directly draw the object will imply a call to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit; that are turned on. Retrieving information about the tree itself. You can refer to the tree (or chain) containing the data by using the; string 'This'.; You can then could any TTree methods. For example:; tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read.; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables. Entry$: A TTree::Draw formula can use the special variable Entry$; to access the entry number being read. For example to draw every; other entry use:; tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a; chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); Length$ : return the total number of element of this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the min",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:79736,Modifiability,variab,variable,79736,"to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit; that are turned on. Retrieving information about the tree itself. You can refer to the tree (or chain) containing the data by using the; string 'This'.; You can then could any TTree methods. For example:; tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read.; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables. Entry$: A TTree::Draw formula can use the special variable Entry$; to access the entry number being read. For example to draw every; other entry use:; tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a; chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); Length$ : return the total number of element of this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the fo",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:81645,Modifiability,variab,variable,81645,"he formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In par",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:82910,Modifiability,variab,variable,82910,"ill draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:84651,Modifiability,variab,variables,84651,"le). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one varia",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:84964,Modifiability,variab,variables,84964,"etails on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:85264,Modifiability,variab,variables,85264,"=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray"" is used, a TEntryListArray object is created; containing also the subentries satisfying the selection, i.e. the indices of; the branches which hold containers classes.; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:85646,Modifiability,variab,variable,85646,"using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray"" is used, a TEntryListArray object is created; containing also the subentries satisfying the selection, i.e. the indices of; the branches which hold containers classes.; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive session, one can type (after TTree::Draw); yplus.Print(""all""); to print the list of entry numbers in the list.; tree.Draw("">>yplus"", ""y>0"", ""entrylist""); will create a TEntryList object names ""yplus"" in the current directory; tree.Draw("">>yplus"", ""y>0"", ""entrylistarray""); will create a TEntryListA",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:95531,Modifiability,config,configuration,95531,"ram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and return total number of bytes read. getall = 0 : get only act",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:109055,Modifiability,variab,variables,109055,"ated by this function.; In a ROOT session, you can do:; root > .L MyClass.C; root > MyClass* t = new MyClass;; root > t->GetEntry(12); // Fill data members of t with entry number 12.; root > t->Show(); // Show values of entry 12.; root > t->Show(16); // Read and show values of entry 16.; root > t->Loop(); // Loop on all entries. NOTE: Do not use the code generated for a single TTree which is part; of a TChain to process that entire TChain. The maximum dimensions; calculated for arrays on the basis of a single TTree from the TChain; might be (will be!) too small when processing all of the TTrees in; the TChain. You must use myChain.MakeClass() to generate the code,; not myTree.MakeClass(...). Int_t MakeCode(const char* filename = 0); Generate a skeleton function for this tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name,; - Opening the Tree file,; - Declaration of Tree variables,; - Setting of branches addresses,; - A skeleton for the entry loop. To use this function:; - Open your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""MyAnalysis.C"");; where T is the name of the TTree in file myfile.root; and MyAnalysis.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy. TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:111811,Modifiability,variab,variables,111811,"TreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:111885,Modifiability,variab,variable,111885,"chname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insur",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:113015,Modifiability,variab,variable,113015," if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:116854,Modifiability,variab,variables,116854," Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". see TTree::Draw for explanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:116942,Modifiability,variab,variables,116942," Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". see TTree::Draw for explanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:122937,Modifiability,variab,variable,122937,"00000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:123016,Modifiability,variab,variable,123016,"00000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:123069,Modifiability,variab,variable,123069,"00000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:123105,Modifiability,variab,variables,123105,"jection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTre",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:123153,Modifiability,variab,variables,123153,"jection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTre",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:123655,Modifiability,variab,variables,123655," or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. char GetNewlineValue(istream& inputStream); Determine which newline this file is using.; Return '\r' for Windows '\r\n' as that already terminates. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:124009,Modifiability,variab,variable,124009,"of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. char GetNewlineValue(istream& inputStream); Determine which newline this file is using.; Return '\r' for Windows '\r\n' as that already terminates. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:126093,Modifiability,variab,variable,126093," Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over tree entries and print entries passing selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. Bool_t SetAlias(const char* aliasName, const char* aliasFormula); Set a tree variable alias. Set an alias for an expression/formula based on the tree 'variables'. The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw,; TTree::Scan, TTreeViewer) and will be evaluated as the content of; 'aliasFormula'.; If the content of 'aliasFormula' only contains symbol names, periods and; array index specification (for example event.fTracks[3]), then; the content of 'aliasName' can be used as the start of symbol. If the alias 'aliasName' already existed, it is replaced by the new; value. When being used, the alias can be preceded by an eventual 'Friend Alias'; (see TTree::GetFriendAlias). Return true if it was added properly. For example:; tree->SetAlias(""x1"",""(tdc1[1]-tdc1[0])/49"");; tree->SetAlias(""y1"",""(tdc1[3]-tdc1[2])/47"");; tree->SetAlias(""x2"",""(tdc2[1]-tdc2[0])/49"");; tree->SetAlias(""y2"",""(tdc2[3]-tdc2[2])/47"");; tree->Draw(""y2-y1:x2-x1"");. tree->SetAlias(""theGoodTrack"",""event.fTracks[3]"");; tree->Draw(""theGoodTrack.fPx",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:126167,Modifiability,variab,variables,126167,"t baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over tree entries and print entries passing selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. Bool_t SetAlias(const char* aliasName, const char* aliasFormula); Set a tree variable alias. Set an alias for an expression/formula based on the tree 'variables'. The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw,; TTree::Scan, TTreeViewer) and will be evaluated as the content of; 'aliasFormula'.; If the content of 'aliasFormula' only contains symbol names, periods and; array index specification (for example event.fTracks[3]), then; the content of 'aliasName' can be used as the start of symbol. If the alias 'aliasName' already existed, it is replaced by the new; value. When being used, the alias can be preceded by an eventual 'Friend Alias'; (see TTree::GetFriendAlias). Return true if it was added properly. For example:; tree->SetAlias(""x1"",""(tdc1[1]-tdc1[0])/49"");; tree->SetAlias(""y1"",""(tdc1[3]-tdc1[2])/47"");; tree->SetAlias(""x2"",""(tdc2[1]-tdc2[0])/49"");; tree->SetAlias(""y2"",""(tdc2[3]-tdc2[2])/47"");; tree->Draw(""y2-y1:x2-x1"");. tree->SetAlias(""theGoodTrack"",""event.fTracks[3]"");; tree->Draw(""theGoodTrack.fPx""); // same as ""event.fTracks[3].fPx"". void SetAutoFlush(Long64_t autof = -300000",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:131005,Modifiability,variab,variables,131005," and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. void SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); Set branch status to Process or DoNotProcess. When reading a Tree, by default, all branches are read.; One can speed up considerably the analysis phase by activating; only the branches that hold variables involved in a query. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; status = 1 branch will be processed; = 0 branch will not be processed; Example:; Assume a tree T with sub-branches a,b,c,d,e,f,g,etc..; when doing T.GetEntry(i) all branches are read for entry i.; to read only the branches c and e, one can do; T.SetBranchStatus(""*"",0); //disable all branches; T.SetBranchStatus(""c"",1);; T.setBranchStatus(""e"",1);; T.GetEntry(i);. bname is interpreted as a wildcarded TRegexp (see TRegexp::MakeWildcard).; Thus, ""a*b"" or ""a.*b"" matches branches starting with ""a"" and ending with; ""b"", but not any other branch with an ""a"" followed at some point by a; ""b"". For this second behavior, use ""*a*b*"". Note that TRegExp does not; support '|', and so you cannot select, e.g. track and shower branches; with ""track|shower"". WARNING! WARNI",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:137032,Modifiability,variab,variable,137032,"r. The dir parameter can; be 0 in which case the tree does not belong to any directory. Long64_t SetEntries(Long64_t n = -1); Change number of entries in the tree. If n >= 0, set number of entries in the tree = n. If n < 0, set number of entries in the tree to match the; number of entries in each branch. (default for n is -1). This function should be called only when one fills each branch; independently via TBranch::Fill without calling TTree::Fill.; Calling TTree::SetEntries() make sense only if the number of entries; in each branch is identical, a warning is issued otherwise.; The function returns the number of entries. void SetEntryList(TEntryList* list, Option_t* opt = """"); Set an EntryList. void SetEventList(TEventList* list); This function transfroms the given TEventList into a TEntryList; The new TEntryList is owned by the TTree and gets deleted when the tree; is deleted. This TEntryList can be returned by GetEntryList() function. void SetEstimate(Long64_t nentries = 1000000); Set number of entries to estimate variable limits.; If n is -1, the estimate is set to be the current maximum; for the tree (i.e. GetEntries() + 1); If n is less than -1, the behavior is undefined. void SetFileNumber(Int_t number = 0); Set fFileNumber to number.; fFileNumber is used by TTree::Fill to set the file name; for a new file to be created when the current file exceeds fgTreeMaxSize.; (see TTree::ChangeFile); if fFileNumber=10, the new file name will have a suffix ""_11"",; ie, fFileNumber is incremented before setting the file name. void SetMakeClass(Int_t make); Set all the branches in this TTree to be in decomposed object mode; (also known as MakeClass mode). void SetMaxTreeSize(Long64_t maxsize = 1900000000); Set the maximum size in bytes of a Tree file (static function).; The default size is 100000000000LL, ie 100 Gigabytes. In TTree::Fill, when the file has a size > fgMaxTreeSize,; the function closes the current file and starts writing into; a new file with a name of the st",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:139993,Modifiability,variab,variable,139993,"the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t StopCacheLearningPhase(); stop the cache learning phase; Returns 0 learning phase stopped or not active; -1 on error. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:140112,Modifiability,variab,variable,140112,"all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t StopCacheLearningPhase(); stop the cache learning phase; Returns 0 learning phase stopped or not active; -1 on error. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectiv",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:141221,Modifiability,variab,variable,141221,"ptions is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UseCurrentStyle(); Replace current attributes by current style. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write this object to the current directory. For more see TObject::Write; Write calls TTree::FlushB",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:9001,Performance,perform,performance,9001,"o copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:26095,Performance,cache,cachesize,26095," = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Bool_tSetAlias(const char* aliasName, const char* aliasFormula); virtual voidSetAutoFlush(Long64_t autof = -30000000); virtual voidSetAutoSave(Long64_t autos = -300000000); virtual voidSetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidSetBranchStyle(Int_t style = 1); virtual Int_tSetCacheEntryRange(Long64_t first, Long64_t last); virtual voidSetCacheLearnEntries(Int_t n = 10); virtual Int_tSetCacheSize(Long64_t cachesize = -1); virtual voidSetChainOffset(Long64_t offset = 0); virtual voidSetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidSetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidSetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* list); virtual voidSetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:30944,Performance,cache,cacheSize,30944,"ry = 0); virtual voidUseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAddClone(TTree*); virtual TBranch*BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tCheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tGetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*GetLeafImpl(const char* branchname, const char* leafname); charGetNewlineValue(istream& inputStream); TTreeCache*GetReadCache(TFile* file, Bool_t create = kFALSE); voidImportClusterRanges(TTree* fromtree); virtual voidKeepCircular(); voidTObject::MakeZombie(); voidMoveReadCache(TFile* src, TDirectory* dir); Int_tSetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Int_tSetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TTree&operator=(const TTree& tt); TTree(const TTree& tt). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TTree::(anonymous)kCircular; static TTree::ESetBr",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:32925,Performance,cache,cache,32925,lectionProxy; static TObject::EStatusBitsTObject::kMustCleanup; static TTree::ESetBranchAddressStatuskNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatuskVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*fAliasesList of aliases for expressions based on the tree branches.; Long64_tfAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tfAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*fBranchRefBranch supporting the TRefTable (if any); TObjArrayfBranchesList of Branches; Bool_tfCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tfCacheSize! Maximum size of file buffers; Bool_tfCacheUserSet! true if the cache setting was explicitly given by user; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if f,MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:33055,Performance,cache,cache,33055,lectionProxy; static TObject::EStatusBitsTObject::kMustCleanup; static TTree::ESetBranchAddressStatuskNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatuskVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*fAliasesList of aliases for expressions based on the tree branches.; Long64_tfAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tfAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*fBranchRefBranch supporting the TRefTable (if any); TObjArrayfBranchesList of Branches; Bool_tfCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tfCacheSize! Maximum size of file buffers; Bool_tfCacheUserSet! true if the cache setting was explicitly given by user; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if f,MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:35160,Performance,load,loading,35160,dex values; TObjArrayfLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tfMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfMaxClusterRange! Memory allocated for the cluster range.; Long64_tfMaxEntriesMaximum number of entries in case of circular buffers; Long64_tfMaxEntryLoopMaximum number of entries to process; Long64_tfMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tfNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tfNfill! Local for EntryLoop; TObject*fNotify! Object to be notified when loading a Tree; Int_tfPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*fPlayer! Pointer to current Tree player; Long64_tfReadEntry! Number of the entry being processed; Long64_tfSavedBytesNumber of autosaved bytes; Int_tfScanFieldNumber of runs before prompting in Scan; Int_tfTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all branches before compression; Long64_tfTotalBuffers! Total number of bytes in branch buffers; TBuffer*fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*fTreeIndexPointer to the tree Index (if any); Int_tfUpdateUpdate frequency for EntryLoop; TList*fUserInfopointer to a list of user objects associated to this Tree; Double_tfWeightTree weight (see TTree::SetWeight); Long64_tfZipBytesTotal number of bytes in all branches after compression; static Int_tfgBranchStyleOld/New branch style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree; static TTree::ELockStatusBitskFindBranch;,MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:37688,Performance,cache,cache,37688,"ee::ELockStatusBitskLoadTree; static TTree::ELockStatusBitskPrint; static TTree::ELockStatusBitskRemoveFriend; static TTree::ELockStatusBitskSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:37739,Performance,cache,cache,37739,"ckStatusBitskRemoveFriend; static TTree::ELockStatusBitskSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:37827,Performance,cache,cache,37827,"us. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:37987,Performance,cache,cache,37987," do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:38075,Performance,cache,cache,38075," Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:38265,Performance,cache,cache,38265," the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFri",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:38320,Performance,cache,cache,38320," creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:38414,Performance,cache,cache,38414," may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:38457,Performance,cache,cache,38457," TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:38584,Performance,cache,cache,38584," by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. I",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:38678,Performance,cache,cache,38678," = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. T",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:38721,Performance,cache,cache,38721," branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The t",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:63737,Performance,optimiz,optimize,63737,"; effect. When this tree is deleted, all the addresses of; the cloned tree are reset to their default values. If 'option' contains the word 'fast' and nentries is -1, the; cloning will be done without unzipping or unstreaming the baskets; (i.e., a direct copy of the raw bytes on disk). When 'fast' is specified, 'option' can also contain a sorting; order for the baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in the; output file in the same order as in the original file (i.e. the; baskets are sorted by their offset in the original file; Usually; this also means that the baskets are sorted by the index/number of; the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each individual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:63933,Performance,perform,performance,63933,"word 'fast' and nentries is -1, the; cloning will be done without unzipping or unstreaming the baskets; (i.e., a direct copy of the raw bytes on disk). When 'fast' is specified, 'option' can also contain a sorting; order for the baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in the; output file in the same order as in the original file (i.e. the; baskets are sorted by their offset in the original file; Usually; this also means that the baskets are sorted by the index/number of; the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each individual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree fro",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:82700,Performance,load,load,82700,"Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy fo",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:83453,Performance,load,loading,83453,"(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is a",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:87534,Performance,load,loaded,87534,"e.Draw("">>yplus"", ""y>0"", ""entrylistarray""); will create a TEntryListArray object names ""yplus"" in the current directory. By default, the specified entry list is reset.; To continue to append data to an existing list, use ""+"" in front; of the list name;; tree.Draw("">>+yplus"",""y>0""); will not reset yplus, but will enter the selected entries at the end; of the existing list. Using a TEventList, TEntryList or TEntryListArray as Input. Once a TEventList or a TEntryList object has been generated, it can be used as input; for TTree::Draw. Use TTree::SetEventList or TTree::SetEntryList to set the; current event list; Example1:; TEventList *elist = (TEventList*)gDirectory->Get(""yplus"");; tree->SetEventList(elist);; tree->Draw(""py"");; Example2:; TEntryList *elist = (TEntryList*)gDirectory->Get(""yplus"");; tree->SetEntryList(elist);; tree->Draw(""py"");; If a TEventList object is used as input, a new TEntryList object is created; inside the SetEventList function. In case of a TChain, all tree headers are loaded; for this transformation. This new object is owned by the chain and is deleted; with it, unless the user extracts it by calling GetEntryList() function.; See also comments to SetEventList() function of TTree and TChain. If arrays are used in the selection criteria and TEntryListArray is not used,; all the entries that have at least one element of the array that satisfy the selection; are entered in the list.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of ALL tracks in event with at least one track with; a positive fPy. To select only the elements that did match the original selection; use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(kTRUE);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy. To draw only the elements that match a selection in ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:92691,Performance,optimiz,optimize,92691," to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the omitted name of the parent branches.; In cas",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:95417,Performance,cache,cache,95417,"ave the histogram as ""hsqrt"" in the current; directory. See also TTree::UnbinnedFit. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:95464,Performance,cache,cache,95464," Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:95493,Performance,cache,cache,95493,"ram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and return total number of bytes read. getall = 0 : get only act",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:100865,Performance,perform,performs,100865,"MPORTANT; T.GetEntry(i);; // the object event has been filled at this point; }. It is strongly recommended to use the default option 1. It has the; additional advantage that functions like TTree::Draw (internally calling; TTree::GetEntry) will be functional even when the classes in the file are; not available. Note: See the comments in TBranchElement::SetAddress() for the; object ownership policy of the underlying (user) data. TEntryList* GetEntryList(); Returns the entry list, set to this tree. Long64_t GetEntryNumber(Long64_t entry) const; Return entry number corresponding to entry. if no TEntryList set returns entry; else returns the entry number corresponding to the list index=entry. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediately lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pa",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:101684,Performance,perform,performs,101684," and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediately lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table, otherwise it returns -1. See also GetEntryNumberWithBestIndex. Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); Read entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TTree* GetFriend(const char* ) const; Return a pointer to the TTree friend whose name or alias is 'friendname. const char* GetFriendAlias(TTree* ) const; If the 'tree' is a friend, this method returns its alias name. This alias is an alternate name for the tree. It can be used in conjunction with a branch or leaf ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:105118,Performance,cache,cache,105118,"he form; TDirectoryName/TreeName. TLeaf* GetLeaf(const char* name); Return pointer to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. aname may be of the form branchname/leafname. Double_t GetMaximum(const char* columname); Return maximum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the maximum; is computed for the entries in this list. Long64_t GetMaxTreeSize(); Static function which returns the tree file size limit in bytes. Double_t GetMinimum(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TTreeCache * GetReadCache(TFile* file, Bool_t create = kFALSE); Find and return the TTreeCache registered with the file and which may; contain branches for us. If create is true and there is no cache; a new cache is created with default size. TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function re",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:105131,Performance,cache,cache,105131,"he form; TDirectoryName/TreeName. TLeaf* GetLeaf(const char* name); Return pointer to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. aname may be of the form branchname/leafname. Double_t GetMaximum(const char* columname); Return maximum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the maximum; is computed for the entries in this list. Long64_t GetMaxTreeSize(); Static function which returns the tree file size limit in bytes. Double_t GetMinimum(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TTreeCache * GetReadCache(TFile* file, Bool_t create = kFALSE); Find and return the TTreeCache registered with the file and which may; contain branches for us. If create is true and there is no cache; a new cache is created with default size. TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function re",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:106213,Performance,load,loading,106213,"t* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton an",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:110852,Performance,load,loading,110852,"ed in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For ex",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:111928,Performance,cache,cache,111928,"chname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insur",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:112963,Performance,load,loaded,112963,"fficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameo",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:113107,Performance,load,loaded,113107,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the original Tree and Input file name; - Definition of selector class (data and functions); - The following class functions:; - construc",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:115723,Performance,cache,cache,115723,"u can do:; root > T->Process(""myselect.C""). Bool_t MemoryFull(Int_t nbytes); Check if adding nbytes to memory we are still below MaxVirtualsize. TTree* MergeTrees(TList* list, Option_t* option = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Lon",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:115855,Performance,cache,cache,115855,"memory we are still below MaxVirtualsize. TTree* MergeTrees(TList* list, Option_t* option = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPri",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:115911,Performance,load,loading,115911,"tion = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipa",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:116226,Performance,optimiz,optimize,116226,"* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" a",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:118336,Performance,cache,cache,118336,"xplanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): cal",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:118412,Performance,cache,cache,118412,"ncipal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:118740,Performance,load,loaded,118740,"hes are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more intere",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:119573,Performance,load,loaded,119573,"this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; };",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:119668,Performance,load,loaded,119668,"se of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""st",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:119779,Performance,load,loaded,119779,"low),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coa",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:128014,Performance,optimiz,optimize,128014,"e->Draw(""theGoodTrack.fPx""); // same as ""event.fTracks[3].fPx"". void SetAutoFlush(Long64_t autof = -30000000); This function may be called at the start of a program to change; the default value for fAutoFlush. CASE 1 : autof > 0. autof is the number of consecutive entries after which TTree::Fill will; flush all branch buffers to disk. CASE 2 : autof < 0. When filling the Tree the branch buffers will be flushed to disk when; more than autof bytes have been written to the file. At the first FlushBaskets; TTree::Fill will replace fAutoFlush by the current value of fEntries. Calling this function with autof<0 is interesting when it is hard to estimate; the size of one entry. This value is also independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = -300000000); This function may be called at the start of a program to change; the default value for fAutoSave (and for SetAutoSave) is -300000000, ie 300 MBytes; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when the watermark is reached.; If fAutoSave is positive the watermark is reached when a multiple of fAutoSave; entries have been written.; If fAutoSave is negative the watermark is reached when -fAutoSave bytes; have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133255,Performance,cache,cachesize,133255,"e (by adding a dot ('.') at the end of the Branch creation and use the; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t l",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133301,Performance,cache,cache,133301,"e (by adding a dot ('.') at the end of the Branch creation and use the; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t l",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133313,Performance,cache,cachesize,133313,"; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133340,Performance,cache,cache,133340,"; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133371,Performance,cache,cachesize,133371,"t branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133497,Performance,cache,cache,133497,"activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133598,Performance,cache,cacheSize,133598,"e trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntrie",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133639,Performance,cache,cache,133639,"e trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntrie",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133722,Performance,cache,cache,133722,"nches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133773,Performance,cache,cache,133773,"nches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133824,Performance,cache,cacheSize,133824," T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in onli",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133836,Performance,cache,cacheSize,133836," T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in onli",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133855,Performance,cache,cache,133855," T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in onli",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133872,Performance,cache,cache,133872," T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in onli",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133899,Performance,cache,cacheSize,133899," T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in onli",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:133935,Performance,cache,cache,133935," T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in onli",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:134003,Performance,cache,cache,134003,"ound matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCir",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:134010,Performance,cache,cacheSize,134010,"ned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before;",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:134040,Performance,cache,cache,134040,"ned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before;",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:134053,Performance,cache,cache,134053,"branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:134142,Performance,cache,cache,134142," Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is auto",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:134171,Performance,cache,cache,134171,"0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tre",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:134308,Performance,cache,cache,134308,"f the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled agai",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:139664,Performance,cache,cache,139664,"ex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t StopCacheLearningPhase(); stop the cache learning phase; Returns 0 learning phase stopped or not active; -1 on error. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if y",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:144561,Performance,perform,performance,144561,"urn fDebugMin; }. TDirectory * GetDirectory() const; { return fDirectory; }. Long64_t GetEntries() const; { return fEntries; }. Long64_t GetEntriesFast() const; { return fEntries; }. Long64_t GetEstimate() const; { return fEstimate; }. Int_t GetEvent(Long64_t entry = 0, Int_t getall = 0); { return GetEntry(entry, getall); }. TEventList * GetEventList() const; { return fEventList; }. Int_t GetFileNumber() const; { return fFileNumber; }. TH1 * GetHistogram(); { return GetPlayer()->GetHistogram(); }. Int_t * GetIndex(); { return &fIndex.fArray[0]; }. Double_t * GetIndexValues(); { return &fIndexValues.fArray[0]; }. TList * GetListOfClones(); { return fClones; }. TObjArray * GetListOfBranches(); { return &fBranches; }. TObjArray * GetListOfLeaves(); { return &fLeaves; }. TList * GetListOfFriends() const; { return fFriends; }. TList * GetListOfAliases() const; { return fAliases; }. Int_t GetMakeClass() const; GetMakeClass is left non-virtual for efficiency reason.; Making it virtual affects the performance of the I/O. { return fMakeClass; }. Long64_t GetMaxEntryLoop() const; { return fMaxEntryLoop; }. Long64_t GetMaxVirtualSize() const; { return fMaxVirtualSize; }. Int_t GetNbranches(); { return fBranches.GetEntriesFast(); }. TObject * GetNotify() const; { return fNotify; }. Int_t GetPacketSize() const; { return fPacketSize; }. TVirtualPerfStats * GetPerfStats() const; { return fPerfStats; }. Long64_t GetReadEntry() const; { return fReadEntry; }. Long64_t GetReadEvent() const; { return fReadEntry; }. Int_t GetScanField() const; { return fScanField; }. TTreeFormula * GetSelect(); { return GetPlayer()->GetSelect(); }. Long64_t GetSelectedRows(); { return GetPlayer()->GetSelectedRows(); }. Int_t GetTimerInterval() const; { return fTimerInterval; }. Long64_t GetTotBytes() const; { return fTotBytes; }. TTree * GetTree() const; { return const_cast<TTree*>(this); }. TVirtualIndex * GetTreeIndex() const; { return fTreeIndex; }. Int_t GetTreeNumber() const; { return 0; }. Int_t Ge",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:8597,Safety,risk,risk,8597,"tain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:9942,Safety,detect,detector,9942,"tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; TH2F *hpxpy = new TH2F(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile *hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);. // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //-----------",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:39614,Safety,risk,risk,39614," cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the var",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:42771,Safety,safe,safe,42771,"f the friend list are also deleted.; It is possible to declare a friend tree that has the same internal; structure (same branches and leaves) as the original tree, and compare the; same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.var""). TFriendElement* AddFriend(const char* treename, TFile* file); Add a TFriendElement to the list of friends. The TFile is managed by the user (e.g. the user must delete the file).; For complete description see AddFriend(const char *, const char *).; This function:; -reads a Tree with name treename from the file; -adds the Tree to the list of friends. TFriendElement* AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); Add a TFriendElement to the list of friends. The TTree is managed by the user (e.g., the user must delete the file).; For a complete description see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE m",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:43720,Safety,recover,recovered,43720,"ve tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The follo",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:43796,Safety,recover,recovered,43796,"e branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- scri",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:44383,Safety,safe,safer,44383,"g; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else nt",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:45944,Safety,detect,detection,45944," *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collecti",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:46182,Safety,detect,detection,46182,"andom,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collection, the entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:46417,Safety,detect,detection,46417,"raw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collection, the entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch is created for each element; of the TObjArray.; - if splitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each elemen",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:47890,Safety,avoid,avoid,47890,"entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch is created for each element; of the TObjArray.; - if splitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". And in general in any cases two or more master branches contain subbranches; with identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *lis",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:81159,Safety,avoid,avoid,81159,"rrent iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:A",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:81277,Safety,avoid,avoid,81277,"rrent iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:A",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:92876,Safety,recover,recoverable,92876,"n is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the omitted name of the parent branches.; In case of ambiguity, returns the first match. TLeaf* FindLeaf(const char* name); FIXME: Describe this function. Int_t Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:128939,Safety,recover,recover,128939,"oFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = -300000000); This function may be called at the start of a program to change; the default value for fAutoSave (and for SetAutoSave) is -300000000, ie 300 MBytes; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when the watermark is reached.; If fAutoSave is positive the watermark is reached when a multiple of fAutoSave; entries have been written.; If fAutoSave is negative the watermark is reached when -fAutoSave bytes; have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the;",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:6269,Security,access,access,6269,"ee->Branch(branchname, &object, bufsize, splitlevel). Note: The 2nd parameter must be the address of a valid object.; The object must not be destroyed (i.e. be deleted) until the TTree; is deleted or TTree::ResetBranchAddress is called. * if splitlevel=0, the object is serialized in the branch buffer.; * if splitlevel=1 (default), this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; * if splitlevel=2 ,this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; it is processed as a TObject*, only one branch. ==> Case D. TBranch *branch = tree->Branch(branchname,clonesarray, bufsize, splitlevel); clonesarray is the address of a pointer to a TClonesArray.; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defi",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:39504,Security,access,access,39504," DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:39798,Security,access,access,39798,"ned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:41003,Security,access,access,41003,"ically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. And when the tree is retrieved, the trees on the friends list are; also retrieved and the friendship restored.; When a tree is deleted, the elements of the friend list are also deleted.; It is possible to declare a friend tree that has the same internal; structure (same branches and leaves) as the original tree, and compare the; same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.v",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:52375,Security,access,access,52375,"n; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non-negative integer, then; it is used as the fixed size of the array.; If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]); where nelem and nelem2 are non-negative integer) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new branch with the object of class classname at address addobj. WARNING:; Starting with Root version 3.01, the Branch function uses the new style; branches (TBranchElement). To get the old behaviour, you can:; - call BranchOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can n",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:53776,Security,access,access,53776,"chOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:55177,Security,access,access,55177," different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each Tree::Fill, the branch numbers containing the; referenced objects are saved to the TBranchRef basket.; When the Tree header is saved (via TTree::Write), the branch; is saved keeping the information with the pointers to the branches; having referenced objects. TBranch* Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new TTree BranchElement. WARNING about this new function. This function is designed to replace the internal; implementation of the old TTree::Branch (whose implementation; has been moved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:56976,Security,access,access,56976,"oved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the address must be the address of a pointer).; For more flexibility use 'Branch'. Use Bronch only in (rare); cases (likely to be legacy cases) where both the new and old; implementation of Branch needs to be used at the same time. This function is far more powerful than the old Branch; function. It supports the full C++, including STL and has; the same behaviour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer siz",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:58255,Security,access,access,58255," different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. void Browse(TBrowser* ); Browse content of the TTree. Int_t BuildIndex(const char* majorname, const char* minorname = ""0""); Build a Tree Index (default is TTreeIndex).; See a description of the parameters and functionality in; TTreeIndex::TTreeIndex(). The return value is the number of entries in the Index (< 0 indicates failure). A TTreeIndex object pointed by fTreeIndex is created.; This object will be automatically deleted by the TTree destructor.; See also comments in TT",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:70744,Security,authoriz,authorized,70744," number is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression that depend on the TTree's data; to static functions and you can only call non-static member function; with 'fixed' parameters. selection is an expression with a combination of the columns.; In a selection all the C++ operators are authorized.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:; value*(boolean expression); if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table. The colors for e3 are evaluated once in linear scale before; painting. Therefore changing the pad to log scale along Z as no effect; on",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:72202,Security,access,access,72202,"rt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table. The colors for e3 are evaluated once in linear scale before; painting. Therefore changing the pad to log scale along Z as no effect; on the colors.; - If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). This function returns the number of selected entries. It returns -1; if an error occurs. Drawing expressions using arrays and array elements. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equivalent. For variable size arrays (and TClonesArray) the range; of the first dimension is recalculated for each entry of the tree.; You can also specify the index as an expression of any other variables from the",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:75895,Security,access,access,75895,"][]"" is:. for (Int_t i0; i < min(3,5); i++) {; for (Int_t i1; i1 < min(3,2); i1++) {; use the value of (fMatrix[i0][i1] - fMatrix[i0][i1]); }; }. So the loop equivalent to ""fMatrix[][fResults[][]]"" is:. for (Int_t i0; i0 < 3; i0++) {; for (Int_t j2; j2 < 5; j2++) {; for (Int_t j3; j3 < 2; j3++) {; i1 = fResults[j2][j3];; use the value of fMatrix[i0][i1]; }; }. Retrieving the result of Draw. By default the temporary histogram created is called ""htemp"", but only in; the one dimensional Draw(""e1"") it contains the TTree's data points. For; a two dimensional Draw, the data is filled into a TGraph which is named; ""Graph"". They can be retrieved by calling; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp""); // 1D; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D. For a three and four dimensional Draw the TPolyMarker3D is unnamed, and; cannot be retrieved. gPad always contains a TH1 derived object called ""htemp"" which allows to; access the axes:; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D; TH2F *htemp = (TH2F*)gPad->GetPrimitive(""htemp""); // empty, but has axes; TAxis *xaxis = htemp->GetXaxis();. Saving the result of Draw to an histogram. If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory (and also the current pad). This works for all dimensions.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. To retrieve it do:; TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");. The binning information is taken from the environment variables. Hist.Binning.?D.?. In addition, the name of the histogram can be followed by up to 9; numbers between '(' and ')', where the numbers describe the; following:. 1 - bins in x-direction; 2 - lower limit in x-direction; 3 - upper limit in x-direction; 4-6 same for y-direction; 7-9 same for z-direction. When a new binning is used the new value will become the defau",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:78212,Security,access,access,78212,"ns in y-direction; lower limit on y-axis is .1; upper limit is .5. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name.; A '+' in front of the histogram name is ignored, when the name is followed by; binning information as described in the previous paragraph.; tree.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling.; This works for 1-D, 2-D and 3-D histograms. Accessing collection objects. TTree::Draw default's handling of collections is to assume that any; request on a collection pertain to it content. For example, if fTracks; is a collection of Track objects, the following:; tree->Draw(""event.fTracks.fPx"");; will plot the value of fPx for each Track objects inside the collection.; Also; tree->Draw(""event.fTracks.size()"");; would plot the result of the member function Track::size() for each; Track object inside the collection.; To access information about the collection itself, TTree::Draw support; the '@' notation. If a variable which points to a collection is prefixed; or postfixed with '@', the next part of the expression will pertain to; the collection object. For example:; tree->Draw(""event.@fTracks.size()"");; will plot the size of the collection referred to by fTracks (i.e the number; of Track objects). Drawing 'objects'. When a class has a member function named AsDouble or AsString, requesting; to directly draw the object will imply a call to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:79756,Security,access,access,79756,"to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit; that are turned on. Retrieving information about the tree itself. You can refer to the tree (or chain) containing the data by using the; string 'This'.; You can then could any TTree methods. For example:; tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read.; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables. Entry$: A TTree::Draw formula can use the special variable Entry$; to access the entry number being read. For example to draw every; other entry use:; tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a; chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); Length$ : return the total number of element of this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the fo",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:82594,Security,access,accessing,82594,"[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the b",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:89018,Security,access,access,89018," ALL tracks in event with at least one track with; a positive fPy. To select only the elements that did match the original selection; use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(kTRUE);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy. To draw only the elements that match a selection in case of arrays,; you can also use TEntryListArray (faster in case of a more general selection).; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"", ""entrylistarray"");; tree->SetEntryList(pyplus);; tree->Draw(""fTracks.fPy"");. will draw the fPy of only the tracks that have a positive fPy,; but without redoing the selection. Note: Use tree->SetEventList(0) if you do not want use the list as input. How to obtain more info from TTree::Draw. Once TTree::Draw has been called, it is possible to access useful; information still stored in the TTree object via the following functions:; -GetSelectedRows() //return the number of values accepted by the; //selection expression. In case where no selection; //was specified, returns the number of values processed.; -GetV1() //returns a pointer to the double array of V1; -GetV2() //returns a pointer to the double array of V2; -GetV3() //returns a pointer to the double array of V3; -GetV4() //returns a pointer to the double array of V4; -GetW() //returns a pointer to the double array of Weights; //where weight equal the result of the selection expression.; where V1,V2,V3 correspond to the expressions in; TTree::Draw(""V1:V2:V3:V4"",selection);; If the expression has more than 4 component use GetVal(index). Example:; Root > ntuple->Draw(""py:px"",""pz>4"");; Root > TGraph *gr = new TGraph(ntuple->GetSelectedRows(),; ntuple->GetV2(), ntuple->GetV1());; Root > gr->Draw(""ap""); //draw graph in current pad; creates a TGraph object with a number of points corresponding to the; number of entries selected by the e",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:106309,Security,access,access,106309,"ly created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classnam",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:106358,Security,access,access,106358," this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classname will be called ""nameoftree"". The generated code in classname.h includes the following:; - Identification ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:109764,Security,access,access,109764,"e = 0); Generate a skeleton function for this tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name,; - Opening the Tree file,; - Declaration of Tree variables,; - Setting of branches addresses,; - A skeleton for the entry loop. To use this function:; - Open your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""MyAnalysis.C"");; where T is the name of the TTree in file myfile.root; and MyAnalysis.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy. TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:110725,Security,access,access,110725,"enting an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are ru",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:112996,Security,access,accessible,112996," if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:113193,Security,access,access,113193,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the original Tree and Input file name; - Definition of selector class (data and functions); - The following class functions:; - construc",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:43478,Testability,test,tests,43478," (e.g., the user must delete the file).; For a complete description see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:44853,Testability,test,test,44853,"last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, ",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:45222,Testability,test,test,45222," new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.;",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:48870,Testability,test,test,48870,"ions to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". And in general in any cases two or more master branches contain subbranches; with identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *list = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support no",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:64475,Testability,test,test,64475,"ets are sorted by their offset in the original file; Usually; this also means that the baskets are sorted by the index/number of; the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each individual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:64696,Testability,test,test,64696,"vidual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:67216,Testability,test,test,67216,"sIsIndexOnError [default]: In case of missing TTreeIndex, the resulting TTree index has gaps.; BuildIndexOnError : If any of the underlying TTree objects do not have a TTreeIndex,; all TTreeIndex are 'ignored' and the missing piece are rebuilt. TTree* CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Copy a tree with selection. IMPORTANT:. The returned copied tree stays connected with the original tree; until the original tree is deleted. In particular, any changes; to the branch addresses in the original tree are also made to; the copied tree. Any changes made to the branch addresses of the; copied tree are overridden anytime the original tree changes its; branch addresses. When the original tree is deleted, all the; branch addresses of the copied tree are set to zero. For examples of CopyTree, see the tutorials:. copytree. Example macro to copy a subset of a tree to a new tree. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree2. Example macro to copy a subset of a tree to a new tree. One branch of the new tree is written to a separate file. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree3. Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree.; NOTE that only the active branches are copied. TBasket* CreateBasket(TBranch* ); Create a basket for this tree and given branch. void Delete(Option_t* option = """"); Delete this tree from memory or/and disk. if option == ""all"" delete Tree object from memory AND from disk; all baskets on disk are deleted. All keys with same name; are deleted.; if option =="""" only Tree object in memory is deleted. void DirectoryAutoAdd(TDirectory* ); Called by TKey and TObject::Clone to automatically add us to a directory; when we are read from a file. Long64_t Draw(const char* varexp, const TC",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:67451,Testability,test,test,67451," rebuilt. TTree* CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Copy a tree with selection. IMPORTANT:. The returned copied tree stays connected with the original tree; until the original tree is deleted. In particular, any changes; to the branch addresses in the original tree are also made to; the copied tree. Any changes made to the branch addresses of the; copied tree are overridden anytime the original tree changes its; branch addresses. When the original tree is deleted, all the; branch addresses of the copied tree are set to zero. For examples of CopyTree, see the tutorials:. copytree. Example macro to copy a subset of a tree to a new tree. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree2. Example macro to copy a subset of a tree to a new tree. One branch of the new tree is written to a separate file. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree3. Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree.; NOTE that only the active branches are copied. TBasket* CreateBasket(TBranch* ); Create a basket for this tree and given branch. void Delete(Option_t* option = """"); Delete this tree from memory or/and disk. if option == ""all"" delete Tree object from memory AND from disk; all baskets on disk are deleted. All keys with same name; are deleted.; if option =="""" only Tree object in memory is deleted. void DirectoryAutoAdd(TDirectory* ); Called by TKey and TObject::Clone to automatically add us to a directory; when we are read from a file. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. This function a",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:71694,Testability,log,log,71694,"; In a selection all the C++ operators are authorized.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:; value*(boolean expression); if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table. The colors for e3 are evaluated once in linear scale before; painting. Therefore changing the pad to log scale along Z as no effect; on the colors.; - If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). This function returns the number of selected entries. It returns -1; if an error occurs. Drawing expressions using arrays and array elements. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:97896,Testability,test,test,97896,"have a Tree with several hundred branches, and you; are interested only by branches named ""a"" and ""b"", do; mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read. WARNING!!; If your Tree has been created in split mode with a parent branch ""parent."",; mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; mytree.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative is to call directly; brancha.GetEntry(i); branchb.GetEntry(i);. IMPORTANT NOTE. By default, GetEntry reuses the space allocated by the previous object; for each branch. You can force the previous object to be automatically; deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Example:; Consider the example in $ROOTSYS/test/Event.h; The top level branch in the tree T is declared with:; Event *event = 0; //event must be null or point to a valid object; //it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:. OPTION 1. for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; The default (recommended). At the first entry an object of the class; Event will be created and pointed by event. At the following entries,; event will be overwritten by the new data. All internal members that are; TObject* are automatically deleted. It is important that these members; be in a valid state when GetEntry is called. Pointers must be correctly; initialized. However these internal members will not be deleted if the; characters ""->"" are specified as the first characters in the comment; field of the data member declaration. If ""->"" is specified, the pointer member is read via pointer->Str",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:1511,Usability,simpl,simple,1511," Branch buffers may be; automatically written to disk or kept in memory until the Tree attribute; fMaxVirtualSize is reached. Variables of one branch are written to the; same buffer. A branch buffer is automatically compressed if the file; compression attribute is set (default). Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one; object into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated b",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:7364,Usability,simpl,simple,7364,"ate one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; A",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:7428,Usability,simpl,simple,7428,"ate one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; A",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:7788,Usability,simpl,simple,7788,"ction will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:9182,Usability,simpl,simple,9182,"ong64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",10",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:10397,Usability,simpl,simple,10397,"-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; TH2F *hpxpy = new TH2F(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile *hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);. // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //--------------------Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->::Rndm(1);. // Fill histograms; hpx->Fill(px);; hpxpy->Fill(px,py,1);; hprof->Fill(px,pz,1);. // Fill structures; p[0] = px;; p[1] = py;; p[2] = pz;; point.x = 10*(random-1);;; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;. // Fill the tree. For each event, save the 2 s",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:11523,Usability,simpl,simple,11523,"} EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //--------------------Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->::Rndm(1);. // Fill histograms; hpx->Fill(px);; hpxpy->Fill(px,py,1);; hprof->Fill(px,pz,1);. // Fill structures; p[0] = px;; p[1] = py;; p[2] = pz;; point.x = 10*(random-1);;; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;. // Fill the tree. For each event, save the 2 structures and 3 objects; // In this simple example, the objects hpx, hprof and hpxpy are slightly; // different from event to event. We expect a big compression factor!; tree->Fill();; }; //--------------End of the loop. tree->Print();. // Save all objects in this file; hfile.Write();. // Close the file. Note that this is automatically done when you leave; // the application.; hfile.Close();. return 0;; }. Function Members (Methods); public:. virtual~TTree(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tAddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*AddFriend(const char* treename, TFile* file); virtual TFriendElement*AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidAddTotBytes(Int_t tot); virtual voidAddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtu",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:14516,Usability,undo,undo,14516,">(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tBuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tCopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*CreateBasket(TBranch*); Int_tDebug() const; virtual voidDelete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:48319,Usability,simpl,simply,48319,"ill be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". And in general in any cases two or more master branches contain subbranches; with identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *list = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = n",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:49947,Usability,simpl,simple,49947,"();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:54431,Usability,simpl,simply,54431,"dobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each T",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:57509,Usability,simpl,simply,57509,"iour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if t",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:64766,Usability,undo,undo,64766," number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. See TTree::CloneTree for a detailed explanat",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:64837,Usability,undo,undo,64837,"ad of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. See TTree::CloneTree for a detailed explanation of the semantics of these 3 options. If the tree or any of the underlying tree of",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:69437,Usability,simpl,simplest,69437,"uple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. varexp is an expression of the general form; - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; on the y-axis versus ""e2"" on the x-axis; - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" on the x-, y-, z-axis, respectively.; - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" and ""e4"" mapped on the color number.; (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving; the result of Draw to an histogram""). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim distribution of y versus sqrt(x); = px:py:pz:2.5*E produces a 3-d scatter-plot of px vs py ps pz; and the color number of each marker will be 2.5*E.; If the color number is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression th",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:91589,Usability,simpl,simple,91589,"imate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows; you need to look at is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first c",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:91610,Usability,simpl,simple,91610,"imate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows; you need to look at is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first c",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:122635,Usability,simpl,simply,122635,"te(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If the Tree (Chain) has an associated EventList, the loop is on the nentries; of the EventList, starting at firstentry, otherwise the loop is on the; specified Tree entries. Long64_t Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the valu",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:124625,Usability,simpl,simply,124625,"the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. char GetNewlineValue(istream& inputStream); Determine which newline this file is using.; Return '\r' for Windows '\r\n' as that already terminates. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being; updated by another process. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and alloca",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:134469,Usability,learn,learning,134469,"lue when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in t",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:139670,Usability,learn,learning,139670,"ex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t StopCacheLearningPhase(); stop the cache learning phase; Returns 0 learning phase stopped or not active; -1 on error. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if y",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTree.html:139696,Usability,learn,learning,139696,"ex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t StopCacheLearningPhase(); stop the cache learning phase; Returns 0 learning phase stopped or not active; -1 on error. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if y",MatchSource.WIKI,root/html604/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTree.html
https://root.cern/root/html604/TTreeCache.html:10770,Availability,error,error,10770," TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tDropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*GetCachedBranches() const; TTreeCache::EPrefillTypeGetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEfficiency() const; Double_tGetEfficiencyRel() const; virtual Int_tGetEntryMax() const; virtual Int_tGetEntryMin() const; TFile*TFileCacheRead::GetFile() const; virtual const char*TObject::GetIconName() const; static Int_tGetLearnEntries(); virtual T",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:10854,Availability,error,error,10854,":Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tDropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*GetCachedBranches() const; TTreeCache::EPrefillTypeGetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEfficiency() const; Double_tGetEfficiencyRel() const; virtual Int_tGetEntryMax() const; virtual Int_tGetEntryMin() const; TFile*TFileCacheRead::GetFile() const; virtual const char*TObject::GetIconName() const; static Int_tGetLearnEntries(); virtual TTreeCache::EPrefillTypeGetLearnPrefill() const; virtual const char*TObject::GetName(",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:22305,Availability,error,error,22305," buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:22904,Availability,error,error,22904," TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEff",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:23133,Availability,error,error,23133,", Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the proc",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:23733,Availability,error,error,23733,"r expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficien",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25591,Availability,failure,failure,25591,"fficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must b",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:26033,Availability,avail,available,26033,"tal size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavi",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:26116,Availability,error,error,26116,"tal size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavi",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:4072,Deployability,configurat,configurations,4072," take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches t",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:4520,Integrability,interface,interface,4520," the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+""",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:116,Modifiability,inherit,inheritance,116,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the '",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:1520,Modifiability,variab,variable,1520,"rs) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand br",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:3987,Modifiability,variab,variable,3987," with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Proces",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:4072,Modifiability,config,configurations,4072," take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches t",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:4248,Modifiability,layers,layers,4248,"fer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:27055,Modifiability,variab,variable,27055,"ll of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillTy",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:409,Performance,cache,cache,409,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the '",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:669,Performance,cache,cache,669,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the '",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:702,Performance,perform,performance,702,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the '",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:776,Performance,latency,latency,776,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the '",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:805,Performance,cache,cache,805,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the '",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:949,Performance,cache,cache,949,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the '",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:1212,Performance,cache,cache,1212,"class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new fil",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:1378,Performance,cache,cache,1378,"ead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:1468,Performance,cache,cache,1468,"utomatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:1620,Performance,cache,cache,1620,"ged via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:2139,Performance,cache,cached,2139,"s done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers f",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:2581,Performance,perform,performance,2581,"eCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maxi",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:2825,Performance,perform,performance,2825,"ent. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:2905,Performance,latency,latency,2905,"ent. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:2954,Performance,latency,latency,2954,"ange is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:3011,Performance,cache,cache,3011,"ange is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:3686,Performance,cache,cache,3686,"ys written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the ex",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:3825,Performance,cache,cache,3825,"g; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branche",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:4565,Performance,cache,cache,4565," the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+""",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:4930,Performance,cache,cache,4930,"ee is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to proc",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:5041,Performance,cache,cache,5041,"configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:5085,Performance,cache,cache,5085,"configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:5263,Performance,cache,cache,5263,"ions the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",ne",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:5399,Performance,cache,cachesize,5399,"nches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ...",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:5450,Performance,cache,cachesize,5450,"nches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ...",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:5531,Performance,cache,cache,5531,"nches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ...",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:5814,Performance,cache,cache,5814,"lly. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:5988,Performance,cache,cachesize,5988,"lly. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:6117,Performance,cache,cachesize,6117,"lly. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:6792,Performance,cache,cachesize,6792,"last = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->StopCacheLearningPhase(); //<<<; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:6843,Performance,cache,cachesize,6843,"last = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->StopCacheLearningPhase(); //<<<; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:6929,Performance,cache,cache,6929,"last = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->StopCacheLearningPhase(); //<<<; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:7886,Performance,cache,cachesize,7886,"important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you c",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:7937,Performance,cache,cachesize,7937,"important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you c",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:8376,Performance,cache,cache,8376,"(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBran",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:8944,Performance,cache,cache,8944,"nt_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); v",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:9012,Performance,perform,performance,9012,"<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:17917,Performance,cache,cache,17917,,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:18521,Performance,cache,cache,18521,,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:18586,Performance,cache,cache,18586,,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:18948,Performance,cache,cache,18948,ool_tTFileCacheRead::fBIsSorted; Bool_tTFileCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen[fBNb]; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos[fBNb]; Long64_t*TFileCacheRead::fBSeek[fBNseek]; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains somethi,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:19152,Performance,cache,cache,19152,ileCacheRead::fBPos[fBNb]; Long64_t*TFileCacheRead::fBSeek[fBNseek]; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPr,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:19170,Performance,cache,cached,19170,s[fBNb]; Long64_t*TFileCacheRead::fBSeek[fBNseek]; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks ,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:19244,Performance,cache,cache,19244,BSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:19288,Performance,cache,cache,19288,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cach,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:19333,Performance,cache,cache,19333,ekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadN,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:19384,Performance,cache,cache,19384,ng64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; ,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:19730,Performance,cache,cache,19730,BufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPr,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:19782,Performance,cache,cache,19782,ed size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:20135,Performance,cache,cache,20135,e of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:20287,Performance,cache,cache,20287,e of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:20374,Performance,cache,cached,20374,e of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:20464,Performance,cache,cached,20464,e of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:21034,Performance,cache,cache,21034,"adNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypefPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:22201,Performance,cache,cache,22201," buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:22435,Performance,cache,cache,22435,"ition of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you;",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:22816,Performance,cache,cache,22816," TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEff",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:23030,Performance,cache,cache,23030,"0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more t",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:23120,Performance,cache,cache,23120,", Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the proc",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:23267,Performance,cache,cache,23267,"h::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a r",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:23647,Performance,cache,cache,23647,"r expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficien",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:23720,Performance,cache,cache,23720,"r expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficien",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:23770,Performance,cache,cache,23770,"f bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:23808,Performance,cache,cache,23808,"f bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:23880,Performance,cache,cache,23880,"ed; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:23934,Performance,cache,cache,23934,"t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:24038,Performance,cache,cache,24038,"ion is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cac",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:24274,Performance,cache,cache,24274,"this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:24402,Performance,cache,cache,24402," same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at p",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:24477,Performance,cache,cache,24477,"regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:24582,Performance,cache,cache,24582,"reeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Ret",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:24967,Performance,cache,cache,24967,"number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a c",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25044,Performance,cache,cache,25044,"re; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 i",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25114,Performance,cache,cachedbranches,25114,"uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntr",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25159,Performance,cache,cached,25159,"uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntr",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25480,Performance,cache,cache,25480,"*TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static functi",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25618,Performance,cache,cache,25618,"fficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must b",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25646,Performance,cache,cache,25646,"fficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must b",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25752,Performance,cache,cache,25752,"00; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a p",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25839,Performance,cache,cache,25839,"ons; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25880,Performance,cache,cache,25880,"tal size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavi",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25948,Performance,cache,cache,25948,"tal size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavi",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:26257,Performance,optimiz,optimize,26257,"nt_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned befo",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:26750,Performance,cache,cache,26750,"r. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void Le",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:26916,Performance,cache,cache,26916,"s some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:27207,Performance,cache,cache,27207,"mber to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLea",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:27690,Performance,cache,cache,27690,"TreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated() const; {return fAutoCreated;}. Bool_t IsEnabled() const; {return fEnabled;}. Bool_t IsLearning() const; {return fIsLearning;}. void SetAutoCreated(Bool_t val); {fAutoCreated = val;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last genera",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:4300,Safety,predict,predict,4300,"fer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:5241,Safety,risk,risk,5241,"ions the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",ne",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:747,Security,access,accessed,747,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the '",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:9073,Security,access,access,9073,"or (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; vir",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:549,Usability,learn,learning,549,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the '",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:570,Usability,learn,learning,570,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the '",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:1389,Usability,learn,learning,1389,"utomatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:1749,Usability,learn,learning,1749," latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be writ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:1859,Usability,learn,learning,1859,"quested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:2001,Usability,learn,learning,2001,"ed when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:2036,Usability,learn,learning,2036,"ed when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:4489,Usability,learn,learning,4489," in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheS",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:19742,Usability,learn,learning,19742,Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:20626,Usability,learn,learning,20626,e of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:21782,Usability,learn,learning,21782,"adNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypefPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:22830,Usability,learn,learning,22830," TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEff",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:23661,Usability,learn,learning,23661,"r expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch added or already included; -1 on error. Int_t DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficien",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25735,Usability,simpl,simply,25735,"00; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a p",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:25742,Usability,clear,clear,25742,"00; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a p",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:26553,Usability,learn,learning,26553,"recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will cr",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:26697,Usability,learn,learning,26697,"r. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void Le",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:27240,Usability,learn,learning,27240,"mber to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLea",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:27359,Usability,learn,learning,27359,"the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCache.html:27781,Usability,learn,learning,27781,"ch type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated() const; {return fAutoCreated;}. Bool_t IsEnabled() const; {return fEnabled;}. Bool_t IsLearning() const; {return fIsLearning;}. void SetAutoCreated(Bool_t val); {fAutoCreated = val;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root/html604/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCache.html
https://root.cern/root/html604/TTreeCacheUnzip.html:2696,Availability,error,error,2696,"ssName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTTreeCache::Disable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tTTreeCache::DropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tTTreeCache::DropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidTTreeCache::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*TTreeCache::GetCachedBranches() const; TTreeCache::EPrefillTypeTTreeCache::GetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTTreeCache::GetEfficiency() const; Double_tTTreeCache::GetEfficiencyRel() const; virtual Int_tTTreeCache::GetEntryMax() const; virtual Int_tTTreeCache::GetEntryMin() const; TFile*TFileCacheRead::GetFile() const; virtual const cha",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:2780,Availability,error,error,2780,":Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTTreeCache::Disable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tTTreeCache::DropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tTTreeCache::DropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidTTreeCache::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*TTreeCache::GetCachedBranches() const; TTreeCache::EPrefillTypeTTreeCache::GetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTTreeCache::GetEfficiency() const; Double_tTTreeCache::GetEfficiencyRel() const; virtual Int_tTTreeCache::GetEntryMax() const; virtual Int_tTTreeCache::GetEntryMin() const; TFile*TFileCacheRead::GetFile() const; virtual const char*TObject::GetIconName() const; static Int_tTTreeCache::GetLearnEntries(); virtual T",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:17378,Availability,error,error,17378,"o signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer t",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:17612,Availability,error,error,17612,"eeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is a",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:17769,Availability,avail,available,17769,"←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:17852,Availability,error,error,17852,"←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:19551,Availability,error,error,19551,"y important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nb",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21740,Availability,failure,failure,21740," must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of th",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:22613,Availability,error,error,22613,"_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This fun",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23603,Availability,error,error,23603,"fer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods related to the thread. Int_t GetNUnzip(); Methods to get stats. { return fNUnzip; }. Int_t GetNFound(); { return fNFound; }. Int_t GetNMissed(); { return fNMissed; }. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:34; This pa",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:18255,Deployability,update,update,18255,"; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional t",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21093,Energy Efficiency,adapt,adapted,21093,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21986,Energy Efficiency,allocate,allocate,21986,"he arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all t",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:22651,Energy Efficiency,allocate,allocate,22651,"_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This fun",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23295,Energy Efficiency,allocate,allocate,23295,"nd also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:619,Integrability,synchroniz,synchronized,619,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidT",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:121,Modifiability,inherit,inheritance,121,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidT",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:18531,Modifiability,variab,variable,18531,"ranch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:19974,Modifiability,variab,variable,19974,"ssing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical reco",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21093,Modifiability,adapt,adapted,21093,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:917,Performance,latency,latency,917,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidT",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:1041,Performance,cache,cache,1041,"OOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = ",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:10982,Performance,queue,queue,10982,,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:11199,Performance,cache,cache,11199,,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:11833,Performance,cache,cache,11833,,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:11910,Performance,cache,cache,11910,,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12272,Performance,cache,cache,12272,leCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen[fBNb]; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos[fBNb]; Long64_t*TFileCacheRead::fBSeek[fBNseek]; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache i,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12501,Performance,cache,cache,12501,; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12519,Performance,cache,cached,12519,Read::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; T,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12605,Performance,cache,cache,12605,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12661,Performance,cache,cache,12661,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12718,Performance,cache,cache,12718,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12781,Performance,cache,cache,12781,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:13204,Performance,cache,cache,13204,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:13268,Performance,cache,cache,13268,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:13652,Performance,cache,cache,13652,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:13718,Performance,cache,cache,13718,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:13885,Performance,cache,cache,13885,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:14164,Performance,cache,cache,14164,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:14251,Performance,cache,cached,14251,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:14341,Performance,cache,cached,14341,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:15086,Performance,cache,cache,15086,"ax size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:17274,Performance,cache,cache,17274,"o signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer t",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:17508,Performance,cache,cache,17508,"eeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is a",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:17720,Performance,cache,cache,17720,"ivate:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty()",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:17993,Performance,optimiz,optimize,17993,"it(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; whe",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:18332,Performance,cache,cache,18332,"; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional t",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:18700,Performance,queue,queue,18700,"e underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits fo",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:18937,Performance,queue,queue,18937,"Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:19702,Performance,queue,queue,19702,"CacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must ",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:20206,Performance,queue,queue,20206,"ding unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void Res",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:20453,Performance,cache,cache,20453," _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is co",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21224,Performance,cache,cache,21224,"ueue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets th",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21268,Performance,cache,cache,21268,"ueue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets th",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21341,Performance,cache,cache,21341,"aving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the p",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21776,Performance,cache,cache,21776," must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of th",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21808,Performance,cache,cache,21808," must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of th",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:22368,Performance,cache,cache,22368,"the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:22440,Performance,cache,cache,22440,"ompletely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the tra",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23028,Performance,cache,cache,23028,"0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers ar",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23153,Performance,cache,cache,23153,"(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCac",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23194,Performance,cache,cache,23194,"(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCac",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23313,Performance,cache,cache,23313,"nd also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23380,Performance,cache,cache,23380,"times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods related to the thread. Int_t GetNUnzip(); Methods to get stats. { return fNUnzip; }. Int_t GetNFound(); { return fNFound; }. Int_t GetNMisse",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:19239,Safety,detect,detection,19239,"the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the que",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:20593,Testability,log,logical,20593,"therwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about ",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:20976,Testability,log,logical,20976,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:13216,Usability,learn,learning,13216,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:14582,Usability,learn,learning,14582,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:16476,Usability,learn,learning,16476,"on of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCloner.html:2208,Availability,error,error,2208,"ngs; static TTreeCloner::EClonerOptionskNone. private:. UInt_t*fBasketBranchNum[fMaxBaskets] Index of the branch(es) of the basket.; Long64_t*fBasketEntry[fMaxBaskets] list of basket start entries.; UInt_t*fBasketIndex[fMaxBaskets] ordered list of basket indices to be written.; UInt_t*fBasketNum[fMaxBaskets] index of the basket within the branch.; Long64_t*fBasketSeek[fMaxBaskets] list of basket position to be read.; UInt_tfCloneMethodIndicates which cloning method was selected.; TObjArrayfFromBranches; TTree*fFromTree; Bool_tfIsValid; UInt_tfMaxBaskets; Option_t*fMethod; Bool_tfNeedConversionTrue if the fast merge is not possible but a slow merge might possible.; UInt_tfOptions; UShort_tfPidOffsetOffset to be added to the copied key/basket.; TObjArrayfToBranches; Long64_tfToStartEntriesNumber of entries in the target tree before any addition.; TTree*fToTree; TStringfWarningMsgText of the error message lead to an 'invalid' state; static TTreeCloner::ECloneMethodkDefault; static TTreeCloner::ECloneMethodkSortBasketsByBranch; static TTreeCloner::ECloneMethodkSortBasketsByEntry; static TTreeCloner::ECloneMethodkSortBasketsByOffset. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCloner(TTree* from, TTree* to, Option_t* method, UInt_t options = kNone); Constructor. This object would transfer the data from; 'from' to 'to' using the method indicated in method. The value of the parameter 'method' determines in which; order the branches' baskets are written to the output file. When a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file i",MatchSource.WIKI,root/html604/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCloner.html
https://root.cern/root/html604/TTreeCloner.html:2214,Integrability,message,message,2214,"ngs; static TTreeCloner::EClonerOptionskNone. private:. UInt_t*fBasketBranchNum[fMaxBaskets] Index of the branch(es) of the basket.; Long64_t*fBasketEntry[fMaxBaskets] list of basket start entries.; UInt_t*fBasketIndex[fMaxBaskets] ordered list of basket indices to be written.; UInt_t*fBasketNum[fMaxBaskets] index of the basket within the branch.; Long64_t*fBasketSeek[fMaxBaskets] list of basket position to be read.; UInt_tfCloneMethodIndicates which cloning method was selected.; TObjArrayfFromBranches; TTree*fFromTree; Bool_tfIsValid; UInt_tfMaxBaskets; Option_t*fMethod; Bool_tfNeedConversionTrue if the fast merge is not possible but a slow merge might possible.; UInt_tfOptions; UShort_tfPidOffsetOffset to be added to the copied key/basket.; TObjArrayfToBranches; Long64_tfToStartEntriesNumber of entries in the target tree before any addition.; TTree*fToTree; TStringfWarningMsgText of the error message lead to an 'invalid' state; static TTreeCloner::ECloneMethodkDefault; static TTreeCloner::ECloneMethodkSortBasketsByBranch; static TTreeCloner::ECloneMethodkSortBasketsByEntry; static TTreeCloner::ECloneMethodkSortBasketsByOffset. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCloner(TTree* from, TTree* to, Option_t* method, UInt_t options = kNone); Constructor. This object would transfer the data from; 'from' to 'to' using the method indicated in method. The value of the parameter 'method' determines in which; order the branches' baskets are written to the output file. When a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file i",MatchSource.WIKI,root/html604/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCloner.html
https://root.cern/root/html604/TTreeCloner.html:3640,Performance,optimiz,optimize,3640,"cated in method. The value of the parameter 'method' determines in which; order the branches' baskets are written to the output file. When a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. Bool_t Exec(); Execute the cloning. ~TTreeCloner(); TTreeCloner destructor. void CloseOutWriteBaskets(); Before we can start adding new basket, we need to flush to; disk the partially filled baskets (the WriteBasket). UInt_t CollectBranches(TBranch* from, TBranch* to); Fill the array of branches, adding the branch 'from' and 'to',; and matching the sub-branches of the 'from' and 'to' branches.; Returns the total number of baskets in all the from branch and; it sub-branches. UInt_t CollectBranches(TOb",MatchSource.WIKI,root/html604/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCloner.html
https://root.cern/root/html604/TTreeCloner.html:3836,Performance,perform,performance,3836,"en a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. Bool_t Exec(); Execute the cloning. ~TTreeCloner(); TTreeCloner destructor. void CloseOutWriteBaskets(); Before we can start adding new basket, we need to flush to; disk the partially filled baskets (the WriteBasket). UInt_t CollectBranches(TBranch* from, TBranch* to); Fill the array of branches, adding the branch 'from' and 'to',; and matching the sub-branches of the 'from' and 'to' branches.; Returns the total number of baskets in all the from branch and; it sub-branches. UInt_t CollectBranches(TObjArray* from, TObjArray* to); Fill the array of branches, matching the branches of the 'from' and 'to' arrays.; Returns the total number",MatchSource.WIKI,root/html604/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCloner.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:1450,Availability,error,error,1450," virtual~TTreeDrawArgsParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::Get",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:1534,Availability,error,error,1534," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::GetIconName() const; Double_tGetIfSpecified(Int_t num, Double_t def) const; static Int_tGetMaxDimension(); virtual const char*TObject::GetName() const; Int_tGetNoParameters() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TStringGetObjectName() const; static Bool_tTObject::GetObjectStat(); TStringGetObjectTitle() const; virtual Option_t*TObject::GetOption() const; Bool_tGetOptionSame() const; TObject*GetOriginal() const; Double_tGetParameter(int num) const; TStringGetProofSelectorName() const; TStringGetSelecti",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8971,Availability,error,error,8971,"ckets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the e",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:9239,Availability,error,error,9239,"ructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from th",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:9984,Availability,error,error,9984,"eturns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t Ge",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10460,Availability,error,error,10460,"rawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TOb",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10488,Availability,error,error,10488,"rawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TOb",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10611,Availability,error,error,10611,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }. » Author: Marek Biskup 24/01/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last g",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10627,Availability,error,error,10627,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }. » Author: Marek Biskup 24/01/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last g",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10494,Integrability,message,message,10494,"rawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TOb",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10633,Integrability,message,message,10633,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }. » Author: Marek Biskup 24/01/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last g",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:125,Modifiability,inherit,inheritance,125,". TTreeDrawArgsParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeDrawArgsParser. class TTreeDrawArgsParser: public TObject. TTreeDrawArgsParser. A class that parses all parameters for TTree::Draw().; See TTree::Draw() for the format description. Function Members (Methods); public:. virtual~TTreeDrawArgsParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::Get",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:5852,Modifiability,variab,variables,5852,"bj); voidSetObjectName(const char* s); static voidTObject::SetObjectStat(Bool_t stat); voidSetOriginal(TObject* o); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeDrawArgsParser(); TTreeDrawArgsParser(const TTreeDrawArgsParser&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidClearPrevious(); TTreeDrawArgsParser::EOutputTypeDefineType(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); Bool_tParseName(TString name); Bool_tParseOption(); Bool_tParseVarExp(); Bool_tSplitVariables(TString variables). Data Members; public:. static Int_tfgMaxDimension= 4; static Int_tfgMaxParameters= 9; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TTreeDrawArgsParser::EOutputTypekENTRYLIST; static TTreeDrawArgsParser::EOutputTypekEVENTLIST; static TTreeDrawArgsParser::EOutputTypekGRAPH; static TTreeDrawArgsParser::EOutputTypekHISTOGRAM1D; static TTreeDrawArgsParser::EOutputTypekHISTOGRAM2D; static TTreeDrawArgsParser::EOutputTypekHISTOGRAM3D; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TTreeDrawArgsParser::EOutputTypekLISTOFGRAPHS; static TTreeDrawArgsParser::EOutputTypekLISTOFPOLYMARKERS3D",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:7536,Modifiability,variab,variable,7536,"static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TTreeDrawArgsParser::EOutputTypekPOLYMARKER3D; static TTreeDrawArgsParser::EOutputTypekPROFILE; static TTreeDrawArgsParser::EOutputTypekPROFILE2D; static TObject::(anonymous)TObject::kSingleKey; static TTreeDrawArgsParser::EOutputTypekUNKNOWN; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAddvalues should be added to an existing object; Int_tfDimensiondimension of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : tha",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8059,Modifiability,variab,variable,8059,"static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TTreeDrawArgsParser::EOutputTypekPOLYMARKER3D; static TTreeDrawArgsParser::EOutputTypekPROFILE; static TTreeDrawArgsParser::EOutputTypekPROFILE2D; static TObject::(anonymous)TObject::kSingleKey; static TTreeDrawArgsParser::EOutputTypekUNKNOWN; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAddvalues should be added to an existing object; Int_tfDimensiondimension of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : tha",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8256,Modifiability,variab,variables,8256,"TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAddvalues should be added to an existing object; Int_tfDimensiondimension of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kF",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8407,Modifiability,variab,variables,8407," of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for ch",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8461,Modifiability,variab,variables,8461,"prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, ",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8529,Modifiability,variab,variables,8529,"expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Dra",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8811,Modifiability,variab,variable,8811,"nal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropr",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8847,Modifiability,variab,variables,8847,"e parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8880,Modifiability,variab,variable,8880,"e parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8920,Modifiability,variab,variable,8920,"e parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:9274,Modifiability,variab,variables,9274,"er(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of ",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10245,Modifiability,variab,variable,10245,"riate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Boo",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10580,Modifiability,variab,variable,10580,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }. » Author: Marek Biskup 24/01/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last g",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10709,Modifiability,variab,variable,10709,"tring GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }. » Author: Marek Biskup 24/01/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions reg",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeFormula.html:731,Availability,avail,available,731,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormula. class TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:3926,Availability,error,error,3926,"char* method, const char* msgfmt) const; virtual Double_tROOT::v5::TFormula::Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual TClass*EvalClass() const; virtual Double_tEvalInstance(Int_t i = 0, const char*[] stringStack = 0); virtual Long64_tEvalInstance64(Int_t i = 0, const char*[] stringStack = 0); doubleEvalInstance<double>(Int_t i = 0, const char*[] stringStack = 0); long doubleEvalInstance<long double>(Int_t i = 0, const char*[] stringStack = 0); Long64_tEvalInstance<long long>(Int_t i = 0, const char*[] stringStack = 0); virtual LongDouble_tEvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); virtual void*EvalObject(Int_t i = 0); virtual Double_tROOT::v5::TFormula::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tROOT::v5::TFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual const char*EvalStringInstance(Int_t i = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringROOT::v5::TFormula::GetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual TLeaf*GetLeaf(Int_t n) const; TFormLeafInfo*GetLeafInfo(Int_t code) const; virtual const TObject*ROOT::v5::TFormula::GetLinearPart(Int_t i); TTreeFormulaManager*GetManager() const; static voidROOT::v5::TFormula::GetMaxima(Int_t& maxop, Int_t& maxpar, Int_t& maxconst); TMethodCall*GetMethodCall(Int_t code) const; virtual Int_tGetMultiplicity() const; virtual const char*T",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:4010,Availability,error,error,4010,"uble_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual TClass*EvalClass() const; virtual Double_tEvalInstance(Int_t i = 0, const char*[] stringStack = 0); virtual Long64_tEvalInstance64(Int_t i = 0, const char*[] stringStack = 0); doubleEvalInstance<double>(Int_t i = 0, const char*[] stringStack = 0); long doubleEvalInstance<long double>(Int_t i = 0, const char*[] stringStack = 0); Long64_tEvalInstance<long long>(Int_t i = 0, const char*[] stringStack = 0); virtual LongDouble_tEvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); virtual void*EvalObject(Int_t i = 0); virtual Double_tROOT::v5::TFormula::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tROOT::v5::TFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual const char*EvalStringInstance(Int_t i = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringROOT::v5::TFormula::GetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual TLeaf*GetLeaf(Int_t n) const; TFormLeafInfo*GetLeafInfo(Int_t code) const; virtual const TObject*ROOT::v5::TFormula::GetLinearPart(Int_t i); TTreeFormulaManager*GetManager() const; static voidROOT::v5::TFormula::GetMaxima(Int_t& maxop, Int_t& maxpar, Int_t& maxconst); TMethodCall*GetMethodCall(Int_t code) const; virtual Int_tGetMultiplicity() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNcodes() const; virtual Int_tGetNdata(); vir",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:27803,Availability,failure,failure,27803,"thod is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:28898,Availability,failure,failure,28898," case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:30742,Availability,redundant,redundant,30742,"Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* ======",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:32471,Availability,avail,available,32471," the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. TLeaf * GetLeaf(Int_t n) const; -*-*Return leaf corresponding to serial number n; *-* ============================================. TMethodCall * GetMethodCall(Int_t code) const; -*-*Return methodcall corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. Int_t GetNdata(); *-*Return number of available instances in the formula; *-* ===================================================. Double_t GetValueFromMethod(Int_t i, TLeaf* leaf) const; Return result of a leafobject method. void* GetValuePointerFromMethod(Int_t i, TLeaf* leaf) const; Return result of a leafobject method. Bool_t IsInteger(Bool_t fast = kTRUE) const; return TRUE if the formula corresponds to one single Tree leaf; and this leaf is short, int or unsigned short, int; When a leaf is of type integer or string, the generated histogram is forced; to have an integer bin width. Bool_t IsLeafInteger(Int_t code) const; return TRUE if the leaf corresponding to code is short, int or unsigned; short, int When a leaf is of type integer, the generated histogram is; forced to have an integer bin width. Bool_t IsString() const; return TRUE if the formula is a string. Bool_t IsString(Int_t oper) const; (fOper[i]>=105000 && fOper[i]<110000) || fOper[i] == kStrings). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member correspon",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:34556,Deployability,update,update,34556,"= 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases). TTreeFormula& operator=(const TTreeFormula& ). Long64_t EvalInstance64(Int_t i = 0, const char*[",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:764,Integrability,interface,interface,764,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormula. class TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:28170,Integrability,message,message,28170,"ultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:28227,Integrability,message,message,28227,"ultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:118,Modifiability,inherit,inheritance,118,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormula. class TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:1032,Modifiability,variab,variability,1032,"ss TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidROOT::v5::TFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tROOT::v5::TFormula::Compile(c",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:2545,Modifiability,variab,variable,2545," virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:15740,Modifiability,variab,variable,15740,"tatic ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsROOT::v5::TFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfL",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:16556,Modifiability,variab,variable,16556,"tring; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNc",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:16596,Modifiability,variab,variable,16596,"tring; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNc",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:17113,Modifiability,variab,variability,17113,"ula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation fo",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:18058,Modifiability,variab,variables,18058,"*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); ROOT::v5::TFormula::TFuncGROOT::v5::TFormula::fOptimal!pointer to optimal function; Double_t*ROOT::v5::TFormula::fParams[fNpar] Array of fNpar parameters; ROOT::v5::TFormulaPrimitive**ROOT::v5::TFormula::fPredefined![fNPar] predefined function; Bool_tfQuickLoad! If true, branch GetEntry is only called when the entry number changes.; TStringTNamed::fTitleobject title; TTree*fTree! pointer to Tree; TTreeFormula*fVarIndexes[500][5]Pointer to a variable index.; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kAdd; static TTreeFormula::(anonymous)kAlias; static TTreeFormula::(anonymous)kAliasString; static TTreeFormula::(anonymous)kAlternate; static TTreeFormula::(anonymous)",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:18751,Modifiability,variab,variable,18751," entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); ROOT::v5::TFormula::TFuncGROOT::v5::TFormula::fOptimal!pointer to optimal function; Double_t*ROOT::v5::TFormula::fParams[fNpar] Array of fNpar parameters; ROOT::v5::TFormulaPrimitive**ROOT::v5::TFormula::fPredefined![fNPar] predefined function; Bool_tfQuickLoad! If true, branch GetEntry is only called when the entry number changes.; TStringTNamed::fTitleobject title; TTree*fTree! pointer to Tree; TTreeFormula*fVarIndexes[500][5]Pointer to a variable index.; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kAdd; static TTreeFormula::(anonymous)kAlias; static TTreeFormula::(anonymous)kAliasString; static TTreeFormula::(anonymous)kAlternate; static TTreeFormula::(anonymous)kAlternateString; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kAnd; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBinary; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBitAnd; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBitOr; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBoolOptimize; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBoolOptimizeAnd; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBoolOptimizeOr; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBoolSet; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kConstant; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kData; s",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:26884,Modifiability,variab,variables,26884,":kylandau; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kypol; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzexpo; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzgaus; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzlandau; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzpol. Class Charts. Inheritance Chart:. ROOT::v5::TFormula. ←; TTreeFormula. Function documentation; TTreeFormula(); Tree Formula default constructor. TTreeFormula(const char* name, const char* formula, TTree* tree); Normal TTree Formula Constuctor. TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failur",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:27014,Modifiability,variab,variables,27014,"OOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzgaus; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzlandau; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzpol. Class Charts. Inheritance Chart:. ROOT::v5::TFormula. ←; TTreeFormula. Function documentation; TTreeFormula(); Tree Formula default constructor. TTreeFormula(const char* name, const char* formula, TTree* tree); Normal TTree Formula Constuctor. TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:27352,Modifiability,variab,variables,27352,"mula default constructor. TTreeFormula(const char* name, const char* formula, TTree* tree); Normal TTree Formula Constuctor. TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:27488,Modifiability,variab,variables,27488," char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& c",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:27613,Modifiability,variab,variables,27613,"ar* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:29033,Modifiability,variab,variable,29033,"inting to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:29361,Modifiability,variab,variable,29361,"ion, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Lo",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:29381,Modifiability,variab,variable,29381,", vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* meth",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:29542,Modifiability,variab,variable,29542,"sponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:33581,Modifiability,variab,variable,33581,". Double_t GetValueFromMethod(Int_t i, TLeaf* leaf) const; Return result of a leafobject method. void* GetValuePointerFromMethod(Int_t i, TLeaf* leaf) const; Return result of a leafobject method. Bool_t IsInteger(Bool_t fast = kTRUE) const; return TRUE if the formula corresponds to one single Tree leaf; and this leaf is short, int or unsigned short, int; When a leaf is of type integer or string, the generated histogram is forced; to have an integer bin width. Bool_t IsLeafInteger(Int_t code) const; return TRUE if the leaf corresponding to code is short, int or unsigned; short, int When a leaf is of type integer, the generated histogram is; forced to have an integer bin width. Bool_t IsString() const; return TRUE if the formula is a string. Bool_t IsString(Int_t oper) const; (fOper[i]>=105000 && fOper[i]<110000) || fOper[i] == kStrings). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:33798,Modifiability,variab,variable,33798," const; return TRUE if the formula corresponds to one single Tree leaf; and this leaf is short, int or unsigned short, int; When a leaf is of type integer or string, the generated histogram is forced; to have an integer bin width. Bool_t IsLeafInteger(Int_t code) const; return TRUE if the leaf corresponding to code is short, int or unsigned; short, int When a leaf is of type integer, the generated histogram is; forced to have an integer bin width. Bool_t IsString() const; return TRUE if the formula is a string. Bool_t IsString(Int_t oper) const; (fOper[i]>=105000 && fOper[i]<110000) || fOper[i] == kStrings). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:1570,Performance,load,loading,1570,"ss TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidROOT::v5::TFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tROOT::v5::TFormula::Compile(c",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:15261,Performance,cache,cache,15261,"UID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kNormalized; static TObject::(anonymous)TObject::kNotDeleted; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsROOT::v5::TFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:15894,Performance,optimiz,optimization,15894,"tatic ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsROOT::v5::TFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfL",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:17208,Performance,optimiz,optimization,17208,"ula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation fo",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:17457,Performance,cache,caches,17457,"ula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation fo",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:17722,Performance,load,loaded,17722,"xes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); ROOT::v5::TFormula::TFuncGROOT::v5::TFormula::fOptimal!pointer to optimal function; Double_t*ROOT::v5::TFormula::fParams[fNpar] Array of fNpar parameters; ROOT::v5::TFormulaPrimitive**ROOT::v5::TFormula::fPredefined![fNPar] predefined function; Bool_tfQuickLoad! If true, branch GetEntry is only called when the entry num",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:27743,Performance,load,load,27743,"========================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from exp",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:34474,Performance,load,loaded,34474,"s). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* form",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:34778,Performance,load,loaded,34778,"ar* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases). TTreeFormula& operator=(const TTreeFormula& ). Long64_t EvalInstance64(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<Long64_t>(i, stringStack); }. LongDouble_t EvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<LongDouble_t>(i, stringStack); }. TT",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:30742,Safety,redund,redundant,30742,"Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* ======",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:29535,Usability,simpl,simple,29535,"sponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:30144,Usability,usab,usable,30144,"===. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the cla",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:31022,Usability,simpl,simple,31022,"rAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable.",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:31238,Usability,simpl,simple,31238,"is name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. TLeaf * GetLeaf(Int_t n) const; -*-*Return leaf corresponding to serial number n; *-* ============================================. TMethodCall * GetMethodCall(Int_t code) const; -*-*Return methodcall correspon",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormulaManager.html:1508,Availability,error,error,1508," voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TTreeFormula*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() con",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:1592,Availability,error,error,1592,"st char* method) const; virtual voidAdd(TTreeFormula*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetMultiplicity() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdata(Bool_t forceLoadDim = kFALSE); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classna",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:7791,Availability,avail,available,7791,"zes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regard",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:8159,Deployability,update,update,8159,"en for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6676,Integrability,synchroniz,synchronization,6676,k; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. vo,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:125,Modifiability,inherit,inheritance,125,". TTreeFormulaManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormulaManager. class TTreeFormulaManager: public TObject. A TreeFormulaManager is used to coordinate one or more TTreeFormula objecs. In particular it makes sure that the dimensions and size of all the formulas; is properly coordinated. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TTreeFormula*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() con",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6364,Modifiability,variab,variable,6364,reeFormulaManager&operator=(const TTreeFormulaManager&); TTreeFormulaManager(const TTreeFormulaManager&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; Th,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6447,Modifiability,variab,variable,6447,reeFormulaManager&operator=(const TTreeFormulaManager&); TTreeFormulaManager(const TTreeFormulaManager&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; Th,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6462,Modifiability,variab,variable,6462,reeFormulaManager&operator=(const TTreeFormulaManager&); TTreeFormulaManager(const TTreeFormulaManager&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; Th,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6524,Modifiability,variab,variability,6524,k; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. vo,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6793,Modifiability,variab,variable,6793,tatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of a,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:7485,Modifiability,variab,variable,7485,"e dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return ",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:7703,Modifiability,variab,variable,7703,"st synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:8077,Performance,load,loaded,8077,"en for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeIndex.html:1435,Availability,error,error,1435,"ct::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolConvertOldToNew(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tFindValues(Long64_t major, Long64_t minor) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual Long64_t*GetIndex() const; virtual Long64_t*GetIndexValues() const; virtual Long64_t*GetIndexValuesMinor() const; virtual TTreeFormula*GetMajorFormula(); virtual TTreeFormu",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:1519,Availability,error,error,1519,"*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolConvertOldToNew(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tFindValues(Long64_t major, Long64_t minor) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual Long64_t*GetIndex() const; virtual Long64_t*GetIndexValues() const; virtual Long64_t*GetIndexValuesMinor() const; virtual TTreeFormula*GetMajorFormula(); virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() con",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:10073,Availability,failure,failure,10073,"a friend Tree TF, the following cases are supported:; CASE 1: T->GetEntry(entry) is called; In this case, the serial number entry is used to retrieve; the data in both Trees.; CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; the expressions given in major/minorname of TF are used; to compute the value pair major,minor with the data in T.; TF->GetEntryWithIndex(major,minor) is then called (tricky case!); CASE 3: T->GetEntryWithIndex(major,minor) is called.; It is assumed that both T and TF have a TreeIndex built using; the same major and minor name. Saving the TreeIndex. Once the index is built, it can be saved with the TTree object; with tree.Write(); (if the file has been open in ""update"" mode). The most convenient place to create the index is at the end of; the filling process just before saving the Tree header.; If a previous index was computed, it is redefined by this new call. Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure). It is possible to play with different TreeIndex in the same Tree.; see comments in TTree::SetTreeIndex. ~TTreeIndex(); Destructor. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); Append 'add' to this index. Entry 0 in add will become entry n+1 in this.; If delaySort is true, do not sort the value, then you must call; Append(0,kFALSE);. bool ConvertOldToNew(); conversion from old 64bit indexes; return true if index was converted. Long64_t GetEntryNumberFriend(const TTree* parent); Returns the entry number in this (friend) Tree corresponding to entry in; the master Tree 'parent'.; In case this (friend) Tree and 'master' do not share an index with the same; major and minor name, the entry serial number in the (friend) tree; and in the master Tree are assumed to be the same. Long64_t FindValues(Long64_t major, Long64_t minor) const; find position where major|minor values are in the IndexValues tables; this is the index in IndexValues ",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:9742,Deployability,update,update,9742,"s eg: ""run-90000"", ""event +3*xx"". However the result; must be integer.; In case an expression is specified, the equivalent expression must be computed; when calling GetEntryWithIndex. To build an index with only majorname, specify minorname=""0"" (default). TreeIndex and Friend Trees. Assuming a parent Tree T and a friend Tree TF, the following cases are supported:; CASE 1: T->GetEntry(entry) is called; In this case, the serial number entry is used to retrieve; the data in both Trees.; CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; the expressions given in major/minorname of TF are used; to compute the value pair major,minor with the data in T.; TF->GetEntryWithIndex(major,minor) is then called (tricky case!); CASE 3: T->GetEntryWithIndex(major,minor) is called.; It is assumed that both T and TF have a TreeIndex built using; the same major and minor name. Saving the TreeIndex. Once the index is built, it can be saved with the TTree object; with tree.Write(); (if the file has been open in ""update"" mode). The most convenient place to create the index is at the end of; the filling process just before saving the Tree header.; If a previous index was computed, it is redefined by this new call. Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure). It is possible to play with different TreeIndex in the same Tree.; see comments in TTree::SetTreeIndex. ~TTreeIndex(); Destructor. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); Append 'add' to this index. Entry 0 in add will become entry n+1 in this.; If delaySort is true, do not sort the value, then you must call; Append(0,kFALSE);. bool ConvertOldToNew(); conversion from old 64bit indexes; return true if index was converted. Long64_t GetEntryNumberFriend(const TTree* parent); Returns the entry number in this (friend) Tree corresponding to entry in; the master Tree 'parent'.; In case this (friend) Tree and 'master' do no",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:13818,Deployability,update,update,13818,". TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:116,Modifiability,inherit,inheritance,116,". TTreeIndex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeIndex. class TTreeIndex: public TVirtualIndex. A Tree Index with majorname and minorname. Function Members (Methods); public:. virtual~TTreeIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolConvertOldToNew(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tFindValues(Long64_t major, Long64_t minor) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long6",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:8721,Modifiability,variab,variables,8721,"n; TTreeIndex(); Default constructor for TTreeIndex. TTreeIndex(const TTree* T, const char* majorname, const char* minorname); Normal constructor for TTreeIndex. Build an index table using the leaves of Tree T with major & minor names; The index is built with the expressions given in ""majorname"" and ""minorname"". a Long64_t array fIndexValues is built with:; major = the value of majorname converted to an integer; minor = the value of minorname converted to an integer; fIndexValues[i] = major<<31 + minor; This array is sorted. The sorted fIndex[i] contains the serial number; in the Tree corresponding to the pair ""major,minor"" in fIndexvalues[i]. Once the index is computed, one can retrieve one entry via; T->GetEntryWithIndex(majornumber, minornumber); Example:; tree.BuildIndex(""Run"",""Event""); //creates an index using leaves Run and Event; tree.GetEntryWithIndex(1234,56789); //reads entry corresponding to; Run=1234 and Event=56789. Note that majorname and minorname may be expressions using original; Tree variables eg: ""run-90000"", ""event +3*xx"". However the result; must be integer.; In case an expression is specified, the equivalent expression must be computed; when calling GetEntryWithIndex. To build an index with only majorname, specify minorname=""0"" (default). TreeIndex and Friend Trees. Assuming a parent Tree T and a friend Tree TF, the following cases are supported:; CASE 1: T->GetEntry(entry) is called; In this case, the serial number entry is used to retrieve; the data in both Trees.; CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; the expressions given in major/minorname of TF are used; to compute the value pair major,minor with the data in T.; TF->GetEntryWithIndex(major,minor) is then called (tricky case!); CASE 3: T->GetEntryWithIndex(major,minor) is called.; It is assumed that both T and TF have a TreeIndex built using; the same major and minor name. Saving the TreeIndex. Once the index is built, it can be saved with the TTree object; with tree.Wr",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:11513,Performance,perform,performs,11513,"ue, then you must call; Append(0,kFALSE);. bool ConvertOldToNew(); conversion from old 64bit indexes; return true if index was converted. Long64_t GetEntryNumberFriend(const TTree* parent); Returns the entry number in this (friend) Tree corresponding to entry in; the master Tree 'parent'.; In case this (friend) Tree and 'master' do not share an index with the same; major and minor name, the entry serial number in the (friend) tree; and in the master Tree are assumed to be the same. Long64_t FindValues(Long64_t major, Long64_t minor) const; find position where major|minor values are in the IndexValues tables; this is the index in IndexValues table, not entry# !; use lower_bound STD algorithm. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair th",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:12327,Performance,perform,performs,12327,"major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table, otherwise it returns -1. See also GetEntryNumberWithBestIndex. Long64_t* GetIndexValuesMinor() const. TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:13736,Performance,load,loaded,13736,". TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeInput.html:4451,Availability,error,error,4451," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:4535,Availability,error,error,4535,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:20086,Availability,mask,mask,20086,,MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:116,Modifiability,inherit,inheritance,116,". TTreeInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » FITPANEL; » TTreeInput. class TTreeInput: public TGTransientFrame. Tree Input Widget. An dialog box that asks the user for the variables and cuts; of the selected tree in the fitpanel. Function Members (Methods); public:. virtual~TTreeInput(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, co",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:387,Modifiability,variab,variables,387,". TTreeInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » FITPANEL; » TTreeInput. class TTreeInput: public TGTransientFrame. Tree Input Widget. An dialog box that asks the user for the variables and cuts; of the selected tree in the fitpanel. Function Members (Methods); public:. virtual~TTreeInput(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, co",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:23244,Modifiability,variab,variables,23244,"ag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TTreeInput. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:23350,Modifiability,variab,variables,23350,"ag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TTreeInput. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:23639,Usability,simpl,simple,23639,"ag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TTreeInput. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreePerfStats.html:3706,Availability,error,error,3706,"r* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&TVirtualPerfStats::CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char*, const char*, const char*, const char*, Bool_t); virtual voidFileOpenEvent(TFile*, const char*, Double_t); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinish(); virtual Long64_tGetBytesRead() const; virtual Long64_tGetBytesReadExtra() const; virtual Double_tGetCpuTime() const; virtual Double_tGetDiskTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGraphErrors*GetGraphIO(); TGraphErrors*GetGraphTime(); const char*GetHostInfo() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:3790,Availability,error,error,3790,"dBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&TVirtualPerfStats::CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char*, const char*, const char*, const char*, Bool_t); virtual voidFileOpenEvent(TFile*, const char*, Double_t); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinish(); virtual Long64_tGetBytesRead() const; virtual Long64_tGetBytesReadExtra() const; virtual Double_tGetCpuTime() const; virtual Double_tGetDiskTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGraphErrors*GetGraphIO(); TGraphErrors*GetGraphTime(); const char*GetHostInfo() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual Int_tGetNleaves() const; virtual Long64_tGetNumEvents() const; virtual char*TObject",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:11323,Energy Efficiency,monitor,monitored,11323,"verwrite; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kPacket; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStart; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tfBytesReadNumber of bytes read; Long64_tfBytesReadExtraNumber of bytes (overhead) of the readahead cache; Double_tfCompressTree compression factor; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance Chart:. TObject. ←; TVirtualPerfStats. ←; TTreePerfStats. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void D",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:120,Modifiability,inherit,inheritance,120,". TTreePerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreePerfStats. class TTreePerfStats: public TVirtualPerfStats. TTreePerfStats. TTree I/O performance measurement. see example of use below. The function FileReadEvent is called from TFile::ReadBuffer.; For each call the following information is stored in fGraphIO; - x[i] = Tree entry number; - y[i] = 1e-6*(file position); - ey[i] = 1e-9*number of bytes read; For each call the following information is stored in fGraphTime; - x[i] = Tree entry number; - y[i] = Time now; - ey[i] = readtime, eg timenow - start; The TTreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:369,Performance,perform,performance,369,". TTreePerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreePerfStats. class TTreePerfStats: public TVirtualPerfStats. TTreePerfStats. TTree I/O performance measurement. see example of use below. The function FileReadEvent is called from TFile::ReadBuffer.; For each call the following information is stored in fGraphIO; - x[i] = Tree entry number; - y[i] = 1e-6*(file position); - ey[i] = 1e-9*number of bytes read; For each call the following information is stored in fGraphTime; - x[i] = Tree entry number; - y[i] = Time now; - ey[i] = readtime, eg timenow - start; The TTreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:1519,Performance,cache,cache,1519,"TreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ReadUZRT = Unzipped MBytes per RT second; ReadUZCP = Unipped MBytes per CP second; ReadRT = Zipped MBytes per RT second; ReadCP = Zipped MBytes per CP second. NOTE1 : The ReadTotal value indicates the effective number of zipped bytes; returned to the application. The physical number of bytes read; from the device (as measured for example with strace) is; ReadTotal +ReadTotal*Readextra/100. Same for ReadSize. NOTE2 : A consequence of NOTE1, the Disk I/O speed corresponds to the effective; number of bytes returned to the application per second.; The Physical disk speed is DiskIO + DiskIO*ReadExtra/100. Function Members (Methods); public:. virtual~TTreePerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrows",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:10501,Performance,cache,cache,10501,"verwrite; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kPacket; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStart; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tfBytesReadNumber of bytes read; Long64_tfBytesReadExtraNumber of bytes (overhead) of the readahead cache; Double_tfCompressTree compression factor; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance Chart:. TObject. ←; TVirtualPerfStats. ←; TTreePerfStats. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void D",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:11125,Performance,cache,cache,11125,"verwrite; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kPacket; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStart; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tfBytesReadNumber of bytes read; Long64_tfBytesReadExtraNumber of bytes (overhead) of the readahead cache; Double_tfCompressTree compression factor; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance Chart:. TObject. ←; TVirtualPerfStats. ←; TTreePerfStats. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void D",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePlayer.html:1910,Availability,error,error,1910,"me = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); static TVirtualTreePlayer*TVirtualTreePlayer::GetCurrentPlayer(); virtual Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries(const char* selection); virtual Long64_tGetEntriesToProcess(Long64_t firstentry, Long64_t nentries) const; virtual TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNfill() const; vi",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:1994,Availability,error,error,1994,"dTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); static TVirtualTreePlayer*TVirtualTreePlayer::GetCurrentPlayer(); virtual Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries(const char* selection); virtual Long64_tGetEntriesToProcess(Long64_t firstentry, Long64_t nentries) const; virtual TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNfill() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::G",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:12851,Availability,error,error,12851,"olean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeProxy (see MakeProxy); and including the files in the proper location. If the branch name can not be used a proper C++ symbol name,; it will be modified as follow:; - white spaces are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename());. The default for the histogram are the same as for; TTreePlayer::DrawSelect. Long64_t DrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw expression varexp for specified entries that matches the selection.; Returns -1 in case of error or number of selected events in case of succss. See the documentation of TTree::Draw for the complete details. Int_t Fit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); Fit a projected item(s) from a Tree.; Returns -1 in case of error or number of selected events in case of success. The formula is a TF1 expression. See TTree::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; tree.Fit(""pol4"",""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null if the fit is OK). Long64_t GetEntries(const char* selection); Return the n",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:13180,Availability,error,error,13180," are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename());. The default for the histogram are the same as for; TTreePlayer::DrawSelect. Long64_t DrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw expression varexp for specified entries that matches the selection.; Returns -1 in case of error or number of selected events in case of succss. See the documentation of TTree::Draw for the complete details. Int_t Fit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); Fit a projected item(s) from a Tree.; Returns -1 in case of error or number of selected events in case of success. The formula is a TF1 expression. See TTree::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; tree.Fit(""pol4"",""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null if the fit is OK). Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEn",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:13929,Availability,error,errors,13929,"ation of TTree::Draw for the complete details. Int_t Fit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); Fit a projected item(s) from a Tree.; Returns -1 in case of error or number of selected events in case of success. The formula is a TF1 expression. See TTree::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; tree.Fit(""pol4"",""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null if the fit is OK). Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesToProcess(Long64_t firstentry, Long64_t nentries) const; return the number of entries to be processed; this function checks that nentries is not bigger than the number; of entries in the Tree or in the associated TEventlist. const char * GetNameByIndex(TString& varexp, Int_t* index, Int_t colindex); -*-*-*Return name corresponding to colindex in varexp; *-* ===============================================. varexp is a string of names separated by :; index is an array with pointers to the start of name[i] in varexp. Int_t MakeClass(const char* classname, Option_t* option);",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:18808,Availability,avail,available,18808,"od; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19547,Availability,avail,available,19547,"vior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit cal",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:22318,Availability,avail,available,22318,"ify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstent",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:23446,Availability,error,error,23446,"d in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically l",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:25842,Availability,error,error,25842,"ll this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(""h1test.C+"");; }. Long64_t Process(TSelector* selector, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the code in the specified selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The TSelector class has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If the Tree (Chain) has an associated EventList, the loop is on the nentries; of the EventList, starting at firstentry, otherwise the loop is on the; specified Tree entries. void RecursiveRemove(TObject* obj); cleanup pointers in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:29834,Availability,error,error,29834,"f format; specification. The value given will be prefixed by % and, if no; conversion specifier is given, will be suffixed by the letter g.; before being passed to fprintf. If no format is specified for a; column, the default is used (aka ${colsize}.${precision}g ); For example:; tree->Scan(""a:b:c"","""",""colsize=30 precision=3 col=::20.10:#x:5ld"");; Will print 3 columns, the first 2 columns will be 30 characters long,; the third columns will be 20 characters long. The printing format used; for the columns (assuming they are numbers) will be respectively:; %30.3g %30.3g %20.10g %#x %5ld. TSQLResult * Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and return TSQLResult object containing entries passing; selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can; be made using ""var1:var2:var3"". In case of error 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better E",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:32422,Availability,error,error,32422,"unc->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t Ge",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:9672,Deployability,update,updated,9672,"tatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfDimensionDimension of the current expression; TList*fFormulaList! Pointer to a list of coordinated list TTreeFormula (used by Scan and Query); TH1*fHistogram! Pointer to histogram used for the projection; TList*fInput! input list to the selector; const char*fScanFileNameName of the file where Scan is redirected; Bool_tfScanRedirectSwitch to redirect TTree::Scan output to a file; Long64_tfSelectedRowsNumber of selected entries; TSelectorDraw*fSelector! Pointer to current selector; TClass*fSelectorClass! Pointer to the actual class of the TSelectorFromFile; TSelector*fSelectorFromFile! Pointer to a user defined selector created by this TTreePlayer object; TSelector*fSelectorUpdate! Set to the selector address when it's entry list needs to be updated by the UpdateFormulaLeaves function; TTree*fTree! Pointer to current Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreePlayer(); Default Tree constructor*-*-*-; *-* ========================. ~TTreePlayer(); Tree destructor*-*-*-*-; *-* =================. TVirtualIndex * BuildIndex(const TTree* T, const char* majorname, const char* minorname); Build the index for the tree (see TTree::BuildIndex). TTree * CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); copy a Tree with selection; make a clone of this Tree header.; then copy the selected entries. selection ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:18954,Deployability,update,updated,18954,"tong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:32783,Deployability,update,update,32783,"effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TSelector * GetSelector() const; {return fSelector;}. TSelector * GetSelectorFromFile() const; See TSelectorDraw::GetVar. {return fSelectorFromFile;}. TTreeFormula * GetVar(Int_t i) const; See TSelectorDraw::GetVar. {return fSelector->GetVar(i);}. TTreeFormula * GetVar1() const; See TSelectorDraw::GetVar. {return",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19668,Energy Efficiency,efficient,efficient,19668,"e the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19795,Energy Efficiency,efficient,efficient,19795,"). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fpri",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:1465,Integrability,wrap,wrapperPrefix,1465," virtual~TTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error =",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:11488,Integrability,wrap,wrapperPrefix,11488,"0). IMPORTANT: The copied tree stays connected with this tree until this tree; is deleted. In particular, any changes in branch addresses; in this tree are forwarded to the clone trees. Any changes; made to the branch addresses of the copied trees are over-ridden; anytime this tree changes its branch addresses.; Once this tree is deleted, all the addresses of the copied tree; are reset to their default values. The following example illustrates how to copy some events from the Tree; generated in $ROOTSYS/test/Event. gSystem->Load(""libEvent"");; TFile f(""Event.root"");; TTree *T = (TTree*)f.Get(""T"");; Event *event = new Event();; T->SetBranchAddress(""event"",&event);; TFile f2(""Event2.root"",""recreate"");; TTree *T2 = T->CopyTree(""fNtrack<595"");; T2->Write();. void DeleteSelectorFromFile(); Delete any selector created by this object.; The selector has been created using TSelector::GetSelector(file). Long64_t DrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw the result of a C++ script. The macrofilename and optionally cutfilename are assumed to contain; at least a method with the same name as the file. The method; should return a value that can be automatically cast to; respectively a double and a boolean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeProxy (see MakeProxy); and including the files in the proper location. If the branch name can not be used a proper C++ symbol name,; it will be modified as follow:; - white spaces are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:20420,Integrability,wrap,wrapper,20420,"e());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:22211,Integrability,interface,interface,22211,"void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for e",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:27717,Integrability,synchroniz,synchronized,27717,"inters in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and print entries passing selection. If varexp is 0 (or """"); then print only first 8 columns. If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; The function returns the number of entries passing the selection. By default 50 rows are shown and you are asked for <CR>; to see the next 50 rows.; You can change the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the default size for all the column; If this options is not specified, the default column size is 9; precision=pp; Where 'pp' will ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:28203,Integrability,synchroniz,synchronized,28203,"hange the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the default size for all the column; If this options is not specified, the default column size is 9; precision=pp; Where 'pp' will be used as the default 'precision' for the; printing format.; col=xxx; Where 'xxx' is colon (:) delimited list of printing format for; each column. The format string should follow the printf format; specification. The value given will be prefixed by % and, if no; conversion specifier is given, will be suffixed by the letter g.; before being passed to fprintf. If no format is specified for a; column, the default is used (aka ${colsize}.${precision}g ); For example:; tree->Scan(""a:b:c"","""",""colsize=30 precision=3 col=::",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:11962,Modifiability,variab,variables,11962,"d tree; are reset to their default values. The following example illustrates how to copy some events from the Tree; generated in $ROOTSYS/test/Event. gSystem->Load(""libEvent"");; TFile f(""Event.root"");; TTree *T = (TTree*)f.Get(""T"");; Event *event = new Event();; T->SetBranchAddress(""event"",&event);; TFile f2(""Event2.root"",""recreate"");; TTree *T2 = T->CopyTree(""fNtrack<595"");; T2->Write();. void DeleteSelectorFromFile(); Delete any selector created by this object.; The selector has been created using TSelector::GetSelector(file). Long64_t DrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw the result of a C++ script. The macrofilename and optionally cutfilename are assumed to contain; at least a method with the same name as the file. The method; should return a value that can be automatically cast to; respectively a double and a boolean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeProxy (see MakeProxy); and including the files in the proper location. If the branch name can not be used a proper C++ symbol name,; it will be modified as follow:; - white spaces are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename());. The default for the histogram are the same as for; TTreePlayer::DrawSelect. Long64_t DrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw expression varexp for specified entries that matches the selection.; Returns -1 in case of error or number of selected events in case of succss. See the documenta",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:16652,Modifiability,variab,variables,16652,"f(""myfile.root"");); - T->MakeClass(""MyClass"");; where T is the name of the Tree in file myfile.root; and MyClass.h, MyClass.C the name of the files created by this function.; In a ROOT session, you can do:; root> .L MyClass.C; root> MyClass t; root> t.GetEntry(12); // Fill t data members with entry number 12; root> t.Show(); // Show values of entry 12; root> t.Show(16); // Read and show values of entry 16; root> t.Loop(); // Loop on all entries. NOTE: Do not use the code generated for one Tree in case of a TChain.; Maximum dimensions calculated on the basis of one TTree only; might be too small when processing all the TTrees in one TChain.; Instead of myTree.MakeClass(.., use myChain.MakeClass(.. Int_t MakeCode(const char* filename); Generate skeleton function for this Tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name; - Connection of the Tree file; - Declaration of Tree variables; - Setting of branches addresses; - A skeleton for the entry loop. To use this function:; - connect your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""anal.C"");; where T is the name of the Tree in file myfile.root; and anal.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy.; TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class ge",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19566,Modifiability,variab,variables,19566,"vior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit cal",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19640,Modifiability,variab,variable,19640,"e the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:20382,Modifiability,variab,variable,20382,"e());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:20802,Modifiability,variab,variable,20802,">10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessibl",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:21784,Modifiability,variab,variable,21784,"lue or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal objec",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:22714,Modifiability,variab,variables,22714,"loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a lo",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:22802,Modifiability,variab,variables,22802,"loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a lo",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:29994,Modifiability,variab,variable,29994,"d by the letter g.; before being passed to fprintf. If no format is specified for a; column, the default is used (aka ${colsize}.${precision}g ); For example:; tree->Scan(""a:b:c"","""",""colsize=30 precision=3 col=::20.10:#x:5ld"");; Will print 3 columns, the first 2 columns will be 30 characters long,; the third columns will be 20 characters long. The printing format used; for the columns (assuming they are numbers) will be respectively:; %30.3g %30.3g %20.10g %#x %5ld. TSQLResult * Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and return TSQLResult object containing entries passing; selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can; be made using ""var1:var2:var3"". In case of error 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitt",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:30435,Modifiability,variab,variable,30435,"hey are numbers) will be respectively:; %30.3g %30.3g %20.10g %#x %5ld. TSQLResult * Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and return TSQLResult object containing entries passing; selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can; be made using ""var1:var2:var3"". In case of error 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitted function; normalized to the number of selected rows; and multiplied by the bin width. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:30611,Modifiability,variab,variable,30611,"; selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can; be made using ""var1:var2:var3"". In case of error 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitted function; normalized to the number of selected rows; and multiplied by the bin width. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the fun",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:31857,Modifiability,variab,variable,31857,"Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitted function; normalized to the number of selected rows; and multiplied by the bin width. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TT",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:18618,Performance,load,loading,18618,"od; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19683,Performance,cache,cache,19683,"e the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:20032,Performance,load,load,20032," value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:21732,Performance,load,loaded,21732,"dic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrinci",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:21876,Performance,load,loaded,21876,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print r",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:23527,Performance,load,loaded,23527,"nterface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more intere",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:24360,Performance,load,loaded,24360,"this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; };",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:24455,Performance,load,loaded,24455,"se of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""st",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:24566,Performance,load,loaded,24566,"low),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coa",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:32701,Performance,load,loaded,32701,"ust be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TSelector * GetSelector() const; {return fSelector;}. TSelector * GetSelectorFromFile() const; See TSelectorDraw::GetVar. {return fSelectorFromFile;}. TTreeFormula * GetVar(Int_t i) const; See ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:389,Security,access,access,389,". TTreePlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreePlayer. class TTreePlayer: public TVirtualTreePlayer. TTreePlayer. Implement some of the functionality of the class TTree requiring access to; extra libraries (Histogram, display, etc). Function Members (Methods); public:. virtual~TTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error =",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:17350,Security,access,access,17350," char* filename); Generate skeleton function for this Tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name; - Connection of the Tree file; - Declaration of Tree variables; - Setting of branches addresses; - A skeleton for the entry loop. To use this function:; - connect your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""anal.C"");; where T is the name of the Tree in file myfile.root; and anal.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy.; TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'.; If the fileprefix contains a period, the right side of the period; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'm",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:18483,Security,access,access,18483," in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'.; If the fileprefix contains a period, the right side of the period; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19948,Security,access,access,19948," value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:20253,Security,access,access,20253,"ame name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:20408,Security,access,access,20408,"e());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:21765,Security,access,accessible,21765,"lue or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal objec",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:21962,Security,access,access,21962,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print r",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:11059,Testability,test,test,11059,"nst TTree* T, const char* majorname, const char* minorname); Build the index for the tree (see TTree::BuildIndex). TTree * CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); copy a Tree with selection; make a clone of this Tree header.; then copy the selected entries. selection is a standard selection expression (see TTreePlayer::Draw); option is reserved for possible future use; nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). IMPORTANT: The copied tree stays connected with this tree until this tree; is deleted. In particular, any changes in branch addresses; in this tree are forwarded to the clone trees. Any changes; made to the branch addresses of the copied trees are over-ridden; anytime this tree changes its branch addresses.; Once this tree is deleted, all the addresses of the copied tree; are reset to their default values. The following example illustrates how to copy some events from the Tree; generated in $ROOTSYS/test/Event. gSystem->Load(""libEvent"");; TFile f(""Event.root"");; TTree *T = (TTree*)f.Get(""T"");; Event *event = new Event();; T->SetBranchAddress(""event"",&event);; TFile f2(""Event2.root"",""recreate"");; TTree *T2 = T->CopyTree(""fNtrack<595"");; T2->Write();. void DeleteSelectorFromFile(); Delete any selector created by this object.; The selector has been created using TSelector::GetSelector(file). Long64_t DrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw the result of a C++ script. The macrofilename and optionally cutfilename are assumed to contain; at least a method with the same name as the file. The method; should return a value that can be automatically cast to; respectively a double and a boolean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeP",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:27539,Testability,log,log,27539,"st, starting at firstentry, otherwise the loop is on the; specified Tree entries. void RecursiveRemove(TObject* obj); cleanup pointers in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and print entries passing selection. If varexp is 0 (or """"); then print only first 8 columns. If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; The function returns the number of entries passing the selection. By default 50 rows are shown and you are asked for <CR>; to see the next 50 rows.; You can change the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:27568,Testability,log,log,27568,"irstentry, otherwise the loop is on the; specified Tree entries. void RecursiveRemove(TObject* obj); cleanup pointers in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and print entries passing selection. If varexp is 0 (or """"); then print only first 8 columns. If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; The function returns the number of entries passing the selection. By default 50 rows are shown and you are asked for <CR>; to see the next 50 rows.; You can change the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the default size for",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreeReader.html:349,Availability,robust,robust,349,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:1924,Availability,error,error,1924," #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray objects. It knows the current entry number and knows; // how to iterate through the TTree.; TTreeReader reader(""MyTree"", file);;  ; // Read a single floa",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:2606,Availability,error,errors,2606,"ose as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray objects. It knows the current entry number and knows; // how to iterate through the TTree.; TTreeReader reader(""MyTree"", file);;  ; // Read a single float value in each tree entries:; TTreeReaderValue<float> weight(reader, ""event.weight"");; if (!CheckValue(weight)) return false;;  ; // Read a TriggerInfo object from the tree entries:; TTreeReaderValue<TriggerInfo> triggerInfo(reader, ""triggerInfo"");; if (!CheckValue(triggerInfo)) return false;;  ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;;  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:;",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:6554,Availability,error,error,6554,"l~TTreeReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TTreeReader::Iterator_tend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetCurrentEntry() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries(Bool_t force) const; TTreeReader::EEntryStatusGetEntryStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:6638,Availability,error,error,6638,"TObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TTreeReader::Iterator_tend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetCurrentEntry() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries(Bool_t force) const; TTreeReader::EEntryStatusGetEntryStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; v",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:13075,Deployability,update,update,13075,", owned; TDirectory*fDirectorydirectory (or current file for chains); TTreeReader::EEntryStatusfEntryStatusstatus of most recent read request; THashTablefProxiesattached ROOT::TNamedBranchProxies; owned; TTree*fTreetree that's read; deque<ROOT::TTreeReaderValueBase*>fValuesreaders that use our director; static TTreeReader::EPropertyBitskBitIsChain. Class Charts. Inheritance Chart:. TObject. ←; TTreeReader. Function documentation; TTreeReader(TTree* tree); Access data from tree. TTreeReader(const char* keyname, TDirectory* dir = __null); Access data from the tree called keyname in the directory (e.g. TFile); dir, or the current directory if dir is NULL. If keyname cannot be; found, or if it is not a TTree, IsZombie() will return true. ~TTreeReader(); Tell all value readers that the tree reader does not exist anymore. void Initialize(); Initialization of the director. Long64_t GetCurrentEntry() const; Returns the index of the current entry being read. void SetTree(TTree* tree); Set (or update) the which tree to reader from. tree can be; a TTree or a TChain. void RegisterValueReader(ROOT::TTreeReaderValueBase* reader); Add a value reader for this tree. void DeregisterValueReader(ROOT::TTreeReaderValueBase* reader); Remove a value reader for this tree. TTreeReader(); {}. TTreeReader(TTree* tree). TTreeReader(const char* keyname, TDirectory* dir = __null). void SetTree(TTree* tree). void SetChain(const char* , TFileCollection* ); { Error(""SetChain()"", ""Not Implemented!"");}. Bool_t IsChain() const; { return TestBit(kBitIsChain); }. Bool_t Next(); { return SetEntry(GetCurrentEntry() + 1) == kEntryValid; }. EEntryStatus SetEntry(Long64_t entry); { return SetEntryBase(entry, kFALSE); }. EEntryStatus SetLocalEntry(Long64_t entry); { return SetEntryBase(entry, kTRUE); }. EEntryStatus GetEntryStatus() const; { return fEntryStatus; }. TTree* GetTree() const; { return fTree; }. Long64_t GetEntries(Bool_t force) const; { return fTree ? (force ? fTree->GetEntries() : fTree->GetEntr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:711,Energy Efficiency,power,power,711,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:365,Integrability,interface,interface,365,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:117,Modifiability,inherit,inheritance,117,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:5100,Modifiability,variab,variable,5100,") {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like an iterator; hist->Fill(taus[iTau].eta(), currentWeight);; }; }; } // TTree entry / event loop; }. Function Members (Methods); public:. virtual~TTreeReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Cop",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:4121,Performance,load,loaded,4121,"triggerInfo"");; if (!CheckValue(triggerInfo)) return false;;  ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;;  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);;  ; while (reader.Next()) {;  ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the ",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:480,Security,access,access,480,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:1473,Security,access,access,1473,"rValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value-",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:1585,Security,access,access,1585,"Reader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:1745,Security,access,access,1745,"rams a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray obj",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:2736,Security,access,access,2736,"as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray objects. It knows the current entry number and knows; // how to iterate through the TTree.; TTreeReader reader(""MyTree"", file);;  ; // Read a single float value in each tree entries:; TTreeReaderValue<float> weight(reader, ""event.weight"");; if (!CheckValue(weight)) return false;;  ; // Read a TriggerInfo object from the tree entries:; TTreeReaderValue<TriggerInfo> triggerInfo(reader, ""triggerInfo"");; if (!CheckValue(triggerInfo)) return false;;  ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;;  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:4466,Security,access,access,4466,"  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);;  ; while (reader.Next()) {;  ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:341,Usability,simpl,simple,341,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:721,Usability,simpl,simpler,721,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:859,Usability,simpl,simple,859,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeResult.html:1552,Availability,error,error,1552," virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:1636,Availability,error,error,1636,"ethod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; TObjArray*GetRows() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) cons",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:349,Integrability,interface,interface,349,". TTreeResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeResult. class TTreeResult: public TSQLResult. TTreeResult. Class defining interface to a TTree query result with the same; interface as for SQL databases. A TTreeResult is returned by; TTree::Query() (actually TTreePlayer::Query()). Related classes are TTreeRow. Function Members (Methods); public:. virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:398,Integrability,interface,interface,398,". TTreeResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeResult. class TTreeResult: public TSQLResult. TTreeResult. Class defining interface to a TTree query result with the same; interface as for SQL databases. A TTreeResult is returned by; TTree::Query() (actually TTreePlayer::Query()). Related classes are TTreeRow. Function Members (Methods); public:. virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:7212,Integrability,interface,interface,7212,"ic TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTSQLResult::fRowCountnumber of rows in result. private:. Int_tfColumnCountnumber of columns in result; TString*fFields[fColumnCount] array containing field strings; Int_tfNextRowrow iterator; TObjArray*fResultquery result (TTreeRow objects). Class Charts. Inheritance Chart:. TObject. ←; TSQLResult. ←; TTreeResult. Function documentation; TTreeResult(); Create a query result object. TTreeResult(Int_t nfields); Create a query result object. ~TTreeResult(); Cleanup result object. void Close(Option_t* option = """"); Close query result. Bool_t IsValid(Int_t field); Check if result set is open and field index within range. Int_t GetFieldCount(); Get number of fields in result. const char * GetFieldName(Int_t field); Get name of specified field. TSQLRow * Next(); Get next query result row. The returned object must be; deleted by the user and becomes invalid when the result set is; closed or deleted. void AddField(Int_t field, const char* fieldname); Add field name to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. void AddRow(TSQLRow* row); Adopt a row to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. TTreeResult(). TObjArray * GetRows() const; {return fResult;}. » Author: Fons Rademakers 30/11/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:7378,Integrability,interface,interface,7378,"ic TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTSQLResult::fRowCountnumber of rows in result. private:. Int_tfColumnCountnumber of columns in result; TString*fFields[fColumnCount] array containing field strings; Int_tfNextRowrow iterator; TObjArray*fResultquery result (TTreeRow objects). Class Charts. Inheritance Chart:. TObject. ←; TSQLResult. ←; TTreeResult. Function documentation; TTreeResult(); Create a query result object. TTreeResult(Int_t nfields); Create a query result object. ~TTreeResult(); Cleanup result object. void Close(Option_t* option = """"); Close query result. Bool_t IsValid(Int_t field); Check if result set is open and field index within range. Int_t GetFieldCount(); Get number of fields in result. const char * GetFieldName(Int_t field); Get name of specified field. TSQLRow * Next(); Get next query result row. The returned object must be; deleted by the user and becomes invalid when the result set is; closed or deleted. void AddField(Int_t field, const char* fieldname); Add field name to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. void AddRow(TSQLRow* row); Adopt a row to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. TTreeResult(). TObjArray * GetRows() const; {return fResult;}. » Author: Fons Rademakers 30/11/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:117,Modifiability,inherit,inheritance,117,". TTreeResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeResult. class TTreeResult: public TSQLResult. TTreeResult. Class defining interface to a TTree query result with the same; interface as for SQL databases. A TTreeResult is returned by; TTree::Query() (actually TTreePlayer::Query()). Related classes are TTreeRow. Function Members (Methods); public:. virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeRow.html:1481,Availability,error,error,1481," virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:1565,Availability,error,error,1565,"ethod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) c",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:334,Integrability,interface,interface,334,". TTreeRow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeRow. class TTreeRow: public TSQLRow. TTreeRow. Class defining interface to a row of a TTree query result.; Objects of this class are created by TTreeResult methods. Related classes are TTreeResult. Function Members (Methods); public:. virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:114,Modifiability,inherit,inheritance,114,". TTreeRow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeRow. class TTreeRow: public TSQLRow. TTreeRow. Class defining interface to a row of a TTree query result.; Objects of this class are created by TTreeResult methods. Related classes are TTreeResult. Function Members (Methods); public:. virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeSQL.html:4262,Availability,error,error,4262,"e_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual Int_tTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TTree::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*TTree::GetBranch(const char* name); virtual TBranchRef*",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:4346,Availability,error,error,4346,"); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual Int_tTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TTree::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*TTree::GetBranch(const char* name); virtual TBranchRef*TTree::GetBranchRef() const; virtual Bool_tTTree::GetBranchStatus(const char* branch",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:15698,Deployability,update,updateExisting,15698,"t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTTree::SetMakeClass(Int",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:30708,Deployability,update,updated,30708," TString& typeName); Convert from ROOT typename to SQL typename. TBasket * CreateBasket(TBranch* br); Create a TBasketSQL. void CreateBranch(const TString& branchName, const TString& typeName); Create the column(s) in the database that correspond to the branch. TString CreateBranches(TSQLResult* rs); determine leaf description string. Bool_t CreateTable(const TString& table); Create the database table corresponding to this TTree. void Init(); Initializeation routine. Int_t Fill(); Copy the information from the user object to the TTree. std::vector<Int_t> * GetColumnIndice(TBranch* branch); Return a vector of columns index corresponding to the; current SQL table and the branch given as argument; Returns 0 if no columns indices is found; Otherwise returns a pointer to a vector to be deleted by the caller. Long64_t GetEntries() const; Get the number of rows in the database. Long64_t GetEntriesFast() const; Return the number of entries as of the last check.; Use GetEntries for a more accurate count. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Load the data for the entry from the database. Long64_t LoadTree(Long64_t entry); Setup the tree to the load the specified entry. Long64_t PrepEntry(Long64_t entry); Make sure the server and result set are setup for the requested entry. void Refresh(); Refresh contents of this Tree and its branches from the current; Tree status in the database; One can call this function in case the Tree on its file is being; updated by another process. void ResetQuery(); Reset the internal query. TTreeSQL(TSQLServer* server, TString DB, const TString& table). Long64_t GetEntries() const. TString GetTableName(); { return fTable; }. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:25135,Energy Efficiency,allocate,allocated,25135,lones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfCurrentEntry; TStringfDB; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); Int_tTTree::fFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TStringfInsertQuery; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTr,MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:29693,Integrability,rout,routine,29693,"(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Not implemented yet. TBranch * Branch(const char* name, void* address, const char* leaflist, Int_t bufsize); Create a branch. void CheckBasket(TBranch* tb); Check if the basket is properly setup. Bool_t CheckBranch(TBranch* tb); Check if the table has a column corresponding the branch; and that the resultset are properly setup. Bool_t CheckTable(const TString& table) const; Check the table exist in the database. TString ConvertTypeName(const TString& typeName); Convert from ROOT typename to SQL typename. TBasket * CreateBasket(TBranch* br); Create a TBasketSQL. void CreateBranch(const TString& branchName, const TString& typeName); Create the column(s) in the database that correspond to the branch. TString CreateBranches(TSQLResult* rs); determine leaf description string. Bool_t CreateTable(const TString& table); Create the database table corresponding to this TTree. void Init(); Initializeation routine. Int_t Fill(); Copy the information from the user object to the TTree. std::vector<Int_t> * GetColumnIndice(TBranch* branch); Return a vector of columns index corresponding to the; current SQL table and the branch given as argument; Returns 0 if no columns indices is found; Otherwise returns a pointer to a vector to be deleted by the caller. Long64_t GetEntries() const; Get the number of rows in the database. Long64_t GetEntriesFast() const; Return the number of entries as of the last check.; Use GetEntries for a more accurate count. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Load the data for the entry from the database. Long64_t LoadTree(Long64_t entry); Setup the tree to the load the specified entry. Long64_t PrepEntry(Long64_t entry); Make sure the server and result set are setup for the requested entry. void Refresh(); Refresh contents of this Tree and its branches from the current; Tree status in the database; One can call this function in case the T",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:114,Modifiability,inherit,inheritance,114,". TTreeSQL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeSQL. class TTreeSQL: public TTree. TTreeSQL. Implement TTree for a SQL backend. Function Members (Methods); public:. virtual~TTreeSQL(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tBranch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tBranch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tBranch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*Branch(const char* name, void* address, const char* leaflist, Int_t bufsize); virtual TBranch*Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<const char>(const char* name, const char* classname, const char* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<void>(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); vir",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
